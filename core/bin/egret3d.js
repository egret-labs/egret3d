/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function (global) {

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active: true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params: null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute: function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params ? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach: function () {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound: function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce: function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener: function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal: function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy: function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString: function () {
            return '[SignalBinding isOnce:' + this._isOnce + ', isBound:' + this.isBound() + ', active:' + this.active + ']';
        }

    };


    /*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error('listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName));
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function () {
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION: '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize: false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate: true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active: true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener: function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if (this.memorize && this._prevParams) {
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding: function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener: function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has: function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add: function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce: function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove: function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll: function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners: function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt: function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch: function (params) {
            if (!this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (!n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget: function () {
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose: function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString: function () {
            return '[Signal active:' + this.active + ' numListeners:' + this.getNumListeners() + ']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;
    global['signals'] = signals
}(window));
var __reflect = (this && this.__reflect) || function (p, c, t) {
    p.__class__ = c, t ? t.push(c) : t = [c], p.__types__ = p.__types__ ? t.concat(p.__types__) : t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __extends = this && this.__extends || function __extends(t, e) { 
 function r() { 
 this.constructor = t;
}
for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
r.prototype = e.prototype, t.prototype = new r();
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var paper;
(function (paper) {
    /**
     * @internal
     */
    function registerClass(baseClass) {
        baseClass.__onRegister();
    }
    paper.registerClass = registerClass;
    function serializedField(classPrototypeOrKey, key) {
        if (key) {
            var baseClass = classPrototypeOrKey.constructor;
            registerClass(baseClass);
            baseClass.__serializeKeys[key] = null;
        }
        else {
            return function (classPrototype, key) {
                var baseClass = classPrototype.constructor;
                registerClass(baseClass);
                baseClass.__serializeKeys[key] = classPrototypeOrKey;
            };
        }
    }
    paper.serializedField = serializedField;
    /**
     * 通过装饰器标记反序列化时需要忽略的属性。
     */
    function deserializedIgnore(classPrototype, key) {
        var baseClass = classPrototype.constructor;
        registerClass(baseClass);
        var keys = baseClass.__deserializeIgnore;
        if (keys.indexOf(key) < 0) {
            keys.push(key);
        }
    }
    paper.deserializedIgnore = deserializedIgnore;
    /**
     * 通过装饰器标记组件是否允许在同一实体上添加多个实例。
     */
    function allowMultiple(componentClass) {
        registerClass(componentClass);
        if (!componentClass.__isSingleton) {
            componentClass.allowMultiple = true;
        }
        else {
            console.warn("Singleton component cannot allow multiple.");
        }
    }
    paper.allowMultiple = allowMultiple;
    /**
     * 通过装饰器标记组件依赖的其他组件。
     */
    function requireComponent(requireComponentClass) {
        return function (componentClass) {
            var requireComponents = componentClass.requireComponents;
            if (requireComponents.indexOf(requireComponentClass) < 0) {
                requireComponents.push(requireComponentClass);
            }
        };
    }
    paper.requireComponent = requireComponent;
    // executionOrder: number;
    // /**
    //  * 通过装饰器标记脚本组件的生命周期优先级。（默认：0）
    //  */
    // export function executionOrder(order: number = 0) {
    //     return function (componentClass: ComponentClass<Behaviour>) {
    //         registerClass(componentClass);
    //         componentClass.executionOrder = order;
    //     }
    // }
    /**
     * 通过装饰器标记脚本组件是否在编辑模式也拥有生命周期。
     */
    function executeInEditMode(componentClass) {
        registerClass(componentClass);
        componentClass.executeInEditMode = true;
    }
    paper.executeInEditMode = executeInEditMode;
    function deprecated(version) {
        var _this = this;
        return function (target, key, descriptor) {
            var method = descriptor.value;
            descriptor.value = function () {
                var arg = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    arg[_i] = arguments[_i];
                }
                console.warn(target.name + "." + key + "\u5728" + version + "\u7248\u672C\u4E2D\u5DF2\u88AB\u5E9F\u5F03");
                return method.apply(_this, arg);
            };
        };
    }
    paper.deprecated = deprecated;
})(paper || (paper = {}));
var paper;
(function (paper) {
    var _hashCount = 1;
    /**
     * 生成 uuid 的方式。
     * @internal
     */
    paper.createUUID = function () {
        return (_hashCount++).toString();
    };
    /**
     * 可以被 paper.DisposeCollecter 收集，并在此帧末尾释放的基础对象。
     */
    var BaseRelease = (function () {
        function BaseRelease() {
        }
        /**
         * 更新该对象，使得该对象的 `onUpdate` 被执行。
         */
        BaseRelease.prototype.update = function () {
            if (this.onUpdate) {
                this.onUpdate.call(this.onUpdateTarget || this, this);
            }
        };
        /**
         * 在此帧末尾释放该对象。
         * - 不能在静态解释阶段执行。
         */
        BaseRelease.prototype.release = function () {
            if (this._released) {
                if (true) {
                    console.warn("The object has been released.");
                }
                return this;
            }
            paper.disposeCollecter.releases.push(this);
            this._released = true;
            return this;
        };
        return BaseRelease;
    }());
    paper.BaseRelease = BaseRelease;
    __reflect(BaseRelease.prototype, "paper.BaseRelease");
    /**
     * 基础对象。
     */
    var BaseObject = (function () {
        function BaseObject() {
            this.uuid = paper.createUUID();
        }
        /**
         * @internal
         */
        BaseObject.__onRegister = function () {
            if (this.__owner && this.__owner === this) {
                return false;
            }
            this.__deserializeIgnore = [];
            this.__serializeKeys = {};
            this.__owner = this;
            return true;
        };
        __decorate([
            paper.serializedField
        ], BaseObject.prototype, "uuid", void 0);
        return BaseObject;
    }());
    paper.BaseObject = BaseObject;
    __reflect(BaseObject.prototype, "paper.BaseObject", ["paper.IUUID"]);
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**属性信息 */
        var PropertyInfo = (function () {
            function PropertyInfo(name, editType, option) {
                this.name = name;
                this.editType = editType;
                this.option = option;
            }
            return PropertyInfo;
        }());
        editor.PropertyInfo = PropertyInfo;
        __reflect(PropertyInfo.prototype, "paper.editor.PropertyInfo");
        /**
         * 编辑类型
         */
        var EditType;
        (function (EditType) {
            /**数字输入 */
            EditType["UINT"] = "UINT";
            EditType["INT"] = "INT";
            EditType["FLOAT"] = "FLOAT";
            /**文本输入 */
            EditType["TEXT"] = "TEXT";
            /**选中框 */
            EditType["CHECKBOX"] = "CHECKBOX";
            /** Size.*/
            EditType["SIZE"] = "SIZE";
            /**vertor2 */
            EditType["VECTOR2"] = "VECTOR2";
            /**vertor3 */
            EditType["VECTOR3"] = "VECTOR3";
            /**vertor4 */
            EditType["VECTOR4"] = "VECTOR4";
            /**Quaternion */
            EditType["QUATERNION"] = "QUATERNION";
            /**颜色选择器 */
            EditType["COLOR"] = "COLOR";
            /**下拉 */
            EditType["LIST"] = "LIST";
            /**Rect */
            EditType["RECT"] = "RECT";
            /**材质 */
            EditType["MATERIAL"] = "MATERIAL";
            /**材质数组 */
            EditType["MATERIAL_ARRAY"] = "MATERIAL_ARRAY";
            /**游戏对象 */
            EditType["GAMEOBJECT"] = "GAMEOBJECT";
            /**变换 TODO 不需要*/
            EditType["TRANSFROM"] = "TRANSFROM";
            /**组件 */
            EditType["COMPONENT"] = "COMPONENT";
            /**声音 */
            EditType["SOUND"] = "SOUND";
            /**Mesh */
            EditType["MESH"] = "MESH";
            /**shader */
            EditType["SHADER"] = "SHADER";
            /**数组 */
            EditType["ARRAY"] = "ARRAY";
            /***/
            EditType["BUTTON"] = "BUTTON";
            /***/
            EditType["NESTED"] = "NESTED";
            /**贴图 */
            EditType["TEXTUREDESC"] = "TEXTUREDESC";
            /**矩阵 */
            EditType["MAT3"] = "MAT3";
        })(EditType = editor.EditType || (editor.EditType = {}));
        var customMap = {};
        /**
         * 装饰器:自定义
         */
        function custom() {
            return function (target) {
                customMap[target.name] = true;
            };
        }
        editor.custom = custom;
        var propertyMap = {};
        /**
         * 装饰器:属性
         * @param editType 编辑类型
         */
        function property(editType, option) {
            return function (target, property) {
                if (!propertyMap[target.constructor.name]) {
                    propertyMap[target.constructor.name] = {
                        extends: target.__proto__.constructor.name,
                        propertyList: [],
                    };
                }
                if (editType !== undefined) {
                    propertyMap[target.constructor.name].propertyList.push(new PropertyInfo(property, editType, option));
                }
                else {
                    //TODO:自动分析编辑类型
                }
            };
        }
        editor.property = property;
        /**
         * 检测一个实例对象是否为已被自定义
         * @param classInstance 实例对象
         */
        function isCustom(classInstance) {
            return customMap[classInstance.constructor.name] ? true : false;
        }
        editor.isCustom = isCustom;
        /**
         * 从枚举中生成装饰器列表项。
         */
        function getItemsFromEnum(enumObject) {
            var items = [];
            for (var k in enumObject) {
                if (!isNaN(Number(k))) {
                    continue;
                }
                items.push({ label: k, value: enumObject[k] });
            }
            return items;
        }
        editor.getItemsFromEnum = getItemsFromEnum;
        /**
         * 获取一个实例对象的编辑信息
         * @param classInstance 实例对象
         */
        function getEditInfo(classInstance) {
            var whileInsance = classInstance.__proto__;
            var retrunList = [];
            var className;
            while (whileInsance) {
                className = whileInsance.constructor.name;
                var classInfo = propertyMap[className];
                if (classInfo) {
                    retrunList = retrunList.concat(classInfo.propertyList);
                }
                whileInsance = whileInsance.__proto__;
            }
            return retrunList;
        }
        editor.getEditInfo = getEditInfo;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Vector2 = (function (_super) {
        __extends(Vector2, _super);
        /**
         * 请使用 `egret3d.Vector2.create()` 创建实例。
         * @see egret3d.Vector2.create()
         * @deprecated
         * @private
         */
        function Vector2(x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            return _this;
        }
        Vector2.create = function (x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y);
                instance._released = false;
                return instance;
            }
            return new Vector2().set(x, y);
        };
        Vector2.prototype.serialize = function () {
            return [this.x, this.y];
        };
        Vector2.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            return this;
        };
        Vector2.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            return this;
        };
        Vector2.prototype.clone = function () {
            var value = new Vector2();
            value.copy(this);
            return value;
        };
        Vector2.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        Vector2.prototype.clear = function () {
            this.x = 0.0;
            this.y = 0.0;
        };
        Vector2.prototype.normalize = function () {
            var l = this.length;
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
            }
            else {
                this.x = 1.0;
                this.y = 0.0;
            }
            return this;
        };
        Object.defineProperty(Vector2.prototype, "length", {
            get: function () {
                return Math.sqrt(this.sqrtLength);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2.prototype, "sqrtLength", {
            get: function () {
                return this.x * this.x + this.y * this.y;
            },
            enumerable: true,
            configurable: true
        });
        Vector2.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            return out;
        };
        Vector2.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            return out;
        };
        Vector2.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            return out;
        };
        Vector2.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        };
        Vector2.scale = function (v, scaler) {
            v.x = v.x * scaler;
            v.y = v.y * scaler;
            return v;
        };
        Vector2.getLength = function (v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        };
        Vector2.getDistance = function (v1, v2) {
            this.subtract(v1, v2, _helpVector2A);
            return this.getLength(_helpVector2A);
        };
        Vector2.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            return true;
        };
        Vector2.lerp = function (v1, v2, value, out) {
            out.x = v1.x * (1 - value) + v2.x * value;
            out.y = v1.y * (1 - value) + v2.y * value;
            return out;
        };
        Vector2.ZERO = new Vector2(0.0, 0.0);
        Vector2.ONE = new Vector2(1.0, 1.0);
        Vector2._instances = [];
        return Vector2;
    }(paper.BaseRelease));
    egret3d.Vector2 = Vector2;
    __reflect(Vector2.prototype, "egret3d.Vector2", ["egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
    var _helpVector2A = new Vector2();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var _createEnabled = null;
    /**
     * 基础组件。
     * - 所有组件的基类。
     */
    var BaseComponent = (function (_super) {
        __extends(BaseComponent, _super);
        /**
         * 禁止实例化。
         * @protected
         */
        function BaseComponent() {
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.hideFlags = 0 /* None */;
            /**
             * 该组件的实体。
             */
            _this.gameObject = null;
            /**
             * 仅保存在编辑器环境的额外数据，项目发布该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            _this._enabled = true;
            if (!_createEnabled) {
                throw new Error("Component instantiation through constructor is not allowed.");
            }
            _this.gameObject = _createEnabled;
            _createEnabled = null;
            return _this;
        }
        /**
         * @internal
         */
        BaseComponent.__onRegister = function () {
            if (!paper.BaseObject.__onRegister.call(this)) {
                return false;
            }
            if ((this.__isSingleton ? this._allSingletonComponents : this._allComponents).indexOf(this) >= 0) {
                console.warn("Register component class again.", egret.getQualifiedClassName(this));
                return false;
            }
            if (this.requireComponents) {
                this.requireComponents = this.requireComponents.concat();
            }
            else {
                this.requireComponents = [];
            }
            this.onComponentEnabled = new signals.Signal();
            this.onComponentDisabled = new signals.Signal();
            if (this.__isSingleton) {
                this.__index = this._allSingletonComponents.length + 300; // This means that a maximum of 300 non-singleton components can be added.
                this._allSingletonComponents.push(this);
            }
            else {
                this.__index = this._allComponents.length;
                this._allComponents.push(this);
            }
            return true;
        };
        /**
         * @internal
         */
        BaseComponent.create = function (componentClass, gameObject) {
            _createEnabled = gameObject;
            return new componentClass();
        };
        /**
         * @internal
         */
        BaseComponent.prototype._dispatchEnabledEvent = function (value) {
            var componentClass = this.constructor;
            if (value) {
                componentClass.onComponentEnabled.dispatch(this);
            }
            else {
                componentClass.onComponentDisabled.dispatch(this);
            }
        };
        /**
         * 添加组件后，组件内部初始化时执行。
         * - 重写此方法时，必须调用 `super.initialize()`。
         * @param config 实体添加该组件时可以传递的初始化数据。
         */
        BaseComponent.prototype.initialize = function (config) {
        };
        /**
         * 移除组件后，组件内部卸载时执行。
         * - 重写此方法时，必须调用 `super.uninitialize()`。
         */
        BaseComponent.prototype.uninitialize = function () {
        };
        Object.defineProperty(BaseComponent.prototype, "isDestroyed", {
            /**
             * 该组件是否已被销毁。
             */
            get: function () {
                return !this.gameObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "enabled", {
            /**
             * 该组件自身的激活状态。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled === value) {
                    return;
                }
                // if (!value && this.constructor === egret3d.Transform) { TODO
                //     console.warn("Cannot disable transform compnent.");
                //     return;
                // }
                var prevEnabled = this.isActiveAndEnabled;
                this._enabled = value;
                var currentEnabled = this.isActiveAndEnabled;
                if (currentEnabled !== prevEnabled) {
                    this._dispatchEnabledEvent(currentEnabled);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "isActiveAndEnabled", {
            /**
             * 该组件在场景的激活状态。
             */
            get: function () {
                // return this._enabled && this.gameObject.activeInHierarchy;
                return this._enabled && (this.gameObject._activeDirty ? this.gameObject.activeInHierarchy : this.gameObject._activeInHierarchy);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "transform", {
            /**
             *
             */
            get: function () {
                return this.gameObject.transform;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该组件的实例是否在编辑模式拥有生命周期。
         * @internal
         */
        BaseComponent.executeInEditMode = false;
        /**
         * 是否允许在同一实体上添加多个该组件的实例。
         * @internal
         */
        BaseComponent.allowMultiple = false;
        /**
         * 该组件实例依赖的其他前置组件。
         * @internal
         */
        BaseComponent.requireComponents = null;
        /**
         * 当该组件被激活时派发事件。
         * @internal
         */
        BaseComponent.onComponentEnabled = null;
        /**
         * 当该组件被禁用时派发事件。
         * @internal
         */
        BaseComponent.onComponentDisabled = null;
        // TODO 基类标记，以阻止注册基类。
        /**
         * 该组件实例是否为单例组件。
         * @internal
         */
        BaseComponent.__isSingleton = false;
        /**
         * 该组件实例索引。
         * @internal
         */
        BaseComponent.__index = -1;
        /**
         * 所有已注册的组件类。
         */
        BaseComponent._allComponents = [];
        /**
         * 所有已注册的单例组件类。
         */
        BaseComponent._allSingletonComponents = [];
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "hideFlags", void 0);
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "_enabled", void 0);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseComponent.prototype, "enabled", null);
        return BaseComponent;
    }(paper.BaseObject));
    paper.BaseComponent = BaseComponent;
    __reflect(BaseComponent.prototype, "paper.BaseComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 欧拉旋转顺序。
     */
    var EulerOrder;
    (function (EulerOrder) {
        EulerOrder[EulerOrder["XYZ"] = 0] = "XYZ";
        EulerOrder[EulerOrder["XZY"] = 1] = "XZY";
        EulerOrder[EulerOrder["YXZ"] = 2] = "YXZ";
        EulerOrder[EulerOrder["YZX"] = 3] = "YZX";
        EulerOrder[EulerOrder["ZXY"] = 4] = "ZXY";
        EulerOrder[EulerOrder["ZYX"] = 5] = "ZYX";
    })(EulerOrder = egret3d.EulerOrder || (egret3d.EulerOrder = {}));
    /**
     * 三维向量。
     */
    var Vector3 = (function (_super) {
        __extends(Vector3, _super);
        /**
         * 请使用 `egret3d.Vector3.create()` 创建实例。
         * @see egret3d.Vector3.create()
         * @deprecated
         * @private
         */
        function Vector3(x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.z = z;
            return _this;
        }
        /**
         * 创建一个三维向量。
         * @param x X 轴分量。
         * @param y Y 轴分量。
         * @param z Z 轴分量。
         */
        Vector3.create = function (x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z);
                instance._released = false;
                return instance;
            }
            return new Vector3().set(x, y, z);
        };
        Vector3.prototype.serialize = function () {
            return [this.x, this.y, this.z];
        };
        Vector3.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector3.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.z);
        };
        Vector3.prototype.clone = function () {
            return Vector3.create(this.x, this.y, this.z);
        };
        Vector3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        /**
         * 通过数组设置该向量。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Vector3.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        };
        Vector3.prototype.clear = function () {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            return this;
        };
        /**
         * 向量归一化。
         * - `v.normalize()` 归一化该向量，相当于 v /= v.length。
         * - `v.normalize(input)` 将输入向量归一化的结果写入该向量，相当于 v = input / input.length。
         * @param input 输入向量。
         * @param defaultVector 如果该向量的长度为 0，则默认归一化的向量。
         */
        Vector3.prototype.normalize = function (input, defaultVector) {
            if (defaultVector === void 0) { defaultVector = Vector3.FORWARD; }
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var l = Math.sqrt(x * x + y * y + z * z);
            if (l > egret3d.EPSILON) {
                l = 1.0 / l;
                this.x = x * l;
                this.y = y * l;
                this.z = z * l;
            }
            else {
                this.copy(defaultVector);
            }
            return this;
        };
        /**
         *
         * @param input 输入向量。
         */
        Vector3.prototype.negate = function (input) {
            if (!input) {
                input = this;
            }
            this.x = input.x * -1.0;
            this.y = input.y * -1.0;
            this.z = input.z * -1.0;
            return this;
        };
        /**
         * 判断该向量是否和一个向量相等。
         * @param value 一个向量。
         * @param threshold 阈值。
         */
        Vector3.prototype.equal = function (value, threshold) {
            if (threshold === void 0) { threshold = 0.000001; }
            if (Math.abs(this.x - value.x) <= threshold &&
                Math.abs(this.y - value.y) <= threshold &&
                Math.abs(this.z - value.z) <= threshold) {
                return true;
            }
            return false;
        };
        Vector3.prototype.fromSphericalCoords = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                p3 = p1.z;
                p2 = p1.y;
                p1 = p1.x;
            }
            var sinPhiRadius = Math.sin(p2) * p1;
            this.x = sinPhiRadius * Math.sin(p3);
            this.y = Math.cos(p2) * p1;
            this.z = sinPhiRadius * Math.cos(p3);
            return this;
        };
        Vector3.prototype.fromPlaneProjection = function (plane, input) {
            if (!input) {
                input = this;
            }
            return this.add(egret3d.helpVector3A.multiplyScalar(-plane.getDistance(input), plane.normal));
        };
        Vector3.prototype.applyMatrix3 = function (matrix, input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var rawData = matrix.rawData;
            this.x = rawData[0] * x + rawData[3] * y + rawData[6] * z;
            this.y = rawData[1] * x + rawData[4] * y + rawData[7] * z;
            this.z = rawData[2] * x + rawData[5] * y + rawData[8] * z;
            return this;
        };
        /**
         * 向量与矩阵相乘运算。
         * - `v.applyMatrix(matrix)` 将该向量与一个矩阵相乘，相当于 v *= matrix。
         * - `v.applyMatrix(matrix, input)` 将输入向量与一个矩阵相乘的结果写入该向量，相当于 v = input * matrix。
         * @param matrix 一个矩阵。
         * @param input 输入向量。
         */
        Vector3.prototype.applyMatrix = function (matrix, input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var rawData = matrix.rawData;
            var w = 1.0 / (rawData[3] * x + rawData[7] * y + rawData[11] * z + rawData[15]); // TODO
            this.x = (rawData[0] * x + rawData[4] * y + rawData[8] * z + rawData[12]) * w;
            this.y = (rawData[1] * x + rawData[5] * y + rawData[9] * z + rawData[13]) * w;
            this.z = (rawData[2] * x + rawData[6] * y + rawData[10] * z + rawData[14]) * w;
            return this;
        };
        /**
         * 向量与矩阵相乘运算。
         * - `v.applyDirection(matrix)` 将该向量与一个矩阵相乘，相当于 v *= matrix。
         * - `v.applyDirection(matrix, input)` 将输入向量与一个矩阵相乘的结果写入该向量，相当于 v = input * matrix。
         * @param matrix 一个矩阵。
         * @param input 输入向量。
         */
        Vector3.prototype.applyDirection = function (matrix, input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var rawData = matrix.rawData;
            this.x = rawData[0] * x + rawData[4] * y + rawData[8] * z;
            this.y = rawData[1] * x + rawData[5] * y + rawData[9] * z;
            this.z = rawData[2] * x + rawData[6] * y + rawData[10] * z;
            return this;
            // return this.normalize(); TODO
        };
        /**
         * 向量与四元数相乘运算。
         * - `v.applyQuaternion(quaternion)` 将该向量与一个四元数相乘，相当于 v *= quaternion。
         * - `v.applyQuaternion(quaternion, input)` 将输入向量与一个四元数相乘的结果写入该向量，相当于 v = input * quaternion。
         * @param matrix 一个四元数。
         * @param input 输入向量。
         */
        Vector3.prototype.applyQuaternion = function (quaternion, input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var qx = quaternion.x, qy = quaternion.y, qz = quaternion.z, qw = quaternion.w;
            // calculate quat * vector
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            // calculate result * inverse quat
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        };
        /**
         * 向量与标量相加运算。
         * - `v.addScalar(scalar)` 将该向量与标量相加，相当于 v += scalar。
         * - `v.addScalar(scalar, input)` 将输入向量与标量相加的结果写入该向量，相当于 v = input + scalar。
         * @param scalar 标量。
         * @param input 输入向量。
         */
        Vector3.prototype.addScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = input.x + scalar;
            this.y = input.y + scalar;
            this.z = input.z + scalar;
            return this;
        };
        /**
         * 向量与标量相乘运算。
         * - `v.multiplyScalar(scalar)` 将该向量与标量相乘，相当于 v *= scalar。
         * - `v.multiplyScalar(scalar, input)` 将输入向量与标量相乘的结果写入该向量，相当于 v = input * scalar。
         * @param scalar 标量。
         * @param input 输入向量。
         */
        Vector3.prototype.multiplyScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = scalar * input.x;
            this.y = scalar * input.y;
            this.z = scalar * input.z;
            return this;
        };
        /**
         * 向量相加运算。
         * - `v.add(a)` 将该向量与一个向量相加，相当于 v += a。
         * - `v.add(a, b)` 将两个向量相加的结果写入该向量，相当于 v = a + b。
         * @param valueA 一个向量。
         * @param valueB 另一个向量。
         */
        Vector3.prototype.add = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = valueA.x + valueB.x;
            this.y = valueA.y + valueB.y;
            this.z = valueA.z + valueB.z;
            return this;
        };
        /**
         * 向量相减运算。
         * - `v.subtract(a)` 将该向量与一个向量相减，相当于 v -= a。
         * - `v.subtract(a, b)` 将两个向量相减的结果写入该向量，相当于 v = a - b。
         * @param valueA 一个向量。
         * @param valueB 另一个向量。
         */
        Vector3.prototype.subtract = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = valueA.x - valueB.x;
            this.y = valueA.y - valueB.y;
            this.z = valueA.z - valueB.z;
            return this;
        };
        /**
         * 向量相乘运算。
         * - `v.multiply(a)` 将该向量与一个向量相乘，相当于 v *= a。
         * - `v.multiply(a, b)` 将两个向量相乘的结果写入该向量，相当于 v = a * b。
         * @param valueA 一个向量。
         * @param valueB 另一个向量。
         */
        Vector3.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = valueA.x * valueB.x;
            this.y = valueA.y * valueB.y;
            this.z = valueA.z * valueB.z;
            return this;
        };
        /**
         * 向量相除运算。
         * - 假设除向量分量均不为零。
         * - `v.divide(a)` 将该向量与一个向量相除，相当于 v /= a。
         * - `v.divide(a, b)` 将两个向量相除的结果写入该向量，相当于 v = a / b。
         * @param valueA 一个向量。
         * @param valueB 另一个向量。
         */
        Vector3.prototype.divide = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            if (true && (valueB.x === 0.0 || valueB.y === 0.0 || valueB.z === 0)) {
                console.warn("Dividing by zero.");
            }
            this.x = valueA.x / valueB.x;
            this.y = valueA.y / valueB.y;
            this.z = valueA.z / valueB.z;
            return this;
        };
        /**
         * 向量点乘运算。
         * - `v.dot(a)` 将该向量与一个向量点乘，相当于 v ·= a。
         * - `v.dot(a, b)` 将两个向量点乘的结果写入该向量，相当于 v = a · b。
         * @param valueA 一个向量。
         * @param valueB 另一个向量。
         */
        Vector3.prototype.dot = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            return valueA.x * valueB.x + valueA.y * valueB.y + valueA.z * valueB.z;
        };
        /**
         * 向量叉乘运算。
         * - `v.cross(a)` 将该向量与一个向量叉乘，相当于 v ×= a。
         * - `v.cross(a, b)` 将两个向量叉乘的结果写入该向量，相当于 v = a × b。
         * @param valueA 一个向量。
         * @param valueB 另一个向量。
         */
        Vector3.prototype.cross = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var x = valueA.x;
            var y = valueA.y;
            var z = valueA.z;
            var xB = valueB.x;
            var yB = valueB.y;
            var zB = valueB.z;
            this.x = y * zB - z * yB;
            this.y = z * xB - x * zB;
            this.z = x * yB - y * xB;
            return this;
        };
        /**
         * 向量插值运算。
         * - `v.lerp(t, a)` 将该向量与一个向量插值，相当于 v = v * (1 - t) + a * t。
         * - `v.lerp(t, a, b)` 将两个向量插值的结果写入该向量，相当于 v = a * (1 - t) + b * t。
         * @param valueA 一个向量。
         * @param valueB 另一个向量。
         */
        Vector3.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var p = 1.0 - t;
            this.x = valueA.x * p + valueB.x * t;
            this.y = valueA.y * p + valueB.y * t;
            this.z = valueA.z * p + valueB.z * t;
            return this;
        };
        /**
         * 向量最小值运算。
         * - `v.min(a)` 将该向量与一个向量的最小值写入该向量，相当于 v = min(v, a)。
         * - `v.min(a, b)` 将两个向量的最小值写入该向量，相当于 v = min(a, b)。
         * @param valueA 一个向量。
         * @param valueB 另一个向量。
         */
        Vector3.prototype.min = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.min(valueA.x, valueB.x);
            this.y = Math.min(valueA.y, valueB.y);
            this.z = Math.min(valueA.z, valueB.z);
            return this;
        };
        /**
         * 向量最大值运算。
         * - `v.max(a)` 将该向量与一个向量的最大值写入该向量，相当于 v = max(v, a)。
         * - `v.max(a, b)` 将两个向量的最大值写入该向量，相当于 v = max(a, b)。
         * @param valueA 一个向量。
         * @param valueB 另一个向量。
         */
        Vector3.prototype.max = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.max(valueA.x, valueB.x);
            this.y = Math.max(valueA.y, valueB.y);
            this.z = Math.max(valueA.z, valueB.z);
            return this;
        };
        /**
         * 向量夹紧运算。
         * - 假设最小向量小于最大向量。
         * - `v.clamp(valueMin, valueMax)` 相当于 v = max(valueMin, min(valueMax, v))。
         * - `v.clamp(valueMin, valueMax, input)` 相当于 v = max(valueMin, min(valueMax, input))。
         * @param valueMin 最小向量。
         * @param valueMax 最大向量。
         * @param input 输入向量。
         */
        Vector3.prototype.clamp = function (valueMin, valueMax, input) {
            if (!input) {
                input = this;
            }
            if (true && (valueMin.x > valueMax.x || valueMin.y > valueMax.y || valueMin.z > valueMax.z)) {
                console.warn("Invalid arguments.");
            }
            // assumes min < max, componentwise
            this.x = Math.max(valueMin.x, Math.min(valueMax.x, input.x));
            this.y = Math.max(valueMin.y, Math.min(valueMax.y, input.y));
            this.z = Math.max(valueMin.z, Math.min(valueMax.z, input.z));
            return this;
        };
        /**
         *
         * @param vector
         * @param input
         */
        Vector3.prototype.reflect = function (vector, input) {
            if (!input) {
                input = this;
            }
            return this.subtract(input, _helpVector3.multiplyScalar(2.0 * this.dot(vector), vector));
        };
        /**
         * 获得该向量和一个向量的夹角。（弧度制）
         * - 假设向量长度均不为零。
         */
        Vector3.prototype.getAngle = function (value) {
            var v = this.squaredLength * value.squaredLength;
            if (true && v === 0.0) {
                console.warn("Dividing by zero.");
            }
            var theta = this.dot(value) / Math.sqrt(v);
            // clamp, to handle numerical problems
            return Math.acos(Math.max(-1.0, Math.min(1.0, theta)));
        };
        /**
         * 获取该向量和一个向量之间的距离的平方。
         * @param value 一个向量。
         */
        Vector3.prototype.getSquaredDistance = function (value) {
            return _helpVector3.subtract(value, this).squaredLength;
        };
        /**
         * 获取该向量和一个向量之间的距离。
         * @param value 一个向量。
         */
        Vector3.prototype.getDistance = function (value) {
            return _helpVector3.subtract(value, this).length;
        };
        Vector3.prototype.closestToTriangle = function (triangle, input) {
            if (!input) {
                input = this;
            }
            var vab = egret3d.helpVector3A;
            var vac = egret3d.helpVector3B;
            var vbc = egret3d.helpVector3C;
            var vap = egret3d.helpVector3D;
            var vbp = egret3d.helpVector3E;
            var vcp = egret3d.helpVector3F;
            var a = triangle.a, b = triangle.b, c = triangle.c;
            var v, w;
            // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
            // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
            // under the accompanying license; see chapter 5.1.5 for detailed explanation.
            // basically, we're distinguishing which of the voronoi regions of the triangle
            // the point lies in with the minimum amount of redundant computation.
            vab.subtract(b, a);
            vac.subtract(c, a);
            vap.subtract(input, a);
            var d1 = vab.dot(vap);
            var d2 = vac.dot(vap);
            if (d1 <= 0 && d2 <= 0) {
                // vertex region of A; barycentric coords (1, 0, 0)
                return this.copy(a);
            }
            vbp.subtract(input, b);
            var d3 = vab.dot(vbp);
            var d4 = vac.dot(vbp);
            if (d3 >= 0 && d4 <= d3) {
                // vertex region of B; barycentric coords (0, 1, 0)
                return this.copy(b);
            }
            var vc = d1 * d4 - d3 * d2;
            if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                v = d1 / (d1 - d3);
                // edge region of AB; barycentric coords (1-v, v, 0)
                return this.multiplyScalar(v, vab).add(a);
            }
            vcp.subtract(input, c);
            var d5 = vab.dot(vcp);
            var d6 = vac.dot(vcp);
            if (d6 >= 0 && d5 <= d6) {
                // vertex region of C; barycentric coords (0, 0, 1)
                return this.copy(c);
            }
            var vb = d5 * d2 - d1 * d6;
            if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                w = d2 / (d2 - d6);
                // edge region of AC; barycentric coords (1-w, 0, w)
                return this.multiplyScalar(w, vac).add(a);
            }
            var va = d3 * d6 - d5 * d4;
            if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                vbc.subtract(c, b);
                w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                // edge region of BC; barycentric coords (0, 1-w, w)
                return this.multiplyScalar(w, vbc).add(b); // edge region of BC
            }
            // face region
            var denom = 1 / (va + vb + vc);
            // u = va * denom
            v = vb * denom;
            w = vc * denom;
            return this.add(a, vac.multiplyScalar(w).add(vab.multiplyScalar(v)));
        };
        /**
         * 将该向量转换为数组。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Vector3.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            array[0 + offset] = this.x;
            array[1 + offset] = this.y;
            array[2 + offset] = this.z;
            return array;
        };
        Object.defineProperty(Vector3.prototype, "length", {
            /**
             * 该向量的长度。
             * - 该值是实时计算的。
             */
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3.prototype, "squaredLength", {
            /**
             * 该向量的长度的平方。
             * - 该值是实时计算的。
             */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Vector3.set = function (x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.normalize = function (v) {
            var num = Vector3.getLength(v);
            if (num > Number.MIN_VALUE) {
                v.x = v.x / num;
                v.y = v.y / num;
                v.z = v.z / num;
            }
            else {
                v.x = 1.0;
                v.y = 0.0;
                v.z = 0.0;
            }
            return v;
        };
        /**
         * @deprecated
         */
        Vector3.copy = function (v, out) {
            out.x = v.x;
            out.y = v.y;
            out.z = v.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            out.z = v1.z + v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            out.z = v1.z * v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.scale = function (v, scale) {
            v.x = v.x * scale;
            v.y = v.y * scale;
            v.z = v.z * scale;
            return v;
        };
        /**
         * @deprecated
         */
        Vector3.cross = function (lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        };
        /**
         * @deprecated
         */
        Vector3.lerp = function (v1, v2, v, out) {
            out.x = v1.x * (1 - v) + v2.x * v;
            out.y = v1.y * (1 - v) + v2.y * v;
            out.z = v1.z * (1 - v) + v2.z * v;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            if (Math.abs(v1.z - v2.z) > threshold) {
                return false;
            }
            return true;
        };
        /**
         * @deprecated
         */
        Vector3.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            out.z = v1.z - v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.getSqrLength = function (v) {
            return v.x * v.x + v.y * v.y + v.z * v.z;
        };
        /**
         * @deprecated
         */
        Vector3.getLength = function (v) {
            return Math.sqrt(this.getSqrLength(v));
        };
        /**
         * @deprecated
         */
        Vector3.getDistance = function (a, b) {
            return this.getLength(this.subtract(a, b, _helpVector3));
        };
        /**
         * 零向量。
         */
        Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
        /**
         * 三方向均为一的向量。
         */
        Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
        /**
         * 三方向均为负一的向量。
         */
        Vector3.MINUS_ONE = new Vector3(-1.0, -1.0, -1.0);
        /**
         * 上向量。
         */
        Vector3.UP = new Vector3(0.0, 1.0, 0.0);
        /**
         * 下向量。
         */
        Vector3.DOWN = new Vector3(0.0, -1.0, 0.0);
        /**
         * 左向量。
         */
        Vector3.LEFT = new Vector3(-1.0, 0.0, 0.0);
        /**
         * 右向量。
         */
        Vector3.RIGHT = new Vector3(1.0, 0.0, 0.0);
        /**
         * 前向量。
         */
        Vector3.FORWARD = new Vector3(0.0, 0.0, 1.0);
        /**
         * 后向量。
         */
        Vector3.BACK = new Vector3(0.0, 0.0, -1.0);
        Vector3._instances = [];
        return Vector3;
    }(paper.BaseRelease));
    egret3d.Vector3 = Vector3;
    __reflect(Vector3.prototype, "egret3d.Vector3", ["egret3d.IVector3", "egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
    var _helpVector3 = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3A = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3B = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3C = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3D = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3E = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3F = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3G = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3H = Vector3.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 资源基类。
     */
    var Asset = (function (_super) {
        __extends(Asset, _super);
        /**
         * TODO
         * remove
         * @param name
         */
        function Asset(name) {
            if (name === void 0) { name = ""; }
            var _this = _super.call(this) || this;
            /**
             * 资源名称。
             * @readonly
             */
            _this.name = "";
            /**
             * @internal
             */
            _this._isBuiltin = false;
            _this.name = name;
            return _this;
        }
        /**
         * @private
         */
        Asset.register = function (asset) {
            if (!this._assets[asset.name]) {
                this._assets[asset.name] = asset;
            }
            else if (this._assets[asset.name] !== asset) {
                console.warn("Replace existing asset.", asset.name);
                this._assets[asset.name] = asset;
            }
        };
        /**
         * 查找已加载的指定资源。
         */
        Asset.find = function (name) {
            var result = this._assets[name];
            if (!result) {
                return RES.getRes(name);
            }
            return result;
        };
        /**
         * 释放资源。
         */
        Asset.prototype.dispose = function (disposeChildren) {
            if (this._isBuiltin) {
                console.warn("Cannot dispose builtin asset.", this.name);
                return false;
            }
            delete Asset._assets[this.name];
            this.name = "";
            return true;
        };
        /**
         * TODO RES 需要有注册的功能，并拥有查询所有指定类型资源的功能。
         * Asset 类型需要引擎枚举，paper 空间还是引擎空间。
         * 空间结构
         * 引擎、res、ecs、2d、3d，其他
         * @internal
         */
        Asset._assets = {};
        return Asset;
    }(paper.BaseObject));
    paper.Asset = Asset;
    __reflect(Asset.prototype, "paper.Asset");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _array = [
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
    ];
    /**
     * 4x4 矩阵。
     */
    var Matrix4 = (function (_super) {
        __extends(Matrix4, _super);
        /**
         * 请使用 `egret3d.Matrix4.create()` 创建实例。
         * @see egret3d.Matrix4.create()
         * @deprecated
         */
        function Matrix4(rawData, offsetOrByteOffset) {
            if (offsetOrByteOffset === void 0) { offsetOrByteOffset = 0; }
            var _this = _super.call(this) || this;
            /**
             * 矩阵原始数据
             * @readonly
             */
            _this.rawData = null;
            if (rawData && rawData instanceof ArrayBuffer) {
                _this.fromBuffer(rawData, offsetOrByteOffset);
            }
            else {
                _this.rawData = new Float32Array(16);
                _this.fromArray(rawData || _array);
            }
            return _this;
        }
        /**
         * 创建一个矩阵。
         * @param rawData
         * @param offsetOrByteOffset
         */
        Matrix4.create = function (rawData, offsetOrByteOffset) {
            if (offsetOrByteOffset === void 0) { offsetOrByteOffset = 0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                if (rawData) {
                    if (rawData instanceof ArrayBuffer) {
                        instance.fromBuffer(rawData, offsetOrByteOffset);
                    }
                    else {
                        instance.fromArray(rawData, offsetOrByteOffset);
                    }
                }
                else {
                    instance.identity();
                }
                return instance;
            }
            return new Matrix4(rawData, offsetOrByteOffset);
        };
        Matrix4.prototype.serialize = function () {
            return this.rawData;
        };
        Matrix4.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Matrix4.prototype.copy = function (value) {
            this.fromArray(value.rawData);
            return this;
        };
        Matrix4.prototype.clone = function () {
            return Matrix4.create(this.rawData);
        };
        Matrix4.prototype.set = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var rawData = this.rawData;
            rawData[0] = n11;
            rawData[4] = n12;
            rawData[8] = n13;
            rawData[12] = n14;
            rawData[1] = n21;
            rawData[5] = n22;
            rawData[9] = n23;
            rawData[13] = n24;
            rawData[2] = n31;
            rawData[6] = n32;
            rawData[10] = n33;
            rawData[14] = n34;
            rawData[3] = n41;
            rawData[7] = n42;
            rawData[11] = n43;
            rawData[15] = n44;
            return this;
        };
        Matrix4.prototype.identity = function () {
            this.rawData[0] = 1.0;
            this.rawData[1] = 0.0;
            this.rawData[2] = 0.0;
            this.rawData[3] = 0.0;
            this.rawData[4] = 0.0;
            this.rawData[5] = 1.0;
            this.rawData[6] = 0.0;
            this.rawData[7] = 0.0;
            this.rawData[8] = 0.0;
            this.rawData[9] = 0.0;
            this.rawData[10] = 1.0;
            this.rawData[11] = 0.0;
            this.rawData[12] = 0.0;
            this.rawData[13] = 0.0;
            this.rawData[14] = 0.0;
            this.rawData[15] = 1.0;
            return this;
        };
        Matrix4.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            for (var i = 0; i < 16; ++i) {
                this.rawData[i] = value[i + offset];
            }
            return this;
        };
        Matrix4.prototype.fromBuffer = function (value, byteOffset) {
            if (byteOffset === void 0) { byteOffset = 0; }
            this.rawData = new Float32Array(value, byteOffset, 16);
            return this;
        };
        Matrix4.prototype.fromTranslate = function (value, rotationAndScaleStays) {
            if (rotationAndScaleStays === void 0) { rotationAndScaleStays = false; }
            if (!rotationAndScaleStays) {
                this.identity();
            }
            this.rawData[12] = value.x;
            this.rawData[13] = value.y;
            this.rawData[14] = value.z;
            return this;
        };
        Matrix4.prototype.fromRotation = function (rotation, translateStays) {
            if (translateStays === void 0) { translateStays = false; }
            return this.compose(translateStays ? _helpVector3A.fromArray(this.rawData, 12) : egret3d.Vector3.ZERO, rotation, egret3d.Vector3.ONE);
        };
        Matrix4.prototype.fromEuler = function (value, order, translateStays) {
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            if (order === void 0) { order = 2 /* YXZ */; }
            if (translateStays === void 0) { translateStays = false; }
            var cos = Math.cos;
            var sin = Math.sin;
            var x = value.x, y = value.y, z = value.z;
            var a = cos(x), b = sin(x);
            var c = cos(y), d = sin(y);
            var e = cos(z), f = sin(z);
            var rawData = this.rawData;
            switch (order) {
                case 0 /* XYZ */: {
                    var ae = a * e, af = a * f, be = b * e, bf = b * f;
                    rawData[0] = c * e;
                    rawData[4] = -c * f;
                    rawData[8] = d;
                    rawData[1] = af + be * d;
                    rawData[5] = ae - bf * d;
                    rawData[9] = -b * c;
                    rawData[2] = bf - ae * d;
                    rawData[6] = be + af * d;
                    rawData[10] = a * c;
                    break;
                }
                case 1 /* XZY */: {
                    var ac_1 = a * c, ad_1 = a * d, bc_1 = b * c, bd_1 = b * d;
                    rawData[0] = c * e;
                    rawData[4] = -f;
                    rawData[8] = d * e;
                    rawData[1] = ac_1 * f + bd_1;
                    rawData[5] = a * e;
                    rawData[9] = ad_1 * f - bc_1;
                    rawData[2] = bc_1 * f - ad_1;
                    rawData[6] = b * e;
                    rawData[10] = bd_1 * f + ac_1;
                    break;
                }
                case 2 /* YXZ */: {
                    var ce = c * e, cf = c * f, de = d * e, df = d * f;
                    rawData[0] = ce + df * b;
                    rawData[4] = de * b - cf;
                    rawData[8] = a * d;
                    rawData[1] = a * f;
                    rawData[5] = a * e;
                    rawData[9] = -b;
                    rawData[2] = cf * b - de;
                    rawData[6] = df + ce * b;
                    rawData[10] = a * c;
                    break;
                }
                case 3 /* YZX */: {
                    var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                    rawData[0] = c * e;
                    rawData[4] = bd - ac * f;
                    rawData[8] = bc * f + ad;
                    rawData[1] = f;
                    rawData[5] = a * e;
                    rawData[9] = -b * e;
                    rawData[2] = -d * e;
                    rawData[6] = ad * f + bc;
                    rawData[10] = ac - bd * f;
                    break;
                }
                case 4 /* ZXY */: {
                    var ce = c * e, cf = c * f, de = d * e, df = d * f;
                    rawData[0] = ce - df * b;
                    rawData[4] = -a * f;
                    rawData[8] = de + cf * b;
                    rawData[1] = cf + de * b;
                    rawData[5] = a * e;
                    rawData[9] = df - ce * b;
                    rawData[2] = -a * d;
                    rawData[6] = b;
                    rawData[10] = a * c;
                    break;
                }
                case 5 /* ZYX */: {
                    var ae = a * e, af = a * f, be = b * e, bf = b * f;
                    rawData[0] = c * e;
                    rawData[4] = be * d - af;
                    rawData[8] = ae * d + bf;
                    rawData[1] = c * f;
                    rawData[5] = bf * d + ae;
                    rawData[9] = af * d - be;
                    rawData[2] = -d;
                    rawData[6] = b * c;
                    rawData[10] = a * c;
                    break;
                }
            }
            // bottom row
            rawData[3] = 0.0;
            rawData[7] = 0.0;
            rawData[11] = 0.0;
            if (!translateStays) {
                // last column
                rawData[12] = 0.0;
                rawData[13] = 0.0;
                rawData[14] = 0.0;
                rawData[15] = 1.0;
            }
            return this;
        };
        Matrix4.prototype.fromScale = function (x, y, z, translateStays) {
            if (translateStays === void 0) { translateStays = false; }
            if (translateStays) {
                _helpVector3A.fromArray(this.rawData, 12);
            }
            this.identity();
            this.rawData[0] = x;
            this.rawData[5] = y;
            this.rawData[10] = z;
            if (translateStays) {
                this.rawData[12] = _helpVector3A.x;
                this.rawData[13] = _helpVector3A.y;
                this.rawData[14] = _helpVector3A.z;
            }
            return this;
        };
        Matrix4.prototype.fromAxis = function (axis, radian) {
            if (radian === void 0) { radian = 0.0; }
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
            var c = Math.cos(radian);
            var s = Math.sin(radian);
            var t = 1.0 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0.0, tx * y + s * z, ty * y + c, ty * z - s * x, 0.0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0.0, 0.0, 0.0, 0.0, 1.0);
            return this;
        };
        Matrix4.prototype.fromAxises = function (axisX, axisY, axisZ) {
            this.set(axisX.x, axisY.x, axisZ.x, 0.0, axisX.y, axisY.y, axisZ.y, 0.0, axisX.z, axisY.z, axisZ.z, 0.0, 0.0, 0.0, 0.0, 1.0);
            return this;
        };
        Matrix4.prototype.fromRotationX = function (radian) {
            var c = Math.cos(radian), s = Math.sin(radian);
            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.fromRotationY = function (radian) {
            var c = Math.cos(radian), s = Math.sin(radian);
            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.fromRotationZ = function (radian) {
            var c = Math.cos(radian), s = Math.sin(radian);
            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.determinant = function () {
            var rawData = this.rawData;
            var n11 = rawData[0], n12 = rawData[4], n13 = rawData[8], n14 = rawData[12];
            var n21 = rawData[1], n22 = rawData[5], n23 = rawData[9], n24 = rawData[13];
            var n31 = rawData[2], n32 = rawData[6], n33 = rawData[10], n34 = rawData[14];
            var n41 = rawData[3], n42 = rawData[7], n43 = rawData[11], n44 = rawData[15];
            //TODO: make this more efficient
            //( based on https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js )
            return (n41 * (+n14 * n23 * n32
                - n13 * n24 * n32
                - n14 * n22 * n33
                + n12 * n24 * n33
                + n13 * n22 * n34
                - n12 * n23 * n34) +
                n42 * (+n11 * n23 * n34
                    - n11 * n24 * n33
                    + n14 * n21 * n33
                    - n13 * n21 * n34
                    + n13 * n24 * n31
                    - n14 * n23 * n31) +
                n43 * (+n11 * n24 * n32
                    - n11 * n22 * n34
                    - n14 * n21 * n32
                    + n12 * n21 * n34
                    + n14 * n22 * n31
                    - n12 * n24 * n31) +
                n44 * (-n13 * n22 * n31
                    - n11 * n23 * n32
                    + n11 * n22 * n33
                    + n13 * n21 * n32
                    - n12 * n21 * n33
                    + n12 * n23 * n31));
        };
        Matrix4.prototype.compose = function (translation, rotation, scale) {
            var rawData = this.rawData;
            var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
            var x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;
            var sx = scale.x, sy = scale.y, sz = scale.z;
            rawData[0] = (1.0 - (yy + zz)) * sx;
            rawData[1] = (xy + wz) * sx;
            rawData[2] = (xz - wy) * sx;
            rawData[3] = 0.0;
            rawData[4] = (xy - wz) * sy;
            rawData[5] = (1.0 - (xx + zz)) * sy;
            rawData[6] = (yz + wx) * sy;
            rawData[7] = 0.0;
            rawData[8] = (xz + wy) * sz;
            rawData[9] = (yz - wx) * sz;
            rawData[10] = (1.0 - (xx + yy)) * sz;
            rawData[11] = 0.0;
            rawData[12] = translation.x;
            rawData[13] = translation.y;
            rawData[14] = translation.z;
            rawData[15] = 1.0;
            return this;
        };
        Matrix4.prototype.decompose = function (translation, rotation, scale) {
            if (translation === void 0) { translation = null; }
            if (rotation === void 0) { rotation = null; }
            if (scale === void 0) { scale = null; }
            var rawData = this.rawData;
            if (translation) {
                translation.x = rawData[12];
                translation.y = rawData[13];
                translation.z = rawData[14];
            }
            if (rotation || scale) {
                var sx = _helpVector3A.set(rawData[0], rawData[1], rawData[2]).length;
                var sy = _helpVector3A.set(rawData[4], rawData[5], rawData[6]).length;
                var sz = _helpVector3A.set(rawData[8], rawData[9], rawData[10]).length;
                // if determine is negative, we need to invert one scale
                var det = this.determinant();
                if (det < 0.0)
                    sx = -sx;
                if (rotation) {
                    // scale the rotation part
                    _helpMatrix.copy(this);
                    var invSX = 1.0 / sx;
                    var invSY = 1.0 / sy;
                    var invSZ = 1.0 / sz;
                    _helpMatrix.rawData[0] *= invSX;
                    _helpMatrix.rawData[1] *= invSX;
                    _helpMatrix.rawData[2] *= invSX;
                    _helpMatrix.rawData[4] *= invSY;
                    _helpMatrix.rawData[5] *= invSY;
                    _helpMatrix.rawData[6] *= invSY;
                    _helpMatrix.rawData[8] *= invSZ;
                    _helpMatrix.rawData[9] *= invSZ;
                    _helpMatrix.rawData[10] *= invSZ;
                    rotation.fromMatrix(_helpMatrix);
                }
                if (scale) {
                    scale.x = sx;
                    scale.y = sy;
                    scale.z = sz;
                }
            }
            return this;
        };
        Matrix4.prototype.transpose = function (source) {
            if (!source) {
                source = this;
            }
            var valueRawData = source.rawData;
            var rawData = this.rawData;
            var temp = 0.0;
            temp = valueRawData[1];
            rawData[1] = valueRawData[4];
            rawData[4] = temp;
            temp = valueRawData[2];
            rawData[2] = valueRawData[8];
            rawData[8] = temp;
            temp = valueRawData[6];
            rawData[6] = valueRawData[9];
            rawData[9] = temp;
            temp = valueRawData[3];
            rawData[3] = valueRawData[12];
            rawData[12] = temp;
            temp = valueRawData[7];
            rawData[7] = valueRawData[13];
            rawData[13] = temp;
            temp = valueRawData[11];
            rawData[11] = valueRawData[14];
            rawData[14] = temp;
            return this;
        };
        Matrix4.prototype.inverse = function (source) {
            if (!source) {
                source = this;
            }
            var valueRawData = source.rawData;
            var rawData = this.rawData;
            var n11 = valueRawData[0], n21 = valueRawData[1], n31 = valueRawData[2], n41 = valueRawData[3], n12 = valueRawData[4], n22 = valueRawData[5], n32 = valueRawData[6], n42 = valueRawData[7], n13 = valueRawData[8], n23 = valueRawData[9], n33 = valueRawData[10], n43 = valueRawData[11], n14 = valueRawData[12], n24 = valueRawData[13], n34 = valueRawData[14], n44 = valueRawData[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0.0) {
                console.warn("Cannot invert matrix, determinant is 0.");
                return this.identity();
            }
            var detInv = 1.0 / det;
            rawData[0] = t11 * detInv;
            rawData[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            rawData[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            rawData[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            rawData[4] = t12 * detInv;
            rawData[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            rawData[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            rawData[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            rawData[8] = t13 * detInv;
            rawData[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            rawData[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            rawData[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            rawData[12] = t14 * detInv;
            rawData[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            rawData[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            rawData[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        };
        /**
         *
         * @param scale
         * @param input
         */
        Matrix4.prototype.multiplyScalar = function (scale, input) {
            if (!input) {
                input = this;
            }
            var sourceRawData = input.rawData;
            var rawData = this.rawData;
            rawData[0] = sourceRawData[0] * scale;
            rawData[1] = sourceRawData[1] * scale;
            rawData[2] = sourceRawData[2] * scale;
            rawData[3] = sourceRawData[3] * scale;
            rawData[4] = sourceRawData[4] * scale;
            rawData[5] = sourceRawData[5] * scale;
            rawData[6] = sourceRawData[6] * scale;
            rawData[7] = sourceRawData[7] * scale;
            rawData[8] = sourceRawData[8] * scale;
            rawData[9] = sourceRawData[9] * scale;
            rawData[10] = sourceRawData[10] * scale;
            rawData[11] = sourceRawData[11] * scale;
            rawData[12] = sourceRawData[12] * scale;
            rawData[13] = sourceRawData[13] * scale;
            rawData[14] = sourceRawData[14] * scale;
            rawData[15] = sourceRawData[15] * scale;
        };
        /**
         * - `v.multiply(a)` 将该矩阵与一个矩阵相乘的结果写入该矩阵，相当于 v *= a。
         * - `v.multiply(a, b)` 将两个矩阵相乘的结果写入该矩阵，相当于 v = a * b。
         * @param valueA 一个矩阵。
         * @param valueB 另一个矩阵。
         */
        Matrix4.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var rawDataA = valueA.rawData;
            var rawDataB = valueB.rawData;
            var rawData = this.rawData;
            var a11 = rawDataA[0], a12 = rawDataA[4], a13 = rawDataA[8], a14 = rawDataA[12];
            var a21 = rawDataA[1], a22 = rawDataA[5], a23 = rawDataA[9], a24 = rawDataA[13];
            var a31 = rawDataA[2], a32 = rawDataA[6], a33 = rawDataA[10], a34 = rawDataA[14];
            var a41 = rawDataA[3], a42 = rawDataA[7], a43 = rawDataA[11], a44 = rawDataA[15];
            var b11 = rawDataB[0], b12 = rawDataB[4], b13 = rawDataB[8], b14 = rawDataB[12];
            var b21 = rawDataB[1], b22 = rawDataB[5], b23 = rawDataB[9], b24 = rawDataB[13];
            var b31 = rawDataB[2], b32 = rawDataB[6], b33 = rawDataB[10], b34 = rawDataB[14];
            var b41 = rawDataB[3], b42 = rawDataB[7], b43 = rawDataB[11], b44 = rawDataB[15];
            rawData[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            rawData[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            rawData[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            rawData[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            rawData[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            rawData[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            rawData[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            rawData[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            rawData[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            rawData[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            rawData[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            rawData[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            rawData[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            rawData[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            rawData[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            rawData[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        };
        /**
         * 将一个矩阵与该矩阵相乘的结果写入该矩阵，相当于 v = x * v。
         * @param value 一个矩阵。
         */
        Matrix4.prototype.premultiply = function (value) {
            this.multiply(value, this);
            return this;
        };
        /**
         * - `v.lert(t, a)` 将该矩阵和一个矩阵插值的结果写入该矩阵。
         * - `v.lert(t, a, b)` 将两个矩阵插值的结果写入该矩阵。
         * @param t 插值。
         * @param valueA 一个矩阵。
         * @param valueB 另一个矩阵。
         */
        Matrix4.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var p = 1.0 - t;
            for (var i = 0; i < 16; i++) {
                this.rawData[i] = valueA.rawData[i] * p + valueB.rawData[i] * t;
            }
            return this;
        };
        /**
         * 设置该矩阵，使其 Z 轴正方向指向目标点。
         * - 矩阵的缩放值将被覆盖。
         * @param from 起始点。
         * @param to 目标点。
         * @param up 旋转后，该矩阵的 Y 轴正方向。
         */
        Matrix4.prototype.lookAt = function (from, to, up) {
            this.lookRotation(_helpVector3C.subtract(to, from), up);
            return this;
        };
        /**
         * 设置该矩阵，使其 Z 轴正方向指向目标方向。
         * - 矩阵的缩放值将被覆盖。
         * @param vector 目标方向。
         * @param up 旋转后，该矩阵的 Y 轴正方向。
         */
        Matrix4.prototype.lookRotation = function (vector, up) {
            var z = _helpVector3C.normalize(vector);
            var x = _helpVector3A.cross(up, z).normalize(undefined, egret3d.Vector3.RIGHT); //TODO  Vector3.FORWARD
            var y = _helpVector3B.cross(z, x);
            var rawData = this.rawData;
            rawData[0] = x.x;
            rawData[4] = y.x;
            rawData[8] = z.x;
            rawData[1] = x.y;
            rawData[5] = y.y;
            rawData[9] = z.y;
            rawData[2] = x.z;
            rawData[6] = y.z;
            rawData[10] = z.z;
            return this;
        };
        /**
         * 获得该矩阵最大的缩放值。
         */
        Matrix4.prototype.getMaxScaleOnAxis = function () {
            var rawData = this.rawData;
            var scaleXSq = rawData[0] * rawData[0] + rawData[1] * rawData[1] + rawData[2] * rawData[2];
            var scaleYSq = rawData[4] * rawData[4] + rawData[5] * rawData[5] + rawData[6] * rawData[6];
            var scaleZSq = rawData[8] * rawData[8] + rawData[9] * rawData[9] + rawData[10] * rawData[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        };
        /**
         * 将该旋转矩阵转换为数组。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Matrix4.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            for (var i = 0; i < 16; ++i) {
                array[i + offset] = this.rawData[i];
            }
            return array;
        };
        /**
         * 将该旋转矩阵转换为欧拉旋转。
         * @param euler 欧拉旋转。（弧度制）
         * @param order 欧拉旋转顺序。
         */
        Matrix4.prototype.toEuler = function (euler, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            if (!euler) {
                euler = egret3d.Vector3.create();
            }
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var rawData = this.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            switch (order) {
                case 0 /* XYZ */: {
                    euler.y = Math.asin(egret3d.floatClamp(m13, -1.0, 1.0));
                    if (Math.abs(m13) < 0.999999) {
                        euler.x = Math.atan2(-m23, m33);
                        euler.z = Math.atan2(-m12, m11);
                    }
                    else {
                        euler.x = Math.atan2(m32, m22);
                        euler.z = 0.0;
                    }
                    break;
                }
                case 1 /* XZY */: {
                    euler.z = Math.asin(-egret3d.floatClamp(m12, -1.0, 1.0));
                    if (Math.abs(m12) < 0.999999) {
                        euler.x = Math.atan2(m32, m22);
                        euler.y = Math.atan2(m13, m11);
                    }
                    else {
                        euler.x = Math.atan2(-m23, m33);
                        euler.y = 0.0;
                    }
                    break;
                }
                case 2 /* YXZ */: {
                    euler.x = Math.asin(-egret3d.floatClamp(m23, -1.0, 1.0));
                    if (Math.abs(m23) < 0.999999) {
                        euler.y = Math.atan2(m13, m33);
                        euler.z = Math.atan2(m21, m22);
                    }
                    else {
                        euler.y = Math.atan2(-m31, m11);
                        euler.z = 0.0;
                    }
                    break;
                }
                case 3 /* YZX */: {
                    euler.z = Math.asin(egret3d.floatClamp(m21, -1.0, 1.0));
                    if (Math.abs(m21) < 0.999999) {
                        euler.x = Math.atan2(-m23, m22);
                        euler.y = Math.atan2(-m31, m11);
                    }
                    else {
                        euler.x = 0.0;
                        euler.y = Math.atan2(m13, m33);
                    }
                    break;
                }
                case 4 /* ZXY */: {
                    euler.x = Math.asin(egret3d.floatClamp(m32, -1.0, 1.0));
                    if (Math.abs(m32) < 0.999999) {
                        euler.y = Math.atan2(-m31, m33);
                        euler.z = Math.atan2(-m12, m22);
                    }
                    else {
                        euler.y = 0.0;
                        euler.z = Math.atan2(m21, m11);
                    }
                    break;
                }
                case 5 /* ZYX */: {
                    euler.y = Math.asin(-egret3d.floatClamp(m31, -1.0, 1.0));
                    if (Math.abs(m31) < 0.999999) {
                        euler.x = Math.atan2(m32, m33);
                        euler.z = Math.atan2(m21, m11);
                    }
                    else {
                        euler.x = 0.0;
                        euler.z = Math.atan2(-m12, m22);
                    }
                    break;
                }
            }
            return euler;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.transformVector3 = function (value, out) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]) + this.rawData[12];
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]) + this.rawData[13];
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]) + this.rawData[14];
            var w = (value.x * this.rawData[3]) + (value.y * this.rawData[7]) + (value.z * this.rawData[11]) + this.rawData[15];
            if (!out) {
                out = value;
            }
            out.x = x / w;
            out.y = y / w;
            out.z = z / w;
            return out;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.transformNormal = function (value, out) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]);
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]);
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]);
            if (!out) {
                out = value;
            }
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        /**
         * @deprecated
         */
        Matrix4.perspectiveProjectLH = function (fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = (zfar + znear) / (zfar - znear);
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = -2 * (znear * zfar) / (zfar - znear);
            return out;
        };
        /**
         * @deprecated
         */
        Matrix4.orthoProjectLH = function (width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 2.0 / (zfar - znear);
            var nid = (znear + zfar) / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
            return out;
        };
        Matrix4.IDENTITY = new Matrix4();
        Matrix4._instances = [];
        return Matrix4;
    }(paper.BaseRelease));
    egret3d.Matrix4 = Matrix4;
    __reflect(Matrix4.prototype, "egret3d.Matrix4", ["paper.ICCS", "paper.ISerializable"]);
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixA = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixB = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixC = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixD = Matrix4.create();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 三角形。
     */
    var Triangle = (function (_super) {
        __extends(Triangle, _super);
        /**
         * 请使用 `egret3d.Triangle.create()` 创建实例。
         * @see egret3d.Triangle.create()
         */
        function Triangle() {
            var _this = _super.call(this) || this;
            /**
             * 点 A。
             */
            _this.a = egret3d.Vector3.create();
            /**
             * 点 B。
             */
            _this.b = egret3d.Vector3.create();
            /**
             * 点 C。
             */
            _this.c = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个三角形实例。
         * @param a 点 A。
         * @param b 点 B。
         * @param c 点 C。
         */
        Triangle.create = function (a, b, c) {
            if (a === void 0) { a = egret3d.Vector3.ZERO; }
            if (b === void 0) { b = egret3d.Vector3.ZERO; }
            if (c === void 0) { c = egret3d.Vector3.ZERO; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(a, b, c);
                instance._released = false;
                return instance;
            }
            return new Triangle().set(a, b, c);
        };
        /**
         * 通过三个点确定一个三角形，获取该三角形的法线。
         * @param a 点 A。
         * @param b 点 B。
         * @param c 点 C。
         * @param out 法线结果。
         */
        Triangle.getNormal = function (a, b, c, out) {
            // out.subtract(c, b); // Right-hand coordinates system.
            out.subtract(b, c); // Left-hand coordinates system.
            out.cross(egret3d.helpVector3A.subtract(a, b));
            var squaredLength = out.squaredLength;
            if (squaredLength > 0.0) {
                return out.multiplyScalar(1.0 / Math.sqrt(squaredLength));
            }
            return out.set(0.0, 0.0, 1.0);
        };
        Triangle.prototype.serialize = function () {
            return [
                this.a.x, this.a.y, this.a.z,
                this.b.x, this.b.y, this.b.z,
                this.c.x, this.c.y, this.c.z,
            ];
        };
        Triangle.prototype.deserialize = function (element) {
            return this.fromArray(element);
        };
        Triangle.prototype.copy = function (value) {
            return this.set(value.a, value.b, value.c);
        };
        Triangle.prototype.clone = function () {
            return Triangle.create(this.a, this.b, this.c);
        };
        Triangle.prototype.set = function (a, b, c) {
            if (a === void 0) { a = egret3d.Vector3.ZERO; }
            if (b === void 0) { b = egret3d.Vector3.ZERO; }
            if (c === void 0) { c = egret3d.Vector3.ZERO; }
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        };
        Triangle.prototype.fromArray = function (array, offsetA, offsetB, offsetC) {
            if (offsetA === void 0) { offsetA = 0; }
            if (offsetB === void 0) { offsetB = -1; }
            if (offsetC === void 0) { offsetC = -1; }
            this.a.fromArray(array, offsetA);
            this.b.fromArray(array, offsetB >= 0 ? offsetB : offsetA + 3);
            this.c.fromArray(array, offsetC >= 0 ? offsetC : offsetA + 6);
        };
        /**
         * 获取该三角形的面积。
         */
        Triangle.prototype.getArea = function () {
            egret3d.helpVector3A.subtract(this.c, this.b);
            egret3d.helpVector3B.subtract(this.a, this.b);
            return egret3d.helpVector3A.cross(egret3d.helpVector3B).length * 0.5;
        };
        /**
         * 获取该三角形的中心点。
         * @param out 输出。
         */
        Triangle.prototype.getCenter = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.add(this.a, this.b).add(this.c).multiplyScalar(1.0 / 3.0);
        };
        /**
         * 获取该三角形的法线。
         * @param out 输出。
         */
        Triangle.prototype.getNormal = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return Triangle.getNormal(this.a, this.b, this.c, out);
        };
        Triangle.prototype.raycast = function (ray, raycastInfo) {
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
            // const edge1 = helpVector3A;
            // const edge2 = helpVector3B;
            // const diff = helpVector3C;
            // const normal = helpVector3D;
            // edge1.subtract(p2, p1);
            // edge2.subtract(p3, p1);
            // normal.cross(edge1, edge2);
            // // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            // //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            // //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            // //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            // let DdN = this.direction.dot(normal);
            // let sign = 1.0;
            // if (DdN > 0.0) {
            //     if (backfaceCulling) return null;
            // }
            // else if (DdN < 0.0) {
            //     sign = -1.0;
            //     DdN = -DdN;
            // }
            // else {
            //     return null;
            // }
            // diff.subtract(this.origin, p1);
            // const DdQxE2 = sign * this.direction.dot(edge2.cross(diff, edge2));
            // // b1 < 0, no intersection
            // if (DdQxE2 < 0.0) {
            //     return null;
            // }
            // const DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
            // // b2 < 0, no intersection
            // if (DdE1xQ < 0.0) {
            //     return null;
            // }
            // // b1+b2 > 1, no intersection
            // if (DdQxE2 + DdE1xQ > DdN) {
            //     return null;
            // }
            // // Line intersects triangle, check if ray does.
            // const QdN = - sign * diff.dot(normal);
            // // t < 0, no intersection
            // if (QdN < 0) {
            //     return null;
            // }
            // const pickInfo = new PickInfo();
            // pickInfo.distance = QdN / DdN;
            // pickInfo.position.multiplyScalar(pickInfo.distance, this.direction).add(this.origin);
            // pickInfo.textureCoordA.x = DdQxE2;
            // pickInfo.textureCoordA.y = DdE1xQ;
            // return pickInfo;
            // TODO
            var edge1 = egret3d.helpVector3A;
            var edge2 = egret3d.helpVector3B;
            var pvec = egret3d.helpVector3C;
            var tvec = egret3d.helpVector3D;
            var qvec = egret3d.helpVector3E;
            var pA = this.a;
            var pB = this.b;
            var pC = this.c;
            edge1.subtract(pB, pA);
            edge2.subtract(pC, pA);
            pvec.cross(ray.direction, edge2);
            var det = pvec.dot(edge1);
            if (det === 0.0) {
                return false;
            }
            var invdet = 1.0 / det;
            tvec.subtract(ray.origin, pA);
            var bu = pvec.dot(tvec) * invdet;
            if (bu < 0.0 || bu > 1.0) {
                return false;
            }
            qvec.cross(tvec, edge1);
            var bv = qvec.dot(ray.direction) * invdet;
            if (bv < 0.0 || bu + bv > 1.0) {
                return false;
            }
            if (raycastInfo) {
                raycastInfo.textureCoordA.x = bu;
                raycastInfo.textureCoordA.y = bv;
                ray.at(raycastInfo.distance = qvec.dot(edge2) * invdet, raycastInfo.position);
                if (raycastInfo.normal) {
                    this.getNormal(raycastInfo.normal);
                }
            }
            return true;
        };
        Triangle._instances = [];
        return Triangle;
    }(paper.BaseRelease));
    egret3d.Triangle = Triangle;
    __reflect(Triangle.prototype, "egret3d.Triangle", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Vector4 = (function (_super) {
        __extends(Vector4, _super);
        /**
         * 请使用 `egret3d.Vector4.create(); egret3d.Quaternion.create()` 创建实例。
         * @see egret3d.Quaternion.create()
         * @see egret3d.Vector4.create()
         * @deprecated
         */
        function Vector4(x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.z = z;
            _this.w = w;
            return _this;
        }
        /**
         *
         */
        Vector4.create = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z, w);
                instance._released = false;
                return instance;
            }
            return new Vector4().set(x, y, z, w);
        };
        Vector4.prototype.serialize = function () {
            return [this.x, this.y, this.z, this.w];
        };
        Vector4.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector4.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.z, value.w);
        };
        Vector4.prototype.clone = function () {
            return Vector4.create(this.x, this.y, this.z, this.w);
        };
        Vector4.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Vector4.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = value[offset];
            this.y = value[offset + 1];
            this.z = value[offset + 2];
            this.w = value[offset + 3];
            return this;
        };
        Vector4.prototype.clear = function () {
            this.x = 0.0;
            this.y = 0.0;
            this.z = 0.0;
            this.w = 1.0;
        };
        /**
         * 向量归一化。
         * - `v.normalize()` 归一化该向量，相当于 v /= v.length。
         * - `v.normalize(input)` 将输入向量归一化的结果写入该向量，相当于 v = input / input.length。
         * @param input 输入向量。
         */
        Vector4.prototype.normalize = function (input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z, w = input.w;
            var l = Math.sqrt(x * x + y * y + z * z + w * w);
            if (l > egret3d.EPSILON) {
                l = 1.0 / l;
                this.x = x * l;
                this.y = y * l;
                this.z = z * l;
                this.w = w * l;
            }
            else {
                this.x = 0.0;
                this.y = 0.0;
                this.z = 0.0;
                this.w = 1.0;
            }
            return this;
        };
        /**
         * 判断该向量是否和一个向量相等。
         * @param value 一个向量。
         * @param threshold 阈值。
         */
        Vector4.prototype.equal = function (value, threshold) {
            if (threshold === void 0) { threshold = 0.000001; }
            if (Math.abs(this.x - value.x) <= threshold &&
                Math.abs(this.y - value.y) <= threshold &&
                Math.abs(this.z - value.z) <= threshold &&
                Math.abs(this.w - value.w) <= threshold) {
                return true;
            }
            return false;
        };
        /**
         * 向量与标量相乘运算。
         * - `v.multiplyScalar(scalar)` 将该向量与标量相乘，相当于 v *= scalar。
         * - `v.multiplyScalar(scalar, input)` 将输入向量与标量相乘的结果写入该向量，相当于 v = input * scalar。
         * @param scalar 标量。
         * @param input 输入向量。
         */
        Vector4.prototype.multiplyScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = scalar * input.x;
            this.y = scalar * input.y;
            this.z = scalar * input.z;
            this.w = scalar * input.w;
            return this;
        };
        /**
         * 向量点乘运算。
         * - `v.dot(a)` 将该向量与一个向量点乘，相当于 v ·= a。
         * - `v.dot(a, b)` 将两个向量点乘的结果写入该向量，相当于 v = a · b。
         * @param valueA 一个向量。
         * @param valueB 另一个向量。
         */
        Vector4.prototype.dot = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            return valueA.x * valueB.x + valueA.y * valueB.y + valueA.z * valueB.z + valueA.w * valueB.w;
        };
        /**
         * 将该向量转换为数组。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Vector4.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            array[0 + offset] = this.x;
            array[1 + offset] = this.y;
            array[2 + offset] = this.z;
            array[3 + offset] = this.w;
            return array;
        };
        Object.defineProperty(Vector4.prototype, "length", {
            /**
             * 该向量的长度。
             * - 该值是实时计算的。
             */
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector4.prototype, "squaredLength", {
            /**
             * 该向量的长度的平方。
             * - 该值是实时计算的。
             */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            },
            enumerable: true,
            configurable: true
        });
        Vector4._instances = [];
        return Vector4;
    }(paper.BaseRelease));
    egret3d.Vector4 = Vector4;
    __reflect(Vector4.prototype, "egret3d.Vector4", ["egret3d.IVector4", "egret3d.IVector3", "egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础预制体资源。
     * - 预制体资源和场景资源的基类。
     */
    var BasePrefabAsset = (function (_super) {
        __extends(BasePrefabAsset, _super);
        function BasePrefabAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._raw = null;
            return _this;
        }
        /**
         * @internal
         */
        BasePrefabAsset.prototype.parse = function (json) {
            this._raw = json;
        };
        BasePrefabAsset.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this._raw = null;
            return true;
        };
        BasePrefabAsset.prototype.caclByteLength = function () {
            return 0;
        };
        return BasePrefabAsset;
    }(paper.Asset));
    paper.BasePrefabAsset = BasePrefabAsset;
    __reflect(BasePrefabAsset.prototype, "paper.BasePrefabAsset");
    /**
     * 预制体资源。
     */
    var Prefab = (function (_super) {
        __extends(Prefab, _super);
        function Prefab() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Prefab.create = function (name, xOrScene, y, z, scene) {
            var prefab = paper.Asset.find(name);
            if (prefab && prefab instanceof Prefab) {
                if (xOrScene !== undefined && xOrScene !== null) {
                    if (xOrScene instanceof paper.Scene) {
                        var gameObject = prefab.createInstance(xOrScene);
                        if (gameObject) {
                            gameObject.transform.setLocalPosition(0.0, 0.0, 0.0);
                        }
                        return gameObject;
                    }
                    else {
                        var gameObject = prefab.createInstance(scene || null);
                        if (gameObject) {
                            gameObject.transform.setLocalPosition(xOrScene, y, z);
                        }
                        return gameObject;
                    }
                }
                else {
                    var gameObject = prefab.createInstance();
                    if (gameObject) {
                        gameObject.transform.setLocalPosition(0.0, 0.0, 0.0);
                    }
                    return gameObject;
                }
            }
            else {
                console.warn("The prefab don't exists.", name);
            }
            return null;
        };
        /**
         * @deprecated
         */
        Prefab.prototype.createInstance = function (scene, keepUUID) {
            if (!this._raw) {
                return null;
            }
            var isEditor = paper.Application.playerMode === 2 /* Editor */;
            var deserializer = new paper.Deserializer();
            var gameObject = deserializer.deserialize(this._raw, keepUUID, isEditor, scene);
            if (gameObject && isEditor) {
                if (!gameObject.extras.prefab) {
                    gameObject.extras.prefab = this;
                }
            }
            return gameObject;
        };
        return Prefab;
    }(BasePrefabAsset));
    paper.Prefab = Prefab;
    __reflect(Prefab.prototype, "paper.Prefab");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 基础渲染组件。
     */
    var BaseRenderer = (function (_super) {
        __extends(BaseRenderer, _super);
        function BaseRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 该组件是否开启视锥剔除。
             */
            _this.frustumCulled = true;
            /**
             * @internal
             */
            _this._aabbDirty = true;
            /**
             * @internal
             */
            _this._boundingSphereDirty = true;
            _this._receiveShadows = false;
            _this._castShadows = false;
            _this._lightmapIndex = -1;
            _this._boundingSphere = egret3d.Sphere.create();
            _this._aabb = egret3d.AABB.create();
            _this._materials = [egret3d.DefaultMaterials.MESH_BASIC];
            return _this;
        }
        BaseRenderer.prototype._recalculateSphere = function () {
            var aabb = this.aabb; // Update aabb.
            var worldMatrix = this.gameObject.transform.getWorldMatrix();
            this._boundingSphere.set(aabb.center, aabb.boundingSphereRadius);
            this._boundingSphere.center.applyMatrix(worldMatrix);
            this._boundingSphere.radius *= worldMatrix.getMaxScaleOnAxis();
        };
        BaseRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this._materials.length = 0;
        };
        Object.defineProperty(BaseRenderer.prototype, "receiveShadows", {
            /**
             * 该渲染组件是否接收投影。
             */
            get: function () {
                return this._receiveShadows;
            },
            set: function (value) {
                if (value === this._receiveShadows) {
                    return;
                }
                this._receiveShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "castShadows", {
            /**
             * 该渲染组件是否产生投影。
             */
            get: function () {
                return this._castShadows;
            },
            set: function (value) {
                if (value === this._castShadows) {
                    return;
                }
                this._castShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "lightmapIndex", {
            /**
             * 该渲染组件的光照图索引。
             */
            get: function () {
                return this._lightmapIndex;
            },
            set: function (value) {
                if (value === this._lightmapIndex) {
                    return;
                }
                this._lightmapIndex = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "aabb", {
            /**
             * 该渲染组件的本地包围盒。
             */
            get: function () {
                if (this._aabbDirty) {
                    this.recalculateAABB();
                    this._aabbDirty = false;
                }
                return this._aabb;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "boundingSphere", {
            /**
             * 该渲染组件本地包围盒的世界包围球，用于摄像机视锥剔除。
             */
            get: function () {
                if (this._boundingSphereDirty) {
                    this._recalculateSphere();
                    this._boundingSphereDirty = false;
                }
                return this._boundingSphere;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "materials", {
            /**
             * 该渲染组件的材质列表。
             */
            get: function () {
                return this._materials;
            },
            set: function (value) {
                if (value === this._materials) {
                    return;
                }
                // TODO 共享材质的接口。
                this._materials.length = 0;
                for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                    var material = value_1[_i];
                    if (!material) {
                        console.warn("Invalid material.");
                    }
                    this._materials.push(material || egret3d.DefaultMaterials.MISSING);
                }
                BaseRenderer.onMaterialsChanged.dispatch(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "material", {
            /**
             * 该渲染组件材质列表中的第一个材质。
             */
            get: function () {
                return this._materials.length > 0 ? this._materials[0] : null;
            },
            set: function (value) {
                var dirty = false;
                if (value) {
                    if (this._materials.length > 0) {
                        if (this._materials[0] !== value) {
                            this._materials[0] = value;
                            dirty = true;
                        }
                    }
                    else {
                        this._materials.push(value);
                        dirty = true;
                    }
                }
                else if (this._materials.length > 0) {
                    this._materials.splice(0, 1);
                    dirty = true;
                }
                if (dirty) {
                    BaseRenderer.onMaterialsChanged.dispatch(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当渲染组件的材质列表改变时派发事件。
         */
        BaseRenderer.onMaterialsChanged = new signals.Signal();
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseRenderer.prototype, "frustumCulled", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_receiveShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_castShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_lightmapIndex", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_materials", void 0);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseRenderer.prototype, "receiveShadows", null);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseRenderer.prototype, "castShadows", null);
        __decorate([
            paper.editor.property("INT" /* INT */, { minimum: -1 })
        ], BaseRenderer.prototype, "lightmapIndex", null);
        __decorate([
            paper.editor.property("MATERIAL_ARRAY" /* MATERIAL_ARRAY */)
        ], BaseRenderer.prototype, "materials", null);
        return BaseRenderer;
    }(paper.BaseComponent));
    paper.BaseRenderer = BaseRenderer;
    __reflect(BaseRenderer.prototype, "paper.BaseRenderer", ["egret3d.ITransformObserver", "egret3d.IRaycast"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 碰撞体类型。
     * - 枚举需要支持的全部碰撞体类型。
     */
    var ColliderType;
    (function (ColliderType) {
        /**
         * 立方体。
         */
        ColliderType[ColliderType["Box"] = 0] = "Box";
        /**
         * 球体。
         */
        ColliderType[ColliderType["Sphere"] = 1] = "Sphere";
        /**
         * 圆柱体。
         */
        ColliderType[ColliderType["Cylinder"] = 2] = "Cylinder";
        /**
         * 圆锥体。
         */
        ColliderType[ColliderType["Cone"] = 3] = "Cone";
        /**
         * 胶囊体。
         */
        ColliderType[ColliderType["Capsule"] = 4] = "Capsule";
        /**
         * TODO
         */
        ColliderType[ColliderType["ConvexHull"] = 5] = "ConvexHull";
    })(ColliderType = egret3d.ColliderType || (egret3d.ColliderType = {}));
    /**
     * 射线检测信息。
     */
    var RaycastInfo = (function (_super) {
        __extends(RaycastInfo, _super);
        function RaycastInfo() {
            var _this = _super.call(this) || this;
            _this.subMeshIndex = -1;
            _this.triangleIndex = -1;
            /**
             * 交点到射线起始点的距离。
             */
            _this.distance = 0.0;
            /**
             * 相交的点。
             */
            _this.position = egret3d.Vector3.create();
            _this.textureCoordA = egret3d.Vector2.create();
            _this.textureCoordB = egret3d.Vector2.create();
            /**
             * 相交的法线。
             * - 提供法线向量将计算法线。
             */
            _this.normal = null;
            /**
             * 相交的变换组件。（如果有的话）
             */
            _this.transform = null;
            /**
             * 相交的碰撞组件。（如果有的话）
             */
            _this.collider = null;
            /**
             * 相交的刚体组件。（如果有的话）
             */
            _this.rigidbody = null;
            return _this;
        }
        /**
         * 创建一个射线检测信息实例。
         */
        RaycastInfo.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new RaycastInfo();
        };
        RaycastInfo.prototype.onClear = function () {
            this.subMeshIndex = -1;
            this.triangleIndex = -1;
            this.distance = 0.0;
            this.position.set(0.0, 0.0, 0.0);
            this.textureCoordA.set(0.0, 0.0);
            this.textureCoordB.set(0.0, 0.0);
            this.normal = null;
            this.transform = null;
            this.collider = null;
            this.rigidbody = null;
        };
        RaycastInfo._instances = [];
        return RaycastInfo;
    }(paper.BaseRelease));
    egret3d.RaycastInfo = RaycastInfo;
    __reflect(RaycastInfo.prototype, "egret3d.RaycastInfo");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * glTF 资源。
     */
    var GLTFAsset = (function (_super) {
        __extends(GLTFAsset, _super);
        function GLTFAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Buffer 列表。
             */
            _this.buffers = [];
            /**
             * 配置。
             */
            _this.config = null;
            return _this;
        }
        /**
         *
         */
        GLTFAsset._createConfig = function () {
            var config = {
                version: "4",
                asset: {
                    version: "2.0"
                },
                extensions: {},
                extensionsRequired: ["paper"],
                extensionsUsed: ["paper"],
            };
            return config;
        };
        /**
         * 从二进制数据中解析。
         */
        GLTFAsset.parseFromBinary = function (array) {
            var index = 0;
            var result = { config: {}, buffers: [] };
            if (array[index++] !== 0x46546C67 ||
                array[index++] !== 2) {
                console.assert(false, "Nonsupport glTF data.");
                return;
            }
            if (array[index++] !== array.byteLength) {
                console.assert(false, "Error glTF data.");
                return;
            }
            var chunkLength = 0;
            var chunkType = 0;
            while (index < array.length) {
                chunkLength = array[index++];
                chunkType = array[index++];
                if (chunkLength % 4) {
                    console.assert(false, "Error glTF data.");
                }
                if (chunkType === 0x4E4F534A) {
                    var jsonArray = new Uint8Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint8Array.BYTES_PER_ELEMENT);
                    var jsonString = egret3d.io.BinReader.utf8ArrayToString(jsonArray);
                    result.config = JSON.parse(jsonString);
                }
                else if (chunkType === 0x004E4942) {
                    var buffer = new Uint32Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint32Array.BYTES_PER_ELEMENT);
                    result.buffers.push(buffer);
                }
                else {
                    console.assert(false, "Nonsupport glTF data.");
                    return;
                }
                index += chunkLength / 4;
            }
            return result;
        };
        /**
         *
         */
        GLTFAsset.createMeshConfig = function () {
            var config = this._createConfig();
            config.buffers = [{ byteLength: 0 }];
            config.bufferViews = [{ buffer: 0, byteOffset: 0, byteLength: 0, target: 34962 /* ArrayBuffer */ }]; // VBO
            config.accessors = [];
            config.meshes = [{
                    primitives: [{ attributes: {} }],
                    extensions: { paper: {} },
                }];
            return config;
        };
        /**
         *
         */
        GLTFAsset.createGLTFExtensionsConfig = function () {
            var config = this._createConfig();
            config.materials = [];
            config.extensions = {
                KHR_techniques_webgl: {
                    shaders: [],
                    techniques: [],
                    programs: [],
                },
                paper: {},
            };
            return config;
        };
        GLTFAsset.createTechnique = function (source) {
            var target = { name: source.name, attributes: {}, uniforms: {} }; // , states: { enable: [], functions: {} }
            for (var key in source.attributes) {
                var attribute = source.attributes[key];
                target.attributes[key] = { semantic: attribute.semantic };
            }
            for (var key in source.uniforms) {
                var uniform = source.uniforms[key];
                var value = void 0;
                if (uniform.type === 35678 /* SAMPLER_2D */ && !uniform.value) {
                    value = egret3d.DefaultTextures.WHITE; // Default texture.
                }
                else if (Array.isArray(uniform.value)) {
                    value = uniform.value ? uniform.value.concat() : [];
                }
                else {
                    value = uniform.value ? uniform.value : [];
                }
                var targetUniform = target.uniforms[key] = { type: uniform.type, value: value };
                if (uniform.semantic) {
                    targetUniform.semantic = uniform.semantic;
                }
            }
            // if (source.states) {
            //     const states = GLTFAsset.copyTechniqueStates(source.states);
            //     if (states) {
            //         target.states = states;
            //     }
            // }
            return target;
        };
        GLTFAsset.copyTechniqueStates = function (source, target) {
            if (source.enable && source.enable.length > 0) {
                if (!target) {
                    target = {};
                }
                target.enable = source.enable.concat();
            }
            if (source.functions) {
                for (var k in source.functions) {
                    if (!target) {
                        target = {};
                    }
                    if (!target.functions) {
                        target.functions = {};
                    }
                    if (Array.isArray(source.functions[k])) {
                        target.functions[k] = source.functions[k].concat();
                    }
                    else {
                        target.functions[k] = source.functions[k];
                    }
                }
            }
            return target;
        };
        GLTFAsset.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this.buffers.length = 0; // TODO clear buffer.
            this.config = null;
            return true;
        };
        GLTFAsset.prototype.caclByteLength = function () {
            return 0;
        };
        /**
         * 根据指定 BufferView 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromBufferView = function (bufferView, componentType) {
            var buffer = this.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0);
            // assert.config.buffers[bufferView.buffer];
            switch (componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int8Array.BYTES_PER_ELEMENT);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint8Array.BYTES_PER_ELEMENT);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int16Array.BYTES_PER_ELEMENT);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int32Array.BYTES_PER_ELEMENT);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint32Array.BYTES_PER_ELEMENT);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Float32Array.BYTES_PER_ELEMENT);
                default:
                    throw new Error();
            }
        };
        /**
         * 根据指定 Accessor 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromAccessor = function (accessor, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var accessorTypeCount = this.getAccessorTypeCount(accessor.type);
            var bufferCount = accessorTypeCount * Math.min(accessor.count - offset, count || accessor.count);
            var bufferView = this.getBufferView(accessor);
            var buffer = this.buffers[bufferView.buffer];
            // assert.config.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
            if (offset > 0) {
                bufferOffset += offset * accessorTypeCount * this.getComponentTypeCount(accessor.componentType);
            }
            switch (accessor.componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferCount);
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.prototype.getComponentTypeCount = function (type) {
            switch (type) {
                case 5120 /* Byte */:
                case 5121 /* UnsignedByte */:
                    return 1;
                case 5122 /* Short */:
                case 5123 /* UnsignedShort */:
                    return 2;
                case 5124 /* Int */:
                case 5125 /* UnsignedInt */:
                    return 4;
                case 5126 /* Float */:
                    return 4;
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.prototype.getAccessorTypeCount = function (type) {
            switch (type) {
                case "SCALAR" /* SCALAR */:
                    return 1;
                case "VEC2" /* VEC2 */:
                    return 2;
                case "VEC3" /* VEC3 */:
                    return 3;
                case "VEC4" /* VEC4 */:
                case "MAT2" /* MAT2 */:
                    return 4;
                case "MAT3" /* MAT3 */:
                    return 9;
                case "MAT4" /* MAT4 */:
                    return 16;
                default:
                    throw new Error();
            }
        };
        /**
         * 自定义 Mesh 的属性枚举。
         */
        GLTFAsset.prototype.getMeshAttributeType = function (type) {
            switch (type) {
                case "POSITION" /* POSITION */:
                case "NORMAL" /* NORMAL */:
                    return "VEC3" /* VEC3 */;
                case "TEXCOORD_0" /* TEXCOORD_0 */:
                case "TEXCOORD_1" /* TEXCOORD_1 */:
                    return "VEC2" /* VEC2 */;
                case "TANGENT" /* TANGENT */:
                case "COLOR_0" /* COLOR_0 */:
                case "COLOR_1" /* COLOR_1 */:
                case "JOINTS_0" /* JOINTS_0 */:
                case "WEIGHTS_0" /* WEIGHTS_0 */:
                    return "VEC4" /* VEC4 */;
                default:
                    throw new Error();
            }
        };
        /**
         * 通过 Accessor 获取指定 BufferLength。
         */
        GLTFAsset.prototype.getBufferLength = function (accessor) {
            return this.getAccessorTypeCount(accessor.type) * this.getComponentTypeCount(accessor.componentType) * accessor.count;
        };
        /**
         * 通过 Accessor 获取指定 BufferOffset。
         */
        GLTFAsset.prototype.getBufferOffset = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // const buffer = this.buffers[bufferView.buffer];
            return (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
        };
        /**
         * 通过 Accessor 获取指定 Buffer。
         */
        GLTFAsset.prototype.getBuffer = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // this.config.buffers[bufferView.buffer];
            return this.buffers[bufferView.buffer];
        };
        /**
         * 通过 Accessor 获取指定 BufferView。
         */
        GLTFAsset.prototype.getBufferView = function (accessor) {
            return this.config.bufferViews[accessor.bufferView || 0];
        };
        /**
         * 通过 Accessor 索引，获取指定 Accessor。
         */
        GLTFAsset.prototype.getAccessor = function (index) {
            return this.config.accessors[index];
        };
        /**
         * 获取节点。
         */
        GLTFAsset.prototype.getNode = function (index) {
            return this.config.nodes[index];
        };
        /*
         * 获取动画剪辑。
         */
        GLTFAsset.prototype.getAnimationClip = function (name) {
            if (!this.config.animations ||
                this.config.animations.length === 0) {
                return null;
            }
            var animation = this.config.animations[0];
            if (animation.extensions.paper.clips.length === 0) {
                return null;
            }
            if (!name) {
                return animation.extensions.paper.clips[0];
            }
            for (var _i = 0, _a = this.config.animations; _i < _a.length; _i++) {
                var animation_1 = _a[_i];
                for (var _b = 0, _c = animation_1.extensions.paper.clips; _b < _c.length; _b++) {
                    var animationClip = _c[_b];
                    if (animationClip.name === name) {
                        return animationClip;
                    }
                }
            }
            return null;
        };
        return GLTFAsset;
    }(paper.Asset));
    egret3d.GLTFAsset = GLTFAsset;
    __reflect(GLTFAsset.prototype, "egret3d.GLTFAsset");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 场景资源。
     */
    var RawScene = (function (_super) {
        __extends(RawScene, _super);
        function RawScene() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @internal
         */
        RawScene.prototype.createInstance = function (keepUUID) {
            if (keepUUID === void 0) { keepUUID = false; }
            if (!this._raw) {
                return null;
            }
            var isEditor = paper.Application.playerMode === 2 /* Editor */;
            var deserializer = new paper.Deserializer();
            var scene = deserializer.deserialize(this._raw, keepUUID);
            if (scene && isEditor) {
            }
            return scene;
        };
        return RawScene;
    }(paper.BasePrefabAsset));
    paper.RawScene = RawScene;
    __reflect(RawScene.prototype, "paper.RawScene");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var HideFlags;
    (function (HideFlags) {
        /**
         *
         */
        HideFlags[HideFlags["None"] = 0] = "None";
        /**
         *
         */
        HideFlags[HideFlags["NotEditable"] = 1] = "NotEditable";
        /**
         *
         */
        HideFlags[HideFlags["Hide"] = 2] = "Hide";
        /**
         *
         */
        HideFlags[HideFlags["HideAndDontSave"] = 3] = "HideAndDontSave";
    })(HideFlags = paper.HideFlags || (paper.HideFlags = {}));
    /**
     *
     */
    var DefaultNames;
    (function (DefaultNames) {
        DefaultNames["NoName"] = "NoName";
        DefaultNames["Global"] = "Global";
        DefaultNames["MainCamera"] = "Main Camera";
        DefaultNames["EditorCamera"] = "Editor Camera";
        DefaultNames["EditorOnly"] = "Editor Only";
        DefaultNames["MissingPrefab"] = "Missing Prefab";
    })(DefaultNames = paper.DefaultNames || (paper.DefaultNames = {}));
    /**
     *
     */
    var DefaultTags;
    (function (DefaultTags) {
        DefaultTags["Untagged"] = "";
        DefaultTags["Respawn"] = "Respawn";
        DefaultTags["Finish"] = "Finish";
        DefaultTags["EditorOnly"] = "Editor Only";
        DefaultTags["MainCamera"] = "Main Camera";
        DefaultTags["Player"] = "Player";
        DefaultTags["GameController"] = "Game Controller";
        DefaultTags["Global"] = "Global";
    })(DefaultTags = paper.DefaultTags || (paper.DefaultTags = {}));
    /**
     * 系统排序。
     */
    var SystemOrder;
    (function (SystemOrder) {
        SystemOrder[SystemOrder["Begin"] = 0] = "Begin";
        SystemOrder[SystemOrder["Enable"] = 1000] = "Enable";
        SystemOrder[SystemOrder["Start"] = 2000] = "Start";
        SystemOrder[SystemOrder["FixedUpdate"] = 3000] = "FixedUpdate";
        SystemOrder[SystemOrder["Update"] = 4000] = "Update";
        SystemOrder[SystemOrder["Animation"] = 5000] = "Animation";
        SystemOrder[SystemOrder["LaterUpdate"] = 6000] = "LaterUpdate";
        SystemOrder[SystemOrder["Renderer"] = 7000] = "Renderer";
        SystemOrder[SystemOrder["Draw"] = 8000] = "Draw";
        SystemOrder[SystemOrder["Disable"] = 9000] = "Disable";
        SystemOrder[SystemOrder["End"] = 10000] = "End";
    })(SystemOrder = paper.SystemOrder || (paper.SystemOrder = {}));
    /**
     * 渲染排序。
     */
    var RenderQueue;
    (function (RenderQueue) {
        RenderQueue[RenderQueue["Background"] = 1000] = "Background";
        RenderQueue[RenderQueue["Geometry"] = 2000] = "Geometry";
        RenderQueue[RenderQueue["AlphaTest"] = 2450] = "AlphaTest";
        RenderQueue[RenderQueue["Transparent"] = 3000] = "Transparent";
        RenderQueue[RenderQueue["Overlay"] = 4000] = "Overlay";
    })(RenderQueue = paper.RenderQueue || (paper.RenderQueue = {}));
    /**
     * 这里暂未实现用户自定义层级，但用户可以使用预留的UserLayer。
     * 这个属性可以实现相机的选择性剔除。
     */
    var Layer;
    (function (Layer) {
        Layer[Layer["Default"] = 2] = "Default";
        Layer[Layer["UI"] = 4] = "UI";
        Layer[Layer["UserLayer1"] = 8] = "UserLayer1";
        Layer[Layer["UserLayer2"] = 16] = "UserLayer2";
        Layer[Layer["UserLayer3"] = 32] = "UserLayer3";
        Layer[Layer["UserLayer4"] = 64] = "UserLayer4";
        Layer[Layer["UserLayer5"] = 128] = "UserLayer5";
        Layer[Layer["UserLayer6"] = 240] = "UserLayer6";
        Layer[Layer["UserLayer7"] = 256] = "UserLayer7";
        Layer[Layer["UserLayer8"] = 512] = "UserLayer8";
        Layer[Layer["UserLayer9"] = 1024] = "UserLayer9";
        Layer[Layer["UserLayer10"] = 2048] = "UserLayer10";
        Layer[Layer["UserLayer11"] = 3840] = "UserLayer11";
    })(Layer = paper.Layer || (paper.Layer = {}));
    /**
     * culling mask
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * culling mask 枚举。
     * 相机的cullingmask与renderer的renderLayer相匹配，才会执行渲染。否则将会被跳过。
     * 这个属性可以实现相机的选择性剔除。
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var CullingMask;
    (function (CullingMask) {
        CullingMask[CullingMask["Everything"] = 16777215] = "Everything";
        CullingMask[CullingMask["Nothing"] = 1] = "Nothing";
        CullingMask[CullingMask["Default"] = 2] = "Default";
        CullingMask[CullingMask["UI"] = 4] = "UI";
        CullingMask[CullingMask["UserLayer1"] = 8] = "UserLayer1";
        CullingMask[CullingMask["UserLayer2"] = 16] = "UserLayer2";
        CullingMask[CullingMask["UserLayer3"] = 32] = "UserLayer3";
        CullingMask[CullingMask["UserLayer4"] = 64] = "UserLayer4";
        CullingMask[CullingMask["UserLayer5"] = 128] = "UserLayer5";
        CullingMask[CullingMask["UserLayer6"] = 240] = "UserLayer6";
        CullingMask[CullingMask["UserLayer7"] = 256] = "UserLayer7";
        CullingMask[CullingMask["UserLayer8"] = 512] = "UserLayer8";
        CullingMask[CullingMask["UserLayer9"] = 1024] = "UserLayer9";
        CullingMask[CullingMask["UserLayer10"] = 2048] = "UserLayer10";
        CullingMask[CullingMask["UserLayer11"] = 3840] = "UserLayer11";
    })(CullingMask = paper.CullingMask || (paper.CullingMask = {}));
    // /**
    //  * 
    //  * @param cullingMask 
    //  * @param layer 
    //  */
    // export function layerTest(cullingMask: CullingMask, layer: Layer) {
    //     return (cullingMask & layer) !== 0;
    // }
    // /**
    //  * 
    //  * @param cullingMask 
    //  * @param layer 
    //  */
    // export function removeLayer(cullingMask: CullingMask, layer: Layer) {
    //     return cullingMask & ~layer;
    // }
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 程序场景管理器。
     */
    var SceneManager = (function () {
        function SceneManager() {
            this._scenes = [];
            this._globalScene = null;
            this._editorScene = null;
        }
        /**
         * 场景管理器单例。
         */
        SceneManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SceneManager();
            }
            return this._instance;
        };
        /**
         * @internal
         */
        SceneManager.prototype.addScene = function (scene, isActive) {
            if (this._scenes.indexOf(scene) >= 0) {
                console.warn("Add the scene again.", scene.name);
            }
            if (isActive) {
                this._scenes.unshift(scene);
            }
            else {
                this._scenes.push(scene);
            }
        };
        /**
         * @internal
         */
        SceneManager.prototype.removeScene = function (scene) {
            if (scene === this._globalScene ||
                scene === this._editorScene) {
                console.warn("Cannot dispose global scene.");
                return false;
            }
            var index = this._scenes.indexOf(scene);
            if (index < 0) {
                console.warn("Remove scene error.", scene.name);
                return false;
            }
            this._scenes.splice(index, 1);
            return true;
        };
        /**
         * 卸载程序中的全部场景。
         * - 不包含全局场景。
         */
        SceneManager.prototype.unloadAllScene = function (excludes) {
            var i = this._scenes.length;
            while (i--) {
                var scene = this._scenes[i];
                if (excludes && excludes.indexOf(scene) >= 0) {
                    continue;
                }
                scene.destroy();
            }
        };
        /**
         * 从程序已创建的全部场景中获取指定名称的场景。
         */
        SceneManager.prototype.getScene = function (name) {
            for (var _i = 0, _a = this._scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                if (scene.name === name) {
                    return scene;
                }
            }
            return null;
        };
        Object.defineProperty(SceneManager.prototype, "scenes", {
            /**
             * 程序已创建的全部动态场景。
             */
            get: function () {
                return this._scenes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalScene", {
            /**
             * 全局静态的场景。
             * - 全局场景无法被销毁。
             */
            get: function () {
                if (!this._globalScene) {
                    this._globalScene = paper.Scene.createEmpty("Global" /* Global */, false);
                    this._scenes.pop(); // Remove global scene from scenes.
                }
                return this._globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "editorScene", {
            /**
             * 全局静态编辑器的场景。
             */
            get: function () {
                if (!this._editorScene) {
                    this._editorScene = paper.Scene.createEmpty("Editor Only" /* EditorOnly */, false);
                    this._scenes.pop(); // Remove editor scene from scenes.
                }
                return this._editorScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "activeScene", {
            /**
             * 当前激活的场景。
             */
            get: function () {
                if (this._scenes.length === 0) {
                    paper.Scene.createEmpty();
                }
                return this._scenes[0];
            },
            set: function (value) {
                if (this._scenes.length <= 1 ||
                    this._scenes[0] === value ||
                    this._globalScene === value //|| // Cannot active global scene.
                ) {
                    return;
                }
                var index = this._scenes.indexOf(value);
                if (index < 0) {
                    console.warn("Active scene error.", value.name);
                }
                this._scenes.splice(index, 1);
                this._scenes.unshift(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        SceneManager.prototype.createScene = function (name, isActive) {
            if (isActive === void 0) { isActive = true; }
            return paper.Scene.createEmpty(name, isActive);
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.loadScene = function (resourceName, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            return paper.Scene.create(resourceName, combineStaticObjects);
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.unloadScene = function (scene) {
            scene.destroy();
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.getActiveScene = function () {
            return this.activeScene;
        };
        SceneManager._instance = null;
        return SceneManager;
    }());
    paper.SceneManager = SceneManager;
    __reflect(SceneManager.prototype, "paper.SceneManager");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 几何平面。
     */
    var Plane = (function (_super) {
        __extends(Plane, _super);
        /**
         * 请使用 `egret3d.Plane.create()` 创建实例。
         * @see egret3d.Plane.create()
         */
        function Plane() {
            var _this = _super.call(this) || this;
            /**
             * 二维平面到原点的距离。
             */
            _this.constant = 0.0;
            /**
             * 平面的法线。
             */
            _this.normal = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个几何平面。
         * @param normal 法线。
         * @param constant 二维平面离原点的距离。
         */
        Plane.create = function (normal, constant) {
            if (normal === void 0) { normal = egret3d.Vector3.ZERO; }
            if (constant === void 0) { constant = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(normal, constant);
                instance._released = false;
                return instance;
            }
            return new Plane().set(normal, constant);
        };
        Plane.prototype.serialize = function () {
            return [this.normal.x, this.normal.y, this.normal.z, this.constant];
        };
        Plane.prototype.deserialize = function (value) {
            this.constant = value[3];
            this.normal.fromArray(value);
            return this;
        };
        Plane.prototype.clone = function () {
            return Plane.create(this.normal, this.constant);
        };
        Plane.prototype.copy = function (value) {
            return this.set(value.normal, value.constant);
        };
        Plane.prototype.set = function (normal, constant) {
            this.constant = constant;
            this.normal.copy(normal);
            return this;
        };
        Plane.prototype.fromPoint = function (value, normal) {
            if (normal === void 0) { normal = egret3d.Vector3.UP; }
            this.constant = -egret3d.helpVector3A.dot(normal, value);
            this.normal.copy(normal);
            return this;
        };
        Plane.prototype.fromPoints = function (valueA, valueB, valueC) {
            var normal = egret3d.helpVector3A.subtract(valueC, valueB).cross(egret3d.helpVector3B.subtract(valueA, valueB)).normalize();
            this.fromPoint(valueA, normal);
            return this;
        };
        Plane.prototype.normalize = function (source) {
            if (!source) {
                source = this;
            }
            var inverseNormalLength = source.normal.length;
            this.constant = source.constant * (1.0 / inverseNormalLength);
            this.normal.multiplyScalar(inverseNormalLength, source.normal);
            return this;
        };
        Plane.prototype.negate = function (source) {
            if (!source) {
                source = this;
            }
            this.constant = -source.constant;
            this.normal.negate(source.normal);
            return this;
        };
        Plane.prototype.getDistance = function (value) {
            return this.normal.dot(value) + this.constant;
        };
        Plane.prototype.raycast = function (ray, raycastInfo) {
            var t = ray.getDistanceToPlane(this);
            if (t > 0.0) {
                if (raycastInfo) {
                    var normal = raycastInfo.normal;
                    raycastInfo.distance = t;
                    ray.at(t, raycastInfo.position);
                    if (normal) {
                        // TODO
                        normal.copy(this.normal);
                    }
                }
                return true;
            }
            return false;
        };
        Plane._instances = [];
        return Plane;
    }(paper.BaseRelease));
    egret3d.Plane = Plane;
    __reflect(Plane.prototype, "egret3d.Plane", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
    /**
     * @internal
     */
    var helpPlane = Plane.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础单例组件。
     * - 全部单例组件的基类。
     */
    var SingletonComponent = (function (_super) {
        __extends(SingletonComponent, _super);
        function SingletonComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @internal
         */
        SingletonComponent.__isSingleton = true;
        return SingletonComponent;
    }(paper.BaseComponent));
    paper.SingletonComponent = SingletonComponent;
    __reflect(SingletonComponent.prototype, "paper.SingletonComponent");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var BaseState = (function () {
            function BaseState() {
                this.autoClear = false;
                this.batchIndex = 0;
                this._isDone = false;
            }
            BaseState.prototype.undo = function () {
                if (this._isDone) {
                    this._isDone = false;
                    return true;
                }
                return false;
            };
            BaseState.prototype.redo = function () {
                if (this._isDone) {
                    return false;
                }
                this._isDone = true;
                this.editorModel.dirty = true;
                return true;
            };
            Object.defineProperty(BaseState.prototype, "isDone", {
                get: function () {
                    return this._isDone;
                },
                set: function (value) {
                    this._isDone = value;
                },
                enumerable: true,
                configurable: true
            });
            BaseState.prototype.dispatchEditorModelEvent = function (type, data) {
                this.editorModel.dispatchEvent(new editor.EditorModelEvent(type, data));
            };
            BaseState.prototype.serialize = function () {
                return null;
            };
            BaseState.prototype.deserialize = function (data) {
            };
            return BaseState;
        }());
        editor.BaseState = BaseState;
        __reflect(BaseState.prototype, "paper.editor.BaseState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var _createEnabled = false;
    /**
     * 基础系统。
     * - 全部系统的基类。
     */
    var BaseSystem = (function () {
        /**
         * 禁止实例化系统。
         * @protected
         */
        function BaseSystem(order) {
            if (order === void 0) { order = -1; }
            /**
             *
             */
            this.order = -1;
            /**
             * @internal
             */
            this._started = true;
            this._locked = false;
            /**
             * 系统是否激活。
             */
            this._enabled = true;
            /**
             *
             */
            this._interests = [];
            /**
             *
             */
            this._groups = [];
            /**
             * 全局时钟信息组件实例。
             */
            this._clock = paper.GameObject.globalGameObject.getOrAddComponent(paper.Clock);
            if (!_createEnabled) {
                throw new Error("Create an instance of a system is not allowed.");
            }
            _createEnabled = false;
            this.order = order;
        }
        /**
         * @internal
         */
        BaseSystem.create = function (systemClass, order) {
            _createEnabled = true;
            return new systemClass(order);
        };
        /**
         * 系统内部初始化。
         * @internal
         */
        BaseSystem.prototype.initialize = function (config) {
            if (this._interests.length > 0) {
                var interests = void 0;
                if (Array.isArray(this._interests[0])) {
                    interests = this._interests;
                }
                else {
                    interests = [this._interests];
                }
                for (var _i = 0, interests_1 = interests; _i < interests_1.length; _i++) {
                    var interest = interests_1[_i];
                    for (var _a = 0, interest_1 = interest; _a < interest_1.length; _a++) {
                        var config_1 = interest_1[_a];
                        if (config_1.listeners) {
                            for (var _b = 0, _c = config_1.listeners; _b < _c.length; _b++) {
                                var listenerConfig = _c[_b];
                                listenerConfig.type.add(listenerConfig.listener, this);
                            }
                        }
                    }
                    this._groups.push(paper.GameObjectGroup.create(interest));
                }
            }
            this.onAwake && this.onAwake(config);
            this.onEnable && this.onEnable();
        };
        /**
         * 系统内部卸载。
         * @internal
         */
        BaseSystem.prototype.uninitialize = function () {
            this.onDestroy && this.onDestroy();
            if (this._interests.length > 0) {
                var interests = void 0;
                if (Array.isArray(this._interests[0])) {
                    interests = this._interests;
                }
                else {
                    interests = [this._interests];
                }
                for (var _i = 0, interests_2 = interests; _i < interests_2.length; _i++) {
                    var interest = interests_2[_i];
                    for (var _a = 0, interest_2 = interest; _a < interest_2.length; _a++) {
                        var config = interest_2[_a];
                        if (config.listeners) {
                            for (var _b = 0, _c = config.listeners; _b < _c.length; _b++) {
                                var listenerConfig = _c[_b];
                                listenerConfig.type.remove(listenerConfig.listener);
                            }
                        }
                    }
                }
            }
        };
        /**
         * 系统内部更新。
         * @internal
         */
        BaseSystem.prototype.update = function () {
            if (!this._enabled) {
                return;
            }
            this._locked = true;
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group = _a[_i];
                if (this.onAddGameObject) {
                    for (var _b = 0, _c = group._addedGameObjects; _b < _c.length; _b++) {
                        var gameObject = _c[_b];
                        if (gameObject) {
                            this.onAddGameObject(gameObject, group);
                        }
                    }
                }
                if (this.onAddComponent) {
                    for (var _d = 0, _e = group._addedComponents; _d < _e.length; _d++) {
                        var component = _e[_d];
                        if (component) {
                            this.onAddComponent(component, group);
                        }
                    }
                }
            }
            this.onUpdate && this.onUpdate(this._clock.deltaTime);
            this._locked = false;
        };
        /**
         * 系统内部更新。
         * @internal
         */
        BaseSystem.prototype.lateUpdate = function () {
            if (!this._enabled) {
                return;
            }
            this._locked = true;
            this.onLateUpdate && this.onLateUpdate(this._clock.deltaTime);
            this._locked = false;
        };
        Object.defineProperty(BaseSystem.prototype, "enabled", {
            /**
             * 该系统是否被激活。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._locked) {
                    console.warn("Cannot change the enabled value when the system is updating.", egret.getQualifiedClassName(this));
                    return;
                }
                if (this._enabled === value) {
                    return;
                }
                this._enabled = value;
                if (this._enabled) {
                    this.onEnable && this.onEnable();
                }
                else {
                    this.onDisable && this.onDisable();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSystem.prototype, "groups", {
            /**
             * 该系统的实体组。
             */
            get: function () {
                return this._groups;
            },
            enumerable: true,
            configurable: true
        });
        return BaseSystem;
    }());
    paper.BaseSystem = BaseSystem;
    __reflect(BaseSystem.prototype, "paper.BaseSystem");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 矩形可序列化对象
     */
    var Rectangle = (function (_super) {
        __extends(Rectangle, _super);
        function Rectangle(x, y, w, h) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (w === void 0) { w = 0.0; }
            if (h === void 0) { h = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.w = w;
            _this.h = h;
            return _this;
        }
        /**
         * 创建一个矩形。
         * @param x X 轴分量。
         * @param y Y 轴分量。
         * @param w 宽。
         * @param h 高。
         */
        Rectangle.create = function (x, y, w, h) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (w === void 0) { w = 0.0; }
            if (h === void 0) { h = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, w, h);
                instance._released = false;
                return instance;
            }
            return new Rectangle().set(x, y, w, h);
        };
        Rectangle.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.w, value.h);
        };
        Rectangle.prototype.clone = function () {
            return Rectangle.create(this.x, this.y, this.w, this.h);
        };
        Rectangle.prototype.set = function (x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            return this;
        };
        Rectangle.prototype.serialize = function () {
            return [this.x, this.y, this.w, this.h];
        };
        Rectangle.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.w = element[2];
            this.h = element[3];
            return this;
        };
        Rectangle._instances = [];
        return Rectangle;
    }(paper.BaseRelease));
    egret3d.Rectangle = Rectangle;
    __reflect(Rectangle.prototype, "egret3d.Rectangle", ["egret3d.IRectangle", "egret3d.IVector2", "egret3d.ISize", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 颜色。
     */
    var Color = (function (_super) {
        __extends(Color, _super);
        /**
         * 请使用 `egret3d.Color.create()` 创建实例。
         * @see egret3d.Color.create()
         */
        function Color() {
            var _this = _super.call(this) || this;
            /**
             * 红色通道
             */
            _this.r = 1.0;
            /**
             * 绿色通道
             */
            _this.g = 1.0;
            /**
             * 蓝色通道
             */
            _this.b = 1.0;
            /**
             * 透明通道
             */
            _this.a = 1.0;
            return _this;
        }
        /**
         * 创建一个新的颜色对象实例
         * @param r 红色通道
         * @param g 绿色通道
         * @param b 蓝色通道
         * @param a 透明通道
         */
        Color.create = function (r, g, b, a) {
            if (r === void 0) { r = 1.0; }
            if (g === void 0) { g = 1.0; }
            if (b === void 0) { b = 1.0; }
            if (a === void 0) { a = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(r, g, b, a);
                instance._released = false;
                return instance;
            }
            return new Color().set(r, g, b, a);
        };
        /**
         * 序列化
         * @returns 序列化后的数据
         */
        Color.prototype.serialize = function () {
            return [this.r, this.g, this.b, this.a];
        };
        /**
         * 反序列化
         * @param value 需要反序列化的数据
         */
        Color.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        /**
         * 复制一个颜色对象
         * @returns 一个复制后的新的颜色对象
         */
        Color.prototype.clone = function () {
            return Color.create(this.r, this.g, this.b, this.a);
        };
        /**
         * 拷贝一个颜色对象的值
         * @param value 要拷贝的颜色对象
         */
        Color.prototype.copy = function (value) {
            return this.set(value.r, value.g, value.b, value.a);
        };
        /**
         * 设置一个颜色对象的rgba
         * @param r 红色通道
         * @param g 绿色通道
         * @param b 蓝色通道
         * @param a 透明通道
         * @returns 该对象本身
         */
        Color.prototype.set = function (r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            return this;
        };
        Color.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.r = value[0 + offset];
            this.g = value[1 + offset];
            this.b = value[2 + offset];
            this.a = value[3 + offset];
            return this;
        };
        Color.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.r = valueA.r * valueB.r;
            this.g = valueA.g * valueB.g;
            this.b = valueA.b * valueB.b;
            this.a = valueA.a * valueB.a;
            return this;
        };
        Color.prototype.scale = function (value, source) {
            if (!source) {
                source = this;
            }
            this.r = source.r * value;
            this.g = source.g * value;
            this.b = source.b * value;
            this.a = source.a * value;
            return this;
        };
        Color.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.r = t * (valueB.r - valueA.r) + valueA.r;
            this.g = t * (valueB.g - valueA.g) + valueA.g;
            this.b = t * (valueB.b - valueA.b) + valueA.b;
            this.a = t * (valueB.a - valueA.a) + valueA.a;
            return this;
        };
        /**
         * 黑色。
         */
        Color.BLACK = new Color().set(0.0, 0.0, 0.0, 1.0);
        /**
         * 灰色。
         */
        Color.GRAY = new Color().set(0.5, 0.5, 0.5, 1.0);
        /**
         * 白色。
         */
        Color.WHITE = new Color().set(1.0, 1.0, 1.0, 1.0);
        /**
         * 红色。
         */
        Color.RED = new Color().set(1.0, 0.0, 0.0, 1.0);
        /**
         * 绿色。
         */
        Color.GREEN = new Color().set(0.0, 1.0, 0.0, 1.0);
        /**
         * 蓝色。
         */
        Color.BLUE = new Color().set(0.0, 0.0, 1.0, 1.0);
        /**
         * 黄色。
         */
        Color.YELLOW = new Color().set(1.0, 1.0, 0.0, 1.0);
        /**
         * 靛蓝色。
         */
        Color.INDIGO = new Color().set(0.0, 1.0, 1.0, 1.0);
        /**
         * 紫色。
         */
        Color.PURPLE = new Color().set(1.0, 0.0, 1.0, 1.0);
        Color._instances = [];
        return Color;
    }(paper.BaseRelease));
    egret3d.Color = Color;
    __reflect(Color.prototype, "egret3d.Color", ["egret3d.IColor", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 灯光组件。
     */
    var BaseLight = (function (_super) {
        __extends(BaseLight, _super);
        function BaseLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * TODO
             */
            _this.cullingMask = 16777215 /* Everything */;
            /**
             * 该灯光的强度。
             */
            _this.intensity = 1.0;
            /**
             * 该灯光的颜色。
             */
            _this.color = egret3d.Color.create(1.0, 1.0, 1.0, 1.0);
            /**
             * 该灯光是否投射阴影。
             */
            _this.castShadows = false;
            /**
             *
             */
            _this.shadowRadius = 0.5;
            /**
             *
             */
            _this.shadowBias = 0.01;
            /**
             *
             */
            _this.shadowSize = 512;
            /**
             *
             */
            _this.shadowCameraNear = 1.0;
            /**
             *
             */
            _this.shadowCameraFar = 100.0;
            /**
             *
             */
            _this.shadowCameraSize = 30;
            _this.viewPortPixel = egret3d.Rectangle.create();
            /**
             * @internal
             */
            _this.shadowMatrix = egret3d.Matrix4.create();
            return _this;
        }
        BaseLight.prototype._updateShadowMatrix = function (camera) {
            // matrix * 0.5 + 0.5, after identity, range is 0 ~ 1 instead of -1 ~ 1
            var matrix = this.shadowMatrix;
            matrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
            var context = camera.context;
            context.updateCamera(camera, this.gameObject.transform.getWorldMatrix());
            context.updateLightDepth(this);
            matrix.multiply(context.matrix_p).multiply(context.matrix_v);
        };
        BaseLight.prototype.updateShadow = function (camera) {
        };
        /**
         * @internal
         */
        BaseLight.prototype.updateFace = function (camera, faceIndex) {
        };
        __decorate([
            paper.serializedField
        ], BaseLight.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "intensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("COLOR" /* COLOR */)
        ], BaseLight.prototype, "color", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseLight.prototype, "castShadows", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "shadowRadius", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01 })
        ], BaseLight.prototype, "shadowBias", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("UINT" /* UINT */)
        ], BaseLight.prototype, "shadowSize", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "shadowCameraNear", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "shadowCameraFar", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "shadowCameraSize", void 0);
        return BaseLight;
    }(paper.BaseComponent));
    egret3d.BaseLight = BaseLight;
    __reflect(BaseLight.prototype, "egret3d.BaseLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpMatrix = egret3d.Matrix4.create();
    /**
     * 网格渲染组件。
     * - 渲染网格筛选组件提供的网格资源。
     */
    var MeshRenderer = (function (_super) {
        __extends(MeshRenderer, _super);
        function MeshRenderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MeshRenderer.prototype.recalculateAABB = function () {
            this._aabb.clear();
            var filter = this.gameObject.getComponent(egret3d.MeshFilter);
            if (filter && filter.mesh) {
                var vertices = filter.mesh.getVertices();
                var position = egret3d.helpVector3A;
                for (var i = 0, l = vertices.length; i < l; i += 3) {
                    position.set(vertices[i], vertices[i + 1], vertices[i + 2]);
                    this._aabb.add(position);
                }
            }
        };
        MeshRenderer.prototype.raycast = function (p1, p2, p3) {
            var meshFilter = this.gameObject.getComponent(egret3d.MeshFilter);
            if (!meshFilter || !meshFilter.enabled || !meshFilter.mesh) {
                return false;
            }
            var raycastMesh = false;
            var raycastInfo = undefined;
            var transform = this.gameObject.transform;
            var localRay = egret3d.helpRay.applyMatrix(transform.inverseWorldMatrix, p1);
            var aabb = this.aabb;
            if (p2) {
                if (p2 === true) {
                    raycastMesh = true;
                }
                else {
                    raycastMesh = p3 || false;
                    raycastInfo = p2;
                }
            }
            if (raycastMesh ? aabb.raycast(localRay) && meshFilter.mesh.raycast(localRay, raycastInfo) : aabb.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    var worldMatrix = transform.worldMatrix;
                    raycastInfo.position.applyMatrix(worldMatrix);
                    raycastInfo.distance = p1.origin.getDistance(raycastInfo.position);
                    var normal = raycastInfo.normal;
                    if (normal) {
                        normal.applyDirection(worldMatrix).normalize();
                    }
                }
                return true;
            }
            return false;
        };
        return MeshRenderer;
    }(paper.BaseRenderer));
    egret3d.MeshRenderer = MeshRenderer;
    __reflect(MeshRenderer.prototype, "egret3d.MeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 射线。
     */
    var Ray = (function (_super) {
        __extends(Ray, _super);
        /**
         * 请使用 `egret3d.Ray.create()` 创建实例。
         * @see egret3d.Ray.create()
         */
        function Ray() {
            var _this = _super.call(this) || this;
            /**
             * 射线的起始点。
             */
            _this.origin = egret3d.Vector3.create();
            /**
             * 射线的方向向量。
             */
            _this.direction = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个射线。
         * @param origin 射线的起始点。
         * @param direction 射线的方向向量。
         */
        Ray.create = function (origin, direction) {
            if (origin === void 0) { origin = egret3d.Vector3.ZERO; }
            if (direction === void 0) { direction = egret3d.Vector3.FORWARD; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(origin, direction);
                instance._released = false;
                return instance;
            }
            return new Ray().set(origin, direction);
        };
        Ray.prototype.serialize = function () {
            return [this.origin.x, this.origin.y, this.origin.z, this.direction.x, this.direction.y, this.direction.z];
        };
        Ray.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Ray.prototype.copy = function (value) {
            return this.set(value.origin, value.direction);
        };
        Ray.prototype.clone = function () {
            return Ray.create(this.origin, this.direction);
        };
        Ray.prototype.set = function (origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        };
        Ray.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.origin.fromArray(value, offset);
            this.direction.fromArray(value, offset + 3);
            return this;
        };
        Ray.prototype.applyMatrix = function (value, ray) {
            this.origin.applyMatrix(value, (ray || this).origin);
            this.direction.applyDirection(value, (ray || this).direction).normalize();
            return this;
        };
        /**
         * 获取点到该射线的最近距离的平方。
         * @param value 点。
         */
        Ray.prototype.getSquaredDistance = function (value) {
            var directionDistance = egret3d.helpVector3A.subtract(value, this.origin).dot(this.direction);
            // point behind the ray
            if (directionDistance < 0.0) {
                return this.origin.getSquaredDistance(value);
            }
            return this.at(directionDistance, egret3d.helpVector3A).getSquaredDistance(value);
        };
        /**
         * 获取点到该射线的最近距离。
         * @param value 点。
         */
        Ray.prototype.getDistance = function (value) {
            return Math.sqrt(this.getSquaredDistance(value));
        };
        Ray.prototype.getDistanceToPlane = function (value) {
            var denominator = value.normal.dot(this.direction);
            if (denominator === 0.0) {
                // line is coplanar, return origin
                if (value.getDistance(this.origin) === 0.0) {
                    return 0.0;
                }
                // Null is preferable to undefined since undefined means.... it is undefined
                return -1.0;
            }
            var t = -(this.origin.dot(value.normal) + value.constant) / denominator;
            // Return if the ray never intersects the plane
            return t >= 0.0 ? t : -1.0;
        };
        Ray.prototype.at = function (value, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            out.multiplyScalar(value, this.direction).add(this.origin);
            return out;
        };
        Ray._instances = [];
        return Ray;
    }(paper.BaseRelease));
    egret3d.Ray = Ray;
    __reflect(Ray.prototype, "egret3d.Ray", ["paper.ICCS", "paper.ISerializable"]);
    /**
     * @internal
     */
    egret3d.helpRay = Ray.create();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * TODO 使用枚举常数。
     */
    egret3d.RAD_DEG = 180.0 / Math.PI;
    /**
     * TODO 使用枚举常数。
     */
    egret3d.DEG_RAD = Math.PI / 180.0;
    /**
     * TODO 使用枚举常数。
     */
    egret3d.EPSILON = 2.220446049250313e-16; // Number.EPSILON
    function sign(value) {
        if (value === 0 || value !== value) {
            return value;
        }
        return value > 0 ? 1 : -1;
    }
    egret3d.sign = sign;
    function floatClamp(v, min, max) {
        if (min === void 0) { min = 0.0; }
        if (max === void 0) { max = 1.0; }
        if (v < min)
            return min;
        else if (v > max)
            return max;
        else
            return v;
    }
    egret3d.floatClamp = floatClamp;
    function numberLerp(fromV, toV, v) {
        return fromV * (1 - v) + toV * v;
    }
    egret3d.numberLerp = numberLerp;
    function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
        var vp1 = planeVector.x;
        var vp2 = planeVector.y;
        var vp3 = planeVector.z;
        var n1 = planePoint.x;
        var n2 = planePoint.y;
        var n3 = planePoint.z;
        var v1 = lineVector.x;
        var v2 = lineVector.y;
        var v3 = lineVector.z;
        var m1 = linePoint.x;
        var m2 = linePoint.y;
        var m3 = linePoint.z;
        var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
        if (vpt === 0) {
            return null;
        }
        else {
            var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
            out.x = m1 + v1 * t;
            out.y = m2 + v2 * t;
            out.z = m3 + v3 * t;
        }
        return out;
    }
    egret3d.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
    function triangleIntersectsPlane() {
    }
    egret3d.triangleIntersectsPlane = triangleIntersectsPlane;
    function satForAxes(axes) {
        var v0 = egret3d.helpVector3A;
        var v1 = egret3d.helpVector3B;
        var v2 = egret3d.helpVector3C;
        var extents = egret3d.helpVector3H;
        var testAxis = egret3d.helpVector3A;
        for (var i = 0, l = axes.length - 3; i <= l; i += 3) {
            testAxis.fromArray(axes, i);
            // project the aabb onto the seperating axis
            var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
            // project all 3 vertices of the triangle onto the seperating axis
            var p0 = v0.dot(testAxis);
            var p1 = v1.dot(testAxis);
            var p2 = v2.dot(testAxis);
            // actual test, basically see if either of the most extreme of the triangle points intersects r
            if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                // points of the projected triangle are outside the projected half-length of the aabb
                // the axis is seperating and we can exit
                return false;
            }
        }
        return true;
    }
    function triangleIntersectsAABB(triangle, aabb) {
        if (aabb.isEmpty) {
            return false;
        }
        var v0 = egret3d.helpVector3A;
        var v1 = egret3d.helpVector3B;
        var v2 = egret3d.helpVector3C;
        // triangle edge vectors
        var f0 = egret3d.helpVector3D;
        var f1 = egret3d.helpVector3E;
        var f2 = egret3d.helpVector3F;
        var center = egret3d.helpVector3G;
        var extents = egret3d.helpVector3H;
        // compute box center and extents
        extents.subtract(aabb.maximum, aabb.center);
        // translate triangle to aabb origin
        v0.subtract(triangle.a, center);
        v1.subtract(triangle.b, center);
        v2.subtract(triangle.c, center);
        // compute edge vectors for triangle
        f0.subtract(v1, v0);
        f1.subtract(v2, v1);
        f2.subtract(v0, v2);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        var axes = [
            0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y,
            f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x,
            -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0
        ];
        if (!satForAxes(axes)) {
            return false;
        }
        // test 3 face normals from the aabb
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes)) {
            return false;
        }
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        egret3d.helpVector3A.cross(f0, f1);
        axes = [egret3d.helpVector3A.x, egret3d.helpVector3A.y, egret3d.helpVector3A.z];
        return satForAxes(axes);
    }
    egret3d.triangleIntersectsAABB = triangleIntersectsAABB;
    function planeIntersectsAABB(plane, aabb) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        var vMin;
        var vMax;
        var min = aabb.minimum;
        var max = aabb.maximum;
        if (plane.normal.x > 0.0) {
            vMin = plane.normal.x * min.x;
            vMax = plane.normal.x * max.x;
        }
        else {
            vMin = plane.normal.x * max.x;
            vMax = plane.normal.x * min.x;
        }
        if (plane.normal.y > 0.0) {
            vMin += plane.normal.y * min.y;
            vMax += plane.normal.y * max.y;
        }
        else {
            vMin += plane.normal.y * max.y;
            vMax += plane.normal.y * min.y;
        }
        if (plane.normal.z > 0.0) {
            vMin += plane.normal.z * min.z;
            vMax += plane.normal.z * max.z;
        }
        else {
            vMin += plane.normal.z * max.z;
            vMax += plane.normal.z * min.z;
        }
        return vMin <= plane.constant && vMax >= plane.constant;
    }
    egret3d.planeIntersectsAABB = planeIntersectsAABB;
    function planeIntersectsSphere(plane, sphere) {
        return Math.abs(plane.getDistance(sphere.center)) <= sphere.radius;
    }
    egret3d.planeIntersectsSphere = planeIntersectsSphere;
    function aabbIntersectsSphere(aabb, sphere) {
        // Find the point on the AABB closest to the sphere center.
        egret3d.helpVector3A.copy(sphere.center).clamp(aabb.minimum, aabb.maximum);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return egret3d.helpVector3A.getSquaredDistance(sphere.center) <= (sphere.radius * sphere.radius);
    }
    egret3d.aabbIntersectsSphere = aabbIntersectsSphere;
    function aabbIntersectsAABB(valueA, valueB) {
        var minA = valueA.minimum;
        var maxA = valueA.maximum;
        var minB = valueB.minimum;
        var maxB = valueB.maximum;
        // using 6 splitting planes to rule out intersections.
        return maxA.x < minB.x || minA.x > maxB.x ||
            maxA.y < minB.y || minA.y > maxB.y ||
            maxA.z < minB.z || minA.z > maxB.z ? false : true;
    }
    egret3d.aabbIntersectsAABB = aabbIntersectsAABB;
    function sphereIntersectsSphere(valueA, valueB) {
        var radiusSum = valueA.radius + valueB.radius;
        return valueA.center.getSquaredDistance(valueB.center) <= (radiusSum * radiusSum);
    }
    egret3d.sphereIntersectsSphere = sphereIntersectsSphere;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = egret3d.Matrix4.create();
    var _helpTriangleA = egret3d.Triangle.create();
    var _helpTriangleB = egret3d.Triangle.create();
    var _helpRaycastInfo = egret3d.RaycastInfo.create();
    var _attributeNames = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    /**
     * 基础网格。
     * - 所有网格的基类。
     */
    var BaseMesh = (function (_super) {
        __extends(BaseMesh, _super);
        function BaseMesh(vertexCountOrConfig, indexCountOrBuffers, attributeNamesOrName, attributeTypes, drawMode) {
            var _this = _super.call(this, typeof attributeNamesOrName === "string" ? attributeNamesOrName : "") || this;
            _this._drawMode = 35044 /* Static */;
            _this._vertexCount = 0;
            _this._attributeNames = [];
            _this._customAttributeTypes = {};
            _this._glTFMesh = null;
            /**
             * Backuped raw vertices when CPU skinned.
             * @internal
             */
            _this._rawVertices = null;
            _this._skinnedVertices = null;
            if (typeof vertexCountOrConfig === "number") {
                vertexCountOrConfig = vertexCountOrConfig || 3;
                indexCountOrBuffers = indexCountOrBuffers || 0;
                _this.config = egret3d.GLTFAsset.createMeshConfig();
                //
                var buffer = _this.config.buffers[0];
                var vertexBufferView = _this.config.bufferViews[0];
                var accessors = _this.config.accessors;
                var attributes = _this.config.meshes[0].primitives[0].attributes;
                //
                var hasCustomAttributeType = false;
                if (attributeTypes) {
                    for (var k in attributeTypes) {
                        hasCustomAttributeType = true;
                        _this._customAttributeTypes[k] = attributeTypes[k];
                    }
                }
                for (var _i = 0, _a = (attributeNamesOrName || _attributeNames); _i < _a.length; _i++) {
                    var attributeName = _a[_i];
                    var attributeType = hasCustomAttributeType ? _this._customAttributeTypes[attributeName] || _this.getMeshAttributeType(attributeName) : _this.getMeshAttributeType(attributeName);
                    var byteOffset = vertexBufferView.byteLength;
                    vertexBufferView.byteLength += vertexCountOrConfig * _this.getAccessorTypeCount(attributeType) * Float32Array.BYTES_PER_ELEMENT;
                    attributes[attributeName] = accessors.length;
                    accessors.push({
                        bufferView: 0,
                        byteOffset: byteOffset,
                        count: vertexCountOrConfig,
                        normalized: attributeName === "NORMAL" /* NORMAL */ || attributeName === "TANGENT" /* TANGENT */,
                        componentType: 5126 /* Float */,
                        type: attributeType,
                    });
                }
                buffer.byteLength = vertexBufferView.byteLength;
                _this.buffers[0] = new Float32Array(vertexBufferView.byteLength / Float32Array.BYTES_PER_ELEMENT);
                _this._drawMode = drawMode || 35044 /* Static */;
                if (indexCountOrBuffers > 0) {
                    _this.addSubMesh(indexCountOrBuffers, 0);
                }
                else {
                    _this.config.meshes[0].primitives[0].material = 0;
                }
            }
            else {
                _this.config = vertexCountOrConfig;
                for (var _b = 0, _c = indexCountOrBuffers; _b < _c.length; _b++) {
                    var buffer = _c[_b];
                    _this.buffers.push(buffer);
                }
                _this.name = attributeNamesOrName;
            }
            _this._glTFMesh = _this.config.meshes[0];
            _this._vertexCount = _this.getAccessor(_this._glTFMesh.primitives[0].attributes.POSITION || 0).count;
            for (var k in _this._glTFMesh.primitives[0].attributes) {
                _this._attributeNames.push(k);
            }
            return _this;
        }
        /**
         * 克隆该网格。
         */
        BaseMesh.prototype.clone = function () {
            var value = new egret3d.Mesh(this.vertexCount, 0, this._attributeNames, this._customAttributeTypes, this.drawMode);
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                if (primitive.indices !== undefined) {
                    var accessor = this.getAccessor(primitive.indices);
                    value.addSubMesh(accessor.count, primitive.material, primitive.mode);
                }
            }
            var index = 0;
            for (var _b = 0, _c = this.config.bufferViews; _b < _c.length; _b++) {
                var bufferViewA = _c[_b];
                var bufferViewB = value.config.bufferViews[index++];
                var a = this.createTypeArrayFromBufferView(bufferViewA, 5125 /* UnsignedInt */);
                var b = value.createTypeArrayFromBufferView(bufferViewB, 5125 /* UnsignedInt */);
                for (var i = 0, l = a.length; i < l; ++i) {
                    b[i] = a[i];
                }
            }
            return value;
        };
        /**
         * TODO applyMatrix
         */
        /**
         *
         */
        BaseMesh.prototype.raycast = function (ray, raycastInfo, boneMatrices) {
            var subMeshIndex = 0;
            var p0 = _helpVector3A;
            var p1 = _helpVector3B;
            var p2 = _helpVector3C;
            var helpTriangleA = _helpTriangleA;
            var helpTriangleB = _helpTriangleB;
            var helpRaycastInfo = _helpRaycastInfo;
            var vertices = this.getVertices();
            var joints = boneMatrices ? this.getAttributes("JOINTS_0" /* JOINTS_0 */) : null;
            var weights = boneMatrices ? this.getAttributes("WEIGHTS_0" /* WEIGHTS_0 */) : null;
            var hit = false;
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var indices = primitive.indices !== undefined ? this.getIndices(subMeshIndex) : null;
                var castVertices = vertices;
                if (boneMatrices) {
                    if (!this._rawVertices) {
                        if (!this._skinnedVertices) {
                            this._skinnedVertices = new Float32Array(vertices.length);
                        }
                        castVertices = this._skinnedVertices;
                        for (var _b = 0, _c = indices; _b < _c.length; _b++) {
                            var index = _c[_b];
                            var vertexIndex = index * 3;
                            var jointIndex = index * 4;
                            p0.fromArray(vertices, vertexIndex);
                            p1.clear();
                            for (var i = 0; i < 4; ++i) {
                                var weight = weights[jointIndex + i];
                                if (weight <= 0.0) {
                                    continue;
                                }
                                p1.add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + i] * 16), p0).multiplyScalar(weight));
                            }
                            p1.toArray(castVertices, vertexIndex);
                        }
                    }
                }
                switch (primitive.mode) {
                    case 0 /* Points */:
                        break;
                    case 1 /* Lines */:
                        break;
                    case 2 /* LineLoop */:
                        break;
                    case 3 /* LineStrip */:
                        break;
                    case 6 /* TrianglesFan */:
                        break;
                    case 5 /* TrianglesStrip */:
                        break;
                    case 4 /* Triangles */:
                    default:
                        if (indices) {
                            for (var i = 0, l = indices.length; i < l; i += 3) {
                                helpTriangleA.fromArray(castVertices, indices[i] * 3, indices[i + 1] * 3, indices[i + 2] * 3);
                                if (raycastInfo) {
                                    if (helpTriangleA.raycast(ray, helpRaycastInfo) &&
                                        (!hit || raycastInfo.distance > helpRaycastInfo.distance)) {
                                        raycastInfo.subMeshIndex = subMeshIndex;
                                        raycastInfo.triangleIndex = i / 3; // TODO
                                        raycastInfo.distance = helpRaycastInfo.distance;
                                        raycastInfo.position.copy(helpRaycastInfo.position);
                                        raycastInfo.textureCoordA.copy(helpRaycastInfo.textureCoordA);
                                        raycastInfo.textureCoordB.copy(helpRaycastInfo.textureCoordB);
                                        hit = true;
                                        if (raycastInfo.normal) {
                                            helpTriangleB.copy(helpTriangleA);
                                        }
                                    }
                                }
                                else if (helpTriangleA.raycast(ray)) {
                                    return true;
                                }
                            }
                        }
                        else {
                            for (var i = 0, l = castVertices.length; i < l; i += 9) {
                                helpTriangleA.fromArray(castVertices, i);
                                if (raycastInfo) {
                                    if (helpTriangleA.raycast(ray, helpRaycastInfo)) {
                                        if (!hit || raycastInfo.distance > helpRaycastInfo.distance) {
                                            raycastInfo.subMeshIndex = subMeshIndex;
                                            raycastInfo.triangleIndex = i / 3; // TODO
                                            raycastInfo.distance = helpRaycastInfo.distance;
                                            raycastInfo.position.copy(helpRaycastInfo.position);
                                            raycastInfo.textureCoordA.copy(helpRaycastInfo.textureCoordA);
                                            raycastInfo.textureCoordB.copy(helpRaycastInfo.textureCoordB);
                                            hit = true;
                                            if (raycastInfo.normal) {
                                                helpTriangleB.copy(helpTriangleA);
                                            }
                                        }
                                    }
                                }
                                else if (helpTriangleA.raycast(ray)) {
                                    return true;
                                }
                            }
                        }
                        break;
                }
                subMeshIndex++;
            }
            if (hit && raycastInfo.normal) {
                // TODO 差值三个顶点的法线，而不是使用三角形法线。或者可以选择使用使用三角形法线还是顶点法线。
                helpTriangleB.getNormal(raycastInfo.normal);
            }
            return hit;
        };
        /**
         *
         */
        BaseMesh.prototype.addSubMesh = function (indexCount, materialIndex, randerMode) {
            if (materialIndex === void 0) { materialIndex = 0; }
            var accessors = this.config.accessors;
            var primitives = this.config.meshes[0].primitives;
            var subMeshIndex = this.buffers.length === primitives.length + 1 ? primitives.length : 0;
            var indexBufferView = this.config.bufferViews[subMeshIndex + 1] = {
                buffer: subMeshIndex + 1,
                byteOffset: 0,
                byteLength: indexCount * this.getAccessorTypeCount("SCALAR" /* SCALAR */) * Uint16Array.BYTES_PER_ELEMENT,
                target: 34963 /* ElementArrayBuffer */,
            };
            var primitive = primitives[subMeshIndex] = primitives[subMeshIndex] || {
                attributes: primitives[0].attributes,
            };
            primitive.indices = accessors.length;
            primitive.material = materialIndex;
            primitive.mode = randerMode;
            accessors.push({
                bufferView: subMeshIndex + 1, byteOffset: 0,
                count: indexCount,
                componentType: 5123 /* UnsignedShort */, type: "SCALAR" /* SCALAR */,
            });
            this.buffers[subMeshIndex + 1] = new Uint16Array(indexBufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
            this.config.buffers[subMeshIndex + 1] = { byteLength: indexBufferView.byteLength };
            return primitives.length - 1;
        };
        /**
         * 获取该网格顶点的位置属性数据。
         * - x0, y0, z0, x1, y1, z1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        BaseMesh.prototype.getVertices = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("POSITION" /* POSITION */, offset, count);
        };
        /**
         * 获取该网格顶点的 UV 属性数据。
         * - u0, v0, u1, v1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        BaseMesh.prototype.getUVs = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */, offset, count);
        };
        /**
         * 获取该网格顶点的颜色属性数据。
         * - r0, g0, b0, a0, r1, g1, b1, a1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        BaseMesh.prototype.getColors = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("COLOR_0" /* COLOR_0 */, offset, count);
        };
        /**
         * 获取该网格顶点的法线属性数据。
         * - x0, y0, z0, x1, y1, z1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        BaseMesh.prototype.getNormals = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("NORMAL" /* NORMAL */, offset, count);
        };
        /**
         * 获取该网格顶点的切线属性数据。
         * - x0, y0, z0, w0,  x1, y1, z1, w1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        BaseMesh.prototype.getTangents = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("TANGENT" /* TANGENT */, offset, count);
        };
        /**
         * 获取该网格顶点的指定属性数据。
         * @param attributeType 属性名。
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点总数。（默认全部顶点）
         */
        BaseMesh.prototype.getAttributes = function (attributeType, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var accessorIndex = this._glTFMesh.primitives[0].attributes[attributeType];
            if (accessorIndex === undefined) {
                return null;
            }
            return this.createTypeArrayFromAccessor(this.getAccessor(accessorIndex), offset, count);
        };
        /**
         * 设置该网格指定的顶点属性数据。
         * @param attributeType 属性名。
         * @param value 属性数据。
         * @param offset 顶点偏移。（默认从第一个点开始）
         */
        BaseMesh.prototype.setAttributes = function (attributeType, value, offset) {
            if (offset === void 0) { offset = 0; }
            var target = this.getAttributes(attributeType, offset);
            if (target) {
                for (var i = 0, l = Math.min(value.length, target.length); i < l; i++) {
                    target[i] = value[i];
                }
            }
            return target;
        };
        /**
         * 获取该网格的顶点索引数据。
         * @param subMeshIndex 子网格索引。（默认第一个子网格）
         */
        BaseMesh.prototype.getIndices = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessorIndex = this._glTFMesh.primitives[subMeshIndex].indices;
                if (accessorIndex === undefined) {
                    return null;
                }
                return this.createTypeArrayFromAccessor(this.getAccessor(accessorIndex));
            }
            console.warn("Error arguments.");
            return null;
        };
        /**
         * 设置该网格的顶点索引数据。
         * @param value 顶点索引数据。
         * @param subMeshIndex 子网格索引。（默认第一个子网格）
         * @param offset 索引偏移。（默认不偏移）
         */
        BaseMesh.prototype.setIndices = function (value, subMeshIndex, offset) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (offset === void 0) { offset = 0; }
            var target = this.getIndices(subMeshIndex);
            if (target) {
                for (var i = 0, l = Math.min(value.length, target.length); i < l; i++) {
                    target[i] = value[offset + i];
                }
            }
            return target;
        };
        Object.defineProperty(BaseMesh.prototype, "drawMode", {
            /**
             * 该网格的渲染模式。
             */
            get: function () {
                return this._drawMode;
            },
            set: function (value) {
                this._drawMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "subMeshCount", {
            /**
             * 该网格的子网格总数。
             */
            get: function () {
                return this._glTFMesh.primitives.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "vertexCount", {
            /**
             * 该网格的顶点总数。
             */
            get: function () {
                return this._vertexCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "attributeNames", {
            /**
             * 该网格的全部顶点属性名称。
             */
            get: function () {
                return this._attributeNames;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "glTFMesh", {
            /**
             * 获取该网格的 glTF mesh 数据。
             */
            get: function () {
                return this._glTFMesh;
            },
            enumerable: true,
            configurable: true
        });
        return BaseMesh;
    }(egret3d.GLTFAsset));
    egret3d.BaseMesh = BaseMesh;
    __reflect(BaseMesh.prototype, "egret3d.BaseMesh", ["egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 纹理资源。
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Texture.prototype.caclByteLength = function () {
            return 0;
        };
        return Texture;
    }(paper.Asset));
    egret3d.Texture = Texture;
    __reflect(Texture.prototype, "egret3d.Texture");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 事件派发器
         */
        var EventDispatcher = (function () {
            function EventDispatcher() {
                this.__z_e_listeners = {};
            }
            EventDispatcher.prototype.addEventListener = function (type, fun, thisObj, level) {
                if (level === void 0) { level = 0; }
                var list = this.__z_e_listeners[type];
                if (list === undefined) {
                    list = [];
                    this.__z_e_listeners[type] = list;
                }
                var item = {
                    func: fun,
                    context: thisObj,
                    level: level
                };
                list.push(item);
                list.sort(function (a, b) {
                    return b.level - a.level;
                });
            };
            EventDispatcher.prototype.removeEventListener = function (type, fun, thisObj) {
                var list = this.__z_e_listeners[type];
                if (list !== undefined) {
                    var size = list.length;
                    for (var i = 0; i < size; i++) {
                        var obj = list[i];
                        if (obj.func === fun && obj.context === thisObj) {
                            list.splice(i, 1);
                            return;
                        }
                    }
                }
            };
            EventDispatcher.prototype.dispatchEvent = function (event) {
                var list = this.__z_e_listeners[event.type];
                if (list !== undefined) {
                    list.forEach(function (ef) {
                        ef['___dirty___'] = true;
                    });
                    var size = list.length;
                    for (var i = 0; i < size; i++) {
                        var ef = list[i];
                        if (ef['___dirty___']) {
                            var fun = ef.func;
                            var context = ef.context;
                            if (context) {
                                fun.call(context, event);
                            }
                            else {
                                fun(event);
                            }
                            ef['___dirty___'] = false;
                        }
                        if (size != list.length) {
                            size = list.length;
                            i = 0;
                        }
                    }
                }
            };
            return EventDispatcher;
        }());
        editor.EventDispatcher = EventDispatcher;
        __reflect(EventDispatcher.prototype, "paper.editor.EventDispatcher", ["paper.editor.IEventDispatcher"]);
        /**
         * 事件
         */
        var BaseEvent = (function () {
            function BaseEvent(type, data) {
                this.type = type;
                this.data = data;
            }
            return BaseEvent;
        }());
        editor.BaseEvent = BaseEvent;
        __reflect(BaseEvent.prototype, "paper.editor.BaseEvent");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 四元数。
     */
    var Quaternion = (function (_super) {
        __extends(Quaternion, _super);
        function Quaternion() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * 创建一个四元数。
         */
        Quaternion.create = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z, w);
                instance._released = false;
                return instance;
            }
            return new Quaternion().set(x, y, z, w);
        };
        Quaternion.prototype.clone = function () {
            return Quaternion.create(this.x, this.y, this.z, this.w);
        };
        /**
         * 通过旋转矩阵设置该四元数。
         * - 旋转矩阵不应包含缩放值。
         * @param rotateMatrix 旋转矩阵。
         */
        Quaternion.prototype.fromMatrix = function (rotateMatrix) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var rawData = rotateMatrix.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            var trace = m11 + m22 + m33;
            var s = 0.0;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                this.w = 0.25 / s;
                this.x = (m32 - m23) * s;
                this.y = (m13 - m31) * s;
                this.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this.w = (m32 - m23) / s;
                this.x = 0.25 * s;
                this.y = (m12 + m21) / s;
                this.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this.w = (m13 - m31) / s;
                this.x = (m12 + m21) / s;
                this.y = 0.25 * s;
                this.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this.w = (m21 - m12) / s;
                this.x = (m13 + m31) / s;
                this.y = (m23 + m32) / s;
                this.z = 0.25 * s;
            }
            return this;
        };
        /**
         * 通过欧拉旋转设置该四元数。
         * @param euler 欧拉旋转。（弧度制）
         * @param order 欧拉旋转顺序。
         */
        Quaternion.prototype.fromEuler = function (euler, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            var x = euler.x, y = euler.y, z = euler.z;
            // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
            var cos = Math.cos;
            var sin = Math.sin;
            var c1 = cos(x * 0.5);
            var c2 = cos(y * 0.5);
            var c3 = cos(z * 0.5);
            var s1 = sin(x * 0.5);
            var s2 = sin(y * 0.5);
            var s3 = sin(z * 0.5);
            switch (order) {
                case 0 /* XYZ */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 1 /* XZY */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 2 /* YXZ */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 3 /* YZX */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 4 /* ZXY */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 5 /* ZYX */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
            }
            return this;
        };
        /**
         * 通过指定旋转轴和旋转角设置该四元数。
         * - 旋转轴应已被归一化。
         * @param axis 旋转轴。
         * @param angle 旋转角。（弧度制）
         */
        Quaternion.prototype.fromAxis = function (axis, angle) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
            if (angle === void 0) { angle = 0.0; }
            var halfAngle = angle * 0.5, s = Math.sin(halfAngle);
            this.x = axis.x * s;
            this.y = axis.y * s;
            this.z = axis.z * s;
            this.w = Math.cos(halfAngle);
            return this;
        };
        /**
         * 通过自起始方向到目标方向的旋转值设置该四元数。
         * - 方向向量应已被归一化。
         * @param from 起始方向。
         * @param to 目标方向。
         */
        Quaternion.prototype.fromVectors = function (from, to) {
            var r = from.dot(to) + 1.0;
            var v1 = egret3d.helpVector3A;
            if (r < egret3d.EPSILON) {
                r = 0.0;
                if (Math.abs(from.x) > Math.abs(from.z)) {
                    v1.set(-from.y, from.x, 0.0);
                }
                else {
                    v1.set(0.0, -from.z, from.y);
                }
            }
            else {
                v1.cross(from, to);
            }
            this.x = v1.x;
            this.y = v1.y;
            this.z = v1.z;
            this.w = r;
            return this.normalize();
        };
        /**
         * - `v.inverse()` 反转该四元数。
         * - `v.inverse(input)` 将反转一个四元数的结果写入该四元数。
         * @param input
         */
        Quaternion.prototype.inverse = function (input) {
            if (!input) {
                input = this;
            }
            this.x = input.x * -1;
            this.y = input.y * -1;
            this.z = input.z * -1;
            this.w = input.w;
            return this;
        };
        /**
         * 四元数相乘运算。
         * - `v.multiply(a)` 将该四元数与一个四元数相乘，相当于 v *= a。
         * - `v.multiply(a, b)` 将两个四元数相乘的结果写入该四元数，相当于 v = a * b。
         * @param valueA 一个四元数。
         * @param valueB 另一个四元数。
         */
        Quaternion.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var ax = valueA.x, ay = valueA.y, az = valueA.z, aw = valueA.w;
            var bx = valueB.x, by = valueB.y, bz = valueB.z, bw = valueB.w;
            this.x = ax * bw + aw * bx + ay * bz - az * by;
            this.y = ay * bw + aw * by + az * bx - ax * bz;
            this.z = az * bw + aw * bz + ax * by - ay * bx;
            this.w = aw * bw - ax * bx - ay * by - az * bz;
            return this;
        };
        /**
         * 将一个四元数与该四元数相乘的结果写入该四元数，相当于 v = x * v。
         * @param value 一个四元数。
         */
        Quaternion.prototype.premultiply = function (value) {
            return this.multiply(value, this);
        };
        /**
         * 四元数插值运算。
         * - `v.lerp(t, a)` 将该四元数与一个四元数插值，相当于 v = v * (1 - t) + a * t。
         * - `v.lerp(t, a, b)` 将两个四元数插值的结果写入该四元数，相当于 v = a * (1 - t) + b * t。
         * @param valueA 一个四元数。
         * @param valueB 另一个四元数。
         */
        Quaternion.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            if (t === 0.0)
                return this.copy(valueA);
            if (t === 1.0)
                return this.copy(valueB);
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var ax = valueA.x, ay = valueA.y, az = valueA.z, aw = valueA.w;
            var bx = valueB.x, by = valueB.y, bz = valueB.z, bw = valueB.w;
            var cosHalfTheta = aw * bw + ax * bx + ay * by + az * bz;
            if (cosHalfTheta < 0.0) {
                this.w = -bw;
                this.x = -bx;
                this.y = -by;
                this.z = -bz;
                cosHalfTheta = -cosHalfTheta;
            }
            else {
                this.w = bw;
                this.x = bx;
                this.y = by;
                this.z = bz;
            }
            if (cosHalfTheta >= 1.0) {
                this.w = aw;
                this.x = ax;
                this.y = ay;
                this.z = az;
                return this;
            }
            var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
            if (sqrSinHalfTheta <= egret3d.EPSILON) {
                var s = 1.0 - t;
                this.w = s * aw + t * this.w;
                this.x = s * ax + t * this.x;
                this.y = s * ay + t * this.y;
                this.z = s * az + t * this.z;
                return this.normalize();
            }
            var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1.0 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this.w = aw * ratioA + this.w * ratioB;
            this.x = ax * ratioA + this.x * ratioB;
            this.y = ay * ratioA + this.y * ratioB;
            this.z = az * ratioA + this.z * ratioB;
            return this;
        };
        /**
         *
         * @param from 起始点。
         * @param to 目标点。
         * @param up 旋转后，该四元数 Y 轴正方向。
         */
        Quaternion.prototype.lookAt = function (from, to, up) {
            return this.fromMatrix(egret3d.helpMatrixA.lookAt(from, to, up));
        };
        /**
         *
         * @param vector 目标方向。
         * @param up 旋转后，该四元数 Y 轴正方向。
         */
        Quaternion.prototype.lookRotation = function (vector, up) {
            return this.fromMatrix(egret3d.helpMatrixA.lookRotation(vector, up));
        };
        /**
         * 获得该四元数和一个四元数的夹角。（弧度制）
         */
        Quaternion.prototype.getAngle = function (value) {
            return 2.0 * Math.acos(Math.abs(egret3d.floatClamp(this.dot(value), -1.0, 1.0)));
        };
        /**
         * 将该四元数转换为欧拉旋转。（弧度制）
         * @param euler 欧拉旋转。
         * @param order 欧拉旋转顺序。
         */
        Quaternion.prototype.toEuler = function (euler, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            if (!euler) {
                euler = egret3d.Vector3.create();
            }
            return _helpMatrix.fromRotation(this).toEuler(euler, order);
        };
        Quaternion.IDENTITY = new Quaternion();
        Quaternion._instances = [];
        return Quaternion;
    }(egret3d.Vector4));
    egret3d.Quaternion = Quaternion;
    __reflect(Quaternion.prototype, "egret3d.Quaternion");
    var _helpMatrix = egret3d.Matrix4.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 程序系统管理器。
     */
    var SystemManager = (function () {
        function SystemManager() {
            this._preSystems = [];
            this._systems = [];
        }
        /**
         * 程序系统管理器单例。
         */
        SystemManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SystemManager();
            }
            return this._instance;
        };
        SystemManager.prototype._getSystemInsertIndex = function (order) {
            var index = -1;
            var systemCount = this._systems.length;
            if (systemCount > 0) {
                if (order < this._systems[0].order) {
                    return 0;
                }
                else if (order >= this._systems[systemCount - 1].order) {
                    return systemCount;
                }
            }
            for (var i = 0; i < systemCount - 1; ++i) {
                if (this._systems[i].order <= order && order < this._systems[i + 1].order) {
                    index = i + 1;
                    break;
                }
            }
            return index < 0 ? this._systems.length : index;
        };
        SystemManager.prototype._checkRegister = function (systemClass) {
            var system = this.getSystem(systemClass);
            if (system) {
                console.warn("The system has been registered.", egret.getQualifiedClassName(systemClass));
                return system;
            }
            return system;
        };
        /**
         * TODO
         * @internal
         */
        SystemManager.prototype._preRegisterSystems = function () {
            this._preSystems.sort(function (a, b) { return a.order - b.order; });
            for (var _i = 0, _a = this._preSystems; _i < _a.length; _i++) {
                var pair = _a[_i];
                this.register(pair.systemClass, pair.order);
            }
            this._preSystems.length = 0;
        };
        /**
         * @internal
         */
        SystemManager.prototype.update = function () {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.enabled && !system._started) {
                    system._started = true;
                    system.onStart && system.onStart();
                }
            }
            for (var _b = 0, _c = this._systems; _b < _c.length; _b++) {
                var system = _c[_b];
                if (system) {
                    system.update();
                }
            }
            for (var _d = 0, _e = this._systems; _d < _e.length; _d++) {
                var system = _e[_d];
                if (system) {
                    system.lateUpdate();
                }
            }
        };
        /**
         * 在程序启动之前预注册一个指定的系统。
         */
        SystemManager.prototype.preRegister = function (systemClass, order) {
            if (order === void 0) { order = 4000 /* Update */; }
            if (this._systems.length > 0) {
                this.register(systemClass, order);
                return this;
            }
            this._preSystems.unshift({ systemClass: systemClass, order: order });
            return this;
        };
        /**
         * 为程序注册一个指定的系统。
         */
        SystemManager.prototype.register = function (systemClass, order, config) {
            if (order === void 0) { order = 4000 /* Update */; }
            var system = this._checkRegister(systemClass);
            if (system) {
                return system;
            }
            system = paper.BaseSystem.create(systemClass, order);
            this._systems.splice(this._getSystemInsertIndex(order), 0, system);
            system.initialize(config);
            return system;
        };
        /**
         * 从程序已注册的全部系统中获取一个指定的系统。
         */
        SystemManager.prototype.getSystem = function (systemClass) {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.constructor === systemClass) {
                    return system;
                }
            }
            return null;
        };
        /**
         * 从程序已注册的全部系统中获取一个指定的系统，如果尚未注册，则注册该系统。
         */
        SystemManager.prototype.getOrRegisterSystem = function (systemClass, order) {
            if (order === void 0) { order = 4000 /* Update */; }
            var system = this.getSystem(systemClass);
            if (!system) {
                system = this.register(systemClass, order);
            }
            return system;
        };
        Object.defineProperty(SystemManager.prototype, "systems", {
            /**
             * 程序已注册的全部系统。
             */
            get: function () {
                return this._systems;
            },
            enumerable: true,
            configurable: true
        });
        SystemManager._instance = null;
        return SystemManager;
    }());
    paper.SystemManager = SystemManager;
    __reflect(SystemManager.prototype, "paper.SystemManager");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 全局时钟信息组件。
     */
    var Clock = (function (_super) {
        __extends(Clock, _super);
        function Clock() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.maxFixedSubSteps = 3;
            _this.fixedDeltaTime = 1.0 / 50.0; // TODO same as fps.
            _this.timeScale = 1.0;
            _this._frameCount = 0;
            _this._beginTime = 0.0;
            _this._lastTime = 0.0;
            _this._delayTime = 0.0;
            _this._unscaledTime = 0.0;
            _this._unscaledDeltaTime = 0.0;
            _this._fixedTime = 0.0;
            return _this;
        }
        Clock.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            paper.Time = paper.clock = this;
            this._beginTime = Date.now() * 0.001;
        };
        /**
         * @internal
         */
        Clock.prototype.update = function (time) {
            if (this._unscaledTime !== 0.0) {
                this._lastTime = this._unscaledTime;
                if (this._fixedTime < this.fixedDeltaTime) {
                }
                else if (this._fixedTime < this.fixedDeltaTime * this.maxFixedSubSteps) {
                    this._fixedTime %= this.fixedDeltaTime;
                }
                else {
                    this._fixedTime -= this.fixedDeltaTime * this.maxFixedSubSteps;
                }
            }
            var now = time || Date.now() * 0.001;
            this._frameCount += 1;
            this._unscaledTime = now - this._beginTime;
            this._unscaledDeltaTime = this._unscaledTime - this._lastTime;
            this._fixedTime += this._unscaledDeltaTime;
        };
        Object.defineProperty(Clock.prototype, "frameCount", {
            get: function () {
                return this._frameCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "time", {
            /**
             * 从程序开始运行时的累计时间。（以秒为单位）
             */
            get: function () {
                return this._unscaledTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "fixedTime", {
            /**
             *
             */
            get: function () {
                return this._fixedTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "deltaTime", {
            /**
             * 上一帧到此帧流逝的时间。（以秒为单位）
             */
            get: function () {
                return this._unscaledDeltaTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledTime", {
            /**
             *
             */
            get: function () {
                return this._unscaledTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledDeltaTime", {
            /**
             *
             */
            get: function () {
                return this._unscaledDeltaTime;
            },
            enumerable: true,
            configurable: true
        });
        return Clock;
    }(paper.SingletonComponent));
    paper.Clock = Clock;
    __reflect(Clock.prototype, "paper.Clock");
    /**
     * 全局时钟信息组件实例。
     */
    paper.clock = null;
    /**
     * @deprecated
     * @see paper.clock
     */
    paper.Time = null;
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 全局销毁信息收集组件。
     */
    var DisposeCollecter = (function (_super) {
        __extends(DisposeCollecter, _super);
        function DisposeCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 暂存此帧销毁的全部场景。
             */
            _this.scenes = [];
            /**
             * 暂存此帧销毁的全部实体。
             */
            _this.gameObjects = [];
            /**
             * 暂存此帧销毁的全部组件。
             */
            _this.components = [];
            /**
             * 暂存需要在此帧结束时释放的对象。
             */
            _this.releases = [];
            return _this;
        }
        DisposeCollecter.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            paper.disposeCollecter = this;
        };
        /**
         * @internal
         */
        DisposeCollecter.prototype.clear = function () {
            this.scenes.length = 0;
            this.gameObjects.length = 0;
            this.components.length = 0;
            this.releases.length = 0;
        };
        return DisposeCollecter;
    }(paper.SingletonComponent));
    paper.DisposeCollecter = DisposeCollecter;
    __reflect(DisposeCollecter.prototype, "paper.DisposeCollecter");
    /**
     * @internal
     */
    paper.disposeCollecter = null;
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 关心组件的类型。
     */
    var InterestType;
    (function (InterestType) {
        /**
         * @deprecated
         */
        InterestType[InterestType["Extends"] = 1] = "Extends";
        /**
         *
         */
        InterestType[InterestType["Exculde"] = 2] = "Exculde";
        /**
         *
         */
        InterestType[InterestType["Unessential"] = 4] = "Unessential";
    })(InterestType = paper.InterestType || (paper.InterestType = {}));
    /**
     * 实体组。
     * - 收集符合指定特征的实体。
     */
    var GameObjectGroup = (function () {
        function GameObjectGroup(interestConfig) {
            /**
             * TODO
             * @internal
             */
            this.locked = false;
            this._isRemoved = false;
            this._isBehaviour = false;
            // TODO add systems
            this._bufferedGameObjects = [];
            /**
             * @internal
             */
            this._addedGameObjects = [];
            this._gameObjects = []; // TODO
            this._bufferedComponents = [];
            /**
             * @internal
             */
            this._addedComponents = [];
            this._behaviourComponents = []; // TODO
            this._interestConfig = null;
            this._isBehaviour = interestConfig.length === 1 && interestConfig[0].type !== undefined && interestConfig[0].type !== 0;
            this._interestConfig = interestConfig;
            for (var _i = 0, _a = this._interestConfig; _i < _a.length; _i++) {
                var config = _a[_i];
                var isUnessential = config.type && (config.type & 4 /* Unessential */) !== 0;
                if (Array.isArray(config.componentClass)) {
                    for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                        var componentClass = _c[_b];
                        this._addListener(componentClass, isUnessential);
                    }
                }
                else {
                    this._addListener(config.componentClass, isUnessential);
                }
            }
            for (var _d = 0, _e = paper.Application.sceneManager.scenes; _d < _e.length; _d++) {
                var scene = _e[_d];
                for (var _f = 0, _g = scene.gameObjects; _f < _g.length; _f++) {
                    var gameObject = _g[_f];
                    this._addGameObject(gameObject);
                }
            }
        }
        /**
         * @internal
         */
        GameObjectGroup.create = function (interestConfig) {
            interestConfig = Array.isArray(interestConfig) ? interestConfig : [interestConfig];
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group_1 = _a[_i];
                if (group_1._interestConfig.length !== interestConfig.length) {
                    continue;
                }
                var isSame = true;
                for (var i = 0, l = interestConfig.length; i < l; ++i) {
                    var configA = interestConfig[i];
                    var configB = group_1._interestConfig[i];
                    if (configA.type !== configB.type) {
                        isSame = false;
                        break;
                    }
                    if (Array.isArray(configA.componentClass) && Array.isArray(configB.componentClass)) {
                        if (configA.componentClass.length !== configB.componentClass.length) {
                            isSame = false;
                            break;
                        }
                    }
                    else if (configA.componentClass !== configB.componentClass) {
                        isSame = false;
                        break;
                    }
                }
                if (isSame) {
                    return group_1;
                }
            }
            var group = new GameObjectGroup(interestConfig);
            this._groups.push(group);
            return group;
        };
        /**
         * @internal
         */
        GameObjectGroup.update = function () {
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group = _a[_i];
                group._update();
            }
        };
        GameObjectGroup.prototype._addListener = function (componentClass, isUnessential) {
            paper.registerClass(componentClass);
            componentClass.onComponentDisabled.add(this._onRemoveUnessentialComponent, this);
            if (!isUnessential) {
                componentClass.onComponentEnabled.add(this._onAddComponent, this);
                componentClass.onComponentDisabled.add(this._onRemoveComponent, this);
            }
            componentClass.onComponentEnabled.add(this._onAddUnessentialComponent, this);
        };
        GameObjectGroup.prototype._onAddComponent = function (component) {
            this._addGameObject(component.gameObject);
        };
        GameObjectGroup.prototype._onAddUnessentialComponent = function (component) {
            var gameObject = component.gameObject;
            if (!component.isActiveAndEnabled) {
                return;
            }
            if (!this._isBehaviour) {
                if (gameObject === paper.GameObject.globalGameObject) {
                    return;
                }
                if (this._bufferedGameObjects.indexOf(gameObject) < 0 && this._gameObjects.indexOf(gameObject) < 0) {
                    return;
                }
            }
            if (this._bufferedComponents.indexOf(component) >= 0 || this._behaviourComponents.indexOf(component) >= 0) {
                return;
            }
            this._bufferedComponents.push(component);
        };
        GameObjectGroup.prototype._onRemoveUnessentialComponent = function (component) {
            var gameObject = component.gameObject;
            var index = this._bufferedComponents.indexOf(component);
            if (index >= 0) {
                this._bufferedComponents.splice(index, 1);
                return;
            }
            if (this._isBehaviour) {
                index = this._behaviourComponents.indexOf(component);
                if (index < 0) {
                    return;
                }
                this._isRemoved = true;
                this._behaviourComponents[index] = null;
                index = this._addedComponents.indexOf(component);
                if (index >= 0) {
                    this._addedComponents[index] = null;
                }
            }
            else {
                if (gameObject === paper.GameObject.globalGameObject) {
                    return;
                }
                if (this._gameObjects.indexOf(gameObject) < 0) {
                    return;
                }
                index = this._addedComponents.indexOf(component);
                if (index >= 0) {
                    this._addedComponents[index] = null;
                }
            }
            for (var _i = 0, _a = paper.Application.systemManager.systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (!system.onRemoveComponent || system.groups.indexOf(this) < 0) {
                    continue;
                }
                system.onRemoveComponent(component, this);
            }
        };
        GameObjectGroup.prototype._onRemoveComponent = function (component) {
            this._removeGameObject(component.gameObject);
        };
        GameObjectGroup.prototype._addGameObject = function (gameObject) {
            if (!gameObject.activeInHierarchy) {
                return;
            }
            if (!this._isBehaviour && gameObject === paper.GameObject.globalGameObject) {
                return;
            }
            if (this._bufferedGameObjects.indexOf(gameObject) >= 0 ||
                this._gameObjects.indexOf(gameObject) >= 0) {
                return;
            }
            for (var _i = 0, _a = this._interestConfig; _i < _a.length; _i++) {
                var config = _a[_i];
                if (config.type && (config.type & 4 /* Unessential */)) {
                    continue;
                }
                var isExtends = config.type && (config.type & 1 /* Extends */) !== 0;
                var isExculde = config.type && (config.type & 2 /* Exculde */) !== 0;
                var insterestComponent = null;
                if (Array.isArray(config.componentClass)) {
                    for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                        var componentClass = _c[_b];
                        insterestComponent = gameObject.getComponent(componentClass, isExtends);
                        if (insterestComponent && insterestComponent.isActiveAndEnabled) {
                            break;
                        }
                        insterestComponent = null;
                    }
                }
                else {
                    insterestComponent = gameObject.getComponent(config.componentClass, isExtends);
                    if (insterestComponent && !insterestComponent.isActiveAndEnabled) {
                        insterestComponent = null;
                    }
                }
                if (isExculde ? insterestComponent : !insterestComponent) {
                    return;
                }
            }
            this._bufferedGameObjects.push(gameObject);
        };
        GameObjectGroup.prototype._removeGameObject = function (gameObject) {
            var index = this._bufferedGameObjects.indexOf(gameObject);
            if (index >= 0) {
                this._bufferedGameObjects.splice(index, 1);
            }
            else {
                index = this._gameObjects.indexOf(gameObject);
                if (index >= 0) {
                    if (this.locked) {
                        this.locked = false;
                        this._gameObjects = this._gameObjects.concat();
                    }
                    this._gameObjects.splice(index, 1);
                    index = this._addedGameObjects.indexOf(gameObject);
                    if (index >= 0) {
                        this._addedGameObjects[index] = null;
                    }
                    for (var _i = 0, _a = paper.Application.systemManager.systems; _i < _a.length; _i++) {
                        var system = _a[_i];
                        if (!system.onRemoveGameObject || system.groups.indexOf(this) < 0) {
                            continue;
                        }
                        system.onRemoveGameObject(gameObject, this);
                    }
                }
            }
        };
        GameObjectGroup.prototype._update = function () {
            this.locked = false;
            if (this._addedGameObjects.length > 0) {
                this._addedGameObjects.length = 0;
            }
            if (this._addedComponents.length > 0) {
                this._addedComponents.length = 0;
            }
            if (this._isRemoved) {
                var index = 0;
                var removeCount = 0;
                this._isRemoved = false;
                for (var _i = 0, _a = this._behaviourComponents; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (component) {
                        if (removeCount > 0) {
                            this._behaviourComponents[index - removeCount] = component;
                            this._behaviourComponents[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
                if (removeCount > 0) {
                    this._behaviourComponents.length -= removeCount;
                }
            }
            if (this._bufferedGameObjects.length > 0) {
                for (var _b = 0, _c = this._bufferedGameObjects; _b < _c.length; _b++) {
                    var gameObject = _c[_b];
                    if (!gameObject) {
                        continue;
                    }
                    this._addedGameObjects.push(gameObject);
                    this._gameObjects.push(gameObject);
                }
                this._bufferedGameObjects.length = 0;
            }
            if (this._bufferedComponents.length > 0) {
                for (var _d = 0, _e = this._bufferedComponents; _d < _e.length; _d++) {
                    var component = _e[_d];
                    if (!component) {
                        continue;
                    }
                    this._addedComponents.push(component);
                    if (component instanceof paper.Behaviour) {
                        if (component.gameObject.getComponent(egret3d.Camera)) {
                            this._behaviourComponents.unshift(component);
                        }
                        else {
                            this._behaviourComponents.push(component);
                        }
                    }
                }
                this._bufferedComponents.length = 0;
            }
        };
        /**
         * 该组是否已收集指定的实体。
         */
        GameObjectGroup.prototype.hasGameObject = function (gameObject) {
            return this._gameObjects.indexOf(gameObject) >= 0;
        };
        Object.defineProperty(GameObjectGroup.prototype, "gameObjects", {
            /**
             * 该组已收集的全部实体。
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObjectGroup.prototype, "components", {
            /**
             * 该组已收集的全部组件。
             */
            get: function () {
                return this._behaviourComponents;
            },
            enumerable: true,
            configurable: true
        });
        GameObjectGroup._groups = [];
        return GameObjectGroup;
    }());
    paper.GameObjectGroup = GameObjectGroup;
    __reflect(GameObjectGroup.prototype, "paper.GameObjectGroup");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Spherical = (function (_super) {
        __extends(Spherical, _super);
        /**
         * 请使用 `egret3d.Spherical.create()` 创建实例。
         * @see egret3d.Spherical.create()
         */
        function Spherical() {
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.radius = 1.0;
            /**
             *
             */
            _this.phi = 0.0;
            /**
             *
             */
            _this.theta = 0.0;
            return _this;
        }
        /**
         *
         */
        Spherical.create = function (radius, phi, theta) {
            if (radius === void 0) { radius = 1.0; }
            if (phi === void 0) { phi = 0.0; }
            if (theta === void 0) { theta = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(radius, phi, theta);
                instance._released = false;
                return instance;
            }
            return new Spherical().set(radius, phi, theta);
        };
        Spherical.prototype.serialize = function () {
            return [this.radius, this.phi, this.theta];
        };
        Spherical.prototype.deserialize = function (value) {
            this.radius = value[0];
            this.phi = value[1];
            this.theta = value[2];
            return this;
        };
        Spherical.prototype.clone = function () {
            return Spherical.create(this.radius, this.phi, this.theta);
        };
        Spherical.prototype.copy = function (value) {
            return this.set(value.radius, value.phi, value.theta);
        };
        Spherical.prototype.set = function (radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        };
        Spherical.prototype.fromCartesianCoords = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                p3 = p1.z;
                p2 = p1.y;
                p1 = p1.x;
            }
            this.radius = Math.sqrt(p1 * p1 + p2 * p2 + p3 * p3);
            if (this.radius === 0.0) {
                this.theta = 0.0;
                this.phi = 0.0;
            }
            else {
                this.theta = Math.atan2(p1, p3); // TODO
                this.phi = Math.acos(egret3d.floatClamp(p2 / this.radius, -1.0, 1.0));
            }
            return this;
        };
        Spherical.prototype.makeSafe = function () {
            var EPS = 0.000001;
            this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
            return this;
        };
        Spherical._instances = [];
        return Spherical;
    }(paper.BaseRelease));
    egret3d.Spherical = Spherical;
    __reflect(Spherical.prototype, "egret3d.Spherical", ["paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var EnableSystem = (function (_super) {
        __extends(EnableSystem, _super);
        function EnableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        EnableSystem.prototype.onAddComponent = function (component) {
            if (!component) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */) {
                if (!component.constructor.executeInEditMode) {
                    return;
                }
                if (!component._isReseted) {
                    component._isReseted = true;
                    component.onReset && component.onReset();
                }
            }
            component.onEnable && component.onEnable();
        };
        return EnableSystem;
    }(paper.BaseSystem));
    paper.EnableSystem = EnableSystem;
    __reflect(EnableSystem.prototype, "paper.EnableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var StartSystem = (function (_super) {
        __extends(StartSystem, _super);
        function StartSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        StartSystem.prototype.onAddComponent = function (component) {
            if (!component || component._isStarted) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */ &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component._isStarted = true;
            component.onStart && component.onStart();
        };
        return StartSystem;
    }(paper.BaseSystem));
    paper.StartSystem = StartSystem;
    __reflect(StartSystem.prototype, "paper.StartSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 固定更新系统。
     * TODO
     */
    var FixedUpdateSystem = (function (_super) {
        __extends(FixedUpdateSystem, _super);
        function FixedUpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        FixedUpdateSystem.prototype.onUpdate = function () {
            var currentTimes = 0;
            var fixedTime = this._clock.fixedTime;
            var totalTimes = Math.min(Math.floor(fixedTime / this._clock.fixedDeltaTime), this._clock.maxFixedSubSteps);
            var components = this._groups[0].components;
            while (fixedTime >= this._clock.fixedDeltaTime && currentTimes++ < this._clock.maxFixedSubSteps) {
                for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
                    var component = components_1[_i];
                    if (component) {
                        component.onFixedUpdate && component.onFixedUpdate(currentTimes, totalTimes);
                    }
                }
                fixedTime -= this._clock.fixedDeltaTime;
            }
        };
        return FixedUpdateSystem;
    }(paper.BaseSystem));
    paper.FixedUpdateSystem = FixedUpdateSystem;
    __reflect(FixedUpdateSystem.prototype, "paper.FixedUpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 更新系统。
     */
    var UpdateSystem = (function (_super) {
        __extends(UpdateSystem, _super);
        function UpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        UpdateSystem.prototype.onUpdate = function (deltaTime) {
            var components = this._groups[0].components;
            if (paper.Application.playerMode === 2 /* Editor */) {
                for (var _i = 0, components_2 = components; _i < components_2.length; _i++) {
                    var component = components_2[_i];
                    if (component && component.constructor.executeInEditMode) {
                        component.onUpdate && component.onUpdate(deltaTime);
                    }
                }
            }
            else {
                for (var _a = 0, components_3 = components; _a < components_3.length; _a++) {
                    var component = components_3[_a];
                    if (component) {
                        component.onUpdate && component.onUpdate(deltaTime);
                    }
                }
            }
        };
        return UpdateSystem;
    }(paper.BaseSystem));
    paper.UpdateSystem = UpdateSystem;
    __reflect(UpdateSystem.prototype, "paper.UpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * Late 更新系统。
     */
    var LateUpdateSystem = (function (_super) {
        __extends(LateUpdateSystem, _super);
        function LateUpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            _this._laterCalls = [];
            return _this;
        }
        LateUpdateSystem.prototype.onUpdate = function (deltaTime) {
            // Update behaviours.
            var components = this._groups[0].components;
            if (paper.Application.playerMode === 2 /* Editor */) {
                for (var _i = 0, components_4 = components; _i < components_4.length; _i++) {
                    var component = components_4[_i];
                    if (component && component.constructor.executeInEditMode) {
                        component.onLateUpdate && component.onLateUpdate(deltaTime);
                    }
                }
            }
            else {
                for (var _a = 0, components_5 = components; _a < components_5.length; _a++) {
                    var component = components_5[_a];
                    if (component) {
                        component.onLateUpdate && component.onLateUpdate(deltaTime);
                    }
                }
            }
            //
            egret.ticker.update(); // TODO 帧频
            //
            if (this._laterCalls.length > 0) {
                for (var _b = 0, _c = this._laterCalls; _b < _c.length; _b++) {
                    var callback = _c[_b];
                    callback();
                }
                this._laterCalls.length = 0;
            }
        };
        /**
         * 在 `paper.Behaviour.onLateUpdate()` 生命周期之后回调指定方法。
         * @param callback 需要回调的方法。
         */
        LateUpdateSystem.prototype.callLater = function (callback) {
            this._laterCalls.push(callback);
        };
        return LateUpdateSystem;
    }(paper.BaseSystem));
    paper.LateUpdateSystem = LateUpdateSystem;
    __reflect(LateUpdateSystem.prototype, "paper.LateUpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var DisableSystem = (function (_super) {
        __extends(DisableSystem, _super);
        function DisableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            _this._disposeCollecter = paper.GameObject.globalGameObject.getOrAddComponent(paper.DisposeCollecter);
            return _this;
        }
        DisableSystem.prototype.onRemoveComponent = function (component) {
            if (!component) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */ &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component.onDisable && component.onDisable();
        };
        DisableSystem.prototype.onUpdate = function () {
            for (var _i = 0, _a = this._disposeCollecter.scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                scene.uninitialize();
            }
            for (var _b = 0, _c = this._disposeCollecter.gameObjects; _b < _c.length; _b++) {
                var gameObject = _c[_b];
                gameObject.uninitialize();
            }
            for (var _d = 0, _e = this._disposeCollecter.components; _d < _e.length; _d++) {
                var component = _e[_d];
                component.uninitialize();
            }
            for (var _f = 0, _g = this._disposeCollecter.releases; _f < _g.length; _f++) {
                var instance = _g[_f];
                var instances = instance.constructor._instances; // TODO
                if (instance.onClear) {
                    instance.onClear();
                }
                instances.push(instance);
            }
            this._disposeCollecter.clear();
        };
        return DisableSystem;
    }(paper.BaseSystem));
    paper.DisableSystem = DisableSystem;
    __reflect(DisableSystem.prototype, "paper.DisableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    paper.serializeClassMap = {
        0: "paper.Scene",
        1: "paper.GameObject",
        2: "egret3d.AniPlayer",
        3: "egret3d.BoxCollider",
        4: "egret3d.Camera",
        5: "egret3d.MeshFilter",
        6: "egret3d.MeshRenderer",
        7: "egret3d.particle.ParticleComponent",
        8: "egret3d.particle.ParticleRenderer",
        9: "egret3d.SkinnedMeshRenderer",
        10: "egret3d.SphereCollider",
        11: "egret3d.Transform",
        12: "egret3d.Shader",
        15: "egret3d.AnimationClip",
        16: "egret3d.TPoseInfo",
        17: "egret3d.PoseBoneMatrix",
        18: "egret3d.Texture",
        19: "egret3d.Texture",
        20: "egret3d.Vector2",
        21: "egret3d.Vector3",
        22: "egret3d.Vector4",
        23: "egret3d.Quaternion",
        24: "egret3d.Color",
        25: "egret3d.Gradient",
        26: "egret3d.Curve",
        27: "egret3d.Keyframe",
        28: "egret3d.Rect",
        29: "egret3d.MainModule",
        30: "egret3d.EmissionModule",
        31: "egret3d.ShapeModule",
        32: "egret3d.VelocityOverLifetimeModule",
        33: "egret3d.RotationOverLifetimeModule",
        34: "egret3d.ColorOverLifetimeModule",
        35: "egret3d.SizeOverLifetimeModule",
        36: "egret3d.MinMaxCurve",
        37: "egret3d.MinMaxGradient",
        38: "egret3d.alphaKey",
        39: "egret3d.colorKey",
        40: "egret3d.Animation",
        41: "egret3d.GLTFAsset",
        //
        13: "paper.Compatible",
        14: "paper.Compatible",
    };
    /**
     * @internal
     */
    var Compatible = (function () {
        function Compatible() {
        }
        Compatible.prototype.serialize = function () {
            throw new Error("Never");
        };
        Compatible.prototype.deserialize = function (element, data) {
            if (!data) {
                throw new Error("Never");
            }
            return data.getAssetOrComponent(element._glTFAsset);
        };
        return Compatible;
    }());
    paper.Compatible = Compatible;
    __reflect(Compatible.prototype, "paper.Compatible", ["paper.ISerializable"]);
})(paper || (paper = {}));
var paper;
(function (paper) {
    var KEY_UUID = "uuid";
    var KEY_ASSET = "asset";
    var KEY_CLASS = "class";
    var KEY_DESERIALIZE = "deserialize";
    var KEY_COMPONENTS = "components";
    var KEY_EXTRAS = "extras";
    var KEY_CHILDREN = "children";
    function _getDeserializedKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        var serializeKeys = serializedClass.__serializeKeys;
        if (serializeKeys) {
            keys = keys || {};
            for (var key in serializeKeys) {
                var retargetKey = serializeKeys[key];
                if (retargetKey) {
                    keys[retargetKey] = key;
                }
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getDeserializedKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    function _getDeserializedIgnoreKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        if (serializedClass.__deserializeIgnore) {
            keys = keys || [];
            for (var _i = 0, _a = serializedClass.__deserializeIgnore; _i < _a.length; _i++) {
                var key = _a[_i];
                keys.push(key);
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getDeserializedIgnoreKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    /**
     *
     */
    var Deserializer = (function () {
        function Deserializer() {
            /**
             *
             */
            this.assets = [];
            /**
             *
             */
            this.objects = {};
            /**
             *
             */
            this.components = {};
            this._deserializers = {};
            this._rootTarget = null;
        }
        Deserializer.prototype._deserializeObject = function (source, target) {
            var deserializedKeys = _getDeserializedKeys(target.constructor);
            var deserializedIgnoreKeys = _getDeserializedIgnoreKeys(target.constructor);
            for (var k in source) {
                if (k === KEY_CLASS) {
                    continue;
                }
                if (!this._keepUUID && k === KEY_UUID) {
                    continue;
                }
                var retargetKey = (deserializedKeys && k in deserializedKeys) ? deserializedKeys[k] : k;
                if (deserializedIgnoreKeys &&
                    deserializedIgnoreKeys.indexOf(retargetKey) >= 0) {
                    continue;
                }
                var retarget = this._deserializeChild(source[k], target[retargetKey]);
                if (retarget !== undefined) {
                    target[retargetKey] = retarget;
                }
            }
            return target;
        };
        Deserializer.prototype._createComponent = function (componentSource, source, target) {
            var className = paper.serializeClassMap[componentSource.class] || componentSource.class;
            var clazz = egret.getDefinitionByName(className);
            var componentTarget = undefined;
            if (clazz) {
                var hasLink = KEY_EXTRAS in componentSource && componentSource[KEY_EXTRAS].linkedID;
                if (clazz === egret3d.Transform) {
                    componentTarget = this.components[componentSource.uuid];
                    if (KEY_CHILDREN in componentSource) {
                        for (var _i = 0, _a = componentSource[KEY_CHILDREN]; _i < _a.length; _i++) {
                            var childUUID = _a[_i];
                            var child = this.components[childUUID.uuid];
                            if (child && child._parent !== componentTarget) {
                                child._parent = componentTarget;
                                componentTarget._children.push(child);
                            }
                        }
                    }
                }
                else {
                    if (hasLink) {
                        var componentExtras = componentSource[KEY_EXTRAS];
                        var extras = source[KEY_EXTRAS];
                        var linkedID = componentExtras.linkedID;
                        var prefabDeserializer = this._deserializers[extras.prefab ? source.uuid : extras.rootID];
                        componentTarget = prefabDeserializer.components[linkedID];
                    }
                    else {
                        // const enabled = componentSource._enabled === undefined ? true : componentSource._enabled;
                        componentTarget = (target || this._rootTarget).addComponent(clazz);
                    }
                    // if (clazz === Behaviour) { TODO
                    //     (componentTarget as Behaviour)._isReseted = true;
                    // }
                }
                if (!hasLink && this._makeLink && componentTarget) {
                    componentTarget.extras.linkedID = componentSource.uuid;
                }
            }
            else {
                componentTarget = (target || this._rootTarget).addComponent(paper.MissingComponent);
                componentTarget.missingObject = componentSource;
                console.warn("Class " + className + " is not defined.");
            }
            this.components[componentSource.uuid] = componentTarget;
            return componentTarget;
        };
        Deserializer.prototype._deserializeChild = function (source, target) {
            if (source === null || source === undefined) {
                return source;
            }
            switch (typeof source) {
                case "function":
                    return undefined;
                case "object": {
                    if (target) {
                        if (ArrayBuffer.isView(target)) {
                            for (var i = 0, l = Math.min(source.length, target.length); i < l; ++i) {
                                target[i] = source[i];
                            }
                            return target;
                        }
                        else if (Array.isArray(target) && target.length === 0) {
                            for (var i = 0, l = source.length; i < l; ++i) {
                                target[i] = this._deserializeChild(source[i]);
                            }
                            return target;
                        }
                        else if (target[KEY_DESERIALIZE]) {
                            return target.deserialize(source, this);
                        }
                        else {
                            // console.info("Deserialize can be optimized."); TODO
                        }
                    }
                    if (Array.isArray(source)) {
                        target = [];
                        for (var i = 0, l = source.length; i < l; ++i) {
                            target[i] = this._deserializeChild(source[i]);
                        }
                        return target;
                    }
                    var classCodeOrName = source[KEY_CLASS];
                    if (KEY_ASSET in source) {
                        var assetIndex = source.asset;
                        if (assetIndex >= 0) {
                            return paper.Asset.find(this.assets[assetIndex]);
                        }
                        return null;
                    }
                    else if (KEY_UUID in source) {
                        var uuid = source.uuid;
                        if (uuid in this.objects) {
                            return this.objects[uuid];
                        }
                        else if (uuid in this.components) {
                            return this.components[uuid];
                        }
                        else if (classCodeOrName) {
                            var scene = this._rootTarget instanceof paper.GameObject ? this._rootTarget.scene : this._rootTarget;
                            if ((paper.serializeClassMap[classCodeOrName] || classCodeOrName) === egret.getQualifiedClassName(paper.GameObject)) {
                                for (var _i = 0, _a = scene.gameObjects; _i < _a.length; _i++) {
                                    var gameObject = _a[_i];
                                    if (gameObject.uuid === uuid) {
                                        return gameObject;
                                    }
                                }
                            }
                            else {
                                for (var _b = 0, _c = scene.gameObjects; _b < _c.length; _b++) {
                                    var gameObject = _c[_b];
                                    for (var _d = 0, _e = gameObject.components; _d < _e.length; _d++) {
                                        var component = _e[_d];
                                        if (component && component.uuid === uuid) {
                                            return component;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if (classCodeOrName) {
                        var clazz = egret.getDefinitionByName(paper.serializeClassMap[classCodeOrName] || classCodeOrName);
                        if (clazz) {
                            target = new clazz();
                            return target.deserialize(source, this);
                        }
                    }
                    else {
                        target = {};
                        for (var k in source) {
                            target[k] = this._deserializeChild(source[k]);
                        }
                        return target;
                    }
                    console.warn("Deserialize error.", source);
                    return undefined;
                }
                default:
                    return source;
            }
        };
        Deserializer.prototype.getAssetOrComponent = function (source) {
            if (KEY_ASSET in source) {
                var assetIndex = source.asset;
                if (assetIndex >= 0) {
                    return paper.Asset.find(this.assets[assetIndex]);
                }
                return null;
            }
            var uuid = source.uuid;
            return this.components[uuid] || this.objects[uuid];
        };
        /**
         * @internal
         */
        Deserializer.prototype.deserialize = function (data, keepUUID, makeLink, rootTarget) {
            if (keepUUID === void 0) { keepUUID = false; }
            if (makeLink === void 0) { makeLink = false; }
            if (rootTarget === void 0) { rootTarget = null; }
            if (data.assets) {
                for (var _i = 0, _a = data.assets; _i < _a.length; _i++) {
                    var assetName = _a[_i];
                    this.assets.push(assetName);
                }
            }
            this._keepUUID = keepUUID;
            this._makeLink = makeLink;
            this._rootTarget = rootTarget;
            var sceneClassName = egret.getQualifiedClassName(paper.Scene);
            var transformClassName = egret.getQualifiedClassName(egret3d.Transform);
            var components = {};
            var root = null;
            if (data.components) {
                for (var _b = 0, _c = data.components; _b < _c.length; _b++) {
                    var componentSource = _c[_b];
                    components[componentSource.uuid] = componentSource;
                }
            }
            if (data.objects) {
                for (var _d = 0, _e = data.objects; _d < _e.length; _d++) {
                    var source = _e[_d];
                    var className = paper.serializeClassMap[source.class] || source.class;
                    var target = undefined;
                    if (className === sceneClassName) {
                        target = paper.Scene.createEmpty(source.name);
                        this._rootTarget = target;
                    }
                    else {
                        if (!this._rootTarget) {
                            this._rootTarget = paper.Application.sceneManager.activeScene; // TODO
                        }
                        var hasLink = KEY_EXTRAS in source && source[KEY_EXTRAS].linkedID;
                        if (hasLink) {
                            var extras = source[KEY_EXTRAS];
                            var linkedID = extras.linkedID;
                            var prefab = extras.prefab;
                            if (prefab) {
                                var assetIndex = prefab.asset;
                                if (assetIndex >= 0) {
                                    var assetName = this.assets[assetIndex];
                                    target = paper.Prefab.create(assetName, this._rootTarget);
                                    if (target) {
                                        this._deserializers[source.uuid] = Deserializer._lastDeserializer;
                                    }
                                    else {
                                        target = paper.GameObject.create("Missing Prefab" /* MissingPrefab */, "" /* Untagged */, this._rootTarget);
                                    }
                                }
                            }
                            else {
                                var prefabDeserializer = this._deserializers[extras.rootID];
                                target = prefabDeserializer.objects[linkedID];
                                if (!target) {
                                    // Delete node.
                                }
                            }
                        }
                        else {
                            target = paper.GameObject.create("NoName" /* NoName */, "" /* Untagged */, this._rootTarget);
                            if (this._makeLink) {
                                target.extras.linkedID = source.uuid;
                                if (root) {
                                    target.extras.rootID = root.uuid;
                                }
                            }
                        }
                        if (target && KEY_COMPONENTS in source) {
                            for (var _f = 0, _g = source[KEY_COMPONENTS]; _f < _g.length; _f++) {
                                var componentUUID = _g[_f];
                                var uuid = componentUUID.uuid;
                                var componentSource = components[uuid];
                                if ((paper.serializeClassMap[componentSource.class] || componentSource.class) === transformClassName) {
                                    this.components[uuid] = target.transform;
                                }
                            }
                        }
                    }
                    if (target) {
                        this.objects[source.uuid] = target;
                        root = root || target;
                    }
                }
                var i = data.objects.length;
                while (i--) {
                    var source = data.objects[i];
                    var target = this.objects[source.uuid];
                    if (target) {
                        this._deserializeObject(source, target); // 场景或实体属性反序列化。
                        if (target.constructor === paper.GameObject && KEY_COMPONENTS in source) {
                            for (var _h = 0, _j = source[KEY_COMPONENTS]; _h < _j.length; _h++) {
                                var componentUUID = _j[_h];
                                this._createComponent(components[componentUUID.uuid], source, target);
                            }
                        }
                    }
                }
            }
            if (data.components) {
                for (var _k = 0, _l = data.components; _k < _l.length; _k++) {
                    var componentSource = _l[_k];
                    var uuid = componentSource.uuid;
                    var component = this.components[uuid];
                    if (component) {
                        if (component.constructor === paper.MissingComponent) {
                            continue;
                        }
                        this._deserializeObject(componentSource, component);
                    }
                    else if (rootTarget && rootTarget.constructor === paper.GameObject) {
                        component = this._createComponent(componentSource);
                        root = root || component;
                        this._deserializeObject(componentSource, component);
                    }
                }
            }
            Deserializer._lastDeserializer = this;
            return root;
        };
        return Deserializer;
    }());
    paper.Deserializer = Deserializer;
    __reflect(Deserializer.prototype, "paper.Deserializer");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    paper.DATA_VERSION = 3;
    /**
     *
     */
    paper.DATA_VERSIONS = [paper.DATA_VERSION];
    var KEY_GAMEOBJECTS = "gameObjects";
    var KEY_COMPONENTS = "components";
    var KEY_EXTRAS = "extras";
    var KEY_CHILDREN = "children";
    var _inline = false;
    var _serializeds = [];
    var _deserializers = {};
    var _ignoreKeys = ["extras"];
    var _rootIgnoreKeys = ["name", "localPosition", "localRotation", "extras"];
    var _serializeData = null;
    var _defaultGameObject = null;
    /**
     *
     */
    function serialize(source, inline) {
        if (inline === void 0) { inline = false; }
        if (_serializeData) {
            console.warn("The deserialization is not complete.");
        }
        if (!_defaultGameObject) {
            _defaultGameObject = paper.GameObject.create("NoName" /* NoName */, "" /* Untagged */, paper.Application.sceneManager.globalScene);
            _defaultGameObject.parent = paper.GameObject.globalGameObject;
        }
        _inline = inline;
        _serializeData = { version: paper.DATA_VERSION, assets: [], objects: [], components: [] };
        _serializeObject(source);
        _serializeds.length = 0;
        for (var k in _deserializers) {
            delete _deserializers[k];
        }
        _defaultGameObject.transform.destroyChildren();
        _defaultGameObject.removeAllComponents();
        var serializeData = _serializeData;
        _serializeData = null;
        return serializeData;
    }
    paper.serialize = serialize;
    /**
     *
     */
    function clone(object) {
        var data = serialize(object, true);
        var deserializer = new paper.Deserializer();
        return deserializer.deserialize(data);
    }
    paper.clone = clone;
    /**
     *
     */
    function equal(source, target) {
        var typeSource = typeof source;
        var typeTarget = typeof target;
        if (typeSource !== typeTarget) {
            return false;
        }
        if (source === null && target === null) {
            return true;
        }
        if (source === null || target === null) {
            return false;
        }
        switch (typeSource) {
            case "undefined":
            case "boolean":
            case "number":
            case "string":
            case "symbol":
            case "function":
                return source === target;
            case "object":
            default:
                break;
        }
        if ((Array.isArray(source) || ArrayBuffer.isView(source)) &&
            (Array.isArray(target) || ArrayBuffer.isView(target))) {
            var sl = source.length;
            if (sl !== target.length) {
                return false;
            }
            if (sl === 0) {
                return true;
            }
            for (var i = 0; i < sl; ++i) {
                if (!equal(source[i], target[i])) {
                    return false;
                }
            }
            return true;
        }
        if (source.constructor !== target.constructor) {
            return false;
        }
        if (source instanceof paper.Asset ||
            source.constructor === paper.GameObject ||
            source instanceof paper.BaseComponent) {
            return source === target;
        }
        if (source.constructor === Object) {
            for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
                var k = source_1[_i];
                if (!equal(source[k], target[k])) {
                    return false;
                }
            }
            return true;
        }
        if (egret.is(source, "paper.ISerializable")) {
            return equal(source.serialize(), target.serialize());
        }
        if (source instanceof paper.BaseObject) {
            return equal(serializeStruct(source), serializeStruct(target));
        }
        throw new Error("Unsupported data.");
    }
    paper.equal = equal;
    /**
     *
     */
    function serializeAsset(source) {
        if (!source.name) {
            return { asset: -1 };
        }
        if (_serializeData && _serializeData.assets) {
            var index = _serializeData.assets.indexOf(source.name);
            if (index < 0) {
                index = _serializeData.assets.length;
                _serializeData.assets.push(source.name);
            }
            return { asset: index };
        }
        return { asset: -1 };
    }
    paper.serializeAsset = serializeAsset;
    /**
     * 创建指定对象的结构体。
     */
    function serializeStruct(source) {
        var className = egret.getQualifiedClassName(source);
        var target = { class: className };
        _serializeChildren(source, target, null, null);
        return target;
    }
    paper.serializeStruct = serializeStruct;
    function _getSerializedKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        var serializeKeys = serializedClass.__serializeKeys;
        if (serializeKeys) {
            keys = keys || [];
            for (var key in serializeKeys) {
                keys.push(serializeKeys[key] || key);
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getSerializedKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    function _serializeReference(source) {
        var className = egret.getQualifiedClassName(source);
        return { uuid: source.uuid, class: className };
    }
    function _findPrefabRoot(gameObject) {
        while (!gameObject.extras.prefab) {
            gameObject = gameObject.parent;
        }
        return gameObject;
    }
    function _serializeObject(source) {
        if (_serializeds.indexOf(source.uuid) >= 0) {
            return true;
        }
        var target = _serializeReference(source);
        var temp = null;
        var ignoreKeys = _ignoreKeys;
        if (source instanceof paper.GameObject) {
            if (source.isDestroyed) {
                console.warn("Missing game object.");
                return false;
            }
            if (source.extras && source.extras.linkedID) {
                var rootPrefabObject = _findPrefabRoot(source);
                var prefabName = rootPrefabObject.extras.prefab.name;
                if (!(prefabName in _deserializers)) {
                    var prefabGameObject = paper.Prefab.create(prefabName, _defaultGameObject.scene);
                    prefabGameObject.parent = _defaultGameObject;
                    _deserializers[prefabName] = paper.Deserializer._lastDeserializer;
                }
                var deserializer = _deserializers[prefabName];
                temp = deserializer.objects[source.extras.linkedID];
                if (source.extras.prefab) {
                    ignoreKeys = _rootIgnoreKeys;
                }
            }
            else {
                temp = _defaultGameObject;
            }
            _serializeData.objects.push(target);
        }
        else if (source instanceof paper.BaseComponent) {
            if (source.isDestroyed) {
                console.warn("Missing component.");
                return false;
            }
            if (source.extras && source.extras.linkedID) {
                var rootPrefabObject = _findPrefabRoot(source.gameObject);
                var prefabName = rootPrefabObject.extras.prefab.name;
                if (!(prefabName in _deserializers)) {
                    var prefabGameObject = paper.Prefab.create(prefabName, _defaultGameObject.scene);
                    prefabGameObject.parent = _defaultGameObject;
                    _deserializers[prefabName] = paper.Deserializer._lastDeserializer;
                }
                var deserializer = _deserializers[prefabName];
                temp = deserializer.components[source.extras.linkedID];
                if (source.gameObject.extras.prefab) {
                    ignoreKeys = _rootIgnoreKeys;
                }
            }
            else {
                temp = _defaultGameObject.getOrAddComponent(source.constructor);
            }
            _serializeData.components.push(target);
        }
        else {
            _serializeData.objects.push(target);
        }
        _serializeds.push(source.uuid);
        _serializeChildren(source, target, temp, ignoreKeys);
        return true;
    }
    function _serializeChildren(source, target, temp, ignoreKeys) {
        var serializedKeys = _getSerializedKeys(source.constructor);
        if (!serializedKeys) {
            return;
        }
        for (var _i = 0, serializedKeys_1 = serializedKeys; _i < serializedKeys_1.length; _i++) {
            var k = serializedKeys_1[_i];
            if (temp && (!ignoreKeys || ignoreKeys.indexOf(k) < 0) && equal(source[k], temp[k])) {
                continue;
            }
            target[k] = _serializeChild(source[k], source, k);
        }
    }
    function _serializeChild(source, parent, key) {
        if (source === null || source === undefined) {
            return source;
        }
        switch (typeof source) {
            case "function":
                return undefined;
            case "object": {
                if (Array.isArray(source) || ArrayBuffer.isView(source)) {
                    var target = [];
                    for (var _i = 0, _a = source; _i < _a.length; _i++) {
                        var element = _a[_i];
                        var result = _serializeChild(element, parent, key);
                        if (result !== undefined) {
                            target.push(result);
                        }
                    }
                    return target;
                }
                if (source.constructor === Object) {
                    var target = {};
                    for (var k in source) {
                        var result = _serializeChild(source[k], parent, key);
                        if (result !== undefined) {
                            target[k] = result;
                        }
                    }
                    return target;
                }
                if (egret.is(source, "paper.ISerializable")) {
                    return source.serialize();
                }
                if (source instanceof paper.BaseObject) {
                    if (source.constructor === paper.Scene) {
                        return undefined; // Pass.
                    }
                    if (source instanceof paper.Asset) {
                        return serializeAsset(source);
                    }
                    if (source.constructor === paper.GameObject || source instanceof paper.BaseComponent) {
                        if (source.constructor === paper.GameObject && source.hideFlags === 3 /* HideAndDontSave */) {
                            return undefined; // Pass.
                        }
                        else if (source.constructor === egret3d.Transform && source.gameObject.hideFlags === 3 /* HideAndDontSave */) {
                            return undefined; // Pass.
                        }
                        if (parent) {
                            if (parent.constructor === paper.Scene) {
                                if (key === KEY_GAMEOBJECTS) {
                                    return _serializeObject(source) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                            else if (parent.constructor === paper.GameObject) {
                                if (key === KEY_COMPONENTS) {
                                    return _serializeObject(source) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                            else if (parent.constructor === egret3d.Transform) {
                                if (key === KEY_CHILDREN) {
                                    return _serializeObject(source.gameObject) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                        }
                        return _serializeReference(source);
                    }
                    return serializeStruct(source);
                }
                console.warn("Serialize error.", source);
                return undefined; // Pass.
            }
            default:
                return source;
        }
    }
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpRotation = egret3d.Quaternion.create();
    var _helpMatrix = egret3d.Matrix4.create();
    var TransformDirty;
    (function (TransformDirty) {
        TransformDirty[TransformDirty["All"] = 63] = "All";
        TransformDirty[TransformDirty["EXT"] = 62] = "EXT";
        TransformDirty[TransformDirty["PRS"] = 7] = "PRS";
        TransformDirty[TransformDirty["MIM"] = 48] = "MIM";
        TransformDirty[TransformDirty["Position"] = 1] = "Position";
        TransformDirty[TransformDirty["Rotation"] = 2] = "Rotation";
        TransformDirty[TransformDirty["Scale"] = 4] = "Scale";
        TransformDirty[TransformDirty["Euler"] = 8] = "Euler";
        TransformDirty[TransformDirty["Matrix"] = 16] = "Matrix";
        TransformDirty[TransformDirty["InverseMatrix"] = 32] = "InverseMatrix";
    })(TransformDirty || (TransformDirty = {}));
    /**
     * 变换组件。
     * - 实现实体之间的父子关系。
     * - 实现 3D 空间坐标系。
     */
    var Transform = (function (_super) {
        __extends(Transform, _super);
        function Transform() {
            var _this = _super.call(this) || this;
            _this._localDirty = 63 /* All */;
            _this._worldDirty = 63 /* All */;
            /**
             * 世界矩阵的行列式，如果小于0，说明进行了反转
             * @internal
             */
            _this._worldMatrixDeterminant = 0.0;
            _this._localPosition = egret3d.Vector3.create();
            _this._localRotation = egret3d.Quaternion.create();
            _this._localEuler = egret3d.Vector3.create();
            _this._localEulerAngles = egret3d.Vector3.create();
            _this._localScale = egret3d.Vector3.ONE.clone();
            _this._localMatrix = egret3d.Matrix4.create();
            _this._position = egret3d.Vector3.create();
            _this._rotation = egret3d.Quaternion.create();
            _this._euler = egret3d.Vector3.create();
            _this._eulerAngles = egret3d.Vector3.create();
            _this._scale = egret3d.Vector3.ONE.clone();
            _this._inverseWorldMatrix = egret3d.Matrix4.create();
            _this._worldMatrix = egret3d.Matrix4.create();
            // private readonly _observers: ITransformObserver[] = []; // TODO
            /**
             * @internal
             */
            _this._children = [];
            /**
             * @internal
             */
            _this._parent = null;
            _this._localPosition.onUpdateTarget = _this._position.onUpdateTarget = _this;
            _this._localPosition.onUpdate = _this._position.onUpdate = _this._onPositionUpdate;
            _this._localRotation.onUpdateTarget = _this._rotation.onUpdateTarget = _this;
            _this._localRotation.onUpdate = _this._rotation.onUpdate = _this._onRotationUpdate;
            _this._localEuler.onUpdateTarget = _this._euler.onUpdateTarget = _this;
            _this._localEuler.onUpdate = _this._euler.onUpdate = _this._onEulerUpdate;
            _this._localEulerAngles.onUpdateTarget = _this._eulerAngles.onUpdateTarget = _this;
            _this._localEulerAngles.onUpdate = _this._eulerAngles.onUpdate = _this._onEulerAnglesUpdate;
            _this._localScale.onUpdateTarget = _this._scale.onUpdateTarget = _this;
            _this._localScale.onUpdate = _this._scale.onUpdate = _this._onScaleUpdate;
            return _this;
        }
        Transform.prototype._removeFromChildren = function (value) {
            var index = 0;
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child === value) {
                    this._children.splice(index, 1);
                    break;
                }
                index++;
            }
        };
        Transform.prototype._dirtify = function (isLocalDirty, dirty) {
            if (isLocalDirty) {
                this._localDirty |= dirty | 48 /* MIM */;
                if (dirty & 2 /* Rotation */) {
                    this._localDirty |= 4 /* Scale */ | 8 /* Euler */;
                }
                else if (dirty & 4 /* Scale */) {
                    this._localDirty |= 2 /* Rotation */;
                }
            }
            if (!(this._worldDirty & dirty) || !(this._worldDirty & 16 /* Matrix */)) {
                if (dirty & 1 /* Position */) {
                    this._worldDirty |= dirty | 48 /* MIM */;
                }
                else {
                    this._worldDirty = 63 /* All */;
                }
                for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child._dirtify(false, dirty);
                }
                if (this.gameObject.renderer) {
                    this.gameObject.renderer._boundingSphereDirty = true;
                }
            }
        };
        Transform.prototype._updateMatrix = function (isWorldSpace) {
            if (isWorldSpace) {
                var localMatrix = this.localMatrix;
                if (this._parent) {
                    this._worldMatrix.multiply(this._parent.worldMatrix, localMatrix);
                }
                else {
                    this._worldMatrix.copy(localMatrix);
                }
                this._worldMatrixDeterminant = this._worldMatrix.determinant();
                this._worldDirty &= ~16 /* Matrix */;
            }
            else {
                if ((this._localDirty & 2 /* Rotation */) || (this._localDirty & 4 /* Scale */)) {
                    this._localMatrix.compose(this.localPosition, this.localRotation, this.localScale);
                    this._localDirty &= ~7 /* PRS */;
                }
                else if (this._localDirty & 1 /* Position */) {
                    this._localMatrix.fromTranslate(this.localPosition, true);
                    this._localDirty &= ~1 /* Position */;
                }
                this._localDirty &= ~16 /* Matrix */;
            }
        };
        Transform.prototype._updateEuler = function (isWorldSpace, order) {
            if (isWorldSpace) {
                this.worldMatrix.toEuler(this._euler, order);
                this._eulerAngles.multiplyScalar(egret3d.RAD_DEG, this._euler);
                this._worldDirty &= ~8 /* Euler */;
            }
            else {
                this.localMatrix.toEuler(this._localEuler, order);
                this._localEulerAngles.multiplyScalar(egret3d.RAD_DEG, this._localEuler);
                this._localDirty &= ~8 /* Euler */;
            }
        };
        Transform.prototype._onParentChange = function (newParent, oldParent) {
            var prevActive = oldParent ? oldParent.gameObject.activeInHierarchy : this.gameObject.activeSelf;
            if ((newParent ? newParent.gameObject.activeInHierarchy : this.gameObject.activeSelf) !== prevActive) {
                this.gameObject._activeInHierarchyDirty(prevActive);
            }
            this._dirtify(false, 7 /* PRS */);
        };
        Transform.prototype._onPositionUpdate = function (position) {
            if (position === this._localPosition) {
                this._dirtify(true, 1 /* Position */);
            }
            else {
                this.position = position;
            }
        };
        Transform.prototype._onRotationUpdate = function (rotation) {
            if (rotation === this._localRotation) {
                this._dirtify(true, 2 /* Rotation */);
            }
            else {
                this.rotation = rotation;
            }
        };
        Transform.prototype._onEulerUpdate = function (euler) {
            if (euler === this._localEuler) {
                this.localEuler = euler;
            }
            else {
                this.euler = euler;
            }
        };
        Transform.prototype._onEulerAnglesUpdate = function (euler) {
            if (euler === this._localEulerAngles) {
                this.localEulerAngles = euler;
            }
            else {
                this.eulerAngles = euler;
            }
        };
        Transform.prototype._onScaleUpdate = function (scale) {
            if (scale === this._localScale) {
                this._dirtify(true, 4 /* Scale */);
            }
            else {
                this.scale = scale;
            }
        };
        /**
         * @internal
         */
        Transform.prototype.getAllChildren = function (out) {
            if (out === void 0) { out = []; }
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (Array.isArray(out)) {
                    out.push(child);
                }
                else {
                    var childName = child.gameObject.name;
                    if (childName in out) {
                        var transformOrTransforms = out[childName];
                        if (Array.isArray(transformOrTransforms)) {
                            transformOrTransforms.push(child);
                        }
                        else {
                            out[childName] = [transformOrTransforms, child];
                        }
                    }
                    else {
                        out[childName] = child;
                    }
                }
                child.getAllChildren(out);
            }
            return out;
        };
        /**
         * 销毁所有子（孙）级变换组件。
         */
        Transform.prototype.destroyChildren = function () {
            var i = this._children.length;
            while (i--) {
                this._children[i].gameObject.destroy();
            }
        };
        /**
         * 该组件是否包含指定的子（孙）级变换组件。
         */
        Transform.prototype.contains = function (value) {
            if (value === this) {
                return false;
            }
            var ancestor = value;
            while (ancestor !== this && ancestor !== null) {
                ancestor = ancestor.parent;
            }
            return ancestor === this;
        };
        /**
         * 设置该组件实体的父级变换组件。
         * @param value 父级变换组件。
         * @param worldPositionStays 是否保留当前世界空间坐标系的位置。
         */
        Transform.prototype.setParent = function (value, worldPositionStays) {
            if (worldPositionStays === void 0) { worldPositionStays = false; }
            var prevParent = this._parent;
            if (prevParent === value) {
                return this;
            }
            if (value &&
                this.gameObject.scene !== value.gameObject.scene) {
                console.warn("Cannot change the parent to a different scene.");
                return this;
            }
            if (this === value || (value && this.contains(value))) {
                console.error("Set the parent error.");
                return this;
            }
            if (worldPositionStays) {
                _helpVector3A.copy(this.position);
                _helpRotation.copy(this.rotation);
                _helpVector3B.copy(this.scale);
            }
            if (prevParent) {
                prevParent._removeFromChildren(this);
            }
            if (value) {
                value._children.push(this);
            }
            this._parent = value;
            this._onParentChange(value, prevParent);
            if (worldPositionStays) {
                this.position = _helpVector3A;
                this.rotation = _helpRotation;
                this.scale = _helpVector3B;
            }
            return this;
        };
        /**
         *
         */
        Transform.prototype.getChildIndex = function (value) {
            if (value.parent !== this) {
                return -1;
            }
            return this._children.indexOf(value);
        };
        /**
         *
         */
        Transform.prototype.setChildIndex = function (value, index) {
            if (value.parent !== this) {
                return;
            }
            var prevIndex = this._children.indexOf(value);
            if (prevIndex === index) {
                return;
            }
            this._children.splice(prevIndex, 1);
            this._children.splice(index, 0, value);
        };
        /**
         *
         */
        Transform.prototype.getChildAt = function (index) {
            return 0 <= index && index < this._children.length ? this._children[index] : null;
        };
        /**
         * 通过指定的名称或路径获取该组件实体的子级（孙级）变换组件。
         * @param nameOrPath 名称或路径。
         */
        Transform.prototype.find = function (nameOrPath) {
            var names = nameOrPath.split("/");
            var ancestor = this;
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_1 = names_1[_i];
                if (!name_1) {
                    return ancestor;
                }
                var prevAncestor = ancestor;
                for (var _a = 0, _b = ancestor._children; _a < _b.length; _a++) {
                    var child = _b[_a];
                    if (child.gameObject.name === name_1) {
                        ancestor = child;
                        break;
                    }
                }
                if (prevAncestor === ancestor) {
                    return null;
                }
            }
            return ancestor;
        };
        /**
         * 该物体的本地位置。
         */
        Transform.prototype.getLocalPosition = function () {
            return this._localPosition;
        };
        Transform.prototype.setLocalPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localPosition.x = p1.x;
                this._localPosition.y = p1.y;
                this._localPosition.z = p1.z;
            }
            else {
                this._localPosition.x = p1;
                this._localPosition.y = p2 || 0.0;
                this._localPosition.z = p3 || 0.0;
            }
            this._dirtify(true, 1 /* Position */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localPosition", {
            /**
             * 该物体的本地位置。
             */
            get: function () {
                return this._localPosition;
            },
            set: function (value) {
                this._localPosition.x = value.x;
                this._localPosition.y = value.y;
                this._localPosition.z = value.z;
                this._dirtify(true, 1 /* Position */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的本地旋转。
         */
        Transform.prototype.getLocalRotation = function () {
            return this._localRotation;
        };
        Transform.prototype.setLocalRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localRotation.x = p1.x;
                this._localRotation.y = p1.y;
                this._localRotation.z = p1.z;
                this._localRotation.w = p1.w;
            }
            else {
                this._localRotation.x = p1;
                this._localRotation.y = p2 || 0.0;
                this._localRotation.z = p3 || 0.0;
                this._localRotation.w = p4 !== undefined ? p4 : 1.0;
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localRotation", {
            /**
             * 该物体的本地旋转。
             */
            get: function () {
                return this._localRotation;
            },
            set: function (value) {
                this._localRotation.x = value.x;
                this._localRotation.y = value.y;
                this._localRotation.z = value.z;
                this._localRotation.w = value.w;
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的本地欧拉旋转。（弧度制）
         */
        Transform.prototype.getLocalEuler = function (order) {
            if (this._localDirty & 8 /* Euler */) {
                this._updateEuler(false, order);
            }
            return this._localEuler;
        };
        Transform.prototype.setLocalEuler = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localEuler.x = p1.x;
                this._localEuler.y = p1.y;
                this._localEuler.z = p1.z;
                this._localEulerAngles.multiplyScalar(egret3d.RAD_DEG, this._localEuler);
                this._localRotation.fromEuler(this._localEuler, p2);
            }
            else {
                this._localEuler.x = p1;
                this._localEuler.y = p2;
                this._localEuler.z = p3;
                this._localEulerAngles.multiplyScalar(egret3d.RAD_DEG, this._localEuler);
                this._localRotation.fromEuler(this._localEuler, p4);
            }
            this._dirtify(true, 2 /* Rotation */);
            this._localDirty &= ~8 /* Euler */;
            return this;
        };
        Object.defineProperty(Transform.prototype, "localEuler", {
            /**
             * 该物体的本地欧拉旋转。（弧度制）
             */
            get: function () {
                if (this._localDirty & 8 /* Euler */) {
                    this._updateEuler(false);
                }
                return this._localEuler;
            },
            set: function (value) {
                this._localEuler.x = value.x;
                this._localEuler.y = value.y;
                this._localEuler.z = value.z;
                this._localEulerAngles.multiplyScalar(egret3d.RAD_DEG, this._localEuler);
                this._localRotation.fromEuler(this._localEuler);
                this._dirtify(true, 2 /* Rotation */);
                this._localDirty &= ~8 /* Euler */;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的本地欧拉旋转。（角度制）
         */
        Transform.prototype.getLocalEulerAngles = function (order) {
            if (this._localDirty & 8 /* Euler */) {
                this._updateEuler(false, order);
            }
            return this._localEulerAngles;
        };
        Transform.prototype.setLocalEulerAngles = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localEulerAngles.x = p1.x;
                this._localEulerAngles.y = p1.y;
                this._localEulerAngles.z = p1.z;
                this._localEuler.multiplyScalar(egret3d.DEG_RAD, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler, p2);
            }
            else {
                this._localEulerAngles.x = p1;
                this._localEulerAngles.y = p2;
                this._localEulerAngles.z = p3;
                this._localEuler.multiplyScalar(egret3d.DEG_RAD, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler, p4);
            }
            this._dirtify(true, 2 /* Rotation */);
            this._localDirty &= ~8 /* Euler */;
            return this;
        };
        Object.defineProperty(Transform.prototype, "localEulerAngles", {
            /**
             * 该物体的本地欧拉旋转。（角度制）
             */
            get: function () {
                if (this._localDirty & 8 /* Euler */) {
                    this._updateEuler(false);
                }
                return this._localEulerAngles;
            },
            set: function (value) {
                this._localEulerAngles.x = value.x;
                this._localEulerAngles.y = value.y;
                this._localEulerAngles.z = value.z;
                this._localEuler.multiplyScalar(egret3d.DEG_RAD, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler);
                this._dirtify(true, 2 /* Rotation */);
                this._localDirty &= ~8 /* Euler */;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的本地缩放。
         */
        Transform.prototype.getLocalScale = function () {
            return this._localScale;
        };
        Transform.prototype.setLocalScale = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localScale.x = p1.x;
                this._localScale.y = p1.y;
                this._localScale.z = p1.z;
            }
            else {
                this._localScale.x = p1;
                this._localScale.y = p2 !== undefined ? p2 : p1;
                this._localScale.z = p3 !== undefined ? p3 : p1;
            }
            this._dirtify(true, 4 /* Scale */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localScale", {
            /**
             * 该物体的本地缩放。
             */
            get: function () {
                return this._localScale;
            },
            set: function (value) {
                this._localScale.x = value.x;
                this._localScale.y = value.y;
                this._localScale.z = value.z;
                this._dirtify(true, 4 /* Scale */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的本地矩阵。
         */
        Transform.prototype.getLocalMatrix = function () {
            if (this._localDirty & 16 /* Matrix */) {
                this._updateMatrix(false);
            }
            return this._localMatrix;
        };
        Object.defineProperty(Transform.prototype, "localMatrix", {
            /**
             * 该物体的本地矩阵。
             */
            get: function () {
                if (this._localDirty & 16 /* Matrix */) {
                    this._updateMatrix(false);
                }
                return this._localMatrix;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界位置。
         */
        Transform.prototype.getPosition = function () {
            if (this._worldDirty & 1 /* Position */) {
                this.worldMatrix.decompose(this._position, null, null);
                this._worldDirty &= ~1 /* Position */;
            }
            return this._position;
        };
        Transform.prototype.setPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localPosition.x = p1.x;
                this._localPosition.y = p1.y;
                this._localPosition.z = p1.z;
            }
            else {
                this._localPosition.x = p1;
                this._localPosition.y = p2 || 0.0;
                this._localPosition.z = p3 || 0.0;
            }
            if (this._parent) {
                this._localPosition.applyMatrix(_helpMatrix.inverse(this._parent.worldMatrix));
            }
            this._dirtify(true, 1 /* Position */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "position", {
            /**
             * 该物体的世界位置。
             */
            get: function () {
                if (this._worldDirty & 1 /* Position */) {
                    this.worldMatrix.decompose(this._position, null, null);
                    this._worldDirty &= ~1 /* Position */;
                }
                return this._position;
            },
            set: function (value) {
                this._localPosition.x = value.x;
                this._localPosition.y = value.y;
                this._localPosition.z = value.z;
                if (this._parent) {
                    this._localPosition.applyMatrix(_helpMatrix.inverse(this._parent.worldMatrix));
                }
                this._dirtify(true, 1 /* Position */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界旋转。
         */
        Transform.prototype.getRotation = function () {
            if (this._worldDirty & 2 /* Rotation */) {
                this.worldMatrix.decompose(null, this._rotation, null);
                this._worldDirty &= ~2 /* Rotation */;
            }
            return this._rotation;
        };
        Transform.prototype.setRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localRotation.x = p1.x;
                this._localRotation.y = p1.y;
                this._localRotation.z = p1.z;
                this._localRotation.w = p1.w;
            }
            else {
                this._localRotation.x = p1;
                this._localRotation.y = p2 || 0.0;
                this._localRotation.z = p3 || 0.0;
                this._localRotation.w = p4 !== undefined ? p4 : 1.0;
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "rotation", {
            /**
             * 该物体的世界旋转。
             */
            get: function () {
                if (this._worldDirty & 2 /* Rotation */) {
                    this.worldMatrix.decompose(null, this._rotation, null);
                    this._worldDirty &= ~2 /* Rotation */;
                }
                return this._rotation;
            },
            set: function (value) {
                this._localRotation.x = value.x;
                this._localRotation.y = value.y;
                this._localRotation.z = value.z;
                this._localRotation.w = value.w;
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界欧拉旋转。（弧度制）
         */
        Transform.prototype.getEuler = function (order) {
            if (this._worldDirty & 8 /* Euler */) {
                this._updateEuler(true, order);
            }
            return this._euler;
        };
        Transform.prototype.setEuler = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                this._localRotation.fromEuler(q1, q2);
            }
            else {
                _helpVector3A.set(q1, q2, q3);
                this._localRotation.fromEuler(_helpVector3A, q4);
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "euler", {
            /**
             * 该物体的世界欧拉旋转。（弧度制）
             */
            get: function () {
                if (this._worldDirty & 8 /* Euler */) {
                    this._updateEuler(true);
                }
                return this._euler;
            },
            set: function (value) {
                this._localRotation.fromEuler(value);
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界欧拉旋转。（角度制）
         */
        Transform.prototype.getEulerAngles = function (order) {
            if (this._worldDirty & 8 /* Euler */) {
                this._updateEuler(true, order);
            }
            return this._eulerAngles;
        };
        Transform.prototype.setEulerAngles = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                _helpVector3A.multiplyScalar(egret3d.DEG_RAD, q1);
                this._localRotation.fromEuler(_helpVector3A, q2);
            }
            else {
                _helpVector3A.set(q1 * egret3d.DEG_RAD, q2 * egret3d.DEG_RAD, q3 * egret3d.DEG_RAD);
                this._localRotation.fromEuler(_helpVector3A, q4);
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "eulerAngles", {
            /**
             * 该物体的世界欧拉旋转。（角度制）
             */
            get: function () {
                if (this._worldDirty & 8 /* Euler */) {
                    this._updateEuler(true);
                }
                return this._eulerAngles;
            },
            set: function (value) {
                _helpVector3A.multiplyScalar(egret3d.DEG_RAD, value);
                this._localRotation.fromEuler(_helpVector3A);
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界缩放。
         */
        Transform.prototype.getScale = function () {
            if (this._worldDirty & 4 /* Scale */) {
                this.worldMatrix.decompose(null, null, this._scale);
                this._worldDirty &= ~4 /* Scale */;
            }
            return this._scale;
        };
        Transform.prototype.setScale = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localScale.x = p1.x;
                this._localScale.y = p1.y;
                this._localScale.z = p1.z;
            }
            else {
                this._localScale.x = p1;
                this._localScale.y = p2 !== undefined ? p2 : p1;
                this._localScale.z = p3 !== undefined ? p3 : p1;
            }
            if (this._parent) {
                this._localScale.applyDirection(_helpMatrix.inverse(this._parent.worldMatrix));
            }
            this._dirtify(true, 4 /* Scale */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "scale", {
            /**
             * 该物体的世界缩放。
             */
            get: function () {
                if (this._worldDirty & 4 /* Scale */) {
                    this.worldMatrix.decompose(null, null, this._scale);
                    this._worldDirty &= ~4 /* Scale */;
                }
                return this._scale;
            },
            set: function (value) {
                this._localScale.x = value.x;
                this._localScale.y = value.y;
                this._localScale.z = value.z;
                if (this._parent) {
                    this._localScale.applyDirection(_helpMatrix.inverse(this._parent.worldMatrix));
                }
                this._dirtify(true, 4 /* Scale */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界矩阵。
         */
        Transform.prototype.getWorldMatrix = function () {
            if (this._worldDirty & 16 /* Matrix */) {
                this._updateMatrix(true);
            }
            return this._worldMatrix;
        };
        Object.defineProperty(Transform.prototype, "worldMatrix", {
            /**
             * 该物体的世界矩阵。
             */
            get: function () {
                if (this._worldDirty & 16 /* Matrix */) {
                    this._updateMatrix(true);
                }
                return this._worldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "inverseWorldMatrix", {
            /**
             * 该物体的世界逆矩阵。
             */
            get: function () {
                if (this._worldDirty & 32 /* InverseMatrix */) {
                    this._inverseWorldMatrix.inverse(this.worldMatrix);
                    this._worldDirty &= ~32 /* InverseMatrix */;
                }
                return this._inverseWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.translate = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                if (p2) {
                    this.position = this._localPosition.add(p1, this.position);
                }
                else {
                    this.localPosition = this._localPosition.add(p1);
                }
            }
            else {
                _helpVector3A.set(p1, p2, p3);
                if (p4) {
                    this.position = this._localPosition.add(_helpVector3A, this.position);
                }
                else {
                    this.localPosition = this._localPosition.add(_helpVector3A);
                }
            }
            return this;
        };
        Transform.prototype.rotate = function (p1, p2, p3, p4, p5) {
            if (p1.hasOwnProperty("x")) {
                if (p2) {
                    this.euler = this._localEuler.add(p1, this.euler);
                }
                else {
                    this.localEuler; // Update euler.
                    this.localEuler = this._localEuler.add(p1);
                }
            }
            else {
                _helpVector3A.set(p1, p2, p3);
                if (p4) {
                    this.euler = this._localEuler.add(_helpVector3A, this.euler);
                }
                else {
                    this.localEuler; // Update euler.
                    this.localEuler = this._localEuler.add(_helpVector3A);
                }
            }
            return this;
        };
        /**
         * 将该物体绕指定轴旋转指定弧度。
         * @param axis 指定轴。
         * @param angle 指定弧度。
         * @param isWorldSpace 是否是世界坐标系。
         */
        Transform.prototype.rotateOnAxis = function (axis, angle, isWorldSpace) {
            _helpRotation.fromAxis(axis, angle);
            if (isWorldSpace) {
                this.localRotation = this._localRotation.premultiply(_helpRotation).normalize();
            }
            else {
                this.localRotation = this._localRotation.multiply(_helpRotation).normalize();
            }
            return this;
        };
        /**
         * 将该物体绕世界指定点和世界指定轴旋转指定弧度。
         * @param worldPosition 世界指定点。
         * @param worldAxis 世界指定轴。
         * @param angle 指定弧度。
         */
        Transform.prototype.rotateAround = function (worldPosition, worldAxis, angle) {
            this.rotateOnAxis(worldAxis, angle, true);
            this.position = this._localPosition.applyMatrix(_helpMatrix.fromRotation(_helpRotation.fromAxis(worldAxis, angle)).fromTranslate(worldPosition, true), this.position);
            return this;
        };
        /**
         * 获取该物体在世界空间坐标系下描述的 X 轴正方向。
         * @param out 输出向量。
         */
        Transform.prototype.getRight = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.worldMatrix, egret3d.Vector3.RIGHT).normalize();
        };
        /**
         * 获取该物体在世界空间坐标系下描述的 Y 轴正方向。
         * @param out 输出向量。
         */
        Transform.prototype.getUp = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.worldMatrix, egret3d.Vector3.UP).normalize();
        };
        /**
         * 获取该物体在世界空间坐标系下描述的 Z 轴正方向。
         * @param out 输出向量。
         */
        Transform.prototype.getForward = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.worldMatrix, egret3d.Vector3.FORWARD).normalize();
        };
        /**
         * 通过旋转使得该物体的 Z 轴正方向指向目标点。
         * @param target 目标点。
         * @param up 旋转后，该物体在世界空间坐标系下描述的 Y 轴正方向。
         */
        Transform.prototype.lookAt = function (target, up) {
            if (up === void 0) { up = egret3d.Vector3.UP; }
            this.rotation = this._localRotation.fromMatrix(_helpMatrix.lookAt(this.position, target instanceof Transform ? target.position : target, up));
            return this;
        };
        /**
         * 通过旋转使得该物体的 Z 轴正方向指向目标方向。
         * @param target 目标方向。
         * @param up 旋转后，该物体在世界空间坐标系下描述的 Y 轴正方向。
         */
        Transform.prototype.lookRotation = function (direction, up) {
            if (up === void 0) { up = egret3d.Vector3.UP; }
            this.rotation = this._localRotation.fromMatrix(_helpMatrix.lookRotation(direction, up));
            return this;
        };
        Object.defineProperty(Transform.prototype, "childCount", {
            /**
             * 该组件实体的全部子级变换组件总数。
             */
            get: function () {
                return this._children.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "children", {
            /**
             * 该组件实体的全部子级变换组件。
             */
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "parent", {
            /**
             * 该组件实体的父级变换组件。
             */
            get: function () {
                return this._parent;
            },
            set: function (value) {
                this.setParent(value, false);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField("localPosition")
        ], Transform.prototype, "_localPosition", void 0);
        __decorate([
            paper.serializedField("localRotation")
        ], Transform.prototype, "_localRotation", void 0);
        __decorate([
            paper.serializedField("localScale")
        ], Transform.prototype, "_localScale", void 0);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Transform.prototype, "localPosition", null);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */, { step: 1.0 })
        ], Transform.prototype, "localEulerAngles", null);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Transform.prototype, "localScale", null);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Transform.prototype, "children", null);
        return Transform;
    }(paper.BaseComponent));
    egret3d.Transform = Transform;
    __reflect(Transform.prototype, "egret3d.Transform");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 全局舞台信息组件。
     * TODO 调整文件结构，标记接口源码链接。
     */
    var Stage = (function (_super) {
        __extends(Stage, _super);
        function Stage() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 当屏幕尺寸改变时派发事件。
             */
            _this.onScreenResize = new signals.Signal();
            /**
             * 当舞台尺寸改变时派发事件。
             */
            _this.onResize = new signals.Signal();
            _this._rotated = false;
            _this._screenSize = { w: 1024, h: 1024 };
            _this._size = { w: 1024, h: 1024 };
            _this._viewport = { x: 0, y: 0, w: 0, h: 0 };
            return _this;
        }
        Stage.prototype._updateViewport = function () {
            var screenSize = this._screenSize;
            var size = this._size;
            var viewport = this._viewport;
            if (paper.Application.isMobile) {
                viewport.w = Math.ceil(size.w);
                if (this._rotated = size.w > size.h ? screenSize.h > screenSize.w : screenSize.w > screenSize.h) {
                    viewport.h = Math.ceil(viewport.w / screenSize.h * screenSize.w);
                }
                else {
                    viewport.h = Math.ceil(viewport.w / screenSize.w * screenSize.h);
                }
            }
            else {
                this._rotated = false;
                viewport.w = Math.ceil(Math.min(size.w, screenSize.w));
                viewport.h = Math.ceil(viewport.w / screenSize.w * screenSize.h);
            }
        };
        Stage.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this);
            egret3d.stage = this;
            this._size.w = config.size.w;
            this._size.h = config.size.h;
            this._screenSize.w = config.screenSize.w;
            this._screenSize.h = config.screenSize.h;
            this._updateViewport();
        };
        /**
         * 屏幕到舞台坐标的转换。
         */
        Stage.prototype.screenToStage = function (value, out) {
            var screenSize = this._screenSize;
            var viewPort = this._viewport;
            var x = value.x, y = value.y;
            if (this._rotated) {
                out.y = (screenSize.w - (x - viewPort.x)) * (viewPort.w / screenSize.h);
                out.x = (y - viewPort.y) * (viewPort.h / screenSize.w);
            }
            else {
                out.x = (x - viewPort.x) * (viewPort.w / screenSize.w);
                out.y = (y - viewPort.y) * (viewPort.h / screenSize.h);
            }
            return this;
        };
        /**
         * 舞台到屏幕坐标的转换。
         */
        Stage.prototype.stageToScreen = function (value, out) {
            // TODO
            return this;
        };
        Object.defineProperty(Stage.prototype, "rotated", {
            /**
             * 舞台是否因屏幕尺寸的改变而发生了旋转。
             * - 旋转不会影响渲染视口的宽高交替，引擎通过反向旋转外部画布来抵消屏幕的旋转，即无论是否旋转，渲染视口的宽度始终等于舞台尺寸宽度。
             */
            get: function () {
                return this._rotated;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "screenSize", {
            /**
             * 屏幕尺寸。
             */
            get: function () {
                return this._screenSize;
            },
            set: function (value) {
                this._screenSize.w = value.w;
                this._screenSize.h = value.h;
                this._updateViewport();
                this.onScreenResize.dispatch();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "size", {
            /**
             * 舞台尺寸。
             */
            get: function () {
                return this._size;
            },
            set: function (value) {
                this._size.w = value.w;
                this._size.h = value.h;
                this._updateViewport();
                this.onResize.dispatch();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "viewport", {
            /**
             * 渲染视口。
             */
            get: function () {
                return this._viewport;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "screenViewport", {
            /**
             * @deprecated
             */
            get: function () {
                return this._viewport;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */, { readonly: true })
        ], Stage.prototype, "rotated", null);
        __decorate([
            paper.editor.property("SIZE" /* SIZE */)
        ], Stage.prototype, "screenSize", null);
        __decorate([
            paper.editor.property("SIZE" /* SIZE */)
        ], Stage.prototype, "size", null);
        __decorate([
            paper.editor.property("RECT" /* RECT */, { readonly: true })
        ], Stage.prototype, "viewport", null);
        return Stage;
    }(paper.SingletonComponent));
    egret3d.Stage = Stage;
    __reflect(Stage.prototype, "egret3d.Stage");
    /**
     * 全局舞台信息组件实例。
     */
    egret3d.stage = null;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    /**
     * 提供默认的几何网格资源的快速访问方式，以及创建几何网格或几何网格实体的方法。
     */
    var DefaultMeshes = (function (_super) {
        __extends(DefaultMeshes, _super);
        function DefaultMeshes() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMeshes.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            // TODO 颜色切线，球体，更多类型。
            {
                var mesh = egret3d.MeshBuilder.createPlane();
                mesh._isBuiltin = true;
                mesh.name = "builtin/quad.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.QUAD = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane(1.0, 1.0, -0.5, 0.0);
                mesh._isBuiltin = true;
                mesh.name = "builtin/quad_particle.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.QUAD_PARTICLE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane(10.0, 10.0);
                mesh._isBuiltin = true;
                mesh.name = "builtin/plane.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.PLANE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCube();
                mesh._isBuiltin = true;
                mesh.name = "builtin/cube.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CUBE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCylinder(0.0, Math.sqrt(0.5), 1.0, 0.0, 0.0, 0.0, 4, 1, false, Math.PI * 0.25);
                mesh._isBuiltin = true;
                mesh.name = "builtin/pyramid.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.PYRAMID = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCylinder(0.0, 0.5, 1.0, 0.0, 0.0, 0.0, 16, 1);
                mesh._isBuiltin = true;
                mesh.name = "builtin/cone.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CONE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCylinder();
                mesh._isBuiltin = true;
                mesh.name = "builtin/cylinder.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CYLINDER = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createTorus();
                mesh._isBuiltin = true;
                mesh.name = "builtin/torus.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.TORUS = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createSphere();
                mesh._isBuiltin = true;
                mesh.name = "builtin/sphere.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.SPHERE = mesh;
            }
            {
                var mesh = new egret3d.Mesh(4, 2, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh._isBuiltin = true;
                mesh.name = "builtin/line_x.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.LINE_X = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,
                    0.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = new egret3d.Mesh(4, 2, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh._isBuiltin = true;
                mesh.name = "builtin/line_y.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.LINE_Y = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = new egret3d.Mesh(4, 2, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh._isBuiltin = true;
                mesh.name = "builtin/line_z.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.LINE_Z = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    0.0, 0.0, 1.0,
                    0.0, 0.0, 0.0,
                    0.0, 0.0, 1.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = egret3d.MeshBuilder.createCircle();
                mesh._isBuiltin = true;
                mesh.name = "builtin/circle_line.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CIRCLE_LINE = mesh;
            }
            {
                var mesh = new egret3d.Mesh(8, 24, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh._isBuiltin = true;
                mesh.name = "builtin/cube_line.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.CUBE_LINE = mesh;
                //
                mesh.setAttributes("POSITION" /* POSITION */, [
                    // Z-
                    -0.5, 0.5, -0.5,
                    0.5, 0.5, -0.5,
                    0.5, -0.5, -0.5,
                    -0.5, -0.5, -0.5,
                    // Z+
                    0.5, 0.5, 0.5,
                    0.5, -0.5, 0.5,
                    -0.5, -0.5, 0.5,
                    -0.5, 0.5, 0.5,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                ]);
                mesh.setIndices([
                    0, 1, 1, 2, 2, 3, 3, 0,
                    4, 5, 5, 6, 6, 7, 7, 4,
                    0, 7, 1, 4, 2, 5, 3, 6,
                ]);
            }
        };
        /**
         * 创建带有指定网格资源的实体。
         * @param mesh 网格资源。
         * @param name 实体的名称。
         * @param tag 实体的标识。
         * @param scene 实体的场景。
         */
        DefaultMeshes.createObject = function (mesh, name, tag, scene) {
            var gameObject = paper.GameObject.create(name, tag, scene);
            var meshFilter = gameObject.addComponent(egret3d.MeshFilter);
            var renderer = gameObject.addComponent(egret3d.MeshRenderer);
            meshFilter.mesh = mesh;
            switch (mesh) {
                case this.QUAD:
                case this.QUAD_PARTICLE:
                case this.PLANE:
                    renderer.material = egret3d.DefaultMaterials.MESH_BASIC_DOUBLESIDE;
                    break;
                case this.LINE_X:
                case this.LINE_Y:
                case this.LINE_Z:
                    renderer.material = egret3d.DefaultMaterials.LINEDASHED_COLOR;
                    break;
                case this.CIRCLE_LINE:
                case this.CUBE_LINE:
                    renderer.material = egret3d.DefaultMaterials.LINEDASHED;
                    break;
            }
            return gameObject;
        };
        DefaultMeshes.createPlane = function (width, height, centerOffsetX, centerOffsetY, widthSegments, heightSegments) {
            if (width === void 0) { width = 1.0; }
            if (height === void 0) { height = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            return egret3d.MeshBuilder.createPlane(width, height, centerOffsetX, centerOffsetY, widthSegments, heightSegments);
        };
        DefaultMeshes.createCube = function (width, height, depth, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, depthSegments, differentFace) {
            if (width === void 0) { width = 1.0; }
            if (height === void 0) { height = 1.0; }
            if (depth === void 0) { depth = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (depthSegments === void 0) { depthSegments = 1; }
            if (differentFace === void 0) { differentFace = false; }
            return egret3d.MeshBuilder.createCube(width, height, depth, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, depthSegments, differentFace);
        };
        DefaultMeshes.createCylinder = function (radiusTop, radiusBottom, height, centerOffsetX, centerOffsetY, centerOffsetZ, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, differentFace) {
            if (radiusTop === void 0) { radiusTop = 0.5; }
            if (radiusBottom === void 0) { radiusBottom = 0.5; }
            if (height === void 0) { height = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (radialSegments === void 0) { radialSegments = 16; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (openEnded === void 0) { openEnded = false; }
            if (thetaStart === void 0) { thetaStart = 0.0; }
            if (thetaLength === void 0) { thetaLength = Math.PI * 2.0; }
            if (differentFace === void 0) { differentFace = false; }
            return egret3d.MeshBuilder.createCylinder(radiusTop, radiusBottom, height, centerOffsetX, centerOffsetY, centerOffsetZ, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, differentFace);
        };
        DefaultMeshes.createCircle = function (radius, arc, axis) {
            if (radius === void 0) { radius = 0.5; }
            if (arc === void 0) { arc = 1.0; }
            if (axis === void 0) { axis = 1; }
            return egret3d.MeshBuilder.createCircle(radius, arc, axis);
        };
        DefaultMeshes.createTorus = function (radius, tube, radialSegments, tubularSegments, arc, axis) {
            if (radius === void 0) { radius = 0.5; }
            if (tube === void 0) { tube = 0.1; }
            if (radialSegments === void 0) { radialSegments = 4; }
            if (tubularSegments === void 0) { tubularSegments = 12; }
            if (arc === void 0) { arc = 1.0; }
            if (axis === void 0) { axis = 1; }
            return egret3d.MeshBuilder.createTorus(radius, tube, radialSegments, tubularSegments, arc, axis);
        };
        DefaultMeshes.createSphere = function (radius, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            if (radius === void 0) { radius = 0.5; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (widthSegments === void 0) { widthSegments = 24; }
            if (heightSegments === void 0) { heightSegments = 12; }
            if (phiStart === void 0) { phiStart = 0.0; }
            if (phiLength === void 0) { phiLength = Math.PI * 2.0; }
            if (thetaStart === void 0) { thetaStart = 0.0; }
            if (thetaLength === void 0) { thetaLength = Math.PI; }
            return egret3d.MeshBuilder.createSphere(radius, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
        };
        __decorate([
            paper.deprecated("1.4")
        ], DefaultMeshes, "createPlane", null);
        __decorate([
            paper.deprecated("1.4")
        ], DefaultMeshes, "createCube", null);
        __decorate([
            paper.deprecated("1.4")
        ], DefaultMeshes, "createCylinder", null);
        __decorate([
            paper.deprecated("1.4")
        ], DefaultMeshes, "createCircle", null);
        __decorate([
            paper.deprecated("1.4")
        ], DefaultMeshes, "createTorus", null);
        __decorate([
            paper.deprecated("1.4")
        ], DefaultMeshes, "createSphere", null);
        return DefaultMeshes;
    }(paper.SingletonComponent));
    egret3d.DefaultMeshes = DefaultMeshes;
    __reflect(DefaultMeshes.prototype, "egret3d.DefaultMeshes");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 默认的贴图。
     */
    var DefaultTextures = (function (_super) {
        __extends(DefaultTextures, _super);
        function DefaultTextures() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultTextures.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            {
                var texture = egret3d.GLTexture2D.createColorTexture("builtin/white.image.json", 255, 255, 255);
                texture._isBuiltin = true;
                DefaultTextures.WHITE = texture;
                paper.Asset.register(texture);
            }
            {
                var texture = egret3d.GLTexture2D.createColorTexture("builtin/gray.image.json", 128, 128, 128);
                texture._isBuiltin = true;
                DefaultTextures.GRAY = texture;
                paper.Asset.register(texture);
            }
            {
                var texture = egret3d.GLTexture2D.createGridTexture("builtin/grid.image.json");
                texture._isBuiltin = true;
                DefaultTextures.GRID = texture;
                paper.Asset.register(texture);
            }
            {
                var texture = egret3d.GLTexture2D.createColorTexture("builtin/missing.image.json", 255, 0, 255);
                texture._isBuiltin = true;
                DefaultTextures.MISSING = texture;
                paper.Asset.register(texture);
            }
        };
        return DefaultTextures;
    }(paper.SingletonComponent));
    egret3d.DefaultTextures = DefaultTextures;
    __reflect(DefaultTextures.prototype, "egret3d.DefaultTextures");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 默认的 shader。
     */
    var DefaultShaders = (function (_super) {
        __extends(DefaultShaders, _super);
        function DefaultShaders() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultShaders.prototype._createShader = function (name, config, renderQueue, states, defines) {
            var shader = new egret3d.Shader(config, name);
            shader._isBuiltin = true;
            if (renderQueue) {
                shader._renderQueue = renderQueue;
            }
            if (defines) {
                shader._defines = defines;
            }
            if (states) {
                var shaderStates = egret3d.GLTFAsset.copyTechniqueStates(states);
                if (shaderStates) {
                    shader._states = shaderStates;
                }
            }
            paper.Asset.register(shader);
            return shader;
        };
        DefaultShaders.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            //
            var helpMaterial = new egret3d.Material(new egret3d.Shader(egret3d.ShaderLib.meshbasic, ""));
            //
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_BASIC = this._createShader("builtin/meshbasic.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_BASIC_DOUBLESIDE = this._createShader("builtin/meshbasic_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_LAMBERT = this._createShader("builtin/meshlambert.shader.json", egret3d.ShaderLib.meshlambert, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_LAMBERT_DOUBLESIDE = this._createShader("builtin/meshlambert_doubleside.shader.json", egret3d.ShaderLib.meshlambert, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_PHONG = this._createShader("builtin/meshphong.shader.json", egret3d.ShaderLib.meshphong, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_PHONE_DOUBLESIDE = this._createShader("builtin/meshphong_doubleside.shader.json", egret3d.ShaderLib.meshphong, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_PHYSICAL = this._createShader("builtin/meshphysical.shader.json", egret3d.ShaderLib.meshphysical, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_PHYSICAL_DOUBLESIDE = this._createShader("builtin/meshphysical_doubleside.shader.json", egret3d.ShaderLib.meshphysical, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */).setBlend(1 /* Blend */);
            DefaultShaders.TRANSPARENT = this._createShader("builtin/transparent.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(1 /* Blend */);
            DefaultShaders.TRANSPARENT_DOUBLESIDE = this._createShader("builtin/transparent_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */).setBlend(3 /* Add */);
            DefaultShaders.TRANSPARENT_ADDITIVE = this._createShader("builtin/transparent_additive.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(3 /* Add */);
            DefaultShaders.TRANSPARENT_ADDITIVE_DOUBLESIDE = this._createShader("builtin/transparent_additive_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */).setBlend(7 /* Multiply */);
            DefaultShaders.TRANSPARENT_MULTIPLY = this._createShader("builtin/transparent_multiply.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(7 /* Multiply */);
            DefaultShaders.TRANSPARENT_MULTIPLY_DOUBLESIDE = this._createShader("builtin/transparent_multiply_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.LINEDASHED = this._createShader("builtin/linedashed.shader.json", egret3d.ShaderLib.linedashed, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.VERTEX_COLOR = this._createShader("builtin/vertcolor.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */, "USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MATERIAL_COLOR = this._createShader("builtin/materialcolor.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.PARTICLE = this._createShader("builtin/particle.shader.json", egret3d.ShaderLib.particle, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(1 /* Blend */);
            DefaultShaders.PARTICLE_BLEND = this._createShader("builtin/particle_blend.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(3 /* Add */);
            DefaultShaders.PARTICLE_ADDITIVE = this._createShader("builtin/particle_additive.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(7 /* Multiply */);
            DefaultShaders.PARTICLE_MULTIPLY = this._createShader("builtin/particle_multiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(2 /* Blend_PreMultiply */);
            DefaultShaders.PARTICLE_BLEND_PREMULTIPLY = this._createShader("builtin/particle_blend_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(4 /* Add_PreMultiply */);
            DefaultShaders.PARTICLE_ADDITIVE_PREMULTIPLY = this._createShader("builtin/particle_additive_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(8 /* Multiply_PreMultiply */);
            DefaultShaders.PARTICLE_MULTIPLY_PREMULTIPLY = this._createShader("builtin/particle_multiply_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.CUBE = this._createShader("builtin/cube.shader.json", egret3d.ShaderLib.cube, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.DEPTH = this._createShader("builtin/depth.shader.json", egret3d.ShaderLib.depth, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.DISTANCE_RGBA = this._createShader("builtin/distanceRGBA.shader.json", egret3d.ShaderLib.distanceRGBA, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.EQUIRECT = this._createShader("builtin/equirect.shader.json", egret3d.ShaderLib.equirect, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.NORMAL = this._createShader("builtin/normal.shader.json", egret3d.ShaderLib.normal, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.POINTS = this._createShader("builtin/points.shader.json", egret3d.ShaderLib.points, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.SHADOW = this._createShader("builtin/shadow.shader.json", egret3d.ShaderLib.shadow, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.SPRITE = this._createShader("builtin/sprite.shader.json", egret3d.ShaderLib.sprite, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            // // TODO
            // helpMaterial.clearStates().setDepth(true, true).setCullFace(true, gltf.FrontFace.CCW, gltf.CullFace.BACK);
            // this._createShader("obsolete/shaders/diffuse.shader.json", egret3d.ShaderLib.diffuse as any, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, [ShaderDefines.USE_MAP]);
            helpMaterial.dispose();
        };
        return DefaultShaders;
    }(paper.SingletonComponent));
    egret3d.DefaultShaders = DefaultShaders;
    __reflect(DefaultShaders.prototype, "egret3d.DefaultShaders");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DefaultMaterials = (function (_super) {
        __extends(DefaultMaterials, _super);
        function DefaultMaterials() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMaterials.prototype._createMaterial = function (name, shader, renderQueue) {
            if (renderQueue === void 0) { renderQueue = 2000 /* Geometry */; }
            var material = new egret3d.Material(shader);
            material.name = name;
            material.renderQueue = renderQueue;
            material._isBuiltin = true;
            paper.Asset.register(material);
            return material;
        };
        DefaultMaterials.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            DefaultMaterials.MESH_BASIC = this._createMaterial("builtin/meshbasic.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setTexture(egret3d.DefaultTextures.WHITE);
            DefaultMaterials.MESH_BASIC_DOUBLESIDE = this._createMaterial("builtin/meshbasic_doubleside.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setTexture(egret3d.DefaultTextures.WHITE)
                .setCullFace(false);
            DefaultMaterials.MESH_LAMBERT = this._createMaterial("builtin/meshlambert.mat.json", egret3d.DefaultShaders.MESH_LAMBERT)
                .setTexture(egret3d.DefaultTextures.WHITE);
            DefaultMaterials.MESH_LAMBERT_DOUBLESIDE = this._createMaterial("builtin/meshlambert_doubleside.mat.json", egret3d.DefaultShaders.MESH_LAMBERT)
                .setTexture(egret3d.DefaultTextures.WHITE)
                .setCullFace(false);
            DefaultMaterials.LINEDASHED = this._createMaterial("builtin/linedashed.mat.json", egret3d.DefaultShaders.LINEDASHED);
            DefaultMaterials.LINEDASHED_COLOR = this._createMaterial("builtin/linedashed_color.mat.json", egret3d.DefaultShaders.LINEDASHED)
                .addDefine("USE_COLOR" /* USE_COLOR */);
            DefaultMaterials.MISSING = this._createMaterial("builtin/missing.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setColor(egret3d.Color.PURPLE);
            DefaultMaterials.SHADOW_DEPTH = this._createMaterial("builtin/shadow_depth.mat.json", egret3d.DefaultShaders.DEPTH)
                .addDefine("DEPTH_PACKING 3201" /* DEPTH_PACKING_3201 */);
            DefaultMaterials.SHADOW_DISTANCE = this._createMaterial("builtin/shadow_distance.mat.json", egret3d.DefaultShaders.DISTANCE_RGBA);
        };
        return DefaultMaterials;
    }(paper.SingletonComponent));
    egret3d.DefaultMaterials = DefaultMaterials;
    __reflect(DefaultMaterials.prototype, "egret3d.DefaultMaterials");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 激活的摄像机和灯光。
     */
    var CameraAndLightCollecter = (function (_super) {
        __extends(CameraAndLightCollecter, _super);
        function CameraAndLightCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.cameras = [];
            _this.lights = [];
            return _this;
        }
        CameraAndLightCollecter.prototype._sortCameras = function (a, b) {
            var aOrder = a.renderTarget ? a.order : a.order * 1000 + 1;
            var bOrder = b.renderTarget ? b.order : b.order * 1000 + 1;
            return aOrder - bOrder;
        };
        /**
         * 更新摄像机。
         */
        CameraAndLightCollecter.prototype.updateCameras = function (gameObjects) {
            this.cameras.length = 0;
            for (var _i = 0, gameObjects_1 = gameObjects; _i < gameObjects_1.length; _i++) {
                var gameObject = gameObjects_1[_i];
                this.cameras.push(gameObject.getComponent(egret3d.Camera));
            }
        };
        CameraAndLightCollecter.prototype.updateLights = function (gameObjects) {
            this.lights.length = 0;
            for (var _i = 0, gameObjects_2 = gameObjects; _i < gameObjects_2.length; _i++) {
                var gameObject = gameObjects_2[_i];
                this.lights.push(gameObject.getComponent(egret3d.BaseLight, true));
            }
        };
        CameraAndLightCollecter.prototype.sortCameras = function () {
            // TODO camera order event.
            this.cameras.sort(this._sortCameras);
        };
        Object.defineProperty(CameraAndLightCollecter.prototype, "cameraCount", {
            /**
             * 摄像机计数
             */
            get: function () {
                return this.cameras.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraAndLightCollecter.prototype, "lightCount", {
            /**
             * 灯光计数。
             */
            get: function () {
                return this.lights.length;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("UINT" /* UINT */)
        ], CameraAndLightCollecter.prototype, "cameraCount", null);
        __decorate([
            paper.editor.property("UINT" /* UINT */)
        ], CameraAndLightCollecter.prototype, "lightCount", null);
        return CameraAndLightCollecter;
    }(paper.SingletonComponent));
    egret3d.CameraAndLightCollecter = CameraAndLightCollecter;
    __reflect(CameraAndLightCollecter.prototype, "egret3d.CameraAndLightCollecter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 绘制信息。
     */
    var DrawCall = (function (_super) {
        __extends(DrawCall, _super);
        function DrawCall() {
            var _this = _super.call(this) || this;
            /**
             * 此次绘制的渲染组件。
             */
            _this.renderer = null;
            /**
             * 此次绘制的世界矩阵，没有则使用渲染组件所属实体的变换世界矩阵。
             */
            _this.matrix = null;
            /**
             * 此次绘制的子网格索引。
             */
            _this.subMeshIndex = -1;
            /**
             * 此次绘制的网格资源。
             */
            _this.mesh = null;
            /**
             * 此次绘制的材质资源。
             */
            _this.material = null;
            /**
             *
             */
            _this.zdist = -1;
            return _this;
        }
        /**
         * 创建一个绘制信息。
         * - 只有在扩展渲染系统时才需要使用此方法。
         */
        DrawCall.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new DrawCall();
        };
        DrawCall.prototype.onClear = function () {
            this.renderer = null;
            this.matrix = null;
            this.subMeshIndex = -1;
            this.mesh = null;
            this.material = null;
            this.zdist = -1;
        };
        DrawCall._instances = [];
        return DrawCall;
    }(paper.BaseRelease));
    egret3d.DrawCall = DrawCall;
    __reflect(DrawCall.prototype, "egret3d.DrawCall");
    /**
     * 全局绘制信息收集组件。
     */
    var DrawCallCollecter = (function (_super) {
        __extends(DrawCallCollecter, _super);
        function DrawCallCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 此帧的绘制总数。
             */
            _this.drawCallCount = 0;
            /**
             * 此帧参与渲染的渲染组件列表。
             */
            _this.renderers = [];
            /**
             * 此帧的绘制信息列表。
             * - 未进行视锥剔除的。
             */
            _this.drawCalls = [];
            /**
             * 此帧的非透明绘制信息列表。
             * - 已进行视锥剔除的。
             */
            _this.opaqueCalls = [];
            /**
             * 此帧的透明绘制信息列表。
             * - 已进行视锥剔除的。
             */
            _this.transparentCalls = [];
            /**
             * 此帧的阴影绘制信息列表。
             * - 已进行视锥剔除的。
             */
            _this.shadowCalls = [];
            _this._isRemoved = false;
            return _this;
        }
        /**
         * 所有非透明的, 按照从近到远排序
         */
        DrawCallCollecter.prototype._sortOpaque = function (a, b) {
            var aMat = a.material;
            var bMat = b.material;
            if (aMat.renderQueue !== bMat.renderQueue) {
                return aMat.renderQueue - bMat.renderQueue;
            }
            else if (aMat._glTFTechnique.program !== bMat._glTFTechnique.program) {
                return aMat._glTFTechnique.program - bMat._glTFTechnique.program;
            }
            else if (aMat._id !== bMat._id) {
                return aMat._id - bMat._id;
            }
            else {
                return a.zdist - b.zdist;
            }
        };
        /**
         * 所有透明的，按照从远到近排序
         */
        DrawCallCollecter.prototype._sortFromFarToNear = function (a, b) {
            if (a.material.renderQueue === b.material.renderQueue) {
                return b.zdist - a.zdist;
            }
            else {
                return a.material.renderQueue - b.material.renderQueue;
            }
        };
        /**
         * @internal
         */
        DrawCallCollecter.prototype._update = function () {
            if (this._isRemoved) {
                var index = 0;
                var removeCount = 0;
                var renderers = this.renderers;
                var drawCalls = this.drawCalls;
                this._isRemoved = false;
                for (var _i = 0, renderers_1 = renderers; _i < renderers_1.length; _i++) {
                    var renderer = renderers_1[_i];
                    if (renderer) {
                        if (removeCount > 0) {
                            renderers[index - removeCount] = renderer;
                            renderers[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
                if (removeCount > 0) {
                    renderers.length -= removeCount;
                }
                index = 0;
                removeCount = 0;
                for (var _a = 0, drawCalls_1 = drawCalls; _a < drawCalls_1.length; _a++) {
                    var drawCall = drawCalls_1[_a];
                    if (drawCall) {
                        if (removeCount > 0) {
                            drawCalls[index - removeCount] = drawCall;
                            drawCalls[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
                if (removeCount > 0) {
                    drawCalls.length -= removeCount;
                }
            }
        };
        /**
         * TODO
         */
        DrawCallCollecter.prototype.shadowFrustumCulling = function (camera) {
            this.shadowCalls.length = 0;
            for (var _i = 0, _a = this.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var renderer = drawCall.renderer;
                if (renderer.castShadows &&
                    (camera.cullingMask & renderer.gameObject.layer) !== 0 &&
                    (!renderer.frustumCulled || camera.testFrustumCulling(renderer))) {
                    this.drawCallCount++; // TODO 编辑模式剔除编辑 drawcall
                    this.shadowCalls.push(drawCall);
                }
            }
            this.shadowCalls.sort(this._sortFromFarToNear);
        };
        /**
         * TODO
         */
        DrawCallCollecter.prototype.frustumCulling = function (camera) {
            var cameraPosition = camera.gameObject.transform.position;
            this.opaqueCalls.length = 0;
            this.transparentCalls.length = 0;
            for (var _i = 0, _a = this.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var renderer = drawCall.renderer;
                if ((camera.cullingMask & renderer.gameObject.layer) !== 0 &&
                    (!renderer.frustumCulled || camera.testFrustumCulling(renderer))) {
                    this.drawCallCount++; // TODO 编辑模式剔除编辑 drawcall
                    // if (drawCall.material.renderQueue >= paper.RenderQueue.Transparent && drawCall.material.renderQueue <= paper.RenderQueue.Overlay) {
                    if (drawCall.material.renderQueue >= 3000 /* Transparent */) {
                        this.transparentCalls.push(drawCall);
                    }
                    else {
                        this.opaqueCalls.push(drawCall);
                    }
                    drawCall.zdist = renderer.gameObject.transform.getPosition().getDistance(cameraPosition);
                }
            }
            this.opaqueCalls.sort(this._sortOpaque);
            this.transparentCalls.sort(this._sortFromFarToNear);
        };
        /**
         * 移除指定渲染组件的绘制信息列表。
         */
        DrawCallCollecter.prototype.removeDrawCalls = function (renderer) {
            var index = this.renderers.indexOf(renderer);
            if (index < 0) {
                return;
            }
            var i = this.drawCalls.length;
            while (i--) {
                var drawCall = this.drawCalls[i];
                if (drawCall && drawCall.renderer === renderer) {
                    this.drawCalls[i] = null;
                    drawCall.release();
                }
            }
            this.renderers[index] = null;
            this._isRemoved = true;
        };
        /**
         * 是否包含指定渲染组件的绘制信息列表。
         */
        DrawCallCollecter.prototype.hasDrawCalls = function (renderer) {
            return this.renderers.indexOf(renderer) >= 0;
        };
        __decorate([
            paper.editor.property("UINT" /* UINT */)
        ], DrawCallCollecter.prototype, "drawCallCount", void 0);
        return DrawCallCollecter;
    }(paper.SingletonComponent));
    egret3d.DrawCallCollecter = DrawCallCollecter;
    __reflect(DrawCallCollecter.prototype, "egret3d.DrawCallCollecter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 全局碰撞信息收集组件。
     */
    var ContactCollecter = (function (_super) {
        __extends(ContactCollecter, _super);
        function ContactCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 当前帧开始碰撞的。
             */
            _this.begin = [];
            /**
             * 当前帧维持碰撞的。
             */
            _this.stay = [];
            /**
             * 当前帧结束碰撞的。
             */
            _this.end = [];
            return _this;
        }
        /**
         * @internal
         */
        ContactCollecter.prototype.update = function (deltaTime) {
            if (this.begin.length > 0) {
                this.begin.length = 0;
            }
            if (this.end.length > 0) {
                this.end.length = 0;
            }
        };
        return ContactCollecter;
    }(paper.SingletonComponent));
    egret3d.ContactCollecter = ContactCollecter;
    __reflect(ContactCollecter.prototype, "egret3d.ContactCollecter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Pointer 按钮的类型。
     * - https://www.w3.org/TR/pointerevents/#the-button-property
     */
    var PointerButtonType;
    (function (PointerButtonType) {
        PointerButtonType[PointerButtonType["None"] = -1] = "None";
        PointerButtonType[PointerButtonType["LeftMouse"] = 0] = "LeftMouse";
        PointerButtonType[PointerButtonType["TouchContact"] = 0] = "TouchContact";
        PointerButtonType[PointerButtonType["Pencontac"] = 0] = "Pencontac";
        PointerButtonType[PointerButtonType["MiddleMouse"] = 1] = "MiddleMouse";
        PointerButtonType[PointerButtonType["RightMouse"] = 2] = "RightMouse";
        PointerButtonType[PointerButtonType["PenBarrel"] = 2] = "PenBarrel";
        PointerButtonType[PointerButtonType["Back"] = 3] = "Back";
        PointerButtonType[PointerButtonType["X1"] = 3] = "X1";
        PointerButtonType[PointerButtonType["Forward"] = 4] = "Forward";
        PointerButtonType[PointerButtonType["X2"] = 4] = "X2";
        PointerButtonType[PointerButtonType["PenEraser"] = 5] = "PenEraser";
    })(PointerButtonType = egret3d.PointerButtonType || (egret3d.PointerButtonType = {}));
    /**
     * Pointer 按钮的状态类型。
     * - https://www.w3.org/TR/pointerevents/#the-buttons-property
     */
    var PointerButtonsType;
    (function (PointerButtonsType) {
        PointerButtonsType[PointerButtonsType["None"] = 0] = "None";
        PointerButtonsType[PointerButtonsType["LeftMouse"] = 1] = "LeftMouse";
        PointerButtonsType[PointerButtonsType["TouchContact"] = 1] = "TouchContact";
        PointerButtonsType[PointerButtonsType["PenContac"] = 1] = "PenContac";
        PointerButtonsType[PointerButtonsType["MiddleMouse"] = 4] = "MiddleMouse";
        PointerButtonsType[PointerButtonsType["RightMouse"] = 2] = "RightMouse";
        PointerButtonsType[PointerButtonsType["PenBarrel"] = 2] = "PenBarrel";
        PointerButtonsType[PointerButtonsType["Back"] = 8] = "Back";
        PointerButtonsType[PointerButtonsType["X1"] = 8] = "X1";
        PointerButtonsType[PointerButtonsType["Forward"] = 16] = "Forward";
        PointerButtonsType[PointerButtonsType["X2"] = 16] = "X2";
        PointerButtonsType[PointerButtonsType["PenEraser"] = 32] = "PenEraser";
    })(PointerButtonsType = egret3d.PointerButtonsType || (egret3d.PointerButtonsType = {}));
    /**
     * 鼠标、笔、触控等的信息。
     */
    var Pointer = (function (_super) {
        __extends(Pointer, _super);
        function Pointer() {
            var _this = _super.call(this) || this;
            /**
             * 该 Pointer 持续按下的时间。
             */
            _this.holdedTime = 0.0;
            /**
             * 该 Pointer 的舞台坐标。
             */
            _this.position = egret3d.Vector3.create();
            /**
             * 该 Pointer 按下的舞台坐标。
             */
            _this.downPosition = egret3d.Vector3.create();
            /**
             * 该 Pointer 此帧的移动速度。
             */
            _this.speed = egret3d.Vector3.create();
            /**
             * 该 Pointer 最近的事件。
             */
            _this.event = null;
            /**
             * @internal
             */
            _this._prevButtons = 0 /* None */;
            /**
             * @internal
             */
            _this._prevPosition = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个 Pointer 实例。
         */
        Pointer.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new Pointer();
        };
        /**
         * 该 Pointer 此帧按下的状态。
         * @param value
         */
        Pointer.prototype.isDown = function (value, isPlayerMode) {
            if (value === void 0) { value = 1 /* TouchContact */; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return (this.event.buttons & value) !== 0 && (this._prevButtons & value) === 0;
        };
        /**
         * 该 Pointer 此帧持续按下的状态。
         * @param value
         */
        Pointer.prototype.isHold = function (value, isPlayerMode) {
            if (value === void 0) { value = 1 /* TouchContact */; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return (this.event.buttons & value) !== 0 && (this._prevButtons & value) !== 0;
        };
        /**
         * 该 Pointer 此帧抬起的状态。
         * @param value
         */
        Pointer.prototype.isUp = function (value, isPlayerMode) {
            if (value === void 0) { value = 1 /* TouchContact */; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return (this.event.buttons & value) === 0 && (this._prevButtons & value) !== 0;
        };
        /**
         * 该 Pointer 此帧移动的状态。
         * @param value
         */
        Pointer.prototype.isMove = function (distance, isPlayerMode) {
            if (distance === void 0) { distance = 5; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return null;
            }
            return Math.abs(this.speed.x) > distance || Math.abs(this.speed.y) > distance;
        };
        Pointer._instances = [];
        return Pointer;
    }(paper.BaseRelease));
    egret3d.Pointer = Pointer;
    __reflect(Pointer.prototype, "egret3d.Pointer");
    /**
     * 按键的信息。
     */
    var Key = (function () {
        function Key() {
            /**
             * 该按键持续按下的时间。
             */
            this.holdedTime = 0.0;
            /**
             * 该按键最近的事件。
             */
            this.event = null;
        }
        /**
         * 该按键此帧按下的状态。
         * @param value
         */
        Key.prototype.isDown = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return egret3d.inputCollecter.downKeys.indexOf(this) >= 0;
        };
        /**
         * 该按键此帧持续按下的状态。
         * @param value
         */
        Key.prototype.isHold = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return egret3d.inputCollecter.holdKeys.indexOf(this) >= 0;
        };
        /**
         * 该按键此帧抬起的状态。
         * @param value
         */
        Key.prototype.isUp = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return egret3d.inputCollecter.upKeys.indexOf(this) >= 0;
        };
        return Key;
    }());
    egret3d.Key = Key;
    __reflect(Key.prototype, "egret3d.Key");
    /**
     * 全局输入信息组件。
     * - https://www.w3.org/TR/pointerevents/
     * - https://github.com/millermedeiros/js-signals/
     */
    // @requireComponent(Stage) TODO
    var InputCollecter = (function (_super) {
        __extends(InputCollecter, _super);
        function InputCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 滚轮当前值。
             */
            _this.mouseWheel = 0;
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerOver = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerEnter = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerDown = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerMove = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerUp = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerCancel = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerOut = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerLeave = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onMouseWheel = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onKeyDown = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onKeyUp = new signals.Signal();
            /**
             * 此帧按下的全部 Pointer。
             */
            _this.downPointers = [];
            /**
             * 此帧持续按下的全部 Pointer。
             */
            _this.holdPointers = [];
            /**
             * 此帧抬起的全部 Pointer。
             */
            _this.upPointers = [];
            /**
             * 此帧按下的全部按键。
             */
            _this.downKeys = [];
            /**
             * 此帧持续按下的全部按键。
             */
            _this.holdKeys = [];
            /**
             * 此帧抬起的全部按键。
             */
            _this.upKeys = [];
            /**
             * 默认的 Pointer 实例。
             */
            _this.defaultPointer = Pointer.create();
            _this._pointers = {};
            _this._keys = {};
            return _this;
        }
        /**
         * @internal
         */
        InputCollecter.prototype.update = function (deltaTime) {
            for (var _i = 0, _a = this.downPointers; _i < _a.length; _i++) {
                var pointer = _a[_i];
                if (this.upPointers.indexOf(pointer) >= 0) {
                    continue;
                }
                pointer.holdedTime = 0.0;
                this.holdPointers.push(pointer);
            }
            for (var _b = 0, _c = this.holdPointers; _b < _c.length; _b++) {
                var pointer = _c[_b];
                pointer.holdedTime += deltaTime;
                pointer.speed.subtract(pointer.position, pointer._prevPosition);
                pointer._prevPosition.copy(pointer.position);
            }
            for (var _d = 0, _e = this.downKeys; _d < _e.length; _d++) {
                var key = _e[_d];
                if (this.holdKeys.indexOf(key) >= 0) {
                    continue;
                }
                key.holdedTime = 0.0;
                this.holdKeys.push(key);
            }
            for (var _f = 0, _g = this.holdKeys; _f < _g.length; _f++) {
                var key = _g[_f];
                key.holdedTime += deltaTime;
            }
            return this;
        };
        /**
         * @internal
         */
        InputCollecter.prototype.clear = function () {
            this.mouseWheel = 0;
            for (var k in this._pointers) {
                var pointer = this._pointers[k];
                if (pointer.event) {
                    pointer.speed.subtract(pointer.position, pointer._prevPosition);
                    pointer._prevButtons = pointer.event.buttons;
                    pointer._prevPosition.copy(pointer.position);
                }
            }
            if (this.upPointers.length > 0) {
                this.upPointers.length = 0;
            }
            if (this.downPointers.length > 0) {
                this.downPointers.length = 0;
            }
            if (this.upKeys.length > 0) {
                this.upKeys.length = 0;
            }
            if (this.downKeys.length > 0) {
                this.downKeys.length = 0;
            }
            return this;
        };
        InputCollecter.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            egret3d.inputCollecter = this;
            this._pointers[1] = this.defaultPointer;
        };
        /**
         * @internal
         */
        InputCollecter.prototype.getPointer = function (pointerID) {
            var pointers = this._pointers;
            if (!(pointerID in pointers)) {
                if (this.downPointers.length === 0 && this.holdPointers.length === 0) {
                    pointers[pointerID] = this.defaultPointer;
                }
                else {
                    pointers[pointerID] = Pointer.create();
                }
            }
            return pointers[pointerID];
        };
        /**
         * @internal
         */
        InputCollecter.prototype.removePointer = function (pointerID) {
            if (pointerID === 1) {
                return;
            }
            var pointers = this._pointers;
            if (pointerID in pointers) {
                var pointer = pointers[pointerID];
                if (pointer !== this.defaultPointer) {
                    pointer.release();
                }
                delete pointers[pointerID];
            }
        };
        /**
         * 通过键名称创建或获取一个按键实例。
         */
        InputCollecter.prototype.getKey = function (code) {
            var keys = this._keys;
            if (!(code in keys)) {
                keys[code] = new Key();
            }
            return keys[code];
        };
        Object.defineProperty(InputCollecter.prototype, "maxTouchPoints", {
            /**
             * 设备最大可支持的多点触摸数量。
             */
            get: function () {
                if (window.navigator) {
                    return window.navigator.maxTouchPoints;
                }
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        return InputCollecter;
    }(paper.SingletonComponent));
    egret3d.InputCollecter = InputCollecter;
    __reflect(InputCollecter.prototype, "egret3d.InputCollecter");
    /**
     * 全局输入信息组件实例。
     */
    egret3d.inputCollecter = null;
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 场景。
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        /**
         * 禁止实例化。
         */
        function Scene(name) {
            var _this = _super.call(this) || this;
            /**
             * 该场景的名称。
             */
            _this.name = "";
            /**
             * 额外数据，仅保存在编辑器环境，项目发布时该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            /**
             * 该场景使用光照贴图时的光照强度。
             */
            _this.lightmapIntensity = 1.0;
            /**
             * 该场景的环境光。
             */
            _this.ambientColor = egret3d.Color.create(0.20, 0.20, 0.25, 1.0);
            /**
             * 该场景的雾。
             */
            _this.fog = egret3d.Fog.create();
            /**
             * 该场景的光照贴图列表。
             */
            _this.lightmaps = [];
            _this._gameObjects = [];
            _this.name = name;
            return _this;
        }
        /**
         * 创建一个空场景。
         * @param name 场景的名称。
         */
        Scene.createEmpty = function (name, isActive) {
            // const exScene = Application.sceneManager.getSceneByName(name); TODO
            // if (exScene) {
            //     console.warn("The scene with the same name already exists.");
            //     return exScene;
            // }
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (isActive === void 0) { isActive = true; }
            var scene = new Scene(name);
            paper.Application.sceneManager.addScene(scene, isActive);
            return scene;
        };
        /**
         * 通过指定的场景资源创建一个场景。
         * @param name 场景资源的名称。
         */
        Scene.create = function (name, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            var exScene = paper.Application.sceneManager.getScene(name);
            if (exScene) {
                console.warn("The scene with the same name already exists.");
                return exScene;
            }
            var rawScene = paper.Asset.find(name);
            if (rawScene && rawScene instanceof paper.RawScene) {
                var scene = rawScene.createInstance();
                if (scene) {
                    if (combineStaticObjects && paper.Application.playerMode !== 2 /* Editor */) {
                        egret3d.combine(scene.gameObjects);
                    }
                    return scene;
                }
            }
            else {
                console.warn("The scene don't exists.", name);
            }
            return null;
        };
        Object.defineProperty(Scene, "globalScene", {
            /**
             * 全局静态的场景。
             * - 全局场景无法被销毁。
             */
            get: function () {
                return paper.Application.sceneManager.globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene, "editorScene", {
            /**
             * 全局静态编辑器的场景。
             */
            get: function () {
                return paper.Application.sceneManager.editorScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene, "activeScene", {
            /**
             * 当前激活的场景。
             */
            get: function () {
                return paper.Application.sceneManager.activeScene;
            },
            set: function (value) {
                paper.Application.sceneManager.activeScene = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @internal
         */
        Scene.prototype.addGameObject = function (gameObject) {
            if (this._gameObjects.indexOf(gameObject) >= 0) {
                console.warn("Add game object error.", gameObject.path);
            }
            this._gameObjects.push(gameObject);
        };
        /**
         * @internal
         */
        Scene.prototype.removeGameObject = function (gameObject) {
            var index = this._gameObjects.indexOf(gameObject);
            if (index < 0) {
                console.warn("Remove game object error.", gameObject.path);
            }
            this._gameObjects.splice(index, 1);
        };
        /**
         * 场景被销毁后，内部卸载。
         * @protected
         */
        Scene.prototype.uninitialize = function () {
            // TODO
            // this.name = "";
            // this.extras
            this.lightmapIntensity = 1.0;
            this.ambientColor.set(0.20, 0.20, 0.25, 1.0);
            // this.fog.clear();
            this.lightmaps.length = 0;
        };
        /**
         * 销毁该场景和场景中的全部实体。
         */
        Scene.prototype.destroy = function () {
            if (!paper.Application.sceneManager.removeScene(this)) {
                return false;
            }
            var i = this._gameObjects.length;
            while (i--) {
                var gameObject = this._gameObjects[i];
                if (!gameObject || gameObject.transform.parent) {
                    continue;
                }
                gameObject.destroy();
            }
            // 销毁的第一时间就将实体清除。
            this._gameObjects.length = 0;
            paper.disposeCollecter.scenes.push(this);
            return true;
        };
        /**
         * 获取该场景指定名称或路径的第一个实体。
         * - 仅返回第一个符合条件的实体。
         * @param nameOrPath 名称或路径。
         */
        Scene.prototype.find = function (nameOrPath) {
            var index = nameOrPath.indexOf("/");
            if (index > 0) {
                var firstName = nameOrPath.slice(0, index);
                for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    if (gameObject.name === firstName) {
                        var child = gameObject.transform.find(nameOrPath.slice(index + 1));
                        return child ? child.gameObject : null;
                    }
                }
            }
            else {
                for (var _b = 0, _c = this._gameObjects; _b < _c.length; _b++) {
                    var gameObject = _c[_b];
                    if (gameObject.name === nameOrPath) {
                        return gameObject;
                    }
                }
            }
            return null;
        };
        /**
         * 获取该场景指定标识的第一个实体。
         * - 仅返回第一个符合条件的实体。
         * @param tag 标识。
         */
        Scene.prototype.findWithTag = function (tag) {
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    return gameObject;
                }
            }
            return null;
        };
        /**
         * 获取该场景指定标识的全部实体。
         * - 返回符合条件的全部实体。
         * @param tag 标识。
         */
        Scene.prototype.findGameObjectsWithTag = function (tag) {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        /**
         * 该场景的全部根实体。
         */
        Scene.prototype.getRootGameObjects = function () {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (!gameObject.transform.parent) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        Object.defineProperty(Scene.prototype, "gameObjectCount", {
            /**
             * 该场景的实体总数。
             */
            get: function () {
                return this._gameObjects.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "gameObjects", {
            /**
             * 该场景的全部实体。
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Scene.prototype, "name", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "extras", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Scene.prototype, "lightmapIntensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("COLOR" /* COLOR */)
        ], Scene.prototype, "ambientColor", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("NESTED" /* NESTED */)
        ], Scene.prototype, "fog", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "lightmaps", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Scene.prototype, "gameObjects", null);
        return Scene;
    }(paper.BaseObject));
    paper.Scene = Scene;
    __reflect(Scene.prototype, "paper.Scene");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 立方体碰撞组件。
     */
    var BoxCollider = (function (_super) {
        __extends(BoxCollider, _super);
        function BoxCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Box;
            /**
             * 描述该组件的立方体。
             */
            _this.aabb = egret3d.AABB.ONE.clone();
            return _this;
        }
        BoxCollider.prototype.raycast = function (ray, raycastInfo) {
            var transform = this.gameObject.transform;
            var localRay = egret3d.helpRay.applyMatrix(transform.inverseWorldMatrix, ray);
            if (this.aabb.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    var worldMatrix = transform.worldMatrix;
                    raycastInfo.position.applyMatrix(worldMatrix);
                    raycastInfo.distance = ray.origin.getDistance(raycastInfo.position);
                    var normal = raycastInfo.normal;
                    if (normal) {
                        normal.applyDirection(worldMatrix).normalize();
                    }
                }
                return true;
            }
            return false;
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("NESTED" /* NESTED */)
        ], BoxCollider.prototype, "aabb", void 0);
        BoxCollider = __decorate([
            paper.allowMultiple
        ], BoxCollider);
        return BoxCollider;
    }(paper.BaseComponent));
    egret3d.BoxCollider = BoxCollider;
    __reflect(BoxCollider.prototype, "egret3d.BoxCollider", ["egret3d.IBoxCollider", "egret3d.ICollider", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 球体碰撞组件。
     */
    var SphereCollider = (function (_super) {
        __extends(SphereCollider, _super);
        function SphereCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Sphere;
            /**
             * 描述该组件的球体。
             */
            _this.sphere = egret3d.Sphere.create(egret3d.Vector3.ZERO, 0.5);
            return _this;
        }
        SphereCollider.prototype.raycast = function (ray, raycastInfo) {
            var transform = this.gameObject.transform;
            var localRay = egret3d.helpRay.applyMatrix(egret3d.helpMatrixA.inverse(transform.worldMatrix), ray);
            if (this.sphere.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    var worldMatrix = transform.worldMatrix;
                    raycastInfo.position.applyMatrix(worldMatrix);
                    raycastInfo.distance = ray.origin.getDistance(raycastInfo.position);
                    var normal = raycastInfo.normal;
                    if (normal) {
                        normal.applyDirection(worldMatrix).normalize();
                    }
                }
                return true;
            }
            return false;
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("NESTED" /* NESTED */)
        ], SphereCollider.prototype, "sphere", void 0);
        SphereCollider = __decorate([
            paper.allowMultiple
        ], SphereCollider);
        return SphereCollider;
    }(paper.BaseComponent));
    egret3d.SphereCollider = SphereCollider;
    __reflect(SphereCollider.prototype, "egret3d.SphereCollider", ["egret3d.ISphereCollider", "egret3d.ICollider", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    var _helpRaycastInfo = egret3d.RaycastInfo.create();
    function _raycastCollider(ray, collider, raycastInfo, hit) {
        var helpRaycastInfo = _helpRaycastInfo;
        var normal = raycastInfo.normal;
        helpRaycastInfo.normal = normal ? _helpVector3 : null;
        if (collider.raycast(ray, helpRaycastInfo) &&
            (!hit || raycastInfo.distance > helpRaycastInfo.distance)) {
            var transform = collider.gameObject.transform;
            raycastInfo.distance = helpRaycastInfo.distance;
            raycastInfo.position.copy(helpRaycastInfo.position);
            raycastInfo.transform = transform;
            raycastInfo.collider = collider;
            if (normal) {
                normal.copy(_helpVector3);
            }
            return true;
        }
        return false;
    }
    function _raycastAll(ray, gameObject, maxDistance, cullingMask, raycastMesh, raycastInfos) {
        if (maxDistance === void 0) { maxDistance = 0.0; }
        if (cullingMask === void 0) { cullingMask = 16777215 /* Everything */; }
        if (raycastMesh === void 0) { raycastMesh = false; }
        if ((gameObject.hideFlags === 3 /* HideAndDontSave */ && gameObject.tag === "Editor Only" /* EditorOnly */ &&
            (!gameObject.transform.parent || gameObject.transform.parent.gameObject.activeInHierarchy)) ? gameObject.activeSelf : !gameObject.activeInHierarchy) {
            return false;
        }
        var raycastInfo = egret3d.RaycastInfo.create();
        if (gameObject.layer & cullingMask) {
            if (raycastMesh) {
                if (gameObject.renderer && gameObject.renderer.enabled &&
                    gameObject.renderer.raycast(ray, raycastInfo, raycastMesh)) {
                    raycastInfo.transform = gameObject.transform;
                }
            }
            else {
                raycast(ray, gameObject, false, raycastInfo);
            }
        }
        if (raycastInfo.transform) {
            if (maxDistance <= 0.0 || raycastInfo.distance <= maxDistance) {
                raycastInfos.push(raycastInfo);
            }
            else {
                raycastInfo.transform = null;
                raycastInfo.release();
            }
        }
        else {
            raycastInfo.transform = null;
            raycastInfo.release();
        }
        if (!raycastInfo.transform) {
            for (var _i = 0, _a = gameObject.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                _raycastAll(ray, child.gameObject, maxDistance, cullingMask, raycastMesh, raycastInfos);
            }
        }
        return true;
    }
    function _sortRaycastInfo(a, b) {
        // TODO renderQueue.
        return a.distance - b.distance;
    }
    /**
     * 用世界空间坐标系的射线检测指定的实体。（不包含其子级）
     * @param ray 世界空间坐标系的射线。
     * @param gameObject 实体。
     * @param raycastMesh 是否检测网格。（需要消耗较多的 CPU 性能，尤其是蒙皮网格）
     * @param raycastInfo
     */
    function raycast(ray, gameObject, raycastMesh, raycastInfo) {
        if (raycastMesh === void 0) { raycastMesh = false; }
        if (raycastMesh) {
            if (gameObject.renderer && gameObject.renderer.enabled &&
                gameObject.renderer.raycast(ray, raycastInfo, raycastMesh)) {
                if (raycastInfo) {
                    raycastInfo.transform = gameObject.transform;
                }
                return true;
            }
            return false;
        }
        else {
            // TODO 更快的查询所有碰撞组件的方式。extends ?
            var hit = false;
            var boxColliders = gameObject.getComponents(egret3d.BoxCollider);
            var sphereColliders = gameObject.getComponents(egret3d.SphereCollider);
            if (boxColliders.length > 0) {
                for (var _i = 0, boxColliders_1 = boxColliders; _i < boxColliders_1.length; _i++) {
                    var collider = boxColliders_1[_i];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo) {
                        if (_raycastCollider(ray, collider, raycastInfo, hit)) {
                            hit = true;
                        }
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            if (sphereColliders.length > 0) {
                for (var _a = 0, sphereColliders_1 = sphereColliders; _a < sphereColliders_1.length; _a++) {
                    var collider = sphereColliders_1[_a];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo) {
                        if (_raycastCollider(ray, collider, raycastInfo, hit)) {
                            hit = true;
                        }
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
        }
        if (raycastInfo && raycastInfo.transform) {
            return true;
        }
        return false;
    }
    egret3d.raycast = raycast;
    /**
     * 用世界空间坐标系的射线检测指定的实体或变换组件列表。
     * @param ray 射线。
     * @param gameObjectsOrTransforms 实体或变换组件列表。
     * @param maxDistance 最大相交点检测距离。
     * @param cullingMask 只对特定层的实体检测。
     * @param raycastMesh 是否检测网格。（需要消耗较多的 CPU 性能，尤其是蒙皮网格）
     */
    function raycastAll(ray, gameObjectsOrTransforms, maxDistance, cullingMask, raycastMesh) {
        if (maxDistance === void 0) { maxDistance = 0.0; }
        if (cullingMask === void 0) { cullingMask = 16777215 /* Everything */; }
        if (raycastMesh === void 0) { raycastMesh = false; }
        var raycastInfos = [];
        for (var _i = 0, gameObjectsOrTransforms_1 = gameObjectsOrTransforms; _i < gameObjectsOrTransforms_1.length; _i++) {
            var gameObject = gameObjectsOrTransforms_1[_i];
            _raycastAll(ray, gameObject instanceof egret3d.Transform ? gameObject.gameObject : gameObject, maxDistance, cullingMask, raycastMesh, raycastInfos);
        }
        raycastInfos.sort(_sortRaycastInfo);
        return raycastInfos;
    }
    egret3d.raycastAll = raycastAll;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var CameraAndLightSystem = (function (_super) {
        __extends(CameraAndLightSystem, _super);
        function CameraAndLightSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                [
                    { componentClass: egret3d.Camera }
                ],
                [
                    { componentClass: [egret3d.DirectionalLight, egret3d.PointLight, egret3d.SpotLight] }
                ]
            ];
            _this._cameraAndLightCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.CameraAndLightCollecter);
            _this._drawCallCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCallCollecter);
            return _this;
        }
        CameraAndLightSystem.prototype.onAddGameObject = function (_gameObject, group) {
            if (group === this._groups[0]) {
                this._cameraAndLightCollecter.updateCameras(this._groups[0].gameObjects);
            }
            else if (group === this._groups[1]) {
                this._cameraAndLightCollecter.updateLights(this._groups[1].gameObjects);
            }
        };
        CameraAndLightSystem.prototype.onRemoveGameObject = function (_gameObject, group) {
            if (group === this._groups[0]) {
                this._cameraAndLightCollecter.updateCameras(this._groups[0].gameObjects);
            }
            else if (group === this._groups[1]) {
                this._cameraAndLightCollecter.updateLights(this._groups[1].gameObjects);
            }
        };
        CameraAndLightSystem.prototype.onUpdate = function (deltaTime) {
            var cameras = this._cameraAndLightCollecter.cameras;
            if (cameras.length > 0) {
                this._cameraAndLightCollecter.sortCameras();
                for (var _i = 0, cameras_1 = cameras; _i < cameras_1.length; _i++) {
                    var component = cameras_1[_i];
                    component._update(deltaTime);
                }
            }
            this._drawCallCollecter._update();
        };
        return CameraAndLightSystem;
    }(paper.BaseSystem));
    egret3d.CameraAndLightSystem = CameraAndLightSystem;
    __reflect(CameraAndLightSystem.prototype, "egret3d.CameraAndLightSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpRectA = new egret3d.Rectangle();
    var _helpPlane = egret3d.Plane.create();
    var _helpRay = egret3d.Ray.create();
    /**
     * 相机组件
     */
    var Camera = (function (_super) {
        __extends(Camera, _super);
        function Camera() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 是否清除颜色缓冲区
             */
            _this.clearOption_Color = true;
            /**
             * 是否清除深度缓冲区
             */
            _this.clearOption_Depth = true;
            /**
             * 相机的渲染剔除，对应 GameObject 的层级。
             * - camera.cullingMask = paper.CullingMask.UI;
             * - camera.cullingMask |= paper.CullingMask.UI;
             * - camera.cullingMask &= ~paper.CullingMask.UI;
             */
            _this.cullingMask = 16777215 /* Everything */;
            /**
             * 相机渲染排序
             */
            _this.order = 0;
            /**
             * 透视投影的fov
             */
            _this.fov = Math.PI * 0.25;
            /**
             * 正交投影的竖向size
             */
            _this.size = 2.0;
            /**
             * 0=正交，1=透视 中间值可以在两种相机间过度
             */
            _this.opvalue = 1.0;
            /**
             * 背景色
             */
            _this.backgroundColor = egret3d.Color.create(0.15, 0.25, 0.5, 1.0);
            /**
             * 相机视窗
             */
            _this.viewport = egret3d.Rectangle.create(0, 0, 1, 1);
            /**
             * TODO 功能完善后开放此接口
             */
            _this.postQueues = [];
            /**
             * 相机渲染上下文
             * @internal
             */
            _this.context = null;
            /**
             * 渲染目标，如果为null，则为画布
             */
            _this.renderTarget = null;
            _this._near = 0.3;
            _this._far = 1000.0;
            _this._projectionMatrix = egret3d.Matrix4.create();
            _this._matProjO = egret3d.Matrix4.create();
            _this._frameVectors = [
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create()
            ];
            return _this;
        }
        Object.defineProperty(Camera, "main", {
            /**
             * 当前场景的主相机。
             * - 如果没有则创建一个。
             */
            get: function () {
                var gameObject = paper.Application.sceneManager.activeScene.findWithTag("Main Camera" /* MainCamera */);
                if (!gameObject) {
                    gameObject = paper.GameObject.create("Main Camera" /* MainCamera */, "Main Camera" /* MainCamera */);
                    gameObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    gameObject.transform.lookAt(egret3d.Vector3.ZERO);
                }
                return gameObject.getOrAddComponent(Camera);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera, "editor", {
            /**
             * 编辑相机。
             * - 如果没有则创建一个。
             */
            get: function () {
                var gameObject = paper.Application.sceneManager.editorScene.find("Editor Camera" /* EditorCamera */);
                if (!gameObject) {
                    gameObject = paper.GameObject.create("Editor Camera" /* EditorCamera */, "Editor Only" /* EditorOnly */, paper.Application.sceneManager.editorScene);
                    gameObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    gameObject.transform.lookAt(egret3d.Vector3.ZERO);
                    var camera = gameObject.addComponent(Camera);
                    camera.cullingMask &= ~4 /* UI */; // TODO 更明确的 UI 编辑方案。
                    camera.far = 10000.0;
                }
                return gameObject.getOrAddComponent(Camera);
            },
            enumerable: true,
            configurable: true
        });
        // private readonly _frustumPlanes: Plane[] = [
        //     Plane.create(),
        //     Plane.create(),
        //     Plane.create(),
        //     Plane.create(),
        //     Plane.create(),
        //     Plane.create(),
        // ];
        /**
         * 计算相机视锥区域
         */
        Camera.prototype._calcCameraFrame = function () {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var farLD = this._frameVectors[0];
            var nearLD = this._frameVectors[1];
            var farRD = this._frameVectors[2];
            var nearRD = this._frameVectors[3];
            var farLT = this._frameVectors[4];
            var nearLT = this._frameVectors[5];
            var farRT = this._frameVectors[6];
            var nearRT = this._frameVectors[7];
            var near_h = this.near * Math.tan(this.fov * 0.5);
            var asp = vpp.w / vpp.h;
            var near_w = near_h * asp;
            nearLT.set(-near_w, near_h, this.near);
            nearLD.set(-near_w, -near_h, this.near);
            nearRT.set(near_w, near_h, this.near);
            nearRD.set(near_w, -near_h, this.near);
            var far_h = this.far * Math.tan(this.fov * 0.5);
            var far_w = far_h * asp;
            farLT.set(-far_w, far_h, this.far);
            farLD.set(-far_w, -far_h, this.far);
            farRT.set(far_w, far_h, this.far);
            farRD.set(far_w, -far_h, this.far);
            var matrix = this.gameObject.transform.getWorldMatrix();
            farLD.applyMatrix(matrix);
            nearLD.applyMatrix(matrix);
            farRD.applyMatrix(matrix);
            nearRD.applyMatrix(matrix);
            farLT.applyMatrix(matrix);
            nearLT.applyMatrix(matrix);
            farRT.applyMatrix(matrix);
            nearRT.applyMatrix(matrix);
        };
        Camera.prototype._intersectPlane = function (boundingSphere, v0, v1, v2) {
            var subV0 = egret3d.helpVector3A;
            var subV1 = egret3d.helpVector3B;
            var cross = egret3d.helpVector3C;
            var hitPoint = egret3d.helpVector3D;
            var distVec = egret3d.helpVector3E;
            var center = boundingSphere.center;
            subV0.subtract(v1, v0);
            subV1.subtract(v2, v1);
            cross.cross(subV0, subV1);
            egret3d.calPlaneLineIntersectPoint(cross, v0, cross, center, hitPoint);
            distVec.subtract(hitPoint, center);
            var val = distVec.dot(cross);
            if (val <= 0) {
                return true;
            }
            var dist = hitPoint.getDistance(center);
            if (dist < boundingSphere.radius) {
                return true;
            }
            return false;
        };
        /**
         * @internal
         */
        Camera.prototype._update = function (_delta) {
            this._calcCameraFrame();
            this.context.updateCamera(this, this.gameObject.transform.getWorldMatrix());
        };
        Camera.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.context = new egret3d.RenderContext();
        };
        /**
         * 计算相机的 project matrix（投影矩阵）
         */
        Camera.prototype.calcProjectMatrix = function (asp, matrix) {
            if (this.opvalue > 0.0) {
                egret3d.Matrix4.perspectiveProjectLH(this.fov, asp, this.near, this.far, this._projectionMatrix);
            }
            if (this.opvalue < 1.0) {
                egret3d.Matrix4.orthoProjectLH(this.size * asp, this.size, this.near, this.far, this._matProjO);
            }
            if (this.opvalue === 0.0) {
                matrix.copy(this._matProjO);
            }
            else if (this.opvalue === 1.0) {
                matrix.copy(this._projectionMatrix);
            }
            else {
                matrix.lerp(this.opvalue, this._matProjO, this._projectionMatrix);
            }
            return matrix;
        };
        /**
         * 计算相机视口像素rect
         */
        Camera.prototype.calcViewPortPixel = function (viewPortPixel) {
            var w;
            var h;
            var renderTarget = this.renderTarget;
            var viewport = this.viewport;
            if (renderTarget) {
                w = renderTarget.width;
                h = renderTarget.height;
            }
            else {
                var stageViewPort = egret3d.stage.viewport;
                w = stageViewPort.w;
                h = stageViewPort.h;
            }
            viewPortPixel.x = w * viewport.x;
            viewPortPixel.y = h * viewport.y;
            viewPortPixel.w = w * viewport.w;
            viewPortPixel.h = h * viewport.h;
            //asp = this.viewPortPixel.w / this.viewPortPixel.h;
        };
        /**
         * 由屏幕坐标得到世界坐标
         */
        Camera.prototype.calcWorldPosFromScreenPos = function (screenPos, outWorldPos) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var vppos = egret3d.helpVector3A;
            vppos.x = screenPos.x / vpp.w * 2.0 - 1.0;
            vppos.y = 1.0 - screenPos.y / vpp.h * 2.0;
            vppos.z = 0.0;
            var matrixProject = egret3d.helpMatrixB;
            var asp = vpp.w / vpp.h;
            this.calcProjectMatrix(asp, matrixProject);
            egret3d.helpMatrixC.multiply(matrixProject, this.gameObject.transform.inverseWorldMatrix).inverse();
            egret3d.helpVector3B.applyMatrix(egret3d.helpMatrixC, vppos);
            vppos.z = 1.0;
            egret3d.helpVector3C.applyMatrix(egret3d.helpMatrixC, vppos);
            egret3d.helpVector3B.subtract(egret3d.helpVector3B, egret3d.helpVector3C).normalize();
            _helpRay.set(egret3d.helpVector3C, egret3d.helpVector3B);
            var position = this.gameObject.transform.getForward().multiplyScalar(screenPos.z).add(this.gameObject.transform.position).release();
            _helpPlane.fromPoint(position, this.gameObject.transform.getForward().release());
            var raycastInfo = egret3d.RaycastInfo.create().release();
            _helpPlane.raycast(_helpRay, raycastInfo);
            outWorldPos.copy(raycastInfo.position);
        };
        /**
         * 由世界坐标得到屏幕坐标
         */
        Camera.prototype.calcScreenPosFromWorldPos = function (worldPos, outScreenPos) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var matrixProject = egret3d.helpMatrixB;
            var asp = vpp.w / vpp.h;
            this.calcProjectMatrix(asp, matrixProject);
            var matrixViewProject = egret3d.helpMatrixC.multiply(matrixProject, this.gameObject.transform.inverseWorldMatrix);
            var ndcPos = egret3d.helpVector3A;
            matrixViewProject.transformVector3(worldPos, ndcPos);
            outScreenPos.x = (ndcPos.x + 1.0) * vpp.w * 0.5;
            outScreenPos.y = (1.0 - ndcPos.y) * vpp.h * 0.5;
        };
        Camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, z, out) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var nearpos = egret3d.helpVector3A;
            nearpos.z = -this.near;
            nearpos.x = screenPos.x - vpp.w * 0.5;
            nearpos.y = vpp.h * 0.5 - screenPos.y;
            var farpos = egret3d.helpVector3B;
            farpos.z = -this.far;
            farpos.x = this.far * nearpos.x / this.near;
            farpos.y = this.far * nearpos.y / this.near;
            var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
            out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
            out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
        };
        /**
         * 由屏幕坐标发射射线
         */
        Camera.prototype.createRayByScreen = function (screenPosX, screenPosY, ray) {
            var from = egret3d.Vector3.create(screenPosX, screenPosY, 0.0).release();
            var to = egret3d.Vector3.create(screenPosX, screenPosY, 1.0).release();
            this.calcWorldPosFromScreenPos(from, from);
            this.calcWorldPosFromScreenPos(to, to);
            to.subtract(to, from).normalize();
            ray = ray || egret3d.Ray.create();
            ray.set(from, to);
            return ray;
        };
        Camera.prototype.testFrustumCulling = function (node) {
            var boundingSphere = node.boundingSphere;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[0], this._frameVectors[1], this._frameVectors[5]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[1], this._frameVectors[3], this._frameVectors[7]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[3], this._frameVectors[2], this._frameVectors[6]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[2], this._frameVectors[0], this._frameVectors[4]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[5], this._frameVectors[7], this._frameVectors[6]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[0], this._frameVectors[2], this._frameVectors[3]))
                return false;
            return true;
        };
        Object.defineProperty(Camera.prototype, "near", {
            /**
             * 相机到近裁剪面距离。
             */
            get: function () {
                return this._near;
            },
            set: function (value) {
                if (value >= this.far) {
                    value = this.far - 0.01;
                }
                if (value < 0.01) {
                    value = 0.01;
                }
                this._near = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "far", {
            /**
             * 相机到远裁剪面距离。
             */
            get: function () {
                return this._far;
            },
            set: function (value) {
                if (value <= this.near) {
                    value = this.near + 0.01;
                }
                if (value >= 10000.0) {
                    value = 10000.0;
                }
                this._far = value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], Camera.prototype, "clearOption_Color", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], Camera.prototype, "clearOption_Depth", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.CullingMask) })
        ], Camera.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("INT" /* INT */)
        ], Camera.prototype, "order", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0, maximum: Math.PI, step: 0.01 })
        ], Camera.prototype, "fov", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Camera.prototype, "size", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0, maximum: 1.0, step: 0.01 })
        ], Camera.prototype, "opvalue", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("COLOR" /* COLOR */)
        ], Camera.prototype, "backgroundColor", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("RECT" /* RECT */)
        ], Camera.prototype, "viewport", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "_near", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "_far", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, step: 1 })
        ], Camera.prototype, "near", null);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.02, maximum: 3000.0, step: 1 })
        ], Camera.prototype, "far", null);
        return Camera;
    }(paper.BaseComponent));
    egret3d.Camera = Camera;
    __reflect(Camera.prototype, "egret3d.Camera");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * TODO 平台无关。
     */
    var CameraPostQueueDepth = (function () {
        function CameraPostQueueDepth() {
            this.renderTarget = null;
        }
        CameraPostQueueDepth.prototype.render = function (camera, renderSystem) {
            // camera.context.drawtype = "_depth";
            // renderSystem._targetAndViewport(camera.viewport, this.renderTarget);
            // renderSystem._cleanBuffer(true, true, Color.BLACK);
            // renderSystem._renderCamera(camera);
            // GlRenderTarget.useNull();
        };
        return CameraPostQueueDepth;
    }());
    egret3d.CameraPostQueueDepth = CameraPostQueueDepth;
    __reflect(CameraPostQueueDepth.prototype, "egret3d.CameraPostQueueDepth", ["egret3d.ICameraPostQueue"]);
    // /**
    //  * framebuffer绘制通道
    //  * 
    //  */
    // export class CameraPostQueueQuad implements ICameraPostQueue {
    //     /**
    //      * shader & uniform
    //      */
    //     public readonly material: Material = new Material();
    //     /**
    //      * @inheritDoc
    //      */
    //     public renderTarget: GlRenderTarget = null as any;
    //     /**
    //      * @inheritDoc
    //      */
    //     public render(camera: Camera, _renderSystem: CameraSystem) {
    //         const webgl = WebGLKit.webgl;
    //         camera._targetAndViewport(this.renderTarget, true);
    //         WebGLKit.zWrite(true);
    //         // webgl.depthMask(true); // 开启 zwrite 以便正常 clear depth
    //         webgl.clearColor(0, 0.3, 0, 0);
    //         webgl.clearDepth(1.0);
    //         webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
    //         const mesh = DefaultMeshes.QUAD;
    //         camera.context.drawtype = "";
    //         WebGLKit.draw(camera.context, this.material, mesh, 0, "quad");
    //     }
    // }
    /**
     * TODO 平台无关。
     */
    var CameraPostQueueColor = (function () {
        function CameraPostQueueColor() {
            /**
             * @inheritDoc
             */
            this.renderTarget = null;
        }
        /**
         * @inheritDoc
         */
        CameraPostQueueColor.prototype.render = function (camera, renderSystem) {
            // renderSystem._targetAndViewport(camera.viewport, this.renderTarget);
            // renderSystem._cleanBuffer(camera.clearOption_Color, camera.clearOption_Depth, camera.backgroundColor);
            // renderSystem._renderCamera(camera);
            // GlRenderTarget.useNull();
        };
        return CameraPostQueueColor;
    }());
    egret3d.CameraPostQueueColor = CameraPostQueueColor;
    __reflect(CameraPostQueueColor.prototype, "egret3d.CameraPostQueueColor", ["egret3d.ICameraPostQueue"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var LightSize;
    (function (LightSize) {
        LightSize[LightSize["Directional"] = 11] = "Directional";
        LightSize[LightSize["Point"] = 15] = "Point";
        LightSize[LightSize["Spot"] = 18] = "Spot";
    })(LightSize || (LightSize = {}));
    var _helpVector3 = egret3d.Vector3.create();
    /**
     * @internal
     */
    var RenderContext = (function () {
        function RenderContext() {
            /**
             *
             */
            this.lightCount = 0;
            this.directLightCount = 0;
            this.pointLightCount = 0;
            this.spotLightCount = 0;
            this.shaderContextDefine = "";
            /**
             *
             */
            this.lightmap = null;
            this.lightmapUV = 1;
            this.lightmapIntensity = 1.0;
            //TODO
            // 12: dirX, dirY, dirZ, colorR, colorG, colorB, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.directLightArray = new Float32Array(0);
            // 16: x, y, z, colorR, colorG, colorB, distance, decay, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY, shadowCameraNear, shadowCameraFar,
            this.pointLightArray = new Float32Array(0);
            // 18: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, distance, decay, coneCos, penumbraCos, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.spotLightArray = new Float32Array(0);
            this.directShadowMatrix = new Float32Array(0);
            this.spotShadowMatrix = new Float32Array(0);
            this.pointShadowMatrix = new Float32Array(0);
            this.matrix_m = egret3d.Matrix4.create();
            this.matrix_mvp = egret3d.Matrix4.create();
            this.directShadowMaps = [];
            this.pointShadowMaps = [];
            this.spotShadowMaps = [];
            //
            this.viewPortPixel = { x: 0, y: 0, w: 0, h: 0 };
            this.cameraPosition = new Float32Array(3);
            this.cameraForward = new Float32Array(3);
            this.cameraUp = new Float32Array(3);
            // transforms
            this.matrix_v = egret3d.Matrix4.create();
            this.matrix_p = egret3d.Matrix4.create();
            this.matrix_mv = egret3d.Matrix4.create();
            this.matrix_vp = egret3d.Matrix4.create();
            this.matrix_mv_inverse = new egret3d.Matrix3(); //INVERS
            this.lightShadowCameraNear = 0;
            this.lightShadowCameraFar = 0;
            this.lightPosition = new Float32Array([0.0, 0.0, 0.0]);
            this.fogColor = new Float32Array(3);
            this.fogDensity = 0.0;
            this.fogNear = 0.0;
            this.fogFar = 0.0;
            this.drawCall = null;
        }
        RenderContext.prototype.updateCamera = function (camera, matrix) {
            camera.calcViewPortPixel(this.viewPortPixel); // update viewport
            camera.calcProjectMatrix(this.viewPortPixel.w / this.viewPortPixel.h, this.matrix_p);
            this.matrix_v.inverse(matrix);
            this.matrix_vp.multiply(this.matrix_p, this.matrix_v);
            var rawData = matrix.rawData;
            if (this.cameraPosition[0] !== rawData[12] ||
                this.cameraPosition[1] !== rawData[13] ||
                this.cameraPosition[2] !== rawData[14]) {
                this.cameraPosition[0] = rawData[12];
                this.cameraPosition[1] = rawData[13];
                this.cameraPosition[2] = rawData[14];
            }
            if (this.cameraUp[0] !== rawData[4] ||
                this.cameraUp[1] !== rawData[5] ||
                this.cameraUp[2] !== rawData[6]) {
                this.cameraUp[0] = rawData[4];
                this.cameraUp[1] = rawData[5];
                this.cameraUp[2] = rawData[6];
            }
            if (this.cameraForward[0] !== rawData[8] ||
                this.cameraForward[1] !== rawData[9] ||
                this.cameraForward[2] !== rawData[10]) {
                this.cameraForward[0] = -rawData[8];
                this.cameraForward[1] = -rawData[9];
                this.cameraForward[2] = -rawData[10];
            }
        };
        RenderContext.prototype.updateLights = function (lights) {
            var allLightCount = 0, directLightCount = 0, pointLightCount = 0, spotLightCount = 0;
            for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
                var light = lights_1[_i];
                if (light instanceof egret3d.DirectionalLight) {
                    directLightCount++;
                }
                else if (light instanceof egret3d.PointLight) {
                    pointLightCount++;
                }
                else if (light instanceof egret3d.SpotLight) {
                    spotLightCount++;
                }
                allLightCount++;
            }
            // TODO
            if (this.directLightArray.length !== directLightCount * 11 /* Directional */) {
                this.directLightArray = new Float32Array(directLightCount * 11 /* Directional */);
            }
            if (this.pointLightArray.length !== pointLightCount * 15 /* Point */) {
                this.pointLightArray = new Float32Array(pointLightCount * 15 /* Point */);
            }
            if (this.spotLightArray.length !== spotLightCount * 18 /* Spot */) {
                this.spotLightArray = new Float32Array(spotLightCount * 18 /* Spot */);
            }
            if (this.directShadowMatrix.length !== directLightCount * 16) {
                this.directShadowMatrix = new Float32Array(directLightCount * 16);
            }
            if (this.pointShadowMatrix.length !== pointLightCount * 16) {
                this.pointShadowMatrix = new Float32Array(pointLightCount * 16);
            }
            if (this.spotShadowMatrix.length !== spotLightCount * 16) {
                this.spotShadowMatrix = new Float32Array(spotLightCount * 16);
            }
            this.directShadowMaps.length = directLightCount;
            this.pointShadowMaps.length = pointLightCount;
            this.spotShadowMaps.length = spotLightCount;
            this.lightCount = allLightCount;
            this.directLightCount = directLightCount;
            this.pointLightCount = pointLightCount;
            this.spotLightCount = spotLightCount;
            var directLightIndex = 0, pointLightIndex = 0, spotLightIndex = 0, index = 0;
            var lightArray = this.directLightArray;
            for (var _a = 0, lights_2 = lights; _a < lights_2.length; _a++) {
                var light = lights_2[_a];
                switch (light.constructor) {
                    case egret3d.DirectionalLight: {
                        light.gameObject.transform.getForward(_helpVector3);
                        _helpVector3.applyDirection(this.matrix_v).normalize();
                        lightArray = this.directLightArray;
                        index = directLightIndex * 11 /* Directional */;
                        // lightArray[index++] = dirHelper.x; // Right-hand.
                        // lightArray[index++] = dirHelper.y;
                        // lightArray[index++] = dirHelper.z;
                        lightArray[index++] = -_helpVector3.x; // Left-hand.
                        lightArray[index++] = -_helpVector3.y;
                        lightArray[index++] = -_helpVector3.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        break;
                    }
                    case egret3d.PointLight: {
                        var position = light.gameObject.transform.getPosition().clone().release();
                        position.applyMatrix(this.matrix_v);
                        lightArray = this.pointLightArray;
                        index = pointLightIndex * 15 /* Point */;
                        lightArray[index++] = position.x;
                        lightArray[index++] = position.y;
                        lightArray[index++] = position.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        var distance = light.distance;
                        lightArray[index++] = distance;
                        lightArray[index++] = distance === 0 ? 0 : light.decay;
                        break;
                    }
                    case egret3d.SpotLight: {
                        var position = light.gameObject.transform.getPosition().clone().release();
                        position.applyMatrix(this.matrix_v);
                        light.gameObject.transform.getForward(_helpVector3);
                        _helpVector3.applyDirection(this.matrix_v).normalize();
                        lightArray = this.spotLightArray;
                        index = spotLightIndex * 18 /* Spot */;
                        lightArray[index++] = position.x;
                        lightArray[index++] = position.y;
                        lightArray[index++] = position.z;
                        // lightArray[index++] = dirHelper.x; // Right-hand.
                        // lightArray[index++] = dirHelper.y;
                        // lightArray[index++] = dirHelper.z;
                        lightArray[index++] = -_helpVector3.x; // Left-hand.
                        lightArray[index++] = -_helpVector3.y;
                        lightArray[index++] = -_helpVector3.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        var distance = light.distance;
                        lightArray[index++] = distance;
                        lightArray[index++] = distance === 0 ? 0 : light.decay;
                        lightArray[index++] = Math.cos(light.angle);
                        lightArray[index++] = Math.cos(light.angle * (1 - light.penumbra));
                        break;
                    }
                }
                if (light.castShadows) {
                    lightArray[index++] = 1;
                    lightArray[index++] = -light.shadowBias; // Left-hand.
                    lightArray[index++] = light.shadowRadius;
                    lightArray[index++] = light.shadowSize;
                    lightArray[index++] = light.shadowSize;
                    switch (light.constructor) {
                        case egret3d.DirectionalLight:
                            this.directShadowMatrix.set(light.shadowMatrix.rawData, directLightIndex * 16);
                            this.directShadowMaps[directLightIndex++] = light.renderTarget.texture;
                            break;
                        case egret3d.PointLight:
                            lightArray[index++] = light.shadowCameraNear;
                            lightArray[index++] = light.shadowCameraFar;
                            this.pointShadowMatrix.set(light.shadowMatrix.rawData, pointLightIndex * 16);
                            this.pointShadowMaps[pointLightIndex++] = light.renderTarget.texture;
                            break;
                        case egret3d.SpotLight:
                            this.spotShadowMatrix.set(light.shadowMatrix.rawData, spotLightIndex * 16);
                            this.spotShadowMaps[spotLightIndex++] = light.renderTarget.texture;
                            break;
                    }
                }
                else {
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    switch (light.constructor) {
                        case egret3d.DirectionalLight:
                            this.directShadowMaps[directLightIndex++] = null;
                            break;
                        case egret3d.PointLight:
                            lightArray[index++] = 0;
                            lightArray[index++] = 0;
                            this.pointShadowMaps[pointLightIndex++] = null;
                            break;
                        case egret3d.SpotLight:
                            this.spotShadowMaps[spotLightIndex++] = null;
                            break;
                    }
                }
            }
        };
        RenderContext.prototype.updateLightDepth = function (light) {
            var position = light.gameObject.transform.getPosition();
            //
            this.lightPosition[0] = position.x;
            this.lightPosition[1] = position.y;
            this.lightPosition[2] = position.z;
            //
            this.lightShadowCameraNear = light.shadowCameraNear;
            this.lightShadowCameraFar = light.shadowCameraFar;
        };
        RenderContext.prototype.update = function (drawCall) {
            var renderer = drawCall.renderer;
            // const scene = renderer.gameObject.scene;
            var scene = paper.Scene.activeScene;
            var matrix = drawCall.matrix || renderer.gameObject.transform.worldMatrix;
            this.drawCall = drawCall;
            this.matrix_m.copy(matrix); // clone matrix because getWorldMatrix returns a reference
            this.matrix_mv.multiply(this.matrix_v, this.matrix_m);
            this.matrix_mvp.multiply(this.matrix_vp, this.matrix_m);
            this.matrix_mv_inverse.getNormalMatrix(this.matrix_mv);
            //
            this.shaderContextDefine = "";
            if (renderer.lightmapIndex >= 0 &&
                scene.lightmaps.length > renderer.lightmapIndex) {
                this.lightmap = scene.lightmaps[renderer.lightmapIndex];
                this.lightmapUV = drawCall.mesh.glTFMesh.primitives[drawCall.subMeshIndex].attributes.TEXCOORD_1 ? 1 : 0;
                this.lightmapIntensity = scene.lightmapIntensity;
                this.shaderContextDefine += "#define USE_LIGHTMAP \n";
            }
            if (this.lightCount > 0) {
                if (this.directLightCount > 0) {
                    this.shaderContextDefine += "#define NUM_DIR_LIGHTS " + this.directLightCount + "\n";
                }
                if (this.pointLightCount > 0) {
                    this.shaderContextDefine += "#define NUM_POINT_LIGHTS " + this.pointLightCount + "\n";
                }
                if (this.spotLightCount > 0) {
                    this.shaderContextDefine += "#define NUM_SPOT_LIGHTS " + this.spotLightCount + "\n";
                }
                if (renderer.receiveShadows) {
                    this.shaderContextDefine += "#define USE_SHADOWMAP \n";
                    this.shaderContextDefine += "#define SHADOWMAP_TYPE_PCF \n";
                }
            }
            var fog = scene.fog;
            if (fog.mode !== 0 /* NONE */) {
                this.fogColor[0] = fog.color.r;
                this.fogColor[1] = fog.color.g;
                this.fogColor[2] = fog.color.b;
                this.shaderContextDefine += "#define USE_FOG \n";
                if (fog.mode === 2 /* FOG_EXP2 */) {
                    this.fogDensity = fog.density;
                    this.shaderContextDefine += "#define FOG_EXP2 \n";
                }
                else {
                    this.fogNear = fog.near;
                    this.fogFar = fog.far;
                }
            }
            if (renderer.constructor === egret3d.SkinnedMeshRenderer && !renderer.forceCPUSkin) {
                this.shaderContextDefine += "#define USE_SKINNING \n" + ("#define MAX_BONES " + Math.min(egret3d.SkinnedMeshRendererSystem.maxBoneCount, renderer.bones.length) + " \n");
            }
        };
        return RenderContext;
    }());
    egret3d.RenderContext = RenderContext;
    __reflect(RenderContext.prototype, "egret3d.RenderContext");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 可以添加egret2d显示对象（包括EUI）进行渲染。
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Egret2DRenderer = (function (_super) {
        __extends(Egret2DRenderer, _super);
        function Egret2DRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._order = -1;
            /**
             * TODO
             */
            _this.frustumCulled = false;
            _this._screenAdapter = new egret3d.ConstantAdapter();
            _this._stageWidth = 0;
            _this._stageHeight = 0;
            _this._scaler = 1;
            return _this;
        }
        Object.defineProperty(Egret2DRenderer.prototype, "screenAdapter", {
            get: function () {
                return this._screenAdapter;
            },
            set: function (adapter) {
                adapter.$dirty = true;
                this._screenAdapter = adapter;
            },
            enumerable: true,
            configurable: true
        });
        Egret2DRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.stage = new egret.Stage();
            this.stage.maxTouches = 98;
            this.root = new egret.DisplayObjectContainer();
            this.stage.addChild(this.root);
            if (!this._renderer) {
                this._renderer = egret.web.Renderer.getInstance(egret3d.WebGLCapabilities.webgl);
            }
            var stage = this.stage;
            var displayList = new egret.sys.DisplayList(stage);
            displayList.renderBuffer = new egret.sys.RenderBuffer(undefined, undefined, true);
            stage.$displayList = displayList;
            // TODO
            var webInput = paper.Application.systemManager.getSystem(egret3d.Egret2DRendererSystem).webInput;
            if (webInput) {
                egret.web.$cacheTextAdapter(webInput, stage, egret3d.WebGLCapabilities.canvas.parentNode, egret3d.WebGLCapabilities.canvas);
            }
        };
        Egret2DRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this.stage.removeChild(this.root);
        };
        Egret2DRenderer.prototype.recalculateAABB = function () {
            // TODO
        };
        Egret2DRenderer.prototype.raycast = function (p1, p2, p3) {
            // TODO
            return false;
        };
        /**
         * screen position to ui position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 从屏幕坐标转换到当前2D系统的坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Egret2DRenderer.prototype.screenPosToUIPos = function (pos, out) {
            if (out === void 0) { out = new egret3d.Vector2(); }
            out.x = pos.x / this._scaler;
            out.y = pos.y / this._scaler;
            return out;
        };
        Object.defineProperty(Egret2DRenderer.prototype, "scaler", {
            /**
             * 从屏幕坐标到当前2D系统的坐标的缩放系数
             */
            get: function () {
                return this._scaler;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        Egret2DRenderer.prototype.update = function (deltaTime, w, h) {
            this._order = -1;
            var stage2d = this.stage;
            if (this._stageWidth !== w || this._stageHeight !== h || this.screenAdapter.$dirty) {
                var result = { w: 0, h: 0, s: 0 };
                this.screenAdapter.calculateScaler(w, h, result);
                this.screenAdapter.$dirty = false;
                // this._scaler = this.root.scaleX = this.root.scaleY = result.s;
                stage2d.$displayList["offsetMatrix"].a = result.s;
                stage2d.$displayList["offsetMatrix"].d = result.s;
                this._scaler = result.s;
                var stageWidth = result.w;
                var stageHeight = result.h;
                stage2d.$stageWidth = stageWidth;
                stage2d.$stageHeight = stageHeight;
                // stage.$displayList.setClipRect(screenWidth, screenHeight);
                stage2d.pushResize(w, h);
                stage2d.dispatchEventWith(egret.Event.RESIZE);
                this._stageWidth = w;
                this._stageHeight = h;
            }
            // // clear catched events
            // this._catchedEvent = {};
        };
        /**
         * @internal
         */
        Egret2DRenderer.prototype._draw = function () {
            this._renderer.beforeRender();
            this.stage.drawToSurface();
        };
        return Egret2DRenderer;
    }(paper.BaseRenderer));
    egret3d.Egret2DRenderer = Egret2DRenderer;
    __reflect(Egret2DRenderer.prototype, "egret3d.Egret2DRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Egret 传统 2D 渲染系统。
     */
    var Egret2DRendererSystem = (function (_super) {
        __extends(Egret2DRendererSystem, _super);
        function Egret2DRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: egret3d.Egret2DRenderer }
            ];
            /**
             * TODO
             * @internal
             */
            _this.webInput = egret.Capabilities.runtimeType === egret.RuntimeType.WEB ? new egret["web"].HTMLInput() : null;
            _this._sortedDirty = false;
            _this._sortedRenderers = [];
            return _this;
        }
        Egret2DRendererSystem.prototype._onSortRenderers = function (a, b) {
            return a._order - b._order;
        };
        Egret2DRendererSystem.prototype._sortRenderers = function () {
            if (this._sortedDirty) {
                this._sortedRenderers.sort(this._onSortRenderers);
                this._sortedDirty = false;
            }
            return this._sortedRenderers;
        };
        Egret2DRendererSystem.prototype._onTouchStart = function (pointer, signal) {
            if (paper.Application.playerMode !== 0 /* Player */) {
                return;
            }
            for (var _i = 0, _a = this._sortRenderers(); _i < _a.length; _i++) {
                var renderer = _a[_i];
                var event_1 = pointer.event;
                var scaler = renderer.scaler;
                if (renderer.stage.$onTouchBegin(pointer.position.x / scaler, pointer.position.y / scaler, event_1.pointerId)) {
                    break;
                }
            }
        };
        Egret2DRendererSystem.prototype._onTouchMove = function (pointer, signal) {
            if (paper.Application.playerMode !== 0 /* Player */) {
                return;
            }
            for (var _i = 0, _a = this._sortRenderers(); _i < _a.length; _i++) {
                var renderer = _a[_i];
                var event_2 = pointer.event;
                var scaler = renderer.scaler;
                if (renderer.stage.$onTouchMove(pointer.position.x / scaler, pointer.position.y / scaler, event_2.pointerId)) {
                    break;
                }
            }
        };
        Egret2DRendererSystem.prototype._onTouchEnd = function (pointer, signal) {
            if (paper.Application.playerMode !== 0 /* Player */) {
                return;
            }
            for (var _i = 0, _a = this._sortRenderers(); _i < _a.length; _i++) {
                var renderer = _a[_i];
                var event_3 = pointer.event;
                var scaler = renderer.scaler;
                if (renderer.stage.$onTouchEnd(pointer.position.x / scaler, pointer.position.y / scaler, event_3.pointerId)) {
                    break;
                }
            }
        };
        Egret2DRendererSystem.prototype.onAwake = function (config) {
            var webInput = this.webInput;
            if (webInput) {
                var canvas = config.canvas;
                webInput._initStageDelegateDiv(canvas.parentNode, canvas);
                webInput.$updateSize();
            }
        };
        Egret2DRendererSystem.prototype.onEnable = function () {
            egret3d.inputCollecter.onPointerDown.add(this._onTouchStart, this);
            egret3d.inputCollecter.onPointerCancel.add(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerUp.add(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerMove.add(this._onTouchMove, this);
        };
        Egret2DRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._sortedDirty = true;
            this._sortedRenderers.push(gameObject.renderer);
        };
        Egret2DRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            var index = this._sortedRenderers.indexOf(gameObject.renderer);
            if (index >= 0) {
                this._sortedRenderers.splice(index, 1);
            }
        };
        Egret2DRendererSystem.prototype.onUpdate = function (deltaTime) {
            var _a = egret3d.stage.viewport, w = _a.w, h = _a.h;
            for (var _i = 0, _b = this._groups[0].gameObjects; _i < _b.length; _i++) {
                var gameObject = _b[_i];
                gameObject.renderer.update(deltaTime, w, h);
            }
        };
        Egret2DRendererSystem.prototype.onDisable = function () {
            egret3d.inputCollecter.onPointerDown.remove(this._onTouchStart, this);
            egret3d.inputCollecter.onPointerCancel.remove(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerUp.remove(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerMove.remove(this._onTouchMove, this);
        };
        return Egret2DRendererSystem;
    }(paper.BaseSystem));
    egret3d.Egret2DRendererSystem = Egret2DRendererSystem;
    __reflect(Egret2DRendererSystem.prototype, "egret3d.Egret2DRendererSystem");
})(egret3d || (egret3d = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var egret;
(function (egret) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var Renderer = (function () {
            function Renderer(context) {
                this.context = context;
                var egretWebGLRenderContext = this.egretWebGLRenderContext = egret.web.WebGLRenderContext.getInstance(0, 0);
                egretWebGLRenderContext.setContext(context);
                this.drawCmdManager = egretWebGLRenderContext.drawCmdManager;
                this.vao = egretWebGLRenderContext.vao;
                // egretWebGLRenderContext.drawFunc = this.$drawWebGL.bind(this);
                egretWebGLRenderContext.$drawWebGL = this.$drawWebGL.bind(this);
                egret.sys.RenderBuffer = egret.web.WebGLRenderBuffer;
                egret.sys.systemRenderer = new egret.web.WebGLRenderer();
                egret.sys.canvasRenderer = new egret.CanvasRenderer();
                egret.sys.customHitTestBuffer = new egret.web.WebGLRenderBuffer(3, 3);
                egret.sys.canvasHitTestBuffer = new egret.web.CanvasRenderBuffer(3, 3);
                egret.Capabilities['$renderMode'] = "webgl";
                this.vertexBuffer = context.createBuffer();
                this.indexBuffer = context.createBuffer();
                // app.addEventListener("beforeRender", function() {
                //     egret.ticker.update();
                // }, this);
            }
            Renderer.getInstance = function (context) {
                if (!this._instance) {
                    this._instance = new Renderer(context);
                }
                return this._instance;
            };
            Renderer.prototype.beforeRender = function () {
                var gl = this.context;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.disable(gl.STENCIL_TEST);
                gl.colorMask(true, true, true, true);
                this.setBlendMode("source-over");
                // 目前只使用0号材质单元，默认开启
                gl.activeTexture(gl.TEXTURE0);
                this.currentProgram = null;
            };
            Renderer.prototype.$drawWebGL = function () {
                if (this.drawCmdManager.drawDataLen == 0) {
                    return;
                }
                this.uploadVerticesArray(this.vao.getVertices());
                // 有mesh，则使用indicesForMesh
                if (this.vao.isMesh()) {
                    this.uploadIndicesArray(this.vao.getMeshIndices());
                }
                var length = this.drawCmdManager.drawDataLen;
                var offset = 0;
                for (var i = 0; i < length; i++) {
                    var data = this.drawCmdManager.drawData[i];
                    if (!data) {
                        continue;
                    }
                    offset = this.drawData(data, offset);
                    // 计算draw call
                    if (data.type == 6 /* ACT_BUFFER */) {
                        this._activatedBuffer = data.buffer;
                        this.egretWebGLRenderContext.activatedBuffer = data.buffer;
                    }
                    if (data.type == 0 /* TEXTURE */ || data.type == 1 /* PUSH_MASK */ || data.type == 2 /* POP_MASK */) {
                        if (this._activatedBuffer && this._activatedBuffer.$computeDrawCall) {
                            this._activatedBuffer.$drawCalls++;
                        }
                    }
                }
                // 切换回默认indices
                if (this.vao.isMesh()) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                // 清空数据
                this.drawCmdManager.clear();
                this.vao.clear();
            };
            /**
             * 执行绘制命令
             */
            Renderer.prototype.drawData = function (data, offset) {
                if (!data) {
                    return;
                }
                var gl = this.context;
                var program;
                var filter = data.filter;
                switch (data.type) {
                    case 0 /* TEXTURE */:
                        if (filter) {
                            if (filter.type === "custom") {
                                program = web.EgretWebGLProgram.getProgram(gl, filter.$vertexSrc, filter.$fragmentSrc, filter.$shaderKey);
                            }
                            else if (filter.type === "colorTransform") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.colorTransform_frag, "colorTransform");
                            }
                            else if (filter.type === "blurX") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "blurY") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "glow") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.glow_frag, "glow");
                            }
                        }
                        else {
                            program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.texture_frag, "texture");
                        }
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawTextureElements(data, offset);
                        break;
                    case 1 /* PUSH_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawPushMaskElements(data, offset);
                        break;
                    case 2 /* POP_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawPopMaskElements(data, offset);
                        break;
                    case 3 /* BLEND */:
                        this.setBlendMode(data.value);
                        break;
                    case 4 /* RESIZE_TARGET */:
                        data.buffer.rootRenderTarget.resize(data.width, data.height);
                        this.onResize(data.width, data.height);
                        break;
                    case 5 /* CLEAR_COLOR */:
                        if (this._activatedBuffer) {
                            var target = this._activatedBuffer.rootRenderTarget;
                            if (target.width != 0 || target.height != 0) {
                                target.clear(true);
                            }
                        }
                        break;
                    case 6 /* ACT_BUFFER */:
                        this.activateBuffer(data.buffer, data.width, data.height);
                        break;
                    case 7 /* ENABLE_SCISSOR */:
                        var buffer = this._activatedBuffer;
                        if (buffer) {
                            if (buffer.rootRenderTarget) {
                                buffer.rootRenderTarget.enabledStencil();
                            }
                            buffer.enableScissor(data.x, data.y, data.width, data.height);
                        }
                        break;
                    case 8 /* DISABLE_SCISSOR */:
                        buffer = this._activatedBuffer;
                        if (buffer) {
                            buffer.disableScissor();
                        }
                        break;
                    default:
                        break;
                }
                return offset;
            };
            Renderer.prototype.activeProgram = function (gl, program) {
                if (program != this.currentProgram) {
                    gl.useProgram(program.id);
                    // 目前所有attribute buffer的绑定方法都是一致的
                    var attribute = program.attributes;
                    for (var key in attribute) {
                        if (key === "aVertexPosition") {
                            gl.vertexAttribPointer(attribute["aVertexPosition"].location, 2, gl.FLOAT, false, 4 * 4, 0);
                            gl.enableVertexAttribArray(attribute["aVertexPosition"].location);
                        }
                        else if (key === "aTextureCoord") {
                            gl.vertexAttribPointer(attribute["aTextureCoord"].location, 2, gl.UNSIGNED_SHORT, true, 4 * 4, 2 * 4);
                            gl.enableVertexAttribArray(attribute["aTextureCoord"].location);
                        }
                        else if (key === "aColor") {
                            gl.vertexAttribPointer(attribute["aColor"].location, 1, gl.FLOAT, false, 4 * 4, 3 * 4);
                            gl.enableVertexAttribArray(attribute["aColor"].location);
                        }
                        else if (key === "aParticlePosition") {
                            gl.vertexAttribPointer(attribute["aParticlePosition"].location, 2, gl.FLOAT, false, 22 * 4, 0);
                            gl.enableVertexAttribArray(attribute["aParticlePosition"].location);
                        }
                        else if (key === "aParticleTextureCoord") {
                            gl.vertexAttribPointer(attribute["aParticleTextureCoord"].location, 2, gl.FLOAT, false, 22 * 4, 2 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleTextureCoord"].location);
                        }
                        else if (key === "aParticleScale") {
                            gl.vertexAttribPointer(attribute["aParticleScale"].location, 2, gl.FLOAT, false, 22 * 4, 4 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleScale"].location);
                        }
                        else if (key === "aParticleRotation") {
                            gl.vertexAttribPointer(attribute["aParticleRotation"].location, 2, gl.FLOAT, false, 22 * 4, 6 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleRotation"].location);
                        }
                        else if (key === "aParticleRed") {
                            gl.vertexAttribPointer(attribute["aParticleRed"].location, 2, gl.FLOAT, false, 22 * 4, 8 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleRed"].location);
                        }
                        else if (key === "aParticleGreen") {
                            gl.vertexAttribPointer(attribute["aParticleGreen"].location, 2, gl.FLOAT, false, 22 * 4, 10 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleGreen"].location);
                        }
                        else if (key === "aParticleBlue") {
                            gl.vertexAttribPointer(attribute["aParticleBlue"].location, 2, gl.FLOAT, false, 22 * 4, 12 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleBlue"].location);
                        }
                        else if (key === "aParticleAlpha") {
                            gl.vertexAttribPointer(attribute["aParticleAlpha"].location, 2, gl.FLOAT, false, 22 * 4, 14 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleAlpha"].location);
                        }
                        else if (key === "aParticleEmitRotation") {
                            gl.vertexAttribPointer(attribute["aParticleEmitRotation"].location, 2, gl.FLOAT, false, 22 * 4, 16 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleEmitRotation"].location);
                        }
                        else if (key === "aParticleEmitRadius") {
                            gl.vertexAttribPointer(attribute["aParticleEmitRadius"].location, 2, gl.FLOAT, false, 22 * 4, 18 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleEmitRadius"].location);
                        }
                        else if (key === "aParticleTime") {
                            gl.vertexAttribPointer(attribute["aParticleTime"].location, 2, gl.FLOAT, false, 22 * 4, 20 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleTime"].location);
                        }
                        //===== particle end =====
                    }
                    this.currentProgram = program;
                }
            };
            Renderer.prototype.syncUniforms = function (program, filter, data) {
                var uniforms = program.uniforms;
                for (var key in uniforms) {
                    if (key === "projectionVector") {
                        uniforms[key].setValue({ x: this.projectionX, y: this.projectionY });
                    }
                    else if (key === "uTextureSize") {
                        uniforms[key].setValue({ x: data.textureWidth, y: data.textureHeight });
                    }
                    else if (key === "uSampler") {
                    }
                    else if (key === "uGlobalMatrix") {
                        uniforms[key].setValue([data.a, data.c, data.tx, data.b, data.d, data.ty, 0, 0, 1]);
                    }
                    else if (key === "uGlobalAlpha") {
                        uniforms[key].setValue(data.alpha);
                    }
                    else {
                        var value = filter.$uniforms[key];
                        if (value !== undefined) {
                            uniforms[key].setValue(value);
                        }
                        else {
                            // egret.warn("filter custom: uniform " + key + " not defined!");
                        }
                    }
                }
            };
            /**
             * 画texture
             **/
            Renderer.prototype.drawTextureElements = function (data, offset) {
                var gl = this.context;
                if (data.texture.isCanvas) {
                    gl.wxBindCanvasTexture(gl.TEXTURE_2D, data.texture);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, data.texture);
                }
                var size = data.count * 3;
                gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                return size;
            };
            /**
             * 启用RenderBuffer
             */
            Renderer.prototype.activateBuffer = function (buffer, width, height) {
                buffer.rootRenderTarget.activate();
                if (!this.bindIndices) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                buffer.restoreStencil();
                buffer.restoreScissor();
                this.onResize(width, height);
            };
            Renderer.prototype.onResize = function (width, height) {
                this.projectionX = width / 2;
                this.projectionY = -height / 2;
                if (this.context) {
                    this.context.viewport(0, 0, width, height);
                }
            };
            /**
             * 上传顶点数据
             */
            Renderer.prototype.uploadVerticesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ARRAY_BUFFER, array, gl.STREAM_DRAW);
            };
            /**
             * 上传索引数据
             */
            Renderer.prototype.uploadIndicesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
                this.bindIndices = true;
            };
            /**
             * 画push mask
             **/
            Renderer.prototype.drawPushMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this._activatedBuffer;
                if (buffer) {
                    if (buffer.rootRenderTarget) {
                        buffer.rootRenderTarget.enabledStencil();
                    }
                    if (buffer.stencilHandleCount == 0) {
                        buffer.enableStencil();
                        gl.clear(gl.STENCIL_BUFFER_BIT); // clear
                    }
                    var level = buffer.stencilHandleCount;
                    buffer.stencilHandleCount++;
                    gl.colorMask(false, false, false, false);
                    gl.stencilFunc(gl.EQUAL, level, 0xFF);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                    // gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                    gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                    gl.colorMask(true, true, true, true);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                }
                return size;
            };
            /**
             * 画pop mask
             **/
            Renderer.prototype.drawPopMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this._activatedBuffer;
                if (buffer) {
                    buffer.stencilHandleCount--;
                    if (buffer.stencilHandleCount == 0) {
                        buffer.disableStencil(); // skip this draw
                    }
                    else {
                        var level = buffer.stencilHandleCount;
                        gl.colorMask(false, false, false, false);
                        gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                        // gl.bindTexture(gl.TEXTURE_2D, null);
                        gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                        gl.stencilFunc(gl.EQUAL, level, 0xFF);
                        gl.colorMask(true, true, true, true);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                    }
                }
                return size;
            };
            /**
             * 设置混色
             */
            Renderer.prototype.setBlendMode = function (value) {
                var gl = this.context;
                var blendModeWebGL = Renderer.blendModesForGL[value];
                if (blendModeWebGL) {
                    gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
                }
            };
            Renderer.initBlendMode = function () {
                Renderer.blendModesForGL = {};
                Renderer.blendModesForGL["source-over"] = [1, 771];
                Renderer.blendModesForGL["lighter"] = [1, 1];
                Renderer.blendModesForGL["lighter-in"] = [770, 771];
                Renderer.blendModesForGL["destination-out"] = [0, 771];
                Renderer.blendModesForGL["destination-in"] = [0, 770];
            };
            Renderer.blendModesForGL = null;
            return Renderer;
        }());
        web.Renderer = Renderer;
        __reflect(Renderer.prototype, "egret.web.Renderer");
        Renderer.initBlendMode();
    })(web = egret.web || (egret.web = {}));
})(egret || (egret = {}));
var egret3d;
(function (egret3d) {
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 恒定像素的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ConstantAdapter = (function () {
        function ConstantAdapter() {
            this.$dirty = true;
            this._scaleFactor = 1;
        }
        Object.defineProperty(ConstantAdapter.prototype, "scaleFactor", {
            /**
             * scaleFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置缩放值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._scaleFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        ConstantAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler = this._scaleFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ConstantAdapter;
    }());
    egret3d.ConstantAdapter = ConstantAdapter;
    __reflect(ConstantAdapter.prototype, "egret3d.ConstantAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 拉伸扩展的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ExpandAdapter = (function () {
        function ExpandAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ExpandAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ExpandAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasHeight / this._resolution.y;
            }
            else {
                scaler = canvasWidth / this._resolution.x;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ExpandAdapter;
    }());
    egret3d.ExpandAdapter = ExpandAdapter;
    __reflect(ExpandAdapter.prototype, "egret3d.ExpandAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ShrinkAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 缩放的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ShrinkAdapter = (function () {
        function ShrinkAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ShrinkAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ShrinkAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasWidth / this._resolution.x;
            }
            else {
                scaler = canvasHeight / this._resolution.y;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ShrinkAdapter;
    }());
    egret3d.ShrinkAdapter = ShrinkAdapter;
    __reflect(ShrinkAdapter.prototype, "egret3d.ShrinkAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * MatchWidthOrHeightAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 适应宽高适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MatchWidthOrHeightAdapter = (function () {
        function MatchWidthOrHeightAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
            this._matchFactor = 0; // width : height
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MatchWidthOrHeightAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        Object.defineProperty(MatchWidthOrHeightAdapter.prototype, "matchFactor", {
            /**
             * matchFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置匹配系数，0-1之间，越小越倾向以宽度适配，越大越倾向以高度适配。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._matchFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        MatchWidthOrHeightAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler1 = canvasWidth / this._resolution.x;
            var scaler2 = canvasHeight / this._resolution.y;
            var scaler = scaler1 + (scaler2 - scaler1) * this._matchFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return MatchWidthOrHeightAdapter;
    }());
    egret3d.MatchWidthOrHeightAdapter = MatchWidthOrHeightAdapter;
    __reflect(MatchWidthOrHeightAdapter.prototype, "egret3d.MatchWidthOrHeightAdapter", ["egret3d.IScreenAdapter"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 实体。
     */
    var GameObject = (function (_super) {
        __extends(GameObject, _super);
        /**
         * 请使用 `paper.GameObject.create()` 创建实例。
         * @see paper.GameObject.create()
         * @deprecated
         */
        function GameObject(name, tag, scene) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (tag === void 0) { tag = "" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var _this = _super.call(this) || this;
            /**
             * 是否是静态模式。
             */
            _this.isStatic = false;
            /**
             *
             */
            _this.hideFlags = 0 /* None */;
            /**
             * 层级。
             * - 用于各种层遮罩。
             */
            _this.layer = 2 /* Default */;
            /**
             * 名称。
             */
            _this.name = "";
            /**
             * 标签。
             */
            _this.tag = "";
            /**
             * 变换组件。
             * @readonly
             */
            _this.transform = null;
            /**
             * 渲染组件。
             * @readonly
             */
            _this.renderer = null;
            /**
             * 额外数据，仅保存在编辑器环境，项目发布该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            _this._activeSelf = true;
            /**
             * @internal
             */
            _this._activeInHierarchy = true;
            /**
             * @internal
             */
            _this._activeDirty = true;
            _this._components = [];
            _this._cachedComponents = [];
            _this._scene = null;
            _this.name = name;
            _this.tag = tag;
            //
            _this._addToScene(scene || paper.Application.sceneManager.activeScene);
            //
            _this.addComponent(egret3d.Transform);
            return _this;
        }
        /**
         * 创建 GameObject，并添加到当前场景中。
         */
        GameObject.create = function (name, tag, scene) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (tag === void 0) { tag = "" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var gameObect;
            // if (this._instances.length > 0) {
            //     gameObect = this._instances.pop()!;
            //     gameObect.name = name;
            //     gameObect.tag = tag;
            //     gameObect._addToScene(scene);
            //     gameObect.addComponent(egret3d.Transform);
            // }
            // else {
            gameObect = new GameObject(name, tag, scene);
            // gameObect = new GameObject();
            // }
            // gameObect.name = name;
            // gameObect.tag = tag;
            // gameObect._addToScene(Application.sceneManager.activeScene);
            // gameObect.addComponent(egret3d.Transform);
            return gameObect;
        };
        GameObject._sortRaycastInfo = function (a, b) {
            // TODO renderQueue.
            return a.distance - b.distance;
        };
        /**
         * @deprecated
         */
        GameObject.raycast = function (ray, gameObjects, maxDistance, cullingMask, raycastMesh) {
            if (maxDistance === void 0) { maxDistance = 0.0; }
            if (cullingMask === void 0) { cullingMask = 16777215 /* Everything */; }
            if (raycastMesh === void 0) { raycastMesh = false; }
            return egret3d.raycastAll(ray, gameObjects, maxDistance, cullingMask, raycastMesh);
        };
        Object.defineProperty(GameObject, "globalGameObject", {
            /**
             * 全局实体。
             * - 全局实体不可被销毁。
             * - 静态组件都会添加到全局实体上。
             */
            get: function () {
                if (!this._globalGameObject) {
                    this._globalGameObject = GameObject.create("Global" /* Global */, "Global" /* Global */, paper.Application.sceneManager.globalScene);
                    this._globalGameObject.dontDestroy = true;
                }
                return this._globalGameObject;
            },
            enumerable: true,
            configurable: true
        });
        GameObject.prototype._destroy = function () {
            this._scene.removeGameObject(this);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child.gameObject._destroy();
            }
            for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                var component = _c[_b];
                if (!component) {
                    continue;
                }
                this._removeComponent(component, null);
            }
            // 销毁的第一时间就将组件和场景清除，场景的有无来判断实体是否已经销毁。
            this._components.length = 0;
            this._scene = null;
            paper.disposeCollecter.gameObjects.push(this);
        };
        GameObject.prototype._addToScene = function (value) {
            if (this._scene) {
                this._scene.removeGameObject(this);
            }
            this._scene = value;
            this._scene.addGameObject(this);
        };
        GameObject.prototype._canRemoveComponent = function (value) {
            if (value === this.transform) {
                console.warn("Cannot remove the transform component from a game object.");
                return false;
            }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    component = component.components[0]; // 只检查第一个。
                }
                var requireComponents = component.constructor.requireComponents;
                if (requireComponents && requireComponents.indexOf(value.constructor) >= 0) {
                    console.warn("Cannot remove the " + egret.getQualifiedClassName(value) + " component from the game object (" + this.path + "), because it is required from the " + egret.getQualifiedClassName(component) + " component.");
                    return false;
                }
            }
            return true;
        };
        GameObject.prototype._removeComponent = function (value, groupComponent) {
            value.enabled = false;
            value.gameObject = null;
            if (value === this.renderer) {
                this.renderer = null;
            }
            paper.disposeCollecter.components.push(value);
            if (groupComponent) {
                groupComponent.removeComponent(value);
                if (groupComponent.components.length === 0) {
                    this._removeComponent(groupComponent, null);
                }
            }
            else if (value.constructor === paper.GroupComponent) {
                groupComponent = value;
                delete this._components[groupComponent.componentIndex];
                for (var _i = 0, _a = groupComponent.components; _i < _a.length; _i++) {
                    var componentInGroup = _a[_i];
                    this._removeComponent(componentInGroup, groupComponent);
                }
            }
            else {
                delete this._components[value.constructor.__index];
            }
        };
        GameObject.prototype._getComponent = function (componentClass) {
            var componentIndex = componentClass.__index;
            return componentIndex < 0 ? null : this._components[componentIndex];
        };
        /**
         * @internal
         */
        GameObject.prototype._activeInHierarchyDirty = function (prevActive) {
            this._activeDirty = true;
            var currentActive = this.activeInHierarchy;
            if (currentActive !== prevActive) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    var componentClass = component.constructor;
                    if (component.enabled) {
                        component._dispatchEnabledEvent(currentActive);
                    }
                    if (component.constructor === paper.GroupComponent) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            if (componentInGroup.enabled) {
                                componentInGroup._dispatchEnabledEvent(currentActive);
                            }
                        }
                    }
                }
            }
            for (var _d = 0, _e = this.transform.children; _d < _e.length; _d++) {
                var child = _e[_d];
                child.gameObject._activeInHierarchyDirty(prevActive);
            }
        };
        /**
         * 实体被销毁后，内部卸载。
         * @internal
         */
        GameObject.prototype.uninitialize = function () {
            this.isStatic = false;
            this.hideFlags = 0 /* None */;
            this.layer = 2 /* Default */;
            this.name = "";
            this.tag = "";
            this.transform = null;
            this.renderer = null;
            if (this.extras) {
                this.extras = {};
            }
            this._activeSelf = true;
            this._activeInHierarchy = true;
            this._activeDirty = true;
            this._cachedComponents.length = 0;
            this._scene = null;
        };
        /**
         * 销毁实体。
         */
        GameObject.prototype.destroy = function () {
            if (this.isDestroyed) {
                console.warn("The game object has been destroyed.");
                return false;
            }
            if (this === GameObject._globalGameObject) {
                console.warn("Cannot destroy global game object.");
                return false;
            }
            var parent = this.transform.parent;
            if (parent) {
                parent._children.splice(parent._children.indexOf(this.transform), 1);
            }
            this._destroy();
            return true;
        };
        /**
         * 添加一个指定组件实例。
         * @param componentClass 组件类。
         * @param config BaseComponent 组件 `initialize(config?: any)` 方法或 Behaviour 组件 `onAwake(config?: any)` 方法的可选参数。
         */
        GameObject.prototype.addComponent = function (componentClass, config) {
            paper.registerClass(componentClass);
            // SingletonComponent.
            if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                return GameObject.globalGameObject.getOrAddComponent(componentClass, config);
            }
            var componentIndex = componentClass.__index;
            var existedComponent = this._components[componentIndex];
            // disallowMultipleComponents.
            if (!componentClass.allowMultiple && existedComponent) {
                console.warn("Cannot add the " + egret.getQualifiedClassName(componentClass) + " component to the game object (" + this.path + ") again.");
                return existedComponent;
            }
            // requireComponents.
            if (componentClass.requireComponents) {
                for (var _i = 0, _a = componentClass.requireComponents; _i < _a.length; _i++) {
                    var requireComponentClass = _a[_i];
                    this.getOrAddComponent(requireComponentClass);
                }
            }
            // Linked reference.
            var component = paper.BaseComponent.create(componentClass, this);
            if (componentClass === egret3d.Transform) {
                this.transform = component;
            }
            else if (component instanceof paper.BaseRenderer) {
                this.renderer = component;
            }
            // Add component.
            if (existedComponent) {
                if (existedComponent.constructor === paper.GroupComponent) {
                    existedComponent.addComponent(component);
                }
                else {
                    paper.registerClass(paper.GroupComponent);
                    var groupComponent = paper.BaseComponent.create(paper.GroupComponent, this);
                    groupComponent.initialize();
                    groupComponent.componentIndex = componentIndex;
                    groupComponent.componentClass = componentClass;
                    groupComponent.addComponent(existedComponent);
                    groupComponent.addComponent(component);
                    this._components[componentIndex] = groupComponent;
                }
            }
            else {
                this._components[componentIndex] = component;
            }
            if (config) {
                component.initialize(config);
            }
            else {
                component.initialize();
            }
            if (component.isActiveAndEnabled) {
                component._dispatchEnabledEvent(true);
            }
            return component;
        };
        /**
         * 移除一个指定组件实例。
         * @param componentInstanceOrClass 组件类或组件实例。
         * @param isExtends 是否尝试移除全部派生自此组件的实例。
         */
        GameObject.prototype.removeComponent = function (componentInstanceOrClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentInstanceOrClass instanceof paper.BaseComponent) {
                var componentClass = componentInstanceOrClass.constructor;
                // SingletonComponent.
                if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                    GameObject.globalGameObject.removeComponent(componentInstanceOrClass, isExtends);
                    return;
                }
                if (!this._canRemoveComponent(componentInstanceOrClass)) {
                    return;
                }
                this._removeComponent(componentInstanceOrClass, null);
            }
            else {
                // SingletonComponent.
                if (componentInstanceOrClass.__isSingleton && this !== GameObject._globalGameObject) {
                    return GameObject.globalGameObject.removeComponent(componentInstanceOrClass, isExtends);
                }
                if (isExtends) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (!component) {
                            continue;
                        }
                        var groupComponent = null;
                        if (component.constructor === paper.GroupComponent) {
                            groupComponent = component;
                            component = groupComponent.components[0];
                        }
                        if (groupComponent) {
                            if (!(groupComponent.components[0] instanceof componentInstanceOrClass) ||
                                (groupComponent.components.length === 1 && !this._canRemoveComponent(groupComponent.components[0]))) {
                                continue;
                            }
                        }
                        else if (!(component instanceof componentInstanceOrClass) ||
                            !this._canRemoveComponent(component)) {
                            continue;
                        }
                        this._removeComponent(component, groupComponent);
                    }
                }
                else {
                    var component = this._getComponent(componentInstanceOrClass);
                    if (!component) {
                        return;
                    }
                    var groupComponent = null;
                    if (component.constructor === paper.GroupComponent) {
                        groupComponent = component;
                        component = groupComponent.components[0];
                    }
                    if (groupComponent) {
                        if (groupComponent.components.length === 1 && !this._canRemoveComponent(groupComponent.components[0])) {
                            return;
                        }
                    }
                    else if (!this._canRemoveComponent(component)) {
                        return;
                    }
                    this._removeComponent(component, groupComponent);
                }
            }
        };
        /**
         * 移除全部指定组件的实例。
         * - 通常只有该组件类允许同一个实体添加多个组件实例时才需要此操作。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试移除全部派生自此组件的实例。
         */
        GameObject.prototype.removeAllComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentClass) {
                // SingletonComponent.
                if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                    GameObject.globalGameObject.removeAllComponents(componentClass, isExtends);
                    return;
                }
                if (isExtends) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (!component) {
                            continue;
                        }
                        if (component.constructor === paper.GroupComponent) {
                            var groupComponent = component;
                            if (!(groupComponent.components[0] instanceof componentClass) ||
                                !this._canRemoveComponent(groupComponent.components[0])) {
                                continue;
                            }
                        }
                        else if (!this._canRemoveComponent(component)) {
                            continue;
                        }
                        this._removeComponent(component, null);
                    }
                }
                else {
                    var component = this._getComponent(componentClass);
                    if (!component) {
                        return;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        var groupComponent = component;
                        if (!this._canRemoveComponent(groupComponent.components[0])) {
                            return;
                        }
                    }
                    else if (!this._canRemoveComponent(component)) {
                        return;
                    }
                    this._removeComponent(component, null);
                }
            }
            else {
                for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                    var component = _c[_b];
                    if (!component || component.constructor === egret3d.Transform) {
                        continue;
                    }
                    this._removeComponent(component, null);
                }
            }
        };
        /**
         * 获取一个指定组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            // SingletonComponent.
            if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                return GameObject.globalGameObject.getComponent(componentClass, isExtends);
            }
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component_1 = _a[_i];
                    if (!component_1) {
                        continue;
                    }
                    if (component_1.constructor === paper.GroupComponent) {
                        var groupComponent = component_1;
                        if (groupComponent.components[0] instanceof componentClass) {
                            return groupComponent.components[0];
                        }
                    }
                    else if (component_1 instanceof componentClass) {
                        return component_1;
                    }
                }
                return null;
            }
            var componentClassIndex = componentClass.__index;
            if (componentClassIndex < 0) {
                return null;
            }
            var component = this._components[componentClassIndex];
            if (!component) {
                return null;
            }
            if (component.constructor === paper.GroupComponent) {
                return component.components[0];
            }
            return component;
        };
        /**
         * 获取全部指定组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            // SingletonComponent.
            if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                return GameObject.globalGameObject.getComponents(componentClass, isExtends);
            }
            var components = [];
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            else {
                var component = this._getComponent(componentClass);
                if (component) {
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _d = 0, _e = component.components; _d < _e.length; _d++) {
                            var componentInGroup = _e[_d];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            return components;
        };
        /**
         * 获取一个自己或父级中指定的组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentInParent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var result = null;
            var parent = this.transform.parent;
            while (!result && parent) {
                result = parent.gameObject.getComponent(componentClass, isExtends); // 
                parent = parent.parent;
            }
            return result;
        };
        /**
         * 获取一个自己或子（孙）级中指定的组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentInChildren = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var component = this.getComponent(componentClass, isExtends);
            if (!component) {
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    component = child.gameObject.getComponentInChildren(componentClass, isExtends);
                    if (component) {
                        break;
                    }
                }
            }
            return component;
        };
        /**
         * 获取全部自己和子（孙）级中指定的组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentsInChildren = function (componentClass, isExtends, components) {
            if (isExtends === void 0) { isExtends = false; }
            if (components === void 0) { components = null; }
            components = components || [];
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    var groupComponent = component;
                    if (isExtends ? groupComponent.components[0] instanceof componentClass : groupComponent.componentClass === componentClass) {
                        for (var _b = 0, _c = groupComponent.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                }
                else if (isExtends ? component instanceof componentClass : component.constructor === componentClass) {
                    components.push(component);
                }
            }
            for (var _d = 0, _e = this.transform.children; _d < _e.length; _d++) {
                var child = _e[_d];
                child.gameObject.getComponentsInChildren(componentClass, isExtends, components);
            }
            return components;
        };
        /**
         * 从该实体已注册的全部组件中获取一个指定组件实例，如果未添加该组件，则添加该组件。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         * @param config BaseComponent 组件 `initialize(config?: any)` 方法或 Behaviour 组件 `onAwake(config?: any)` 方法的可选参数。
         */
        GameObject.prototype.getOrAddComponent = function (componentClass, isExtends, config) {
            if (isExtends === void 0) { isExtends = false; }
            return this.getComponent(componentClass, isExtends) || this.addComponent(componentClass, config);
        };
        /**
         * 向该实体已激活的全部 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (component && component.isActiveAndEnabled && component instanceof paper.Behaviour) {
                    if (methodName in component) {
                        component[methodName](parameter);
                    }
                    else if (true && requireReceiver) {
                        console.warn(this.name, egret.getQualifiedClassName(component), methodName); // TODO
                    }
                }
            }
        };
        /**
         * 向该实体和其父级的 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessageUpwards = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            //
            var parent = this.transform.parent;
            if (parent && parent.gameObject.activeInHierarchy) {
                parent.gameObject.sendMessage(methodName, parameter, requireReceiver);
            }
        };
        /**
         * 向该实体和的其子（孙）级的 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.broadcastMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.gameObject.activeInHierarchy) {
                    child.gameObject.broadcastMessage(methodName, parameter, requireReceiver);
                }
            }
        };
        Object.defineProperty(GameObject.prototype, "isDestroyed", {
            /**
             * 该实体是否已经被销毁。
             */
            get: function () {
                return !this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "dontDestroy", {
            /**
             * 该实体是否可以被销毁。
             * - 当此值为 `true` 时，将会被添加到全局场景，反之将被添加到激活场景。
             * - 设置此属性时，可能改变该实体的父级。
             */
            get: function () {
                return this._scene === paper.Application.sceneManager.globalScene;
            },
            set: function (value) {
                if (this.dontDestroy === value) {
                    return;
                }
                if (this.transform.parent && this.transform.parent.gameObject.dontDestroy !== value) {
                    this.transform.parent = null;
                }
                if (value) {
                    this._addToScene(paper.Application.sceneManager.globalScene);
                }
                else {
                    if (this === GameObject._globalGameObject) {
                        console.warn("Cannot change the `dontDestroy` value of the global game object.", this.name, this.uuid);
                        return;
                    }
                    this._addToScene(paper.Application.sceneManager.activeScene);
                }
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child.gameObject.dontDestroy = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeSelf", {
            /**
             * 该实体自身的激活状态。
             */
            get: function () {
                return this._activeSelf;
            },
            set: function (value) {
                if (this._activeSelf === value) {
                    return;
                }
                var parent = this.transform.parent;
                if (!parent || parent.gameObject.activeInHierarchy) {
                    var prevActive = this._activeSelf;
                    this._activeSelf = value;
                    this._activeInHierarchyDirty(prevActive);
                }
                else {
                    this._activeSelf = value; //TODO
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeInHierarchy", {
            /**
             * 该实体在场景中的激活状态。
             */
            get: function () {
                if (this._activeDirty) {
                    var parent_1 = this.transform.parent;
                    if (!parent_1 || parent_1.gameObject.activeInHierarchy) {
                        this._activeInHierarchy = this._activeSelf;
                    }
                    else {
                        this._activeInHierarchy = false;
                    }
                    this._activeDirty = false;
                }
                return this._activeInHierarchy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "path", {
            /**
             * 该实体的路径。
             */
            get: function () {
                var path = this.name;
                if (this.transform) {
                    var parent_2 = this.transform.parent;
                    while (parent_2) {
                        path = parent_2.gameObject.name + "/" + path;
                        parent_2 = parent_2.parent;
                    }
                    return this._scene.name + "/" + path;
                }
                return path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "components", {
            /**
             * 该实体已添加的全部组件。
             */
            get: function () {
                this._cachedComponents.length = 0;
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            this._cachedComponents.push(componentInGroup);
                        }
                    }
                    else {
                        this._cachedComponents.push(component);
                    }
                }
                return this._cachedComponents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "parent", {
            /**
             * 该实体的父级实体。
             */
            get: function () {
                return this.transform.parent ? this.transform.parent.gameObject : null;
            },
            set: function (gameObject) {
                this.transform.parent = gameObject ? gameObject.transform : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "scene", {
            /**
             * 该实体所属的场景。
             */
            get: function () {
                return this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "globalGameObject", {
            /**
             * 全局实体。
             * - 全局实体不可被销毁。
             * - 静态组件都会添加到全局实体上。
             */
            get: function () {
                return GameObject.globalGameObject;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         * @see paper.Scene#find()
         */
        GameObject.find = function (name, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).find(name);
        };
        /**
         * @deprecated
         * @see paper.Scene#findWithTag()
         */
        GameObject.findWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findWithTag(tag);
        };
        /**
         * @deprecated
         * @see paper.Scene#findGameObjectsWithTag()
         */
        GameObject.findGameObjectsWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findGameObjectsWithTag(tag);
        };
        /**
         * @internal
         */
        GameObject._instances = [];
        GameObject._globalGameObject = null;
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], GameObject.prototype, "isStatic", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "hideFlags", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.Layer) })
        ], GameObject.prototype, "layer", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("TEXT" /* TEXT */)
        ], GameObject.prototype, "name", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.DefaultTags) })
        ], GameObject.prototype, "tag", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "_activeSelf", void 0);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], GameObject.prototype, "activeSelf", null);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], GameObject.prototype, "components", null);
        return GameObject;
    }(paper.BaseObject));
    paper.GameObject = GameObject;
    __reflect(GameObject.prototype, "paper.GameObject");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _points = [
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
    ];
    /**
     * 轴对称包围盒。
     */
    var AABB = (function (_super) {
        __extends(AABB, _super);
        /**
         * 请使用 `egret3d.AABB.create()` 创建实例。
         * @see egret3d.AABB.create()
         */
        function AABB() {
            var _this = _super.call(this) || this;
            _this._dirtyRadius = true;
            _this._dirtyCenter = true;
            _this._dirtySize = true;
            _this._boundingSphereRadius = 0.0;
            _this._minimum = egret3d.Vector3.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            _this._maximum = egret3d.Vector3.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            _this._center = egret3d.Vector3.create();
            _this._size = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个
         * @param minimum
         * @param maximum
         */
        AABB.create = function (minimum, maximum) {
            if (minimum === void 0) { minimum = null; }
            if (maximum === void 0) { maximum = null; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(minimum, maximum);
                instance._released = false;
                return instance;
            }
            return new AABB().set(minimum, maximum);
        };
        AABB.prototype.serialize = function () {
            return [this._minimum.x, this._minimum.y, this._minimum.z, this._maximum.x, this._maximum.y, this._maximum.z];
        };
        AABB.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        AABB.prototype.clone = function () {
            return AABB.create(this.minimum, this.maximum);
        };
        AABB.prototype.copy = function (value) {
            return this.set(value.minimum, value.maximum);
        };
        AABB.prototype.clear = function () {
            this._minimum.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            this._maximum.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        AABB.prototype.set = function (minimum, maximum) {
            if (minimum === void 0) { minimum = null; }
            if (maximum === void 0) { maximum = null; }
            if (minimum && minimum !== this._minimum) {
                this._minimum.copy(minimum);
            }
            if (maximum && maximum !== this._maximum) {
                this._maximum.copy(maximum);
            }
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        AABB.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this._minimum.fromArray(value, offset);
            this._maximum.fromArray(value, offset + 3);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.fromPoints = function (value) {
            this.clear();
            for (var _i = 0, _a = value; _i < _a.length; _i++) {
                var point = _a[_i];
                this.add(point);
            }
            return this;
        };
        AABB.prototype.applyMatrix = function (value, source) {
            if (!source) {
                source = this;
            }
            // transform of empty box is an empty box.
            if (source.isEmpty) {
                if (source !== this) {
                    this.copy(source);
                }
                return this;
            }
            var min = source.minimum;
            var max = source.maximum;
            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            _points[0].set(min.x, min.y, min.z).applyMatrix(value); // 000
            _points[1].set(min.x, min.y, max.z).applyMatrix(value); // 001
            _points[2].set(min.x, max.y, min.z).applyMatrix(value); // 010
            _points[3].set(min.x, max.y, max.z).applyMatrix(value); // 011
            _points[4].set(max.x, min.y, min.z).applyMatrix(value); // 100
            _points[5].set(max.x, min.y, max.z).applyMatrix(value); // 101
            _points[6].set(max.x, max.y, min.z).applyMatrix(value); // 110
            _points[7].set(max.x, max.y, max.z).applyMatrix(value); // 111
            this.fromPoints(_points);
            return this;
        };
        /**
         *
         */
        AABB.prototype.add = function (value, source) {
            if (!source) {
                source = this;
            }
            var min = source.minimum;
            var max = source.maximum;
            if (value instanceof AABB) {
                this._minimum.min(value._minimum, min);
                this._maximum.max(value._maximum, max);
            }
            else {
                this._minimum.min(value, min);
                this._maximum.max(value, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.expand = function (value, source) {
            if (!source) {
                source = this;
            }
            var min = source.minimum;
            var max = source.maximum;
            if (typeof value === "number") {
                this._minimum.addScalar(-value, min);
                this._maximum.addScalar(value, max);
            }
            else {
                this._minimum.subtract(value, min);
                this._maximum.add(value, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.offset = function (value, source) {
            if (!source) {
                source = this;
            }
            var min = source.minimum;
            var max = source.maximum;
            if (typeof value === "number") {
                this._minimum.addScalar(value, min);
                this._maximum.addScalar(value, max);
            }
            else {
                this._minimum.add(value, min);
                this._maximum.add(value, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.contains = function (value) {
            var min = this._minimum;
            var max = this._maximum;
            if (value instanceof AABB) {
                var vMin = value.minimum;
                var vMax = value.maximum;
                return min.x <= vMin.x && vMax.x <= max.x &&
                    min.y <= vMin.y && vMax.y <= max.y &&
                    min.z <= vMin.z && vMax.z <= max.z;
            }
            return (value.x > min.x) && (value.x < max.x) &&
                (value.y > min.y) && (value.x < max.y) &&
                (value.z > min.z) && (value.z < max.z);
        };
        AABB.prototype.getDistance = function (value) {
            return egret3d.helpVector3A.clamp(this._minimum, this._maximum, value).subtract(value).length;
        };
        AABB.prototype.clampPoints = function (value, out) {
            return out.clamp(this._minimum, this._maximum, value);
        };
        AABB.prototype.raycast = function (ray, raycastInfo) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var hitDirection = 0;
            var origin = ray.origin;
            var direction = ray.direction;
            var minimum = this.minimum;
            var maximum = this.maximum;
            var invdirx = 1.0 / direction.x, invdiry = 1.0 / direction.y, invdirz = 1.0 / direction.z;
            if (invdirx >= 0.0) {
                tmin = (minimum.x - origin.x) * invdirx;
                tmax = (maximum.x - origin.x) * invdirx;
            }
            else {
                tmin = (maximum.x - origin.x) * invdirx;
                tmax = (minimum.x - origin.x) * invdirx;
            }
            if (invdiry >= 0.0) {
                tymin = (minimum.y - origin.y) * invdiry;
                tymax = (maximum.y - origin.y) * invdiry;
            }
            else {
                tymin = (maximum.y - origin.y) * invdiry;
                tymax = (minimum.y - origin.y) * invdiry;
            }
            if ((tmin > tymax) || (tymin > tmax))
                return false;
            // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN
            if (tymin > tmin || tmin !== tmin) {
                tmin = tymin;
                hitDirection = 1;
            }
            if (tymax < tmax || tmax !== tmax)
                tmax = tymax;
            if (invdirz >= 0.0) {
                tzmin = (minimum.z - origin.z) * invdirz;
                tzmax = (maximum.z - origin.z) * invdirz;
            }
            else {
                tzmin = (maximum.z - origin.z) * invdirz;
                tzmax = (minimum.z - origin.z) * invdirz;
            }
            if ((tmin > tzmax) || (tzmin > tmax))
                return false;
            if (tzmin > tmin || tmin !== tmin) {
                tmin = tzmin;
                hitDirection = 2;
            }
            if (tzmax < tmax || tmax !== tmax)
                tmax = tzmax;
            // return point closest to the ray (positive side)
            if (tmax < 0.0)
                return false;
            if (raycastInfo) {
                var normal = raycastInfo.normal;
                ray.at(raycastInfo.distance = tmin >= 0.0 ? tmin : tmax, raycastInfo.position);
                if (normal) {
                    switch (hitDirection) {
                        case 0:
                            normal.set(invdirx > 0.0 ? -1.0 : 1.0, 0.0, 0.0);
                            break;
                        case 1:
                            normal.set(0.0, invdiry > 0.0 ? -1.0 : 1.0, 0.0);
                            break;
                        case 2:
                            normal.set(0.0, 0.0, invdirz > 0.0 ? -1.0 : 1.0);
                            break;
                    }
                }
            }
            return true;
        };
        Object.defineProperty(AABB.prototype, "isEmpty", {
            get: function () {
                // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                return (this._maximum.x < this._minimum.x) || (this._maximum.y < this._minimum.y) || (this._maximum.z < this._minimum.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "boundingSphereRadius", {
            /**
             * Bounding sphere radius.
             */
            get: function () {
                if (this._dirtyRadius) {
                    egret3d.helpVector3A.subtract(this._maximum, this._minimum).multiplyScalar(0.5);
                    this._boundingSphereRadius = egret3d.helpVector3A.length;
                    this._dirtyRadius = false;
                }
                return this._boundingSphereRadius;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "minimum", {
            /**
             *
             */
            get: function () {
                return this._minimum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "maximum", {
            /**
             *
             */
            get: function () {
                return this._maximum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "size", {
            /**
             *
             */
            get: function () {
                if (this._dirtySize) {
                    this._size.subtract(this._maximum, this._minimum);
                    this._dirtySize = false;
                }
                return this._size;
            },
            set: function (value) {
                var center = this.center;
                var size = this._size.copy(value);
                var halfSize = egret3d.helpVector3A.copy(size).multiplyScalar(0.5);
                this._minimum.copy(center).subtract(halfSize);
                this._maximum.copy(center).add(halfSize);
                this._dirtyRadius = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "center", {
            /**
             *
             */
            get: function () {
                if (this._dirtyCenter) {
                    this._center.add(this._maximum, this._minimum).multiplyScalar(0.5);
                    this._dirtyCenter = false;
                }
                return this._center;
            },
            set: function (value) {
                var size = this.size;
                var center = this._center.copy(value);
                var halfSize = egret3d.helpVector3A.copy(size).multiplyScalar(0.5);
                this._minimum.copy(center).subtract(halfSize);
                this._maximum.copy(center).add(halfSize);
            },
            enumerable: true,
            configurable: true
        });
        AABB.ONE = new AABB().set(egret3d.Vector3.MINUS_ONE.clone().multiplyScalar(0.5), egret3d.Vector3.ONE.clone().multiplyScalar(0.5));
        AABB._instances = [];
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */, { minimum: 0.0 })
        ], AABB.prototype, "size", null);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], AABB.prototype, "center", null);
        return AABB;
    }(paper.BaseRelease));
    egret3d.AABB = AABB;
    __reflect(AABB.prototype, "egret3d.AABB", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
    /**
     * @internal
     */
    egret3d.helpAABBA = AABB.create();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 平行光组件。
     */
    var DirectionalLight = (function (_super) {
        __extends(DirectionalLight, _super);
        function DirectionalLight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DirectionalLight.prototype.updateShadow = function (camera) {
            if (!this.renderTarget) {
                this.renderTarget = new egret3d.GlRenderTarget("DirectionalLight", this.shadowSize, this.shadowSize, true); // TODO
            }
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowCameraSize;
            camera.fov = Math.PI * 0.25;
            camera.opvalue = 0.0;
            camera.renderTarget = this.renderTarget;
            this.viewPortPixel.set(0, 0, this.shadowSize, this.shadowSize);
            this._updateShadowMatrix(camera);
        };
        return DirectionalLight;
    }(egret3d.BaseLight));
    egret3d.DirectionalLight = DirectionalLight;
    __reflect(DirectionalLight.prototype, "egret3d.DirectionalLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _targets = [
        new egret3d.Vector3(1, 0, 0), new egret3d.Vector3(-1, 0, 0), new egret3d.Vector3(0, 0, 1),
        new egret3d.Vector3(0, 0, -1), new egret3d.Vector3(0, 1, 0), new egret3d.Vector3(0, -1, 0)
    ];
    var _ups = [
        new egret3d.Vector3(0, 1, 0), new egret3d.Vector3(0, 1, 0), new egret3d.Vector3(0, 1, 0),
        new egret3d.Vector3(0, 1, 0), new egret3d.Vector3(0, 0, 1), new egret3d.Vector3(0, 0, -1)
    ];
    var _viewPortsScale = [
        new egret3d.Vector4(2, 1, 1, 1), new egret3d.Vector4(0, 1, 1, 1), new egret3d.Vector4(3, 1, 1, 1),
        new egret3d.Vector4(1, 1, 1, 1), new egret3d.Vector4(3, 0, 1, 1), new egret3d.Vector4(1, 0, 1, 1)
    ];
    /**
     * 点光组件。
     */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.decay = 0.0;
            /**
             *
             */
            _this.distance = 10.0;
            return _this;
        }
        PointLight.prototype.updateShadow = function (camera) {
            if (!this.renderTarget) {
                this.renderTarget = new egret3d.GlRenderTarget("PointLight", this.shadowSize * 4, this.shadowSize * 2); //   4x2  cube
            }
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.fov = Math.PI * 0.5;
            camera.opvalue = 1.0;
            camera.renderTarget = this.renderTarget;
            var context = camera.context;
            camera.calcProjectMatrix(1.0, context.matrix_p);
            var shadowMatrix = this.shadowMatrix;
            shadowMatrix.fromTranslate(this.gameObject.transform.getPosition().clone().multiplyScalar(-1).release());
        };
        PointLight.prototype.updateFace = function (camera, faceIndex) {
            var position = this.gameObject.transform.getPosition().clone().release();
            egret3d.helpVector3A.set(position.x + _targets[faceIndex].x, position.y + _targets[faceIndex].y, position.z + _targets[faceIndex].z);
            this.viewPortPixel.x = _viewPortsScale[faceIndex].x * this.shadowSize;
            this.viewPortPixel.y = _viewPortsScale[faceIndex].y * this.shadowSize;
            this.viewPortPixel.w = _viewPortsScale[faceIndex].z * this.shadowSize;
            this.viewPortPixel.h = _viewPortsScale[faceIndex].w * this.shadowSize;
            var cameraTransform = camera.gameObject.transform;
            cameraTransform.setPosition(position); // TODO support copy matrix.
            cameraTransform.lookAt(egret3d.helpVector3A, _ups[faceIndex]);
            // const temp = cameraTransform.getWorldMatrix().clone().release();
            // temp.rawData[12] = -temp.rawData[12];//Left-hand
            var context = camera.context;
            context.matrix_v.inverse(cameraTransform.getWorldMatrix());
            context.matrix_vp.multiply(context.matrix_p, context.matrix_v);
            context.updateLightDepth(this);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], PointLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], PointLight.prototype, "distance", void 0);
        return PointLight;
    }(egret3d.BaseLight));
    egret3d.PointLight = PointLight;
    __reflect(PointLight.prototype, "egret3d.PointLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 聚光组件。
     */
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        function SpotLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.decay = 2.0;
            /**
             *
             */
            _this.distance = 0.0;
            /**
             *
             */
            _this.angle = Math.PI / 3.0;
            /**
             *
             */
            _this.penumbra = 1.0;
            return _this;
        }
        SpotLight.prototype.updateShadow = function (camera) {
            if (!this.renderTarget) {
                this.renderTarget = new egret3d.GlRenderTarget("SpotLight", this.shadowSize, this.shadowSize); //
            }
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.fov = this.angle;
            camera.opvalue = 1.0;
            camera.renderTarget = this.renderTarget;
            camera.gameObject.transform.getWorldMatrix().copy(this.gameObject.transform.getWorldMatrix()); //
            this.viewPortPixel.set(0, 0, this.shadowSize, this.shadowSize);
            this._updateShadowMatrix(camera);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], SpotLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], SpotLight.prototype, "distance", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */)
        ], SpotLight.prototype, "angle", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01 })
        ], SpotLight.prototype, "penumbra", void 0);
        return SpotLight;
    }(egret3d.BaseLight));
    egret3d.SpotLight = SpotLight;
    __reflect(SpotLight.prototype, "egret3d.SpotLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格筛选组件。
     * - 为网格渲染组件提供网格资源。
     */
    var MeshFilter = (function (_super) {
        __extends(MeshFilter, _super);
        function MeshFilter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._mesh = null;
            return _this;
        }
        MeshFilter.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                // this._mesh.dispose(); //TODO shaderdMesh暂时没法dispose
            }
            this._mesh = null;
        };
        Object.defineProperty(MeshFilter.prototype, "mesh", {
            /**
             * 该渲染组件的网格资源。
             */
            get: function () {
                return this._mesh;
            },
            set: function (value) {
                if (this._mesh === value) {
                    return;
                }
                if (this._mesh) {
                    // this._mesh.dispose();//TODO shaderdMesh暂时没法dispose
                }
                this._mesh = value;
                MeshFilter.onMeshChanged.dispatch(this);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当网格筛选组件的网格资源改变时派发事件。
         */
        MeshFilter.onMeshChanged = new signals.Signal();
        __decorate([
            paper.serializedField
        ], MeshFilter.prototype, "_mesh", void 0);
        __decorate([
            paper.editor.property("MESH" /* MESH */)
        ], MeshFilter.prototype, "mesh", null);
        return MeshFilter;
    }(paper.BaseComponent));
    egret3d.MeshFilter = MeshFilter;
    __reflect(MeshFilter.prototype, "egret3d.MeshFilter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 贝塞尔曲线，目前定义了三种：线性贝塞尔曲线(两个点形成),二次方贝塞尔曲线（三个点形成），三次方贝塞尔曲线（四个点形成）
     */
    var Curve3 = (function () {
        /**
         * @internal
         */
        function Curve3(beizerPoints, bezierPointNum) {
            this.beizerPoints = beizerPoints;
            this.bezierPointNum = bezierPointNum;
        }
        /**
         * 线性贝塞尔曲线
         */
        Curve3.createLinearBezier = function (start, end, indices) {
            indices = indices > 2 ? indices : 3;
            var bez = new Array();
            var equation = function (t, va10, va11) {
                var res = (1.0 - t) * va10 + t * va11;
                return res;
            };
            bez.push(start);
            for (var i = 1; i <= indices; i++) {
                bez.push(new egret3d.Vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
            }
            return new Curve3(bez, indices);
        };
        /**
         * 二次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 选中的节点
         * @param v2 结尾点
         * @param bezierPointNum 将贝塞尔曲线拆分bezierPointNum段，一共有bezierPointNum + 1个点
         * @returns 贝塞尔曲线对象
         */
        Curve3.createQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
            bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2) {
                var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        /**
         * 三次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 第一个插值点
         * @param v2 第二个插值点
         * @param v3 终点
         * @param bezierPointNum 将贝塞尔曲线拆分bezierPointNum段，一共有bezierPointNum + 1个点
         * @returns 贝塞尔曲线对象
         */
        Curve3.createCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
            bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2, val3) {
                var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        return Curve3;
    }());
    egret3d.Curve3 = Curve3;
    __reflect(Curve3.prototype, "egret3d.Curve3");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格渲染组件系统。
     * - 为网格渲染组件生成绘制信息。
     */
    var MeshRendererSystem = (function (_super) {
        __extends(MeshRendererSystem, _super);
        function MeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.MeshFilter,
                    listeners: [{
                            type: egret3d.MeshFilter.onMeshChanged, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject);
                                if (component.gameObject.renderer) {
                                    component.gameObject.renderer._aabbDirty = true;
                                }
                            }
                        }]
                },
                {
                    componentClass: egret3d.MeshRenderer,
                    listeners: [{
                            type: egret3d.MeshRenderer.onMaterialsChanged, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject);
                            }
                        }]
                },
            ];
            _this._drawCallCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCallCollecter);
            return _this;
        }
        MeshRendererSystem.prototype._updateDrawCalls = function (gameObject, pass) {
            if (!pass &&
                (!this._enabled || !this._groups[0].hasGameObject(gameObject))) {
                return;
            }
            var drawCallCollecter = this._drawCallCollecter;
            var filter = gameObject.getComponent(egret3d.MeshFilter);
            var renderer = gameObject.renderer;
            var materials = renderer.materials;
            drawCallCollecter.removeDrawCalls(renderer);
            if (!filter.mesh || materials.length === 0) {
                return;
            }
            filter.mesh._createBuffer(); // TODO 更合适的时机。
            drawCallCollecter.renderers.push(renderer);
            var subMeshIndex = 0;
            for (var _i = 0, _a = filter.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var drawCall = egret3d.DrawCall.create();
                drawCall.renderer = renderer;
                drawCall.subMeshIndex = subMeshIndex++;
                drawCall.mesh = filter.mesh;
                drawCall.material = materials[primitive.material] || egret3d.DefaultMaterials.MISSING;
                drawCallCollecter.drawCalls.push(drawCall);
            }
        };
        MeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._updateDrawCalls(gameObject, true);
            }
        };
        MeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._updateDrawCalls(gameObject, true);
        };
        MeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
        };
        MeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
            }
        };
        return MeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.MeshRendererSystem = MeshRendererSystem;
    __reflect(MeshRendererSystem.prototype, "egret3d.MeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = egret3d.Matrix4.create();
    /**
     * 蒙皮网格渲染组件。
     */
    var SkinnedMeshRenderer = (function (_super) {
        __extends(SkinnedMeshRenderer, _super);
        function SkinnedMeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 强制使用 cpu 蒙皮。
             * - 骨骼数超过硬件支持的最大骨骼数量，或顶点权重大于 4 个，需要使用 CPU 蒙皮。
             * - CPU 蒙皮性能较低，仅是兼容方案，应合理的控制骨架的最大骨骼数量。
             */
            _this.forceCPUSkin = false;
            /**
             * @internal
             */
            _this.boneMatrices = null;
            _this._bones = [];
            _this._rootBone = null;
            _this._inverseBindMatrices = null;
            /**
             * @internal
             */
            _this._retargetBoneNames = null;
            _this._mesh = null;
            return _this;
        }
        /**
         * @internal
         */
        SkinnedMeshRenderer.prototype._update = function () {
            // TODO cache 剔除，脏标记。
            var bones = this._bones;
            var inverseBindMatrices = this._inverseBindMatrices;
            var boneMatrices = this.boneMatrices;
            for (var i = 0, l = bones.length; i < l; ++i) {
                var offset = i * 16;
                var bone = bones[i];
                var matrix = bone ? bone.getWorldMatrix() : egret3d.Matrix4.IDENTITY;
                _helpMatrix.fromArray(inverseBindMatrices, offset).premultiply(matrix).toArray(boneMatrices, offset);
            }
            if (this.forceCPUSkin) {
                var vA = _helpVector3A;
                var vB = _helpVector3B;
                var vC = _helpVector3C;
                var mA = _helpMatrix;
                var mesh = this._mesh;
                var indices = mesh.getIndices();
                var vertices = mesh.getVertices();
                var joints = mesh.getAttributes("JOINTS_0" /* JOINTS_0 */);
                var weights = mesh.getAttributes("WEIGHTS_0" /* WEIGHTS_0 */);
                if (!mesh._rawVertices) {
                    mesh._rawVertices = new Float32Array(vertices.length);
                    mesh._rawVertices.set(vertices);
                }
                for (var _i = 0, _a = indices; _i < _a.length; _i++) {
                    var index = _a[_i];
                    var vertexIndex = index * 3;
                    var jointIndex = index * 4;
                    vA.fromArray(mesh._rawVertices, vertexIndex);
                    vB.clear();
                    for (var i = 0; i < 4; ++i) {
                        var weight = weights[jointIndex + i];
                        if (weight <= 0.0) {
                            continue;
                        }
                        vB.add(vC.applyMatrix(mA.fromArray(boneMatrices, joints[jointIndex + i] * 16), vA).multiplyScalar(weight));
                    }
                    vB.toArray(vertices, vertexIndex);
                }
                mesh.uploadVertexBuffer();
            }
        };
        SkinnedMeshRenderer.prototype.initialize = function (reset) {
            _super.prototype.initialize.call(this);
            if (!reset) {
                return;
            }
            this._bones.length = 0;
            this._rootBone = null;
            this.boneMatrices = null;
            this._inverseBindMatrices = null;
            if (this._mesh) {
                var config = this._mesh.config;
                var skin = config.skins[0];
                var children = this.gameObject.transform.parent.getAllChildren({});
                if (skin.skeleton !== undefined) {
                    var rootNode = config.nodes[skin.skeleton];
                    if (rootNode.name in children) {
                        var transforms = children[rootNode.name];
                        this._rootBone = Array.isArray(transforms) ? transforms[0] : transforms;
                    }
                }
                for (var _i = 0, _a = skin.joints; _i < _a.length; _i++) {
                    var joint = _a[_i];
                    var node = config.nodes[joint];
                    if (node.name in children) {
                        var transforms = children[node.name];
                        this._bones.push(Array.isArray(transforms) ? transforms[0] : transforms);
                    }
                    else {
                        this._bones.push(null);
                    }
                }
                this._inverseBindMatrices = this._mesh.createTypeArrayFromAccessor(this._mesh.getAccessor(skin.inverseBindMatrices));
                this.boneMatrices = new Float32Array(this._bones.length * 16);
                if (this._bones.length > egret3d.SkinnedMeshRendererSystem.maxBoneCount) {
                    this.forceCPUSkin = true;
                    console.warn("The bone count of this mesh has exceeded the maxBoneCount and will use the forced CPU skin.", this._mesh.name);
                }
                // this._update(); TODO
            }
        };
        SkinnedMeshRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            // TODO
            if (this._mesh) {
                // this._mesh.dispose();
            }
            this._bones.length = 0;
            this._rootBone = null;
            this.boneMatrices = null;
            this._inverseBindMatrices = null;
            this._retargetBoneNames = null;
            this._mesh = null;
        };
        SkinnedMeshRenderer.prototype.recalculateAABB = function () {
            // TODO 蒙皮网格的 aabb 需要能自定义。
            if (this._mesh) {
                this._aabb.clear();
                var vertices = this._mesh._rawVertices || this._mesh.getVertices(); // T pose mesh aabb.
                var position = egret3d.helpVector3A;
                for (var i = 0, l = vertices.length; i < l; i += 3) {
                    position.set(vertices[i], vertices[i + 1], vertices[i + 2]);
                    this._aabb.add(position);
                }
            }
        };
        SkinnedMeshRenderer.prototype.raycast = function (p1, p2, p3) {
            if (!this._mesh) {
                return false;
            }
            var raycastMesh = false;
            var raycastInfo = undefined;
            var transform = this.gameObject.transform;
            var localRay = egret3d.helpRay.applyMatrix(transform.inverseWorldMatrix, p1);
            var aabb = this.aabb;
            if (p2) {
                if (p2 === true) {
                    raycastMesh = true;
                }
                else {
                    raycastMesh = p3 || false;
                    raycastInfo = p2;
                }
            }
            if (raycastMesh) {
                return aabb.raycast(localRay) && this._mesh.raycast(p1, raycastInfo, this.forceCPUSkin ? null : this.boneMatrices);
            }
            else if (aabb.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    raycastInfo.position.applyMatrix(transform.worldMatrix);
                    raycastInfo.distance = p1.origin.getDistance(raycastInfo.position);
                }
                return true;
            }
            return false;
        };
        Object.defineProperty(SkinnedMeshRenderer.prototype, "bones", {
            /**
             * 该渲染组件的骨骼列表。
             */
            get: function () {
                return this._bones;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "rootBone", {
            /**
             * 该渲染组件的根骨骼。
             */
            get: function () {
                return this._rootBone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "mesh", {
            /**
             * 该渲染组件的网格资源。
             */
            get: function () {
                return this._mesh;
            },
            set: function (mesh) {
                if (mesh && !mesh.config.scenes && !mesh.config.nodes && !mesh.config.skins) {
                    console.warn("Invalid skinned mesh.", mesh.name);
                    return;
                }
                if (this._mesh === mesh) {
                    return;
                }
                if (this._mesh) {
                    // this._mesh.dispose(); TODO
                }
                this._mesh = mesh;
                SkinnedMeshRenderer.onMeshChanged.dispatch(this);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当蒙皮网格渲染组件的网格资源改变时派发事件。
         */
        SkinnedMeshRenderer.onMeshChanged = new signals.Signal();
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "_mesh", void 0);
        return SkinnedMeshRenderer;
    }(egret3d.MeshRenderer));
    egret3d.SkinnedMeshRenderer = SkinnedMeshRenderer;
    __reflect(SkinnedMeshRenderer.prototype, "egret3d.SkinnedMeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 蒙皮网格渲染器。
     */
    var SkinnedMeshRendererSystem = (function (_super) {
        __extends(SkinnedMeshRendererSystem, _super);
        function SkinnedMeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.SkinnedMeshRenderer,
                    listeners: [
                        {
                            type: egret3d.SkinnedMeshRenderer.onMeshChanged, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject);
                                if (component.gameObject.renderer) {
                                    component.gameObject.renderer._aabbDirty = true;
                                }
                            }
                        },
                        {
                            type: egret3d.SkinnedMeshRenderer.onMaterialsChanged, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject);
                            }
                        },
                    ]
                }
            ];
            _this._drawCallCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCallCollecter);
            return _this;
        }
        SkinnedMeshRendererSystem.prototype._updateDrawCalls = function (gameObject) {
            if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                return;
            }
            var drawCallCollecter = this._drawCallCollecter;
            var renderer = gameObject.renderer;
            drawCallCollecter.removeDrawCalls(renderer);
            if (!renderer.mesh || renderer.materials.length === 0) {
                return;
            }
            renderer.mesh._createBuffer();
            this._drawCallCollecter.renderers.push(renderer);
            //
            var subMeshIndex = 0;
            for (var _i = 0, _a = renderer.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var material = renderer.materials[primitive.material]; // TODO miss material
                var drawCall = egret3d.DrawCall.create();
                drawCall.renderer = renderer;
                drawCall.matrix = egret3d.Matrix4.IDENTITY;
                drawCall.subMeshIndex = subMeshIndex++;
                drawCall.mesh = renderer.mesh;
                drawCall.material = material || egret3d.DefaultMaterials.MISSING;
                drawCallCollecter.drawCalls.push(drawCall);
            }
        };
        SkinnedMeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._updateDrawCalls(gameObject);
            }
        };
        SkinnedMeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            var renderer = gameObject.renderer;
            if (renderer.mesh && !renderer.boneMatrices) {
                renderer.initialize(true);
            }
            this._updateDrawCalls(gameObject);
        };
        SkinnedMeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
        };
        SkinnedMeshRendererSystem.prototype.onUpdate = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                gameObject.renderer._update();
            }
        };
        SkinnedMeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
            }
        };
        /**
         * @internal
         */
        SkinnedMeshRendererSystem.maxBoneCount = 36;
        return SkinnedMeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.SkinnedMeshRendererSystem = SkinnedMeshRendererSystem;
    __reflect(SkinnedMeshRendererSystem.prototype, "egret3d.SkinnedMeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var BlendLayer = (function (_super) {
        __extends(BlendLayer, _super);
        function BlendLayer() {
            var _this = _super.call(this) || this;
            _this.dirty = 0;
            _this.layer = 0;
            _this.leftWeight = 0.0;
            _this.layerWeight = 0.0;
            _this.blendWeight = 0.0;
            return _this;
        }
        /**
         * @internal
         */
        BlendLayer.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new BlendLayer();
        };
        BlendLayer.prototype.onClear = function () {
            this.dirty = 0;
            this.layer = 0;
            this.leftWeight = 0.0;
            this.layerWeight = 0.0;
            this.blendWeight = 0.0;
        };
        BlendLayer.prototype.update = function (animationState) {
            var animationLayer = animationState.layer;
            var animationWeight = animationState._globalWeight;
            if (this.dirty > 0) {
                if (this.leftWeight > 0.0) {
                    if (animationState.additive && this.layer !== animationLayer) {
                        if (this.layerWeight >= this.leftWeight) {
                            this.leftWeight = 0.0;
                            return false;
                        }
                        this.layer = animationLayer;
                        this.leftWeight -= this.layerWeight;
                        this.layerWeight = animationWeight * this.leftWeight;
                    }
                    animationWeight *= this.leftWeight;
                    this.dirty++;
                    this.blendWeight = animationWeight;
                    return true;
                }
                return false;
            }
            this.dirty++;
            this.layer = animationLayer;
            this.leftWeight = 1.0;
            this.layerWeight = animationWeight;
            this.blendWeight = animationWeight;
        };
        BlendLayer._instances = [];
        return BlendLayer;
    }(paper.BaseRelease));
    __reflect(BlendLayer.prototype, "BlendLayer");
    /**
     *
     */
    var AnimationChannel = (function (_super) {
        __extends(AnimationChannel, _super);
        function AnimationChannel() {
            var _this = _super.call(this) || this;
            _this.update = null;
            return _this;
        }
        /**
         * @internal
         */
        AnimationChannel.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new AnimationChannel();
        };
        AnimationChannel._instances = [];
        return AnimationChannel;
    }(paper.BaseRelease));
    __reflect(AnimationChannel.prototype, "AnimationChannel");
    var _animationChannels = [];
    /**
     * 动画混合节点。
     */
    var BlendNode = (function () {
        function BlendNode() {
            /**
             * @private
             */
            this.additive = false;
            /**
             * 动画混合模式。（根节点有效）
             */
            this.layer = 0;
            /**
             * 节点权重。
             */
            this.weight = 1.0;
            /**
             * 淡入淡出的时间。
             */
            this.fadeTotalTime = 1.0;
            /**
             * 父节点。
             */
            this.parent = null;
            /**
             * -1: Fade in, 0: Fade complete, 1: Fade out;
             * @internal
             */
            this._fadeState = -1;
            /**
             * -1: Fade start, 0: Fading, 1: Fade complete;
             * @internal
             */
            this._subFadeState = -1;
            /**
             * 累计权重。
             * @internal
             */
            this._globalWeight = 0.0;
            /**
             * 融合进度。
             * @internal
             */
            this._fadeProgress = 0.0;
            /**
             * 本地融合时间。
             */
            this._fadeTime = 0.0;
        }
        BlendNode.prototype._onFadeStateChange = function () {
        };
        /**
         * @internal
         */
        BlendNode.prototype._update = function (deltaTime) {
            if (this._fadeState !== 0 || this._subFadeState !== 0) {
                var isFadeOut = this._fadeState > 0;
                if (this._subFadeState < 0) {
                    this._subFadeState = 0;
                    this._onFadeStateChange();
                }
                if (deltaTime < 0.0) {
                    deltaTime = -deltaTime;
                }
                this._fadeTime += deltaTime;
                if (this._fadeTime >= this.fadeTotalTime) {
                    this._subFadeState = 1;
                    this._fadeProgress = isFadeOut ? 0.0 : 1.0;
                }
                else if (this._fadeTime > 0.0) {
                    this._fadeProgress = isFadeOut ? (1.0 - this._fadeTime / this.fadeTotalTime) : (this._fadeTime / this.fadeTotalTime);
                }
                else {
                    this._fadeProgress = isFadeOut ? 1.0 : 0.0;
                }
                if (this._subFadeState > 0) {
                    if (!isFadeOut) {
                        this._fadeState = 0;
                        this._onFadeStateChange();
                    }
                }
            }
            this._globalWeight = this.weight * this._fadeProgress;
            if (this.parent) {
                this._globalWeight *= this.parent._globalWeight;
            }
        };
        BlendNode.prototype.fadeOut = function (fadeOutTime) {
            if (fadeOutTime < 0.0 || fadeOutTime !== fadeOutTime) {
                fadeOutTime = 0.0;
            }
            if (this._fadeState > 0) {
                if (fadeOutTime > this.fadeTotalTime - this._fadeTime) {
                    return;
                }
            }
            else {
                this._fadeState = 1;
                this._subFadeState = -1;
                if (fadeOutTime <= 0.0 || this._fadeProgress <= 0.0) {
                    this._fadeProgress = 0.000001; // Modify fade progress to different value.
                }
            }
            this.fadeTotalTime = this._fadeProgress > 0.000001 ? fadeOutTime / this._fadeProgress : 0.0;
            this._fadeTime = this.fadeTotalTime * (1.0 - this._fadeProgress);
        };
        return BlendNode;
    }());
    egret3d.BlendNode = BlendNode;
    __reflect(BlendNode.prototype, "egret3d.BlendNode");
    /**
     * 动画混合树节点。
     */
    var BlendTree = (function (_super) {
        __extends(BlendTree, _super);
        function BlendTree() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._blendNodes = [];
            return _this;
        }
        return BlendTree;
    }(BlendNode));
    egret3d.BlendTree = BlendTree;
    __reflect(BlendTree.prototype, "egret3d.BlendTree");
    /**
     * 动画状态。
     */
    var AnimationState = (function (_super) {
        __extends(AnimationState, _super);
        function AnimationState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.layer = 0;
            /**
             * 动画总播放次数。
             */
            _this.playTimes = 0;
            /**
             * 动画当前播放次数。
             */
            _this.currentPlayTimes = 0;
            /**
             * 播放速度。
             */
            _this.timeScale = 1.0;
            /**
             * @private
             */
            _this.animationAsset = null;
            /**
             * 播放的动画数据。
             */
            _this.animation = null;
            /**
             * 播放的动画剪辑。
             */
            _this.animationClip = null;
            /**
             * 是否允许播放。
             */
            _this._isPlaying = true;
            /**
             * 播放状态。
             * -1: start, 0: playing, 1: complete;
             */
            _this._playState = -1;
            /**
             * 本地播放时间。
             */
            _this._time = 0.0;
            /**
             * 当前动画时间。
             */
            _this._currentTime = 0.0;
            // TODO cache.
            _this._channels = [];
            _this._animationComponent = null;
            return _this;
        }
        AnimationState.prototype._onUpdateTranslation = function (channel, animationState) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            if (animationState._currentTime <= inputBuffer[0]) {
            }
            else if (animationState._currentTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (animationState._currentTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var isComponents = Array.isArray(channel.components);
            var offset = frameIndex * 3;
            var x = outputBuffer[offset++];
            var y = outputBuffer[offset++];
            var z = outputBuffer[offset++];
            if (isInterpolation) {
                var progress = (animationState._currentTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                x += (outputBuffer[offset++] - x) * progress;
                y += (outputBuffer[offset++] - y) * progress;
                z += (outputBuffer[offset++] - z) * progress;
            }
            if (isComponents) {
                for (var _i = 0, _a = channel.components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.setLocalPosition(x, y, z);
                }
            }
            else {
                channel.components.setLocalPosition(x, y, z);
            }
        };
        AnimationState.prototype._onUpdateRotation = function (channel, animationState) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            if (animationState._currentTime <= inputBuffer[0]) {
            }
            else if (animationState._currentTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (animationState._currentTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var isComponents = Array.isArray(channel.components);
            var offset = frameIndex * 4;
            var x = outputBuffer[offset++];
            var y = outputBuffer[offset++];
            var z = outputBuffer[offset++];
            var w = outputBuffer[offset++];
            if (isInterpolation) {
                var progress = (animationState._currentTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                x += (outputBuffer[offset++] - x) * progress;
                y += (outputBuffer[offset++] - y) * progress;
                z += (outputBuffer[offset++] - z) * progress;
                w += (outputBuffer[offset++] - w) * progress;
            }
            if (isComponents) {
                for (var _i = 0, _a = channel.components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.setLocalRotation(x, y, z, w);
                }
            }
            else {
                channel.components.setLocalRotation(x, y, z, w);
            }
        };
        AnimationState.prototype._onUpdateScale = function (channel, animationState) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            if (animationState._currentTime <= inputBuffer[0]) {
            }
            else if (animationState._currentTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (animationState._currentTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var isComponents = Array.isArray(channel.components);
            var offset = frameIndex * 3;
            var x = outputBuffer[offset++];
            var y = outputBuffer[offset++];
            var z = outputBuffer[offset++];
            if (isInterpolation) {
                var progress = (animationState._currentTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                x += (outputBuffer[offset++] - x) * progress;
                y += (outputBuffer[offset++] - y) * progress;
                z += (outputBuffer[offset++] - z) * progress;
            }
            if (isComponents) {
                for (var _i = 0, _a = channel.components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.setLocalScale(x, y, z);
                }
            }
            else {
                channel.components.setLocalScale(x, y, z);
            }
        };
        AnimationState.prototype._onUpdateActive = function (channel, animationState) {
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            if (animationState._currentTime <= inputBuffer[0]) {
            }
            else if (animationState._currentTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (animationState._currentTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var isComponents = Array.isArray(channel.components);
            var activeSelf = outputBuffer[frameIndex] !== 0;
            if (isComponents) {
                for (var _i = 0, _a = channel.components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.gameObject.activeSelf = activeSelf;
                }
            }
            else {
                channel.components.gameObject.activeSelf = activeSelf;
            }
        };
        /**
         * @internal
         */
        AnimationState.prototype.initialize = function (animationComponent, animationAsset, animationClip) {
            var assetConfig = animationAsset.config;
            //
            this.animationAsset = animationAsset;
            this.animationClip = animationClip;
            this.animation = assetConfig.animations[0]; // TODO 动画数据暂不合并。
            //
            this._fadeTime = 0.0;
            this._time = 0.0;
            this._animationComponent = animationComponent;
            if (this.animation.channels) {
                var rootGameObject = this._animationComponent.gameObject;
                var children = rootGameObject.transform.getAllChildren({});
                children["__root__"] = rootGameObject.transform;
                for (var _i = 0, _a = this.animation.channels; _i < _a.length; _i++) {
                    var glTFChannel = _a[_i];
                    var node = this.animationAsset.getNode(glTFChannel.target.node || 0);
                    if (!(node.name in children)) {
                        continue;
                    }
                    var transforms = children[node.name];
                    var channel = _animationChannels.length > 0 ? _animationChannels.pop() : AnimationChannel.create();
                    var pathName = glTFChannel.target.path;
                    channel.glTFChannel = glTFChannel;
                    channel.glTFSampler = this.animation.samplers[glTFChannel.sampler];
                    channel.components = transforms; // TODO 更多组件
                    channel.inputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.input));
                    channel.outputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.output));
                    switch (pathName) {
                        case "translation":
                            channel.blendLayer = this._animationComponent._getBlendlayer(pathName, node.name);
                            channel.update = this._onUpdateTranslation;
                            break;
                        case "rotation":
                            channel.blendLayer = this._animationComponent._getBlendlayer(pathName, node.name);
                            channel.update = this._onUpdateRotation;
                            break;
                        case "scale":
                            channel.blendLayer = this._animationComponent._getBlendlayer(pathName, node.name);
                            channel.update = this._onUpdateScale;
                            break;
                        case "weights":
                            // TODO
                            break;
                        case "custom":
                            switch (channel.glTFChannel.extensions.paper.type) {
                                case "paper.GameObject":
                                    switch (channel.glTFChannel.extensions.paper.property) {
                                        case "activeSelf":
                                            channel.update = this._onUpdateActive;
                                            break;
                                    }
                                    break;
                            }
                            break;
                        default:
                            console.warn("Unknown animation channel.", channel.glTFChannel.target.path);
                            break;
                    }
                    this._channels.push(channel);
                }
            }
        };
        /**
         * @internal
         */
        AnimationState.prototype._update = function (deltaTime) {
            _super.prototype._update.call(this, deltaTime);
            // Update time.
            if (this._isPlaying) {
                deltaTime *= this.timeScale * this._animationComponent.timeScale;
                this._time += deltaTime;
            }
            var prevPlayState = this._playState;
            // const prevPlayTimes = this.currentPlayTimes;
            var duration = this.animationClip.duration;
            var totalTime = this.playTimes * duration;
            if (this.playTimes > 0 && (this._time >= totalTime || this._time <= -totalTime)) {
                if (this._playState <= 0 && this._isPlaying) {
                    this._playState = 1;
                }
                this.currentPlayTimes = this.playTimes;
                if (this._time >= totalTime) {
                    // currentTime = duration + 0.000001; // Precision problem.
                    this._currentTime = duration; // TODO CHECK.
                }
                else {
                    this._currentTime = 0.0;
                }
            }
            else {
                if (this._playState !== 0 && this._isPlaying) {
                    this._playState = 0;
                }
                if (this._time < 0.0) {
                    this._time = -this._time;
                    this.currentPlayTimes = Math.floor(this._time / duration);
                    this._currentTime = duration - (this._time % duration);
                }
                else {
                    this.currentPlayTimes = Math.floor(this._time / duration);
                    this._currentTime = this._time % duration;
                }
            }
            this._currentTime += this.animationClip.position;
            if (this.weight !== 0.0) {
                for (var _i = 0, _a = this._channels; _i < _a.length; _i++) {
                    var channel = _a[_i];
                    if (channel.update) {
                        channel.update(channel, this);
                    }
                }
            }
            if (prevPlayState !== this._playState && this._playState === 1) {
                this._animationComponent._dispatchEvent("complete", this); // TODO buffer event.
                var animationNames = this._animationComponent._animationNames;
                if (animationNames.length > 0) {
                    var animationName = animationNames.shift();
                    this._animationComponent.play(animationName);
                }
            }
        };
        AnimationState.prototype.play = function () {
            this._isPlaying = true;
        };
        AnimationState.prototype.stop = function () {
            this._isPlaying = false;
        };
        AnimationState.prototype.fateOut = function () {
            this._fadeState = 1;
            this._subFadeState = -1;
        };
        Object.defineProperty(AnimationState.prototype, "isPlaying", {
            get: function () {
                return this._isPlaying && this._playState !== 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isCompleted", {
            get: function () {
                return this._playState === 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "totalTime", {
            get: function () {
                return this.animationClip.duration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "currentTime", {
            get: function () {
                return this._currentTime;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationState;
    }(BlendNode));
    egret3d.AnimationState = AnimationState;
    __reflect(AnimationState.prototype, "egret3d.AnimationState");
    /**
     * 动画组件。
     */
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.autoPlay = false;
            /**
             * 动画速度。
             */
            _this.timeScale = 1.0;
            /**
             * 动画数据列表。
             */
            _this._animations = [];
            /**
             * 混合节点列表。
             */
            _this._blendNodes = [];
            /**
             * @internal
             */
            _this._animationNames = [];
            /**
             * 骨骼姿势列表。
             * @internal
             */
            _this._blendLayers = {};
            /**
             * 最后一个播放的动画状态。
             * - 当进行动画混合时，该值通常没有任何意义。
             */
            _this._lastAnimationState = null;
            return _this;
        }
        /**
         * TODO more event type.
         * sendMessage.
         * @internal
         */
        Animation.prototype._dispatchEvent = function (type, animationState, eventObject) {
            for (var _i = 0, _a = this.gameObject.getComponents(paper.Behaviour, true); _i < _a.length; _i++) {
                var component = _a[_i];
                if (component.onAnimationEvent) {
                    component.onAnimationEvent(type, animationState, eventObject);
                }
            }
        };
        /**
         * @internal
         */
        Animation.prototype._getBlendlayer = function (type, name) {
            if (!(type in this._blendLayers)) {
                this._blendLayers[type] = {};
            }
            var blendLayers = this._blendLayers[type];
            if (!(name in blendLayers)) {
                blendLayers[name] = BlendLayer.create();
            }
            return blendLayers[name];
        };
        /**
         * @internal
         */
        Animation.prototype._update = function (globalTime) {
            var blendNodes = this._blendNodes;
            var blendNodeCount = blendNodes.length;
            if (blendNodeCount === 1) {
                var blendNode = blendNodes[0];
                if (blendNode._fadeState > 0 && blendNode._subFadeState > 0) {
                    blendNodes.length = 0;
                    if (this._lastAnimationState === blendNode) {
                        this._lastAnimationState = null;
                    }
                }
                else {
                    blendNode._update(globalTime);
                }
            }
            else if (blendNodeCount > 1) {
                for (var i = 0, r = 0; i < blendNodeCount; ++i) {
                    var blendNode = blendNodes[i];
                    if (blendNode._fadeState > 0 && blendNode._subFadeState > 0) {
                        r++;
                        if (this._lastAnimationState === blendNode) {
                            this._lastAnimationState = null;
                        }
                    }
                    else {
                        if (r > 0) {
                            blendNodes[i - r] = blendNode;
                        }
                        blendNode._update(globalTime);
                    }
                    if (i === blendNodeCount - 1 && r > 0) {
                        blendNodes.length -= r;
                        if (this._lastAnimationState === null && blendNodes.length > 0) {
                            var blendNode_1 = blendNodes[blendNodes.length - 1];
                            if (blendNode_1 instanceof AnimationState) {
                                this._lastAnimationState = blendNode_1;
                            }
                        }
                    }
                }
            }
            else {
            }
        };
        Animation.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            // TODO
            // for (const blendLayer in this._blendLayers) {
            //     blendLayer.release();
            // }
            // this._blendLayers.length = 0;
        };
        Animation.prototype.fadeIn = function (animationName, fadeTime, playTimes, layer, additive) {
            if (animationName === void 0) { animationName = null; }
            if (playTimes === void 0) { playTimes = -1; }
            if (layer === void 0) { layer = 0; }
            if (additive === void 0) { additive = false; }
            var animationAsset = null;
            var animationClip = null;
            for (var _i = 0, _a = this._animations; _i < _a.length; _i++) {
                var animation = _a[_i];
                animationAsset = animation;
                if (animationName) {
                    animationClip = animation.getAnimationClip(animationName);
                    if (animationClip !== null) {
                        break;
                    }
                }
                else {
                    animationClip = animation.getAnimationClip("");
                    break;
                }
            }
            if (!animationAsset || !animationClip) {
                return null;
            }
            for (var _b = 0, _c = this._blendNodes; _b < _c.length; _b++) {
                var blendNode = _c[_b];
                if ((!blendNode.parent && blendNode.layer === layer)) {
                    blendNode.fadeOut(fadeTime);
                }
            }
            var animationState = new AnimationState();
            animationState.initialize(this, animationAsset, animationClip);
            animationState.additive = additive;
            animationState.fadeTotalTime = fadeTime;
            animationState.playTimes = playTimes < 0 ? (animationClip.playTimes || 0) : playTimes;
            // TODO sort by layer and blend tree.
            this._blendNodes.push(animationState);
            this._lastAnimationState = animationState;
            return animationState;
        };
        Animation.prototype.play = function (animationNameOrNames, playTimes) {
            if (animationNameOrNames === void 0) { animationNameOrNames = null; }
            if (playTimes === void 0) { playTimes = -1; }
            this._animationNames.length = 0;
            if (Array.isArray(animationNameOrNames)) {
                if (animationNameOrNames.length > 0) {
                    for (var _i = 0, animationNameOrNames_1 = animationNameOrNames; _i < animationNameOrNames_1.length; _i++) {
                        var animationName = animationNameOrNames_1[_i];
                        this._animationNames.push(animationName);
                    }
                    return this.fadeIn(this._animationNames.shift(), 0.0, playTimes);
                }
                return this.fadeIn(null, 0.0, playTimes);
            }
            return this.fadeIn(animationNameOrNames, 0.0, playTimes);
        };
        Animation.prototype.stop = function () {
            for (var _i = 0, _a = this._blendNodes; _i < _a.length; _i++) {
                var blendNode = _a[_i];
                if (!blendNode.parent && blendNode instanceof AnimationState) {
                    blendNode.stop();
                }
            }
        };
        Object.defineProperty(Animation.prototype, "lastAnimationnName", {
            get: function () {
                return this._lastAnimationState ? this._lastAnimationState.animationClip.name : "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animations", {
            get: function () {
                return this._animations;
            },
            /**
             * 动画数据列表。
             */
            set: function (animations) {
                for (var i = 0, l = animations.length; i < l; i++) {
                    this._animations[i] = animations[i];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "lastAnimationState", {
            get: function () {
                return this._lastAnimationState;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Animation.prototype, "autoPlay", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */)
        ], Animation.prototype, "timeScale", void 0);
        __decorate([
            paper.serializedField
        ], Animation.prototype, "_animations", void 0);
        return Animation;
    }(paper.BaseComponent));
    egret3d.Animation = Animation;
    __reflect(Animation.prototype, "egret3d.Animation");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 动画系统。
     */
    var AnimationSystem = (function (_super) {
        __extends(AnimationSystem, _super);
        function AnimationSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: egret3d.Animation }
            ];
            return _this;
        }
        AnimationSystem.prototype.onAddComponent = function (component) {
            if (component.autoPlay && (!component.lastAnimationState || !component.lastAnimationState.isPlaying)) {
                component.play();
            }
        };
        AnimationSystem.prototype.onUpdate = function (deltaTime) {
            // TODO 应将组件功能尽量移到系统，视野剔除
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                gameObject.getComponent(egret3d.Animation)._update(deltaTime);
            }
        };
        return AnimationSystem;
    }(paper.BaseSystem));
    egret3d.AnimationSystem = AnimationSystem;
    __reflect(AnimationSystem.prototype, "egret3d.AnimationSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         * @private
         * 渲染类型为Mesh的属性格式
         */
        var MeshShaderAttributeFormat = [
            { key: "POSITION" /* POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "COLOR_0" /* COLOR_0 */, type: "VEC4" /* VEC4 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "_START_POSITION" /* _START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_START_VELOCITY" /* _START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "_START_COLOR" /* _START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "_START_SIZE" /* _START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "_START_ROTATION" /* _START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "_TIME" /* _TIME */, type: "VEC2" /* VEC2 */ },
            { key: "_RANDOM0" /* _RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "_RANDOM1" /* _RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "_WORLD_POSITION" /* _WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_WORLD_ROTATION" /* _WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
         * @private
         * 渲染类型为Billboard的属性格式
         */
        var BillboardShaderAttributeFormat = [
            { key: "_CORNER" /* _CORNER */, type: "VEC2" /* VEC2 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "_START_POSITION" /* _START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_START_VELOCITY" /* _START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "_START_COLOR" /* _START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "_START_SIZE" /* _START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "_START_ROTATION" /* _START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "_TIME" /* _TIME */, type: "VEC2" /* VEC2 */ },
            { key: "_RANDOM0" /* _RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "_RANDOM1" /* _RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "_WORLD_POSITION" /* _WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_WORLD_ROTATION" /* _WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
        * @internal
        */
        function createBatchMesh(renderer, maxParticleCount) {
            var meshAttributes = [];
            var meshAttributesType = {};
            if (renderer.renderMode === 4 /* Mesh */) {
                var mesh = renderer.mesh;
                var orginIndexBuffer = mesh.getIndices();
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _i = 0, MeshShaderAttributeFormat_1 = MeshShaderAttributeFormat; _i < MeshShaderAttributeFormat_1.length; _i++) {
                    var attribute = MeshShaderAttributeFormat_1[_i];
                    meshAttributes.push(attribute.key);
                    meshAttributesType[attribute.key] = attribute.type;
                }
                var totalVertexCount = mesh.vertexCount * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = new egret3d.Mesh(totalVertexCount, totalIndexCount, meshAttributes, meshAttributesType, 35048 /* Dynamic */);
                //
                var index = 0;
                //提前填充
                var orginPostionBuffer = mesh.getAttributes("POSITION" /* POSITION */);
                var orginUVBuffer = mesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                var orginColorBuffer = mesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var positionBuffer = batchMesh.getAttributes("POSITION" /* POSITION */);
                var colorBuffer = batchMesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var vector2Offset = i * 2;
                    var vector3Offset = i * 3;
                    var vector4Offset = i * 4;
                    var orginVertexIndex = i % mesh.vertexCount;
                    positionBuffer[vector3Offset] = orginPostionBuffer[orginVertexIndex * 3];
                    positionBuffer[vector3Offset + 1] = orginPostionBuffer[orginVertexIndex * 3 + 1];
                    positionBuffer[vector3Offset + 2] = orginPostionBuffer[orginVertexIndex * 3 + 2];
                    if (orginUVBuffer) {
                        uvBuffer[vector2Offset] = orginUVBuffer[orginVertexIndex * 2];
                        uvBuffer[vector2Offset + 1] = orginUVBuffer[orginVertexIndex * 2 + 1];
                    }
                    if (orginColorBuffer) {
                        colorBuffer[vector4Offset] = orginColorBuffer[orginVertexIndex * 4];
                        colorBuffer[vector4Offset + 1] = orginColorBuffer[orginVertexIndex * 4 + 1];
                        colorBuffer[vector4Offset + 2] = orginColorBuffer[orginVertexIndex * 4 + 2];
                        colorBuffer[vector4Offset + 3] = orginColorBuffer[orginVertexIndex * 4 + 3];
                    }
                    else {
                        colorBuffer[vector4Offset] = 1;
                        colorBuffer[vector4Offset + 1] = 1;
                        colorBuffer[vector4Offset + 2] = 1;
                        colorBuffer[vector4Offset + 3] = 1;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * mesh.vertexCount;
                    for (var j = 0; j < orginIndexBufferCount; j++) {
                        indexBuffer[index++] = orginIndexBuffer[j] + indexOffset;
                    }
                }
                return batchMesh;
            }
            else {
                var orginIndexBuffer = [0, 2, 1, 0, 3, 2];
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _a = 0, BillboardShaderAttributeFormat_1 = BillboardShaderAttributeFormat; _a < BillboardShaderAttributeFormat_1.length; _a++) {
                    var attribute = BillboardShaderAttributeFormat_1[_a];
                    meshAttributes.push(attribute.key);
                    meshAttributesType[attribute.key] = attribute.type;
                }
                var vertexStride = 4;
                var totalVertexCount = vertexStride * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = new egret3d.Mesh(totalVertexCount, totalIndexCount, meshAttributes, meshAttributesType, 35048 /* Dynamic */);
                var cornerBuffer = batchMesh.getAttributes("_CORNER" /* _CORNER */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var orginVertexIndex = i % vertexStride;
                    var vector2Offset = i * 2;
                    switch (orginVertexIndex) {
                        case 0:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 1:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 2:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                        case 3:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * 6;
                    var firstVertex = i * vertexStride;
                    var secondVertex = firstVertex + 2;
                    indexBuffer[indexOffset + 0] = firstVertex;
                    indexBuffer[indexOffset + 1] = secondVertex;
                    indexBuffer[indexOffset + 2] = firstVertex + 1;
                    indexBuffer[indexOffset + 3] = firstVertex;
                    indexBuffer[indexOffset + 4] = firstVertex + 3;
                    indexBuffer[indexOffset + 5] = secondVertex;
                }
                return batchMesh;
            }
        }
        particle.createBatchMesh = createBatchMesh;
        /**
         * @internal
         */
        function generatePositionAndDirection(position, direction, shape) {
            if (!shape.enable) {
                position.x = position.y = position.z = 0;
                direction.x = direction.y = 0;
                direction.z = 1.0;
                return;
            }
            //
            switch (shape.shapeType) {
                case 4 /* Cone */:
                case 7 /* ConeShell */:
                    {
                        _generateConeParticlePosition(shape, position, direction);
                    }
                    break;
                case 8 /* ConeVolume */:
                case 9 /* ConeVolumeShell */:
                    {
                        _generateConeVolumeParticlePosition(shape, position, direction);
                    }
                    break;
                case 5 /* Box */:
                    {
                        _generateBoxParticlePosition(shape, position, direction);
                    }
                    break;
                case 0 /* Sphere */:
                case 1 /* SphereShell */:
                    {
                        _generateSphereParticlePosition(shape, position, direction);
                    }
                    break;
                case 10 /* Circle */:
                    {
                        _generateCircleParticlePosition(shape, position, direction);
                    }
                    break;
                default:
                    {
                        position.x = position.y = position.z = 0;
                        direction.x = direction.y = 0;
                        direction.z = 1;
                    }
            }
        }
        particle.generatePositionAndDirection = generatePositionAndDirection;
        function _randomPostionCircle(out) {
            var angle = Math.random() * Math.PI * 2;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideCircle(out) {
            _randomPostionCircle(out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionArcCircle(arc, out) {
            var angle = Math.random() * arc;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideArcCircle(arc, out) {
            _randomPositionArcCircle(arc, out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionSphere(out) {
            var ranZ = Math.random() * 2 - 1.0;
            var angle = Math.random() * Math.PI * 2;
            var range = Math.sqrt(1.0 - ranZ * ranZ);
            out.x = Math.cos(angle) * range;
            out.y = Math.sin(angle) * range;
            out.z = ranZ;
        }
        function _randomPositionInsideSphere(out) {
            _randomPositionSphere(out);
            var range = Math.pow(Math.random(), 1.0 / 3.0);
            out.x = out.x * range;
            out.y = out.y * range;
            out.z = out.z * range;
        }
        function _generateConeParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType === 4 /* Cone */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = temp.z * shape.radius;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            if (shape.randomDirection) {
                _randomPositionInsideCircle(direction);
                direction.x = direction.x * sinValue;
                direction.y = direction.y * sinValue;
                direction.z = cosValue;
            }
            else {
                direction.x = temp.x * sinValue;
                direction.y = temp.y * sinValue;
                direction.z = cosValue;
            }
        }
        function _generateConeVolumeParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType === 8 /* ConeVolume */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            direction.x = temp.x * sinValue;
            direction.y = temp.y * sinValue;
            direction.z = cosValue;
            egret3d.Vector3.normalize(direction);
            var len = Math.random() * shape.length;
            direction.x = direction.x * len;
            direction.y = direction.y * len;
            direction.z = direction.z * len;
            position.x += direction.x;
            position.y += direction.y;
            position.z += direction.z;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
        }
        function _generateBoxParticlePosition(shape, position, direction) {
            position.x = shape.box.x * (Math.random() - 0.5);
            position.y = shape.box.y * (Math.random() - 0.5);
            position.z = shape.box.z * (Math.random() - 0.5);
            if (shape.randomDirection) {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
            else {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
        }
        function _generateSphereParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (!shape.spherizeDirection) {
                if (shape.shapeType === 0 /* Sphere */) {
                    _randomPositionInsideSphere(position);
                }
                else {
                    _randomPositionSphere(position);
                }
            }
            position.x = position.x * shape.radius;
            position.y = position.y * shape.radius;
            position.z = position.z * shape.radius;
            if (shape.randomDirection || shape.spherizeDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
        function _generateCircleParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType === 10 /* Circle */) {
                _randomPositionInsideArcCircle(shape.radiusSpread, temp);
            }
            else {
                _randomPositionArcCircle(shape.radiusSpread, temp);
            }
            position.x = -temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        particle.onMainChanged = new signals.Signal();
        particle.onColorChanged = new signals.Signal();
        particle.onVelocityChanged = new signals.Signal();
        particle.onSizeChanged = new signals.Signal();
        particle.onRotationChanged = new signals.Signal();
        particle.onTextureSheetChanged = new signals.Signal();
        particle.onShapeChanged = new signals.Signal();
        particle.onStartRotation3DChanged = new signals.Signal();
        particle.onSimulationSpaceChanged = new signals.Signal();
        particle.onScaleModeChanged = new signals.Signal();
        particle.onMaxParticlesChanged = new signals.Signal();
        /**
         *
         */
        var CurveMode;
        (function (CurveMode) {
            CurveMode[CurveMode["Constant"] = 0] = "Constant";
            CurveMode[CurveMode["Curve"] = 1] = "Curve";
            CurveMode[CurveMode["TwoCurves"] = 2] = "TwoCurves";
            CurveMode[CurveMode["TwoConstants"] = 3] = "TwoConstants";
        })(CurveMode = particle.CurveMode || (particle.CurveMode = {}));
        /**
         *
         */
        var ColorGradientMode;
        (function (ColorGradientMode) {
            ColorGradientMode[ColorGradientMode["Color"] = 0] = "Color";
            ColorGradientMode[ColorGradientMode["Gradient"] = 1] = "Gradient";
            ColorGradientMode[ColorGradientMode["TwoColors"] = 2] = "TwoColors";
            ColorGradientMode[ColorGradientMode["TwoGradients"] = 3] = "TwoGradients";
            ColorGradientMode[ColorGradientMode["RandomColor"] = 4] = "RandomColor";
        })(ColorGradientMode = particle.ColorGradientMode || (particle.ColorGradientMode = {}));
        /**
         *
         */
        var SimulationSpace;
        (function (SimulationSpace) {
            SimulationSpace[SimulationSpace["Local"] = 0] = "Local";
            SimulationSpace[SimulationSpace["World"] = 1] = "World";
            SimulationSpace[SimulationSpace["Custom"] = 2] = "Custom";
        })(SimulationSpace = particle.SimulationSpace || (particle.SimulationSpace = {}));
        /**
         *
         */
        var ScalingMode;
        (function (ScalingMode) {
            ScalingMode[ScalingMode["Hierarchy"] = 0] = "Hierarchy";
            ScalingMode[ScalingMode["Local"] = 1] = "Local";
            ScalingMode[ScalingMode["Shape"] = 2] = "Shape";
        })(ScalingMode = particle.ScalingMode || (particle.ScalingMode = {}));
        /**
         *
         */
        var ShapeType;
        (function (ShapeType) {
            ShapeType[ShapeType["None"] = -1] = "None";
            ShapeType[ShapeType["Sphere"] = 0] = "Sphere";
            ShapeType[ShapeType["SphereShell"] = 1] = "SphereShell";
            ShapeType[ShapeType["Hemisphere"] = 2] = "Hemisphere";
            ShapeType[ShapeType["HemisphereShell"] = 3] = "HemisphereShell";
            ShapeType[ShapeType["Cone"] = 4] = "Cone";
            ShapeType[ShapeType["Box"] = 5] = "Box";
            ShapeType[ShapeType["Mesh"] = 6] = "Mesh";
            ShapeType[ShapeType["ConeShell"] = 7] = "ConeShell";
            ShapeType[ShapeType["ConeVolume"] = 8] = "ConeVolume";
            ShapeType[ShapeType["ConeVolumeShell"] = 9] = "ConeVolumeShell";
            ShapeType[ShapeType["Circle"] = 10] = "Circle";
            ShapeType[ShapeType["CircleEdge"] = 11] = "CircleEdge";
            ShapeType[ShapeType["SingleSidedEdge"] = 12] = "SingleSidedEdge";
            ShapeType[ShapeType["MeshRenderer"] = 13] = "MeshRenderer";
            ShapeType[ShapeType["SkinnedMeshRenderer"] = 14] = "SkinnedMeshRenderer";
            ShapeType[ShapeType["BoxShell"] = 15] = "BoxShell";
            ShapeType[ShapeType["BoxEdge"] = 16] = "BoxEdge";
        })(ShapeType = particle.ShapeType || (particle.ShapeType = {}));
        /**
         *
         */
        var ShapeMultiModeValue;
        (function (ShapeMultiModeValue) {
            ShapeMultiModeValue[ShapeMultiModeValue["Random"] = 0] = "Random";
            ShapeMultiModeValue[ShapeMultiModeValue["Loop"] = 1] = "Loop";
            ShapeMultiModeValue[ShapeMultiModeValue["PingPong"] = 2] = "PingPong";
            ShapeMultiModeValue[ShapeMultiModeValue["BurstSpread"] = 3] = "BurstSpread";
        })(ShapeMultiModeValue = particle.ShapeMultiModeValue || (particle.ShapeMultiModeValue = {}));
        /**
         *
         */
        var AnimationType;
        (function (AnimationType) {
            AnimationType[AnimationType["WholeSheet"] = 0] = "WholeSheet";
            AnimationType[AnimationType["SingleRow"] = 1] = "SingleRow";
        })(AnimationType = particle.AnimationType || (particle.AnimationType = {}));
        /**
         *
         */
        var UVChannelFlags;
        (function (UVChannelFlags) {
            UVChannelFlags[UVChannelFlags["UV0"] = 1] = "UV0";
            UVChannelFlags[UVChannelFlags["UV1"] = 2] = "UV1";
            UVChannelFlags[UVChannelFlags["UV2"] = 4] = "UV2";
            UVChannelFlags[UVChannelFlags["UV3"] = 8] = "UV3";
        })(UVChannelFlags = particle.UVChannelFlags || (particle.UVChannelFlags = {}));
        /**
         *
         */
        var GradientMode;
        (function (GradientMode) {
            GradientMode[GradientMode["Blend"] = 0] = "Blend";
            GradientMode[GradientMode["Fixed"] = 1] = "Fixed";
        })(GradientMode = particle.GradientMode || (particle.GradientMode = {}));
        var _helpColorA = egret3d.Color.create();
        var _helpColorB = egret3d.Color.create();
        /**
         * TODO
         */
        var Keyframe = (function () {
            function Keyframe() {
            }
            Keyframe.prototype.serialize = function () {
                return [this.time, this.value];
            };
            Keyframe.prototype.deserialize = function (element) {
                this.time = element[0];
                this.value = element[1];
                return this;
            };
            Keyframe.prototype.copy = function (source) {
                this.time = source.time;
                this.value = source.value;
            };
            return Keyframe;
        }());
        particle.Keyframe = Keyframe;
        __reflect(Keyframe.prototype, "egret3d.particle.Keyframe", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var AnimationCurve = (function () {
            function AnimationCurve() {
                /**
                 * 功能与效率平衡长度取4
                 */
                this._keys = new Array();
                this._floatValues = new Float32Array(8);
            }
            AnimationCurve.prototype.serialize = function () {
                return this._keys.map(function (keyFrame) { return keyFrame.serialize(); });
            };
            AnimationCurve.prototype.deserialize = function (element) {
                this._keys.length = 0;
                for (var i = 0, l = element.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.deserialize(element[i]);
                    this._keys.push(keyframe);
                }
                return this;
            };
            AnimationCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this._keys.length; i < l; i++) {
                    var curKeyFrame = this._keys[i];
                    if (curKeyFrame.time < t) {
                        continue;
                    }
                    //
                    var lastIndex = i === 0 ? 0 : i - 1;
                    var lastKeyFrame = this._keys[lastIndex];
                    var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                    return egret3d.numberLerp(lastKeyFrame.value, curKeyFrame.value, tt);
                }
                throw "AnimationCurve: invalid t or keys.length is 0";
            };
            Object.defineProperty(AnimationCurve.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    var offset = 0;
                    for (var _i = 0, _a = this._keys; _i < _a.length; _i++) {
                        var keyFrame = _a[_i];
                        res[offset++] = keyFrame.time;
                        res[offset++] = keyFrame.value;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            AnimationCurve.prototype.copy = function (source) {
                this._keys.length = 0;
                var sourceKeys = source._keys;
                for (var i = 0, l = sourceKeys.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.time = sourceKeys[i].time;
                    keyframe.value = sourceKeys[i].value;
                    this._keys.push(keyframe);
                }
            };
            return AnimationCurve;
        }());
        particle.AnimationCurve = AnimationCurve;
        __reflect(AnimationCurve.prototype, "egret3d.particle.AnimationCurve", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var GradientColorKey = (function (_super) {
            __extends(GradientColorKey, _super);
            function GradientColorKey() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.color = egret3d.Color.create();
                return _this;
            }
            GradientColorKey.prototype.deserialize = function (element) {
                this.color.deserialize(element.color);
                this.time = element.time;
                return this;
            };
            __decorate([
                paper.serializedField
            ], GradientColorKey.prototype, "time", void 0);
            __decorate([
                paper.serializedField
            ], GradientColorKey.prototype, "color", void 0);
            return GradientColorKey;
        }(paper.BaseObject));
        particle.GradientColorKey = GradientColorKey;
        __reflect(GradientColorKey.prototype, "egret3d.particle.GradientColorKey");
        /**
         * TODO
         */
        var GradientAlphaKey = (function (_super) {
            __extends(GradientAlphaKey, _super);
            function GradientAlphaKey() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            GradientAlphaKey.prototype.deserialize = function (element) {
                this.alpha = element.alpha;
                this.time = element.time;
                return this;
            };
            __decorate([
                paper.serializedField
            ], GradientAlphaKey.prototype, "alpha", void 0);
            __decorate([
                paper.serializedField
            ], GradientAlphaKey.prototype, "time", void 0);
            return GradientAlphaKey;
        }(paper.BaseObject));
        particle.GradientAlphaKey = GradientAlphaKey;
        __reflect(GradientAlphaKey.prototype, "egret3d.particle.GradientAlphaKey");
        /**
         * TODO
         */
        var Gradient = (function (_super) {
            __extends(Gradient, _super);
            function Gradient() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 0 /* Blend */;
                _this.alphaKeys = new Array();
                _this.colorKeys = new Array();
                _this._alphaValue = new Float32Array(8);
                _this._colorValue = new Float32Array(16);
                return _this;
            }
            Gradient.prototype.deserialize = function (element) {
                this.colorKeys.length = 0;
                for (var i = 0, l = element.colorKeys.length; i < l; i++) {
                    var color = new GradientColorKey();
                    color.deserialize(element.colorKeys[i]);
                    this.colorKeys.push(color);
                }
                //
                this.alphaKeys.length = 0;
                for (var i = 0, l = element.alphaKeys.length; i < l; i++) {
                    var alpha = new GradientAlphaKey();
                    alpha.deserialize(element.alphaKeys[i]);
                    this.alphaKeys.push(alpha);
                }
                return this;
            };
            Gradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this.alphaKeys.length; i < l; i++) {
                    var curKeyFrame = this.alphaKeys[i];
                    if (curKeyFrame.time > t) {
                        var lastIndex = i === 0 ? 0 : i - 1;
                        var lastKeyFrame = this.alphaKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                        out.a = egret3d.numberLerp(lastKeyFrame.alpha, curKeyFrame.alpha, tt);
                        break;
                    }
                }
                for (var i = 0, l = this.colorKeys.length; i < l; i++) {
                    var colorKey = this.colorKeys[i];
                    if (colorKey.time > t) {
                        var lastIndex = i === 0 ? 0 : i - 1;
                        var lastKeyFrame = this.colorKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (colorKey.time - lastKeyFrame.time);
                        out.r = egret3d.numberLerp(lastKeyFrame.color.r, colorKey.color.r, tt);
                        out.g = egret3d.numberLerp(lastKeyFrame.color.g, colorKey.color.g, tt);
                        out.b = egret3d.numberLerp(lastKeyFrame.color.b, colorKey.color.b, tt);
                        break;
                    }
                }
                return out;
            };
            Object.defineProperty(Gradient.prototype, "alphaValues", {
                get: function () {
                    var res = this._alphaValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.alphaKeys; _i < _a.length; _i++) {
                        var alpha = _a[_i];
                        res[offset++] = alpha.time;
                        res[offset++] = alpha.alpha;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Gradient.prototype, "colorValues", {
                get: function () {
                    var res = this._colorValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.colorKeys; _i < _a.length; _i++) {
                        var color = _a[_i];
                        res[offset++] = color.time;
                        res[offset++] = color.color.r;
                        res[offset++] = color.color.g;
                        res[offset++] = color.color.b;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "alphaKeys", void 0);
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "colorKeys", void 0);
            return Gradient;
        }(paper.BaseObject));
        particle.Gradient = Gradient;
        __reflect(Gradient.prototype, "egret3d.particle.Gradient");
        /**
         * TODO create
         */
        var MinMaxCurve = (function (_super) {
            __extends(MinMaxCurve, _super);
            function MinMaxCurve() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 0 /* Constant */;
                _this.curve = new AnimationCurve();
                _this.curveMin = new AnimationCurve();
                _this.curveMax = new AnimationCurve();
                return _this;
            }
            MinMaxCurve.prototype.deserialize = function (element) {
                this.mode = element.mode;
                this.constant = element.constant || 0;
                this.constantMin = element.constantMin || 0;
                this.constantMax = element.constantMax || 0;
                element.curve && this.curve.deserialize(element.curve);
                element.curveMin && this.curveMin.deserialize(element.curveMin);
                element.curveMax && this.curveMax.deserialize(element.curveMax);
                return this;
            };
            MinMaxCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Constant */) {
                    return this.constant;
                }
                else if (this.mode === 3 /* TwoConstants */) {
                    return (Math.random() * (this.constantMax - this.constantMin) + this.constantMin);
                }
                else if (this.mode === 1 /* Curve */) {
                    return this.curve.evaluate(t);
                }
                else {
                    var min = this.curveMin.evaluate(t);
                    var max = this.curveMax.evaluate(t);
                    return (Math.random() * (min - max) + min);
                }
            };
            MinMaxCurve.prototype.copy = function (source) {
                this.mode = source.mode;
                this.constant = source.constant;
                this.constantMin = source.constantMin;
                this.constantMax = source.constantMax;
                this.curve.copy(source.curve);
                this.curveMin.copy(source.curveMin);
                this.curveMax.copy(source.curveMax);
            };
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constant", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constantMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constantMax", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curve", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curveMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curveMax", void 0);
            return MinMaxCurve;
        }(paper.BaseObject));
        particle.MinMaxCurve = MinMaxCurve;
        __reflect(MinMaxCurve.prototype, "egret3d.particle.MinMaxCurve");
        /**
         * TODO create
         */
        var MinMaxGradient = (function (_super) {
            __extends(MinMaxGradient, _super);
            function MinMaxGradient() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 1 /* Gradient */;
                _this.color = egret3d.Color.create();
                _this.colorMin = egret3d.Color.create();
                _this.colorMax = egret3d.Color.create();
                _this.gradient = new Gradient();
                _this.gradientMin = new Gradient();
                _this.gradientMax = new Gradient();
                return _this;
            }
            MinMaxGradient.prototype.deserialize = function (element) {
                // super.deserialize(element);
                this.mode = element.mode;
                if (element.color) {
                    this.color.deserialize(element.color);
                }
                if (element.colorMin) {
                    this.colorMin.deserialize(element.colorMin);
                }
                if (element.colorMax) {
                    this.colorMax.deserialize(element.colorMax);
                }
                if (element.gradient) {
                    this.gradient.deserialize(element.gradient);
                }
                if (element.gradientMin) {
                    this.gradientMin.deserialize(element.gradientMin);
                }
                if (element.gradientMax) {
                    this.gradientMax.deserialize(element.gradientMax);
                }
                return this;
            };
            MinMaxGradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Color */) {
                    out.r = this.color.r;
                    out.g = this.color.g;
                    out.b = this.color.b;
                    out.a = this.color.a;
                }
                else if (this.mode === 2 /* TwoColors */) {
                    out.r = Math.random() * (this.colorMax.r - this.colorMin.r) + this.colorMin.r;
                    out.g = Math.random() * (this.colorMax.g - this.colorMin.g) + this.colorMin.g;
                    out.b = Math.random() * (this.colorMax.b - this.colorMin.b) + this.colorMin.b;
                    out.a = Math.random() * (this.colorMax.a - this.colorMin.a) + this.colorMin.a;
                }
                else if (this.mode === 1 /* Gradient */) {
                    return this.gradient.evaluate(t, out);
                }
                else if (this.mode === 3 /* TwoGradients */) {
                    this.gradientMin.evaluate(t, _helpColorA);
                    this.gradientMax.evaluate(t, _helpColorB);
                    out.r = (Math.random() * (_helpColorA.r - _helpColorB.r) + _helpColorA.r);
                    out.g = (Math.random() * (_helpColorA.g - _helpColorB.g) + _helpColorA.g);
                    out.b = (Math.random() * (_helpColorA.b - _helpColorB.b) + _helpColorA.b);
                    out.a = (Math.random() * (_helpColorA.a - _helpColorB.a) + _helpColorA.a);
                }
                else {
                    out.r = Math.random();
                    out.g = Math.random();
                    out.b = Math.random();
                    out.a = Math.random();
                }
                return out;
            };
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "color", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "colorMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "colorMax", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradient", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradientMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradientMax", void 0);
            return MinMaxGradient;
        }(paper.BaseObject));
        particle.MinMaxGradient = MinMaxGradient;
        __reflect(MinMaxGradient.prototype, "egret3d.particle.MinMaxGradient");
        /**
         *
         */
        var Burst = (function () {
            function Burst() {
            }
            Burst.prototype.serialize = function () {
                return [this.time, this.minCount, this.maxCount, this.cycleCount, this.repeatInterval];
            };
            Burst.prototype.deserialize = function (element) {
                this.time = element[0];
                this.minCount = element[1];
                this.maxCount = element[2];
                this.cycleCount = element[3];
                this.repeatInterval = element[4];
                return this;
            };
            return Burst;
        }());
        particle.Burst = Burst;
        __reflect(Burst.prototype, "egret3d.particle.Burst", ["paper.ISerializable"]);
        /**
         * 粒子模块基类。
         */
        var ParticleModule = (function (_super) {
            __extends(ParticleModule, _super);
            function ParticleModule(component) {
                var _this = _super.call(this) || this;
                _this.enable = false;
                _this._component = component;
                return _this;
            }
            ParticleModule.prototype.deserialize = function (element) {
                this.enable = true;
                return this;
            };
            __decorate([
                paper.serializedField
            ], ParticleModule.prototype, "enable", void 0);
            return ParticleModule;
        }(paper.BaseObject));
        particle.ParticleModule = ParticleModule;
        __reflect(ParticleModule.prototype, "egret3d.particle.ParticleModule");
        /**
         *
         */
        var MainModule = (function (_super) {
            __extends(MainModule, _super);
            function MainModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 *
                 */
                _this.loop = false;
                /**
                 *
                 */
                _this.playOnAwake = false;
                /**
                 *
                 */
                _this.duration = 0.0;
                /**
                 *
                 */
                _this.startDelay = new MinMaxCurve();
                /**
                 *
                 */
                _this.startLifetime = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSpeed = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSizeX = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSizeY = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSizeZ = new MinMaxCurve();
                /**
                 *
                 */
                _this.startRotationX = new MinMaxCurve();
                /**
                 *
                 */
                _this.startRotationY = new MinMaxCurve();
                /**
                 *
                 */
                _this.startRotationZ = new MinMaxCurve();
                /**
                 *
                 */
                _this.startColor = new MinMaxGradient();
                /**
                 *
                 */
                _this.gravityModifier = new MinMaxCurve(); //TODO
                _this._startRotation3D = false;
                _this._simulationSpace = 0 /* Local */;
                _this._scaleMode = 0 /* Hierarchy */;
                _this._maxParticles = 0;
                return _this;
            }
            MainModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.duration = element.duration;
                this.loop = element.loop || element.looping; // TODO 兼容代码 looping。
                this.startDelay.deserialize(element.startDelay);
                this.startLifetime.deserialize(element.startLifetime);
                this.startSpeed.deserialize(element.startSpeed);
                this.startSizeX.deserialize(element.startSizeX);
                this.startSizeY.deserialize(element.startSizeY);
                this.startSizeZ.deserialize(element.startSizeZ);
                this._startRotation3D = (element._startRotation3D || element.startRotation3D) || false;
                this.startRotationX.deserialize(element.startRotationX);
                this.startRotationY.deserialize(element.startRotationY);
                this.startRotationZ.deserialize(element.startRotationZ);
                this.startColor.deserialize(element.startColor);
                this.gravityModifier.deserialize(element.gravityModifier);
                this._simulationSpace = (element._simulationSpace || element.simulationSpace) || 0;
                this._scaleMode = (element._scaleMode || element.scaleMode) || 0 /* Hierarchy */;
                this.playOnAwake = element.playOnAwake;
                this._maxParticles = (element._maxParticles || element.maxParticles) || 0;
                return this;
            };
            Object.defineProperty(MainModule.prototype, "startRotation3D", {
                /**
                 *
                 */
                get: function () {
                    return this._startRotation3D;
                },
                set: function (value) {
                    if (this._startRotation3D === value) {
                        return;
                    }
                    this._startRotation3D = value;
                    particle.onStartRotation3DChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "simulationSpace", {
                /**
                 *
                 */
                get: function () {
                    return this._simulationSpace;
                },
                set: function (value) {
                    if (this._simulationSpace === value) {
                        return;
                    }
                    this._simulationSpace = value;
                    particle.onSimulationSpaceChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "scaleMode", {
                /**
                 *
                 */
                get: function () {
                    return this._scaleMode;
                },
                set: function (value) {
                    if (this._scaleMode === value) {
                        return;
                    }
                    this._scaleMode = value;
                    particle.onScaleModeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "maxParticles", {
                /**
                 *
                 */
                get: function () {
                    return this._maxParticles;
                },
                set: function (value) {
                    if (this._maxParticles === value) {
                        return;
                    }
                    this._maxParticles = value;
                    particle.onMaxParticlesChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "loop", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "playOnAwake", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "duration", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startDelay", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startLifetime", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSpeed", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startColor", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "gravityModifier", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_startRotation3D", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_simulationSpace", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_scaleMode", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_maxParticles", void 0);
            return MainModule;
        }(ParticleModule));
        particle.MainModule = MainModule;
        __reflect(MainModule.prototype, "egret3d.particle.MainModule");
        /**
         *
         */
        var EmissionModule = (function (_super) {
            __extends(EmissionModule, _super);
            function EmissionModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 *
                 */
                _this.rateOverTime = new MinMaxCurve();
                /**
                 *
                 */
                _this.bursts = [];
                return _this;
            }
            EmissionModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.rateOverTime.deserialize(element.rateOverTime);
                if (element.bursts) {
                    this.bursts.length = 0;
                    for (var i = 0, l = element.bursts.length; i < l; i++) {
                        var burst = new Burst();
                        burst.deserialize(element.bursts[i]);
                        this.bursts.push(burst);
                    }
                }
                return this;
            };
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "rateOverTime", void 0);
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "bursts", void 0);
            return EmissionModule;
        }(ParticleModule));
        particle.EmissionModule = EmissionModule;
        __reflect(EmissionModule.prototype, "egret3d.particle.EmissionModule");
        /**
         *
         */
        var ShapeModule = (function (_super) {
            __extends(ShapeModule, _super);
            function ShapeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 *
                 */
                _this.shapeType = 0 /* Sphere */;
                /**
                 *
                 */
                _this.radius = 0.0;
                /**
                 *
                 */
                _this.angle = 0.0;
                /**
                 *
                 */
                _this.length = 0.0;
                /**
                 *
                 */
                _this.arcSpeed = new MinMaxCurve();
                /**
                 *
                 */
                _this.arcMode = 0 /* Random */;
                /**
                 *
                 */
                _this.radiusMode = 0 /* Random */;
                /**
                 *
                 */
                _this.box = egret3d.Vector3.create();
                /**
                 *
                 */
                _this.randomDirection = false;
                /**
                 *
                 */
                _this.spherizeDirection = false;
                return _this;
            }
            ShapeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.shapeType = element.shapeType;
                this.radius = element.radius;
                this.angle = element.angle;
                this.length = element.length;
                this.arcSpeed.deserialize(element.arcSpeed);
                this.arcMode = element.arcMode;
                this.radiusSpread = element.radiusSpread;
                this.radiusMode = element.radiusMode;
                this.box.deserialize(element.box);
                this.randomDirection = element.randomDirection;
                this.spherizeDirection = element.spherizeDirection;
                return this;
            };
            /**
             * @internal
             */
            ShapeModule.prototype.invalidUpdate = function () {
                particle.onShapeChanged.dispatch(this._component);
            };
            /**
             * @internal
             */
            ShapeModule.prototype.generatePositionAndDirection = function (position, direction) {
                particle.generatePositionAndDirection(position, direction, this);
            };
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "shapeType", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radius", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "angle", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "length", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcSpeed", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusSpread", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "box", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "randomDirection", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "spherizeDirection", void 0);
            return ShapeModule;
        }(ParticleModule));
        particle.ShapeModule = ShapeModule;
        __reflect(ShapeModule.prototype, "egret3d.particle.ShapeModule");
        /**
         *
         */
        var VelocityOverLifetimeModule = (function (_super) {
            __extends(VelocityOverLifetimeModule, _super);
            function VelocityOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._mode = 0 /* Constant */;
                _this._space = 0 /* Local */;
                _this._x = new MinMaxCurve();
                _this._y = new MinMaxCurve();
                _this._z = new MinMaxCurve();
                return _this;
            }
            VelocityOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._mode = (element._mode || element.mode) || 0 /* Constant */;
                this._space = (element._space || element.space) || 0 /* Local */;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "mode", {
                /**
                 *
                 */
                get: function () {
                    return this._mode;
                },
                set: function (value) {
                    if (this._mode === value) {
                        return;
                    }
                    this._mode = value;
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "space", {
                /**
                 *
                 */
                get: function () {
                    return this._space;
                },
                set: function (value) {
                    if (this._space === value) {
                        return;
                    }
                    this._space = value;
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "x", {
                /**
                 *
                 */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x.copy(value);
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "y", {
                /**
                 *
                 */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y.copy(value);
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "z", {
                /**
                 *
                 */
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z.copy(value);
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_mode", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_space", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_z", void 0);
            return VelocityOverLifetimeModule;
        }(ParticleModule));
        particle.VelocityOverLifetimeModule = VelocityOverLifetimeModule;
        __reflect(VelocityOverLifetimeModule.prototype, "egret3d.particle.VelocityOverLifetimeModule");
        /**
         *
         */
        var ColorOverLifetimeModule = (function (_super) {
            __extends(ColorOverLifetimeModule, _super);
            function ColorOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._color = new MinMaxGradient(); // TODO readonly
                return _this;
            }
            ColorOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._color.deserialize(element._color || element.color);
                return this;
            };
            Object.defineProperty(ColorOverLifetimeModule.prototype, "color", {
                /**
                 *
                 */
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._color = value; // TODO copy
                    particle.onColorChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ColorOverLifetimeModule.prototype, "_color", void 0);
            return ColorOverLifetimeModule;
        }(ParticleModule));
        particle.ColorOverLifetimeModule = ColorOverLifetimeModule;
        __reflect(ColorOverLifetimeModule.prototype, "egret3d.particle.ColorOverLifetimeModule");
        /**
         *
         */
        var SizeOverLifetimeModule = (function (_super) {
            __extends(SizeOverLifetimeModule, _super);
            function SizeOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._separateAxes = false;
                _this._size = new MinMaxCurve();
                _this._x = new MinMaxCurve();
                _this._y = new MinMaxCurve();
                _this._z = new MinMaxCurve();
                return _this;
            }
            SizeOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._size.deserialize(element._size || element.size);
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(SizeOverLifetimeModule.prototype, "separateAxes", {
                /**
                 *
                 */
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes === value) {
                        return;
                    }
                    this._separateAxes = value;
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "size", {
                /**
                 *
                 */
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    this._size.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "x", {
                /**
                 *
                 */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "y", {
                /**
                 *
                 */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "z", {
                /**
                 *
                 */
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_size", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_z", void 0);
            return SizeOverLifetimeModule;
        }(ParticleModule));
        particle.SizeOverLifetimeModule = SizeOverLifetimeModule;
        __reflect(SizeOverLifetimeModule.prototype, "egret3d.particle.SizeOverLifetimeModule");
        /**
         *
         */
        var RotationOverLifetimeModule = (function (_super) {
            __extends(RotationOverLifetimeModule, _super);
            function RotationOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._x = new MinMaxCurve();
                _this._y = new MinMaxCurve();
                _this._z = new MinMaxCurve();
                return _this;
            }
            RotationOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(RotationOverLifetimeModule.prototype, "separateAxes", {
                /**
                 *
                 */
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes === value) {
                        return;
                    }
                    this._separateAxes = value;
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "x", {
                /**
                 *
                 */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x.copy(value);
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "y", {
                /**
                 *
                 */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y.copy(value);
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "z", {
                /**
                 *
                 */
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z.copy(value);
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_z", void 0);
            return RotationOverLifetimeModule;
        }(ParticleModule));
        particle.RotationOverLifetimeModule = RotationOverLifetimeModule;
        __reflect(RotationOverLifetimeModule.prototype, "egret3d.particle.RotationOverLifetimeModule");
        /**
         *
         */
        var TextureSheetAnimationModule = (function (_super) {
            __extends(TextureSheetAnimationModule, _super);
            function TextureSheetAnimationModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._animation = 0 /* WholeSheet */;
                _this._frameOverTime = new MinMaxCurve();
                _this._startFrame = new MinMaxCurve();
                _this._floatValues = new Float32Array(4);
                return _this;
            }
            TextureSheetAnimationModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._numTilesX = (element._numTilesX || element.numTilesX) || 0;
                this._numTilesY = (element._numTilesY || element.numTilesY) || 0;
                this._animation = (element._animation || element.animation) || 0 /* WholeSheet */;
                this._useRandomRow = (element._useRandomRow || element.useRandomRow) || false;
                this._frameOverTime.deserialize(element._frameOverTime || element.frameOverTime);
                this._startFrame.deserialize(element._startFrame || element.startFrame);
                this._cycleCount = (element._cycleCount || element.cycleCount) || 0;
                this._rowIndex = (element._rowIndex || element.rowIndex) || 0;
                return this;
            };
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesX", {
                /**
                 *
                 */
                get: function () {
                    return this._numTilesX;
                },
                set: function (value) {
                    if (this._numTilesX === value) {
                        return;
                    }
                    this._numTilesX = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesY", {
                /**
                 *
                 */
                get: function () {
                    return this._numTilesY;
                },
                set: function (value) {
                    if (this._numTilesY === value) {
                        return;
                    }
                    this._numTilesY = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "animation", {
                /**
                 *
                 */
                get: function () {
                    return this._animation;
                },
                set: function (value) {
                    if (this._animation === value) {
                        return;
                    }
                    this._animation = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "useRandomRow", {
                /**
                 *
                 */
                get: function () {
                    return this._useRandomRow;
                },
                set: function (value) {
                    if (this._useRandomRow === value) {
                        return;
                    }
                    this._useRandomRow = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "frameOverTime", {
                /**
                 *
                 */
                get: function () {
                    return this._frameOverTime;
                },
                set: function (value) {
                    this._frameOverTime.copy(value);
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "startFrame", {
                /**
                 *
                 */
                get: function () {
                    return this._startFrame;
                },
                set: function (value) {
                    this._startFrame.copy(value);
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "cycleCount", {
                /**
                 *
                 */
                get: function () {
                    return this._cycleCount;
                },
                set: function (value) {
                    if (this._cycleCount === value) {
                        return;
                    }
                    this._cycleCount = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "rowIndex", {
                /**
                 *
                 */
                get: function () {
                    return this._rowIndex;
                },
                set: function (value) {
                    if (this._rowIndex === value) {
                        return;
                    }
                    this._rowIndex = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    if (this.enable) {
                        var subU = 1.0 / this._numTilesX;
                        var subV = 1.0 / this._numTilesY;
                        var startFrmaeCount = Math.floor(this._startFrame.constant);
                        var startRow = 0;
                        switch (this._animation) {
                            case 1 /* SingleRow */:
                                {
                                    if (this._useRandomRow) {
                                        startRow = Math.floor(Math.random() * this._numTilesY);
                                    }
                                    else {
                                        startRow = this._rowIndex;
                                    }
                                    break;
                                }
                            case 0 /* WholeSheet */:
                                {
                                    startRow = Math.floor(startFrmaeCount / this._numTilesX);
                                    break;
                                }
                        }
                        var startCol = Math.floor(startFrmaeCount % this._numTilesX);
                        res[0] = subU;
                        res[1] = subV;
                        res[2] = startCol * subU;
                        res[3] = startRow * subV;
                    }
                    else {
                        res[0] = 1.0;
                        res[1] = 1.0;
                        res[2] = 0.0;
                        res[3] = 0.0;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_useRandomRow", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_animation", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesX", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesY", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_cycleCount", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_rowIndex", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_frameOverTime", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_startFrame", void 0);
            return TextureSheetAnimationModule;
        }(ParticleModule));
        particle.TextureSheetAnimationModule = TextureSheetAnimationModule;
        __reflect(TextureSheetAnimationModule.prototype, "egret3d.particle.TextureSheetAnimationModule");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        //
        var positionHelper = new egret3d.Vector3();
        var velocityHelper = new egret3d.Vector3();
        var startSizeHelper = new egret3d.Vector3();
        var startColorHelper = egret3d.Color.create();
        var startRotationHelper = new egret3d.Vector3();
        var GRAVITY = new egret3d.Vector3(0, -9.81, 0); //TODO没有物理系统，暂时先放到这里
        /**
         * @internal
         */
        var ParticleBatcher = (function () {
            function ParticleBatcher() {
                this._dirty = false;
                this._time = 0.0;
                this._emittsionTime = 0;
                this._frameRateTime = 0;
                //最新存活位置
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                //最后存活位置
                this._lastAliveCursor = 0;
                this._forceUpdate = false;
                //原始顶点数量
                this._vertexStride = 0;
                //当前爆发的索引
                this._burstIndex = 0;
                //
                this._readEmitCount = 0;
                //最终重力
                this._finalGravity = new egret3d.Vector3();
            }
            /**
            * 计算粒子爆发数量
            * @param startTime
            * @param endTime
            */
            ParticleBatcher.prototype._getBurstCount = function (startTime, endTime) {
                var totalEmitCount = 0;
                var bursts = this._comp.emission.bursts;
                for (var l = bursts.length; this._burstIndex < l; this._burstIndex++) {
                    var burst = bursts[this._burstIndex];
                    if (burst.time >= startTime && burst.time < endTime) {
                        // totalEmitCount += numberLerp(burst.minCount, burst.maxCount, Math.random());
                        totalEmitCount += burst.maxCount;
                    }
                    else {
                        break;
                    }
                }
                return totalEmitCount;
            };
            /**
             * 判断粒子是否已经过期
             * @param particleIndex
             */
            ParticleBatcher.prototype._isParticleExpired = function (particleIndex) {
                var startTimeOffset = particleIndex * this._vertexStride * 2;
                return this._time - this._startTimeBuffer[startTimeOffset + 1] + 0.0001 > this._startTimeBuffer[startTimeOffset];
            };
            /**
             *
             * @param time 批量增加粒子
             * @param startCursor
             * @param endCursor
             */
            ParticleBatcher.prototype._addParticles = function (time, startCursor, count, lastEmittsionTime) {
                var comp = this._comp;
                var main = comp.main;
                var velocityModule = comp.velocityOverLifetime;
                var colorModule = comp.colorOverLifetime;
                var sizeModule = comp.sizeOverLifetime;
                var rotationModule = comp.rotationOverLifetime;
                var textureSheetModule = comp.textureSheetAnimation;
                var isVelocityRandom = velocityModule.enable && (velocityModule.mode === 3 /* TwoConstants */ || velocityModule.mode === 2 /* TwoCurves */);
                var isColorRandom = colorModule.enable && colorModule.color.mode === 3 /* TwoGradients */;
                var isSizeRandom = sizeModule.enable && (sizeModule.size.mode === 3 /* TwoConstants */ || sizeModule.size.mode === 2 /* TwoCurves */);
                var isRotationRandom = rotationModule.enable && (rotationModule.x.mode === 3 /* TwoConstants */ || rotationModule.x.mode === 2 /* TwoCurves */);
                var isTextureRandom = textureSheetModule.enable && (textureSheetModule.startFrame.mode === 3 /* TwoConstants */ || textureSheetModule.startFrame.mode === 2 /* TwoCurves */);
                var needRandom0 = isColorRandom || isSizeRandom || isRotationRandom || isTextureRandom;
                var worldPosition = this._worldPostionCache;
                var worldRotation = this._worldRotationCache;
                var isWorldSpace = main.simulationSpace === 1 /* World */;
                var startPositionBuffer = this._startPositionBuffer;
                var startVelocityBuffer = this._startVelocityBuffer;
                var startColorBuffer = this._startColorBuffer;
                var startSizeBuffer = this._startSizeBuffer;
                var startRotationBuffer = this._startRotationBuffer;
                var startTimeBuffer = this._startTimeBuffer;
                var random0Buffer = this._random0Buffer;
                var random1Buffer = this._random1Buffer;
                var worldPostionBuffer = this._worldPostionBuffer;
                var worldRoationBuffer = this._worldRoationBuffer;
                var age = Math.min(lastEmittsionTime / main.duration, 1.0);
                var vertexStride = this._vertexStride;
                var addCount = 0, startIndex = 0, endIndex = 0;
                var lifetime = 0.0;
                var startSpeed = 0.0;
                var randomVelocityX = 0.0, randomVelocityY = 0.0, randomVelocityZ = 0.0;
                var randomColor = 0.0, randomSize = 0.0, randomRotation = 0.0, randomTextureAnimation = 0.0;
                var vector2Offset = 0, vector3Offset = 0, vector4Offset = 0;
                while (addCount !== count) {
                    comp.shape.generatePositionAndDirection(positionHelper, velocityHelper);
                    main.startColor.evaluate(age, startColorHelper);
                    lifetime = main.startLifetime.evaluate(age);
                    startSpeed = main.startSpeed.evaluate(age);
                    velocityHelper.x *= startSpeed;
                    velocityHelper.y *= startSpeed;
                    velocityHelper.z *= startSpeed;
                    startSizeHelper.x = main.startSizeX.evaluate(age);
                    startSizeHelper.y = main.startSizeY.evaluate(age);
                    startSizeHelper.z = main.startSizeZ.evaluate(age);
                    startRotationHelper.x = main.startRotationX.evaluate(age);
                    startRotationHelper.y = main.startRotationY.evaluate(age);
                    startRotationHelper.z = main.startRotationZ.evaluate(age);
                    randomVelocityX = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityY = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityZ = isVelocityRandom ? Math.random() : 0.0;
                    randomColor = isColorRandom ? Math.random() : 0.0;
                    randomSize = isSizeRandom ? Math.random() : 0.0;
                    randomRotation = isRotationRandom ? Math.random() : 0.0;
                    randomTextureAnimation = isTextureRandom ? Math.random() : 0.0;
                    for (startIndex = startCursor * vertexStride, endIndex = startIndex + vertexStride; startIndex < endIndex; startIndex++) {
                        vector2Offset = startIndex * 2;
                        vector3Offset = startIndex * 3;
                        vector4Offset = startIndex * 4;
                        //
                        startPositionBuffer[vector3Offset] = positionHelper.x;
                        startPositionBuffer[vector3Offset + 1] = positionHelper.y;
                        startPositionBuffer[vector3Offset + 2] = positionHelper.z;
                        startVelocityBuffer[vector3Offset] = velocityHelper.x;
                        startVelocityBuffer[vector3Offset + 1] = velocityHelper.y;
                        startVelocityBuffer[vector3Offset + 2] = velocityHelper.z;
                        startColorBuffer[vector4Offset] = startColorHelper.r;
                        startColorBuffer[vector4Offset + 1] = startColorHelper.g;
                        startColorBuffer[vector4Offset + 2] = startColorHelper.b;
                        startColorBuffer[vector4Offset + 3] = startColorHelper.a;
                        startSizeBuffer[vector3Offset] = startSizeHelper.x;
                        startSizeBuffer[vector3Offset + 1] = startSizeHelper.y;
                        startSizeBuffer[vector3Offset + 2] = startSizeHelper.z;
                        startRotationBuffer[vector3Offset] = startRotationHelper.x;
                        startRotationBuffer[vector3Offset + 1] = startRotationHelper.y;
                        startRotationBuffer[vector3Offset + 2] = startRotationHelper.z;
                        startTimeBuffer[vector2Offset] = lifetime;
                        startTimeBuffer[vector2Offset + 1] = time;
                        //
                        if (needRandom0) {
                            random0Buffer[vector4Offset] = randomColor;
                            random0Buffer[vector4Offset + 1] = randomSize;
                            random0Buffer[vector4Offset + 2] = randomRotation;
                            random0Buffer[vector4Offset + 3] = randomTextureAnimation;
                        }
                        if (isVelocityRandom) {
                            random1Buffer[vector4Offset] = randomVelocityX;
                            random1Buffer[vector4Offset + 1] = randomVelocityY;
                            random1Buffer[vector4Offset + 2] = randomVelocityZ;
                            random1Buffer[vector4Offset + 3] = 0;
                        }
                        if (isWorldSpace) {
                            worldPostionBuffer[vector3Offset] = worldPosition.x;
                            worldPostionBuffer[vector3Offset + 1] = worldPosition.y;
                            worldPostionBuffer[vector3Offset + 2] = worldPosition.z;
                            worldRoationBuffer[vector4Offset] = worldRotation.x;
                            worldRoationBuffer[vector4Offset + 1] = worldRotation.y;
                            worldRoationBuffer[vector4Offset + 2] = worldRotation.z;
                            worldRoationBuffer[vector4Offset + 3] = worldRotation.w;
                        }
                    }
                    startCursor++;
                    if (startCursor >= main.maxParticles) {
                        startCursor = 0;
                    }
                    addCount++;
                }
                //TODO理论上应该是每帧更新，不过现在没有物理系统，先放到这里
                var gravityModifier = main.gravityModifier.constant;
                this._finalGravity.x = GRAVITY.x * gravityModifier;
                this._finalGravity.y = GRAVITY.y * gravityModifier;
                this._finalGravity.z = GRAVITY.z * gravityModifier;
            };
            ParticleBatcher.prototype._tryEmit = function () {
                if (!this._isParticleExpired(this._firstAliveCursor)) {
                    return false;
                }
                //
                var maxParticles = this._comp.main.maxParticles;
                var nextCursor = this._firstAliveCursor + 1 >= maxParticles ? 0 : this._firstAliveCursor + 1;
                //
                if (nextCursor === this._lastAliveCursor) {
                    this._forceUpdate = true;
                }
                this._firstAliveCursor = nextCursor;
                return true;
            };
            ParticleBatcher.prototype.clean = function () {
                this._time = 0.0;
                this._dirty = false;
                this._emittsionTime = 0.0;
                this._frameRateTime = 0.0;
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                this._lastAliveCursor = 0;
                this._forceUpdate = false;
                this._vertexStride = 0;
                this._vertexAttributes = null;
                this._burstIndex = 0;
                this._readEmitCount = 0;
                this._startPositionBuffer = null;
                this._startVelocityBuffer = null;
                this._startColorBuffer = null;
                this._startSizeBuffer = null;
                this._startRotationBuffer = null;
                this._startTimeBuffer = null;
                this._random0Buffer = null;
                this._random1Buffer = null;
                this._worldPostionBuffer = null;
                this._worldRoationBuffer = null;
                this._worldPostionCache = null;
                this._worldRotationCache = null;
                this._comp = null;
                this._renderer = null;
            };
            ParticleBatcher.prototype.resetTime = function () {
                this._burstIndex = 0;
                this._emittsionTime = 0;
                this._readEmitCount = 0;
            };
            ParticleBatcher.prototype.init = function (comp, renderer) {
                this._comp = comp;
                this._renderer = renderer;
                var mesh = particle.createBatchMesh(renderer, comp.main.maxParticles);
                this._vertexStride = renderer.renderMode === 4 /* Mesh */ ? renderer.mesh.vertexCount : 4;
                this._startPositionBuffer = mesh.getAttributes("_START_POSITION" /* _START_POSITION */);
                this._startVelocityBuffer = mesh.getAttributes("_START_VELOCITY" /* _START_VELOCITY */);
                this._startColorBuffer = mesh.getAttributes("_START_COLOR" /* _START_COLOR */);
                this._startSizeBuffer = mesh.getAttributes("_START_SIZE" /* _START_SIZE */);
                this._startRotationBuffer = mesh.getAttributes("_START_ROTATION" /* _START_ROTATION */);
                this._startTimeBuffer = mesh.getAttributes("_TIME" /* _TIME */);
                this._random0Buffer = mesh.getAttributes("_RANDOM0" /* _RANDOM0 */);
                this._random1Buffer = mesh.getAttributes("_RANDOM1" /* _RANDOM1 */);
                this._worldPostionBuffer = mesh.getAttributes("_WORLD_POSITION" /* _WORLD_POSITION */);
                this._worldRoationBuffer = mesh.getAttributes("_WORLD_ROTATION" /* _WORLD_ROTATION */);
                var primitive = mesh.glTFMesh.primitives[0];
                this._vertexAttributes = [];
                for (var k in primitive.attributes) {
                    this._vertexAttributes.push(k);
                }
                renderer.batchMesh = mesh;
                renderer.batchMaterial = renderer.materials[0].clone();
                mesh.uploadSubIndexBuffer();
            };
            ParticleBatcher.prototype.update = function (elapsedTime) {
                if (!this._comp || this._comp.isPaused) {
                    return;
                }
                //
                this._time += elapsedTime;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                while (this._lastAliveCursor !== this._firstAliveCursor || this._forceUpdate) {
                    if (!this._isParticleExpired(this._lastAliveCursor)) {
                        break;
                    }
                    this._forceUpdate = false;
                    this._lastAliveCursor++;
                    if (this._lastAliveCursor >= mainModule.maxParticles) {
                        this._lastAliveCursor = 0;
                    }
                }
                var transform = comp.gameObject.transform;
                this._worldPostionCache = transform.getPosition();
                this._worldRotationCache = transform.getRotation();
                if (comp._isPlaying && this._time >= mainModule.startDelay.constant && comp.emission.enable) {
                    this._updateEmission(elapsedTime);
                }
                this._updateRender();
            };
            ParticleBatcher.prototype._updateEmission = function (elapsedTime) {
                var comp = this._comp;
                var mainModule = comp.main;
                var lastEmittsionTime = this._emittsionTime;
                this._emittsionTime += elapsedTime;
                var isOver = this._emittsionTime > mainModule.duration;
                var aliveParticleCount = this.aliveParticleCount;
                var totalEmitCount = 0;
                if (!isOver) {
                    if (comp.emission.bursts.length > 0) {
                        this._readEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                    }
                }
                else {
                    if (mainModule.loop) {
                        this._readEmitCount = 0;
                        this._readEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                        this._emittsionTime -= mainModule.duration;
                        this._burstIndex = 0;
                        this._readEmitCount += this._getBurstCount(0, this._emittsionTime);
                    }
                    else {
                        comp.stop(false);
                    }
                }
                //
                for (var i = 0; i < this._readEmitCount; i++) {
                    if (this._tryEmit()) {
                        totalEmitCount++;
                        this._readEmitCount--;
                    }
                }
                var rateOverTime = comp.emission.rateOverTime.constant;
                if (rateOverTime > 0) {
                    var minEmissionTime = 1 / rateOverTime;
                    this._frameRateTime += elapsedTime;
                    while (this._frameRateTime > minEmissionTime) {
                        if (!this._tryEmit()) {
                            break;
                        }
                        totalEmitCount++;
                        this._frameRateTime -= minEmissionTime;
                    }
                }
                totalEmitCount = Math.min(mainModule.maxParticles - aliveParticleCount, totalEmitCount);
                if (totalEmitCount > 0) {
                    this._addParticles(this._time, this._lastFrameFirstCursor, totalEmitCount, lastEmittsionTime);
                    this._dirty = true;
                }
            };
            ParticleBatcher.prototype._updateRender = function () {
                var renderer = this._renderer;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                if (this._dirty) {
                    renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes);
                    // const bufferOffset = this._lastFrameFirstCursor * this._vertexStride;
                    // const bufferOffset = this._lastFrameFirstCursor;
                    // if (this._firstAliveCursor > this._lastFrameFirstCursor) {
                    //     const bufferCount = (this._firstAliveCursor - this._lastFrameFirstCursor) * this._vertexStride;
                    //     // const bufferCount = (this._firstAliveCursor - this._lastFrameFirstCursor);
                    //     renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, bufferCount);
                    // }
                    // else {
                    //     const addCount = mainModule._maxParticles - this._lastFrameFirstCursor;
                    //     renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, addCount * this._vertexStride);
                    //     renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, 0, this._firstAliveCursor * this._vertexStride);
                    //     // renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, addCount);
                    //     // renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, 0, this._firstAliveCursor);
                    // }
                    this._lastFrameFirstCursor = this._firstAliveCursor;
                    this._dirty = false;
                }
                var transform = comp.gameObject.transform;
                var material = renderer.batchMaterial;
                if (mainModule.simulationSpace === 0 /* Local */) {
                    material.setVector3("u_worldPosition" /* WORLD_POSITION */, this._worldPostionCache);
                    material.setVector4("u_worldRotation" /* WORLD_ROTATION */, this._worldRotationCache);
                }
                //
                switch (mainModule.scaleMode) {
                    case 1 /* Local */:
                        {
                            var scale = transform.getLocalScale();
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                    case 2 /* Shape */:
                        {
                            var scale = transform.getScale();
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, egret3d.Vector3.ONE);
                        }
                        break;
                    case 0 /* Hierarchy */:
                        {
                            var scale = transform.getScale();
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                }
                material.setFloat("u_currentTime" /* CURRENTTIME */, this._time);
                material.setVector3("u_gravity" /* GRAVIT */, this._finalGravity);
            };
            Object.defineProperty(ParticleBatcher.prototype, "aliveParticleCount", {
                get: function () {
                    if (this._firstAliveCursor >= this._lastAliveCursor) {
                        return this._firstAliveCursor - this._lastAliveCursor;
                    }
                    else {
                        return this._comp.main.maxParticles - this._lastAliveCursor + this._firstAliveCursor;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return ParticleBatcher;
        }());
        particle.ParticleBatcher = ParticleBatcher;
        __reflect(ParticleBatcher.prototype, "egret3d.particle.ParticleBatcher");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         * 粒子组件。
         */
        var ParticleComponent = (function (_super) {
            __extends(ParticleComponent, _super);
            function ParticleComponent() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * 主模块。
                 */
                _this.main = new particle.MainModule(_this);
                /**
                 * 发射模块。
                 */
                _this.emission = new particle.EmissionModule(_this);
                /**
                 * 发射形状模块。
                 */
                _this.shape = new particle.ShapeModule(_this);
                /**
                 * 速率变换模块。
                 */
                _this.velocityOverLifetime = new particle.VelocityOverLifetimeModule(_this);
                /**
                 * 旋转变换模块。
                 */
                _this.rotationOverLifetime = new particle.RotationOverLifetimeModule(_this);
                /**
                 * 尺寸变化模块。
                 */
                _this.sizeOverLifetime = new particle.SizeOverLifetimeModule(_this);
                /**
                 * 颜色变化模块。
                 */
                _this.colorOverLifetime = new particle.ColorOverLifetimeModule(_this);
                /**
                 * 序列帧变化模块。
                 */
                _this.textureSheetAnimation = new particle.TextureSheetAnimationModule(_this);
                /**
                 * @internal
                 */
                _this._isPlaying = false;
                /**
                 * @internal
                 */
                _this._isPaused = false;
                _this._batcher = new particle.ParticleBatcher();
                return _this;
            }
            ParticleComponent.prototype._clean = function (cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = false; }
                if (cleanPlayState) {
                    this._isPlaying = false;
                    this._isPaused = false;
                }
                this._batcher.clean();
            };
            ParticleComponent.prototype.initialize = function () {
                _super.prototype.initialize.call(this);
                this._clean();
            };
            ParticleComponent.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initBatcher = function (cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = false; }
                this._clean(cleanPlayState);
                this._batcher.init(this, this.gameObject.getComponent(particle.ParticleRenderer));
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.update = function (elapsedTime) {
                this._batcher.update(elapsedTime);
            };
            ParticleComponent.prototype.play = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (this._isPaused) {
                    this._isPaused = false;
                }
                else {
                    this._isPlaying = true;
                    this._isPaused = false;
                    this._batcher.resetTime();
                }
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                        var child = children_1[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.play(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.pause = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPaused = true;
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
                        var child = children_2[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.pause(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.stop = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPlaying = false;
                this._batcher.resetTime();
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                        var child = children_3[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.clear = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                        var child = children_4[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            Object.defineProperty(ParticleComponent.prototype, "isPlaying", {
                get: function () {
                    return this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPaused", {
                get: function () {
                    return this._isPaused;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isAlive", {
                get: function () {
                    return this._batcher.aliveParticleCount > 0 || this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "loop", {
                get: function () {
                    return this.main.loop;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "main", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "emission", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "shape", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "velocityOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "rotationOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "sizeOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "colorOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "textureSheetAnimation", void 0);
            return ParticleComponent;
        }(paper.BaseComponent));
        particle.ParticleComponent = ParticleComponent;
        __reflect(ParticleComponent.prototype, "egret3d.particle.ParticleComponent");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var _helpMatrix = egret3d.Matrix4.create();
        /**
         * 粒子渲染模式。
         */
        var ParticleRenderMode;
        (function (ParticleRenderMode) {
            ParticleRenderMode[ParticleRenderMode["Billboard"] = 0] = "Billboard";
            ParticleRenderMode[ParticleRenderMode["Stretch"] = 1] = "Stretch";
            ParticleRenderMode[ParticleRenderMode["HorizontalBillboard"] = 2] = "HorizontalBillboard";
            ParticleRenderMode[ParticleRenderMode["VerticalBillboard"] = 3] = "VerticalBillboard";
            ParticleRenderMode[ParticleRenderMode["Mesh"] = 4] = "Mesh";
            ParticleRenderMode[ParticleRenderMode["None"] = 5] = "None";
        })(ParticleRenderMode = particle.ParticleRenderMode || (particle.ParticleRenderMode = {}));
        /**
         * 粒子着色器的变量名。
         * @internal
         */
        var ParticleMaterialUniform;
        (function (ParticleMaterialUniform) {
            ParticleMaterialUniform["WORLD_POSITION"] = "u_worldPosition";
            ParticleMaterialUniform["WORLD_ROTATION"] = "u_worldRotation";
            ParticleMaterialUniform["POSITION_SCALE"] = "u_positionScale";
            ParticleMaterialUniform["SIZE_SCALE"] = "u_sizeScale";
            ParticleMaterialUniform["SCALING_MODE"] = "u_scalingMode";
            ParticleMaterialUniform["GRAVIT"] = "u_gravity";
            ParticleMaterialUniform["START_ROTATION3D"] = "u_startRotation3D";
            ParticleMaterialUniform["SIMULATION_SPACE"] = "u_simulationSpace";
            ParticleMaterialUniform["CURRENTTIME"] = "u_currentTime";
            ParticleMaterialUniform["ALPHAS_GRADIENT"] = "u_alphaGradient[0]";
            ParticleMaterialUniform["COLOR_GRADIENT"] = "u_colorGradient[0]";
            ParticleMaterialUniform["ALPHA_GRADIENT_MAX"] = "u_alphaGradientMax[0]";
            ParticleMaterialUniform["COLOR_GRADIENT_MAX"] = "u_colorGradientMax[0]";
            ParticleMaterialUniform["VELOCITY_CONST"] = "u_velocityConst";
            ParticleMaterialUniform["VELOCITY_CURVE_X"] = "u_velocityCurveX[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_Y"] = "u_velocityCurveY[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_Z"] = "u_velocityCurveZ[0]";
            ParticleMaterialUniform["VELOCITY_CONST_MAX"] = "u_velocityConstMax";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_X"] = "u_velocityCurveMaxX[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_Y"] = "u_velocityCurveMaxY[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_Z"] = "u_velocityCurveMaxZ[0]";
            ParticleMaterialUniform["SPACE_TYPE"] = "u_spaceType";
            ParticleMaterialUniform["SIZE_CURVE"] = "u_sizeCurve[0]";
            ParticleMaterialUniform["SIZE_CURVE_X"] = "u_sizeCurveX[0]";
            ParticleMaterialUniform["SIZE_CURVE_Y"] = "u_sizeCurveY[0]";
            ParticleMaterialUniform["SIZE_CURVE_Z"] = "u_sizeCurveZ[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX"] = "u_sizeCurveMax[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_X"] = "u_sizeCurveMaxX[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_Y"] = "u_sizeCurveMaxY[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_Z"] = "u_sizeCurveMaxZ[0]";
            ParticleMaterialUniform["ROTATION_CONST"] = "u_rotationConst";
            ParticleMaterialUniform["ROTATION_CONST_SEPRARATE"] = "u_rotationConstSeprarate";
            ParticleMaterialUniform["ROTATION_CURVE"] = "u_rotationCurve[0]";
            ParticleMaterialUniform["ROTATE_CURVE_X"] = "u_rotationCurveX[0]";
            ParticleMaterialUniform["ROTATE_CURVE_y"] = "u_rotationCurveY[0]";
            ParticleMaterialUniform["ROTATE_CURVE_Z"] = "u_rotationCurveZ[0]";
            ParticleMaterialUniform["ROTATE_CURVE_W"] = "u_rotationCurveW[0]";
            ParticleMaterialUniform["ROTATION_CONST_MAX"] = "u_rotationConstMax";
            ParticleMaterialUniform["ROTATION_CONST_MAX_SEPRARATE"] = "u_rotationConstMaxSeprarate";
            ParticleMaterialUniform["ROTATION_CURVE_MAX"] = "u_rotationCurveMax[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_X"] = "u_rotationCurveMaxX[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_Y"] = "u_rotationCurveMaxY[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_Z"] = "u_rotationCurveMaxZ[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_W"] = "u_rotationCurveMaxW[0]";
            ParticleMaterialUniform["CYCLES"] = "u_cycles";
            ParticleMaterialUniform["SUB_UV"] = "u_subUV";
            ParticleMaterialUniform["UV_CURVE"] = "u_uvCurve[0]";
            ParticleMaterialUniform["UV_CURVE_MAX"] = "u_uvCurveMax[0]";
            ParticleMaterialUniform["LENGTH_SCALE"] = "u_lengthScale";
            ParticleMaterialUniform["SPEED_SCALE"] = "u_speeaScale";
        })(ParticleMaterialUniform = particle.ParticleMaterialUniform || (particle.ParticleMaterialUniform = {}));
        /**
         * 粒子着色器的宏定义。
         * @internal
         */
        var ParticleMaterialDefine;
        (function (ParticleMaterialDefine) {
            ParticleMaterialDefine["SPHERHBILLBOARD"] = "SPHERHBILLBOARD";
            ParticleMaterialDefine["STRETCHEDBILLBOARD"] = "STRETCHEDBILLBOARD";
            ParticleMaterialDefine["HORIZONTALBILLBOARD"] = "HORIZONTALBILLBOARD";
            ParticleMaterialDefine["VERTICALBILLBOARD"] = "VERTICALBILLBOARD";
            ParticleMaterialDefine["ROTATIONOVERLIFETIME"] = "ROTATIONOVERLIFETIME";
            ParticleMaterialDefine["ROTATIONCONSTANT"] = "ROTATIONCONSTANT";
            ParticleMaterialDefine["ROTATIONTWOCONSTANTS"] = "ROTATIONTWOCONSTANTS";
            ParticleMaterialDefine["ROTATIONSEPERATE"] = "ROTATIONSEPERATE";
            ParticleMaterialDefine["ROTATIONCURVE"] = "ROTATIONCURVE";
            ParticleMaterialDefine["ROTATIONTWOCURVES"] = "ROTATIONTWOCURVES";
            ParticleMaterialDefine["TEXTURESHEETANIMATIONCURVE"] = "TEXTURESHEETANIMATIONCURVE";
            ParticleMaterialDefine["TEXTURESHEETANIMATIONTWOCURVE"] = "TEXTURESHEETANIMATIONTWOCURVE";
            ParticleMaterialDefine["VELOCITYCONSTANT"] = "VELOCITYCONSTANT";
            ParticleMaterialDefine["VELOCITYCURVE"] = "VELOCITYCURVE";
            ParticleMaterialDefine["VELOCITYTWOCONSTANT"] = "VELOCITYTWOCONSTANT";
            ParticleMaterialDefine["VELOCITYTWOCURVE"] = "VELOCITYTWOCURVE";
            ParticleMaterialDefine["COLOROGRADIENT"] = "COLOROGRADIENT";
            ParticleMaterialDefine["COLORTWOGRADIENTS"] = "COLORTWOGRADIENTS";
            ParticleMaterialDefine["SIZECURVE"] = "SIZECURVE";
            ParticleMaterialDefine["SIZETWOCURVES"] = "SIZETWOCURVES";
            ParticleMaterialDefine["SIZECURVESEPERATE"] = "SIZECURVESEPERATE";
            ParticleMaterialDefine["SIZETWOCURVESSEPERATE"] = "SIZETWOCURVESSEPERATE";
            ParticleMaterialDefine["RENDERMESH"] = "RENDERMESH";
            ParticleMaterialDefine["SHAPE"] = "SHAPE";
        })(ParticleMaterialDefine = particle.ParticleMaterialDefine || (particle.ParticleMaterialDefine = {}));
        /**
         * 粒子渲染器。
         */
        var ParticleRenderer = (function (_super) {
            __extends(ParticleRenderer, _super);
            function ParticleRenderer() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * TODO
                 */
                _this.frustumCulled = false;
                _this._renderMode = 0 /* Billboard */;
                return _this;
            }
            ParticleRenderer.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._mesh = null;
                this._renderMode = 0 /* Billboard */;
                this.velocityScale = 1.0;
                this.lengthScale = 1.0;
            };
            ParticleRenderer.prototype.recalculateAABB = function () {
                this._aabb.copy(egret3d.AABB.ONE);
            };
            ParticleRenderer.prototype.raycast = function (p1, p2, p3) {
                var raycastMesh = false;
                var raycastInfo = undefined;
                var worldMatrix = this.gameObject.transform.worldMatrix;
                var localRay = egret3d.helpRay.applyMatrix(_helpMatrix.inverse(worldMatrix), p1); // TODO transform inverse world matrix.
                var aabb = this.aabb;
                if (p2) {
                    if (p2 === true) {
                        raycastMesh = true;
                    }
                    else {
                        raycastMesh = p3 || false;
                        raycastInfo = p2;
                    }
                }
                if (aabb.raycast(localRay, raycastInfo)) {
                    if (raycastInfo) {
                        raycastInfo.position.applyMatrix(worldMatrix);
                        raycastInfo.distance = p1.origin.getDistance(raycastInfo.position);
                    }
                    return true;
                }
                return false;
            };
            Object.defineProperty(ParticleRenderer.prototype, "renderMode", {
                /**
                 *
                 */
                get: function () {
                    return this._renderMode;
                },
                set: function (value) {
                    if (this._renderMode === value) {
                        return;
                    }
                    this._renderMode = value;
                    ParticleRenderer.onRenderModeChanged.dispatch(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "mesh", {
                /**
                 *
                 */
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh === mesh) {
                        return;
                    }
                    this._mesh = mesh;
                    ParticleRenderer.onMeshChanged.dispatch(this);
                },
                enumerable: true,
                configurable: true
            });
            /**
             * 渲染模式改变
             */
            ParticleRenderer.onRenderModeChanged = new signals.Signal();
            /**
             * TODO
             */
            ParticleRenderer.onVelocityScaleChanged = new signals.Signal();
            /**
             * TODO
             */
            ParticleRenderer.onLengthScaleChanged = new signals.Signal();
            /**
             *
             */
            ParticleRenderer.onMeshChanged = new signals.Signal();
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "velocityScale", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "lengthScale", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_renderMode", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_mesh", void 0);
            __decorate([
                paper.editor.property("MESH" /* MESH */)
            ], ParticleRenderer.prototype, "mesh", null);
            return ParticleRenderer;
        }(paper.BaseRenderer));
        particle.ParticleRenderer = ParticleRenderer;
        __reflect(ParticleRenderer.prototype, "egret3d.particle.ParticleRenderer");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         *
         */
        var ParticleSystem = (function (_super) {
            __extends(ParticleSystem, _super);
            function ParticleSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._interests = [
                    {
                        componentClass: particle.ParticleComponent,
                        listeners: [
                            { type: particle.onStartRotation3DChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onStartRotation3DChanged); } },
                            { type: particle.onSimulationSpaceChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onSimulationSpaceChanged); } },
                            { type: particle.onScaleModeChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onScaleModeChanged); } },
                            { type: particle.onVelocityChanged, listener: _this._onVelocityOverLifetime.bind(_this) },
                            { type: particle.onColorChanged, listener: _this._onColorOverLifetime.bind(_this) },
                            { type: particle.onSizeChanged, listener: _this._onSizeOverLifetime.bind(_this) },
                            { type: particle.onRotationChanged, listener: _this._onRotationOverLifetime.bind(_this) },
                            { type: particle.onTextureSheetChanged, listener: _this._onTextureSheetAnimation.bind(_this) },
                        ]
                    },
                    {
                        componentClass: particle.ParticleRenderer,
                        listeners: [
                            { type: particle.ParticleRenderer.onMeshChanged, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: particle.ParticleRenderer.onMaterialsChanged, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            // { type: ParticleRendererEventType.LengthScaleChanged, listener: (comp: ParticleRenderer) => { this._onRenderUpdate(comp, ParticleRendererEventType.LengthScaleChanged); } },
                            // { type: ParticleRendererEventType.VelocityScaleChanged, listener: (comp: ParticleRenderer) => { this._onRenderUpdate(comp, ParticleRendererEventType.VelocityScaleChanged); } },
                            { type: particle.ParticleRenderer.onRenderModeChanged, listener: function (comp) { _this._onRenderUpdate(comp, particle.ParticleRenderer.onRenderModeChanged); } },
                        ]
                    }
                ];
                _this._drawCallCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCallCollecter);
                return _this;
            }
            /**
            * Buffer改变的时候，有可能是初始化，也有可能是mesh改变，此时全部刷一下
            */
            ParticleSystem.prototype._onUpdateBatchMesh = function (comp, cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = true; }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                comp.initBatcher(cleanPlayState);
                //
                this._onRenderUpdate(renderer, particle.ParticleRenderer.onRenderModeChanged);
                this._onRenderUpdate(renderer, particle.ParticleRenderer.onVelocityScaleChanged);
                this._onRenderUpdate(renderer, particle.ParticleRenderer.onLengthScaleChanged);
                //
                this._onMainUpdate(comp, particle.onStartRotation3DChanged);
                this._onMainUpdate(comp, particle.onSimulationSpaceChanged);
                this._onMainUpdate(comp, particle.onScaleModeChanged);
                this._onShapeChanged(comp);
                this._onVelocityOverLifetime(comp);
                this._onColorOverLifetime(comp);
                this._onSizeOverLifetime(comp);
                this._onRotationOverLifetime(comp);
                this._onTextureSheetAnimation(comp);
            };
            ParticleSystem.prototype._onRenderUpdate = function (render, type) {
                if (!this._enabled || !this._groups[0].hasGameObject(render.gameObject)) {
                    return;
                }
                var material = render.batchMaterial;
                switch (type) {
                    case particle.ParticleRenderer.onRenderModeChanged: {
                        this._onRenderMode(render);
                        break;
                    }
                    case particle.ParticleRenderer.onLengthScaleChanged: {
                        material.setFloat("u_lengthScale" /* LENGTH_SCALE */, render.lengthScale);
                        break;
                    }
                    case particle.ParticleRenderer.onVelocityScaleChanged: {
                        material.setFloat("u_speeaScale" /* SPEED_SCALE */, render.velocityScale);
                        break;
                    }
                }
            };
            /**
             *
             * @param render 渲染模式改变
             */
            ParticleSystem.prototype._onRenderMode = function (render) {
                var material = render.batchMaterial;
                material.removeDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                material.removeDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                material.removeDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                material.removeDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                material.removeDefine("RENDERMESH" /* RENDERMESH */);
                var mode = render.renderMode;
                switch (mode) {
                    case 0 /* Billboard */: {
                        material.addDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                        break;
                    }
                    case 1 /* Stretch */: {
                        material.addDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                        break;
                    }
                    case 2 /* HorizontalBillboard */: {
                        material.addDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                        break;
                    }
                    case 3 /* VerticalBillboard */: {
                        material.addDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                        break;
                    }
                    case 4 /* Mesh */: {
                        material.addDefine("RENDERMESH" /* RENDERMESH */);
                        break;
                    }
                    default: {
                        throw "_onRenderMode:invalid renderMode";
                    }
                }
            };
            ParticleSystem.prototype._onMainUpdate = function (component, type) {
                if (!this._enabled || !this._groups[0].hasGameObject(component.gameObject)) {
                    return;
                }
                var renderer = component.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                var mainModule = component.main;
                switch (type) {
                    case particle.onStartRotation3DChanged: {
                        material.setBoolean("u_startRotation3D" /* START_ROTATION3D */, mainModule.startRotation3D);
                        break;
                    }
                    case particle.onSimulationSpaceChanged: {
                        material.setInt("u_simulationSpace" /* SIMULATION_SPACE */, mainModule.simulationSpace);
                        break;
                    }
                    case particle.onScaleModeChanged: {
                        material.setInt("u_scalingMode" /* SCALING_MODE */, mainModule.scaleMode);
                        break;
                    }
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onShapeChanged = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("SHAPE" /* SHAPE */);
                if (comp.shape.enable) {
                    material.addDefine("SHAPE" /* SHAPE */);
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onVelocityOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                material.removeDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                material.removeDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                material.removeDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                var velocityModule = comp.velocityOverLifetime;
                if (velocityModule.enable) {
                    var mode = velocityModule.mode;
                    switch (mode) {
                        case 0 /* Constant */: {
                            material.addDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                            //
                            var vec3 = new egret3d.Vector3(velocityModule.x.evaluate(), velocityModule.y.evaluate(), velocityModule.z.evaluate());
                            material.setVector3("u_velocityConst" /* VELOCITY_CONST */, vec3);
                            break;
                        }
                        case 1 /* Curve */: {
                            material.addDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                            //
                            material.setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule.x.curve.floatValues);
                            material.setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule.y.curve.floatValues);
                            material.setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule.z.curve.floatValues);
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            material.addDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                            //
                            var minVec3 = new egret3d.Vector3(velocityModule.x.constantMin, velocityModule.y.constantMin, velocityModule.z.constantMin);
                            var maxVec3 = new egret3d.Vector3(velocityModule.x.constantMax, velocityModule.y.constantMax, velocityModule.z.constantMax);
                            material.setVector3("u_velocityConst" /* VELOCITY_CONST */, minVec3);
                            material.setVector3("u_velocityConstMax" /* VELOCITY_CONST_MAX */, maxVec3);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                            //
                            material.setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule.x.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule.y.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule.z.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveMaxX[0]" /* VELOCITY_CURVE_MAX_X */, velocityModule.x.curveMax.floatValues);
                            material.setVector2v("u_velocityCurveMaxY[0]" /* VELOCITY_CURVE_MAX_Y */, velocityModule.y.curveMax.floatValues);
                            material.setVector2v("u_velocityCurveMaxZ[0]" /* VELOCITY_CURVE_MAX_Z */, velocityModule.z.curveMax.floatValues);
                            break;
                        }
                    }
                    material.setInt("u_spaceType" /* SPACE_TYPE */, velocityModule.space);
                }
            };
            /**
             * 更新颜色模块
             * @param component
             */
            ParticleSystem.prototype._onColorOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                material.removeDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                var colorModule = comp.colorOverLifetime;
                if (colorModule.enable) {
                    var color = colorModule.color;
                    switch (color.mode) {
                        case 1 /* Gradient */: {
                            material.addDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                            //
                            material.setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradient.alphaValues);
                            material.setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradient.colorValues);
                            break;
                        }
                        case 3 /* TwoGradients */: {
                            material.addDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                            //
                            material.setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradientMin.alphaValues);
                            material.setVector2v("u_alphaGradientMax[0]" /* ALPHA_GRADIENT_MAX */, color.gradientMax.alphaValues);
                            material.setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradientMin.colorValues);
                            material.setVector4v("u_colorGradientMax[0]" /* COLOR_GRADIENT_MAX */, color.gradientMax.colorValues);
                            break;
                        }
                    }
                }
            };
            /**
             * 更新大小模块
             * @param component
             */
            ParticleSystem.prototype._onSizeOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("SIZECURVE" /* SIZECURVE */);
                material.removeDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                material.removeDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                material.removeDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                var sizeModule = comp.sizeOverLifetime;
                if (sizeModule.enable) {
                    var separateAxes = sizeModule.separateAxes;
                    var mode = sizeModule.x.mode;
                    switch (mode) {
                        case 1 /* Curve */: {
                            if (separateAxes) {
                                material.addDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                                //
                                material.setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule.x.curve.floatValues);
                                material.setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule.y.curve.floatValues);
                                material.setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule.z.curve.floatValues);
                            }
                            else {
                                material.addDefine("SIZECURVE" /* SIZECURVE */);
                                //
                                material.setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule.size.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            if (separateAxes) {
                                material.addDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                                //
                                material.setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule.x.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule.y.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule.z.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveMaxX[0]" /* SIZE_CURVE_MAX_X */, sizeModule.x.curveMax.floatValues);
                                material.setVector2v("u_sizeCurveMaxY[0]" /* SIZE_CURVE_MAX_Y */, sizeModule.y.curveMax.floatValues);
                                material.setVector2v("u_sizeCurveMaxZ[0]" /* SIZE_CURVE_MAX_Z */, sizeModule.z.curveMax.floatValues);
                            }
                            else {
                                material.addDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                                //
                                material.setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule.size.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveMax[0]" /* SIZE_CURVE_MAX */, sizeModule.size.curveMax.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            /**
             * 更新旋转模块
             * @param comp
             */
            ParticleSystem.prototype._onRotationOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                material.removeDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                material.removeDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                material.removeDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                material.removeDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                material.removeDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                var rotationModule = comp.rotationOverLifetime;
                if (rotationModule.enable) {
                    var mode = comp.rotationOverLifetime.x.mode;
                    var separateAxes = rotationModule.separateAxes;
                    if (separateAxes) {
                        material.addDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                    }
                    else {
                        material.addDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                    }
                    switch (mode) {
                        case 0 /* Constant */: {
                            material.addDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                            //
                            if (separateAxes) {
                                material.setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule.x.constant, rotationModule.y.constant, rotationModule.z.constant));
                            }
                            else {
                                material.setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule.z.constant);
                            }
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            material.addDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                            //
                            if (separateAxes) {
                                material.setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule.x.constantMin, rotationModule.y.constantMin, rotationModule.z.constantMin));
                                material.setVector3("u_rotationConstMaxSeprarate" /* ROTATION_CONST_MAX_SEPRARATE */, new egret3d.Vector3(rotationModule.x.constantMax, rotationModule.y.constantMax, rotationModule.z.constantMax));
                            }
                            else {
                                material.setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule.z.constantMin);
                                material.setFloat("u_rotationConstMax" /* ROTATION_CONST_MAX */, rotationModule.z.constantMax);
                            }
                            break;
                        }
                        case 1 /* Curve */: {
                            material.addDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                            //
                            if (separateAxes) {
                                material.setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule.x.curve.floatValues);
                                material.setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule.y.curve.floatValues);
                                material.setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule.z.curve.floatValues);
                            }
                            else {
                                material.setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule.z.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                            //
                            if (separateAxes) {
                                material.setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule.x.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule.y.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule.z.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveMaxX[0]" /* ROTATION_CURVE_MAX_X */, rotationModule.x.curveMax.floatValues);
                                material.setVector2v("u_rotationCurveMaxY[0]" /* ROTATION_CURVE_MAX_Y */, rotationModule.y.curveMax.floatValues);
                                material.setVector2v("u_rotationCurveMaxZ[0]" /* ROTATION_CURVE_MAX_Z */, rotationModule.z.curveMax.floatValues);
                            }
                            else {
                                material.setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule.z.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveMax[0]" /* ROTATION_CURVE_MAX */, rotationModule.z.curveMin.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            ParticleSystem.prototype._onTextureSheetAnimation = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                material.removeDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                var module = comp.textureSheetAnimation;
                if (module.enable) {
                    var type = module.frameOverTime.mode;
                    switch (type) {
                        case 1 /* Curve */: {
                            material.addDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                            //
                            material.setVector2v("u_uvCurve[0]" /* UV_CURVE */, module.frameOverTime.curve.floatValues);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                            //
                            material.setVector2v("u_uvCurve[0]" /* UV_CURVE */, module.frameOverTime.curveMin.floatValues);
                            material.setVector2v("u_uvCurveMax[0]" /* UV_CURVE_MAX */, module.frameOverTime.curveMax.floatValues);
                            break;
                        }
                    }
                    if (type === 1 /* Curve */ || type === 2 /* TwoCurves */) {
                        material.setFloat("u_cycles" /* CYCLES */, module.cycleCount);
                        material.setVector4v("u_subUV" /* SUB_UV */, module.floatValues);
                    }
                }
            };
            ParticleSystem.prototype._updateDrawCalls = function (gameObject, cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = true; }
                if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                    return;
                }
                var drawCallCollecter = this._drawCallCollecter;
                var component = gameObject.getComponent(particle.ParticleComponent);
                var renderer = gameObject.getComponent(particle.ParticleRenderer);
                //
                this._onUpdateBatchMesh(component, cleanPlayState);
                drawCallCollecter.removeDrawCalls(renderer);
                if (!renderer.batchMesh || !renderer.batchMaterial) {
                    return;
                }
                if (renderer.renderMode === 5 /* None */) {
                    console.error("ParticleSystem : error renderMode");
                }
                renderer.batchMesh._createBuffer();
                this._drawCallCollecter.renderers.push(renderer);
                //
                var subMeshIndex = 0;
                for (var _i = 0, _a = renderer.batchMesh.glTFMesh.primitives; _i < _a.length; _i++) {
                    var _primitive = _a[_i];
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.renderer = renderer;
                    drawCall.subMeshIndex = subMeshIndex++;
                    drawCall.mesh = renderer.batchMesh;
                    drawCall.material = renderer.batchMaterial || egret3d.DefaultMaterials.MISSING,
                        drawCallCollecter.drawCalls.push(drawCall);
                }
            };
            ParticleSystem.prototype.onEnable = function () {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    this._updateDrawCalls(gameObject);
                }
            };
            ParticleSystem.prototype.onAddGameObject = function (gameObject, _group) {
                this._updateDrawCalls(gameObject, false);
                var component = gameObject.getComponent(particle.ParticleComponent);
                if (component.main.playOnAwake) {
                    component.play();
                }
            };
            ParticleSystem.prototype.onRemoveGameObject = function (gameObject) {
                this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
                // component.stop();
            };
            ParticleSystem.prototype.onUpdate = function (deltaTime) {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    gameObject.getComponent(particle.ParticleComponent).update(deltaTime);
                }
            };
            ParticleSystem.prototype.onDisable = function () {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
                }
            };
            return ParticleSystem;
        }(paper.BaseSystem));
        particle.ParticleSystem = ParticleSystem;
        __reflect(ParticleSystem.prototype, "egret3d.particle.ParticleSystem");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
// namespace egret3d {
//     export class Audio extends paper.BaseComponent {
//     }
// } 
var egret3d;
(function (egret3d) {
    var _pattern = /#include +<([\w\d.]+)>/g;
    var _browserPrefixes = [
        "",
        "MOZ_",
        "OP_",
        "WEBKIT_",
    ];
    function _getExtension(gl, name) {
        for (var _i = 0, _browserPrefixes_1 = _browserPrefixes; _i < _browserPrefixes_1.length; _i++) {
            var prefixedName = _browserPrefixes_1[_i];
            var extension = gl.getExtension(prefixedName + name);
            if (extension) {
                return extension;
            }
        }
        return null;
    }
    function _getMaxShaderPrecision(gl, precision) {
        if (precision === void 0) { precision = "highp"; }
        if (precision === "highp") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                return "highp";
            }
            precision = "mediump";
        }
        if (precision === "mediump") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                return "mediump";
            }
        }
        return "lowp";
    }
    function _getConstDefines(maxPrecision) {
        var defines = "precision " + maxPrecision + " float; \n";
        defines += "precision " + maxPrecision + " int; \n";
        // defines += "#extension GL_OES_standard_derivatives : enable \n";
        return defines;
    }
    function _replace(_match, include) {
        if (!(include in egret3d.ShaderChunk)) {
            throw new Error("Can not resolve #include <" + include + ">");
        }
        return _parseIncludes(egret3d.ShaderChunk[include]);
    }
    function _parseIncludes(string) {
        return string.replace(_pattern, _replace);
    }
    function _getWebGLShader(type, webgl, gltfShader, defines) {
        var shader = webgl.createShader(type);
        webgl.shaderSource(shader, defines + _parseIncludes(gltfShader.uri));
        webgl.compileShader(shader);
        var parameter = webgl.getShaderParameter(shader, webgl.COMPILE_STATUS);
        if (!parameter) {
            if (confirm("Shader compile:" + gltfShader.name + " error! ->" + webgl.getShaderInfoLog(shader) + "\n" + ". did you want see the code?")) {
                alert(gltfShader.uri);
            }
            webgl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    function _extractAttributes(webgl, program) {
        var webglProgram = program.program;
        var attributes = program.attributes;
        var totalAttributes = webgl.getProgramParameter(webglProgram, webgl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < totalAttributes; i++) {
            var attribData = webgl.getActiveAttrib(webglProgram, i);
            var location_1 = webgl.getAttribLocation(webglProgram, attribData.name);
            attributes.push({ name: attribData.name, type: attribData.type, size: attribData.size, location: location_1 });
        }
    }
    function _extractUniforms(webgl, program, technique) {
        var webglProgram = program.program;
        var contextUniforms = program.contextUniforms;
        var uniforms = program.uniforms;
        var totalUniforms = webgl.getProgramParameter(webglProgram, webgl.ACTIVE_UNIFORMS);
        for (var i = 0; i < totalUniforms; i++) {
            var uniformData = webgl.getActiveUniform(webglProgram, i);
            var techniqueUniform = technique.uniforms[uniformData.name];
            var location_2 = webgl.getUniformLocation(webglProgram, uniformData.name);
            if (!techniqueUniform) {
                console.error("缺少Uniform定义：" + uniformData.name);
            }
            if (techniqueUniform.semantic) {
                contextUniforms.push({ name: uniformData.name, type: uniformData.type, size: uniformData.size, location: location_2 });
            }
            else {
                uniforms.push({ name: uniformData.name, type: uniformData.type, size: uniformData.size, location: location_2 });
            }
        }
    }
    function _extractTextureUnits(program) {
        var activeUniforms = program.contextUniforms.concat(program.uniforms);
        var samplerArrayKeys = [];
        var samplerKeys = [];
        //排序
        for (var _i = 0, activeUniforms_1 = activeUniforms; _i < activeUniforms_1.length; _i++) {
            var uniform = activeUniforms_1[_i];
            var key = uniform.name;
            if (uniform.type === 35678 /* SAMPLER_2D */ || uniform.type === 35680 /* SAMPLER_CUBE */) {
                if (key.indexOf("[") > -1) {
                    samplerArrayKeys.push(key);
                }
                else {
                    samplerKeys.push(key);
                }
            }
        }
        var textureUint = 0;
        var allKeys = samplerKeys.concat(samplerArrayKeys);
        for (var _a = 0, activeUniforms_2 = activeUniforms; _a < activeUniforms_2.length; _a++) {
            var uniform = activeUniforms_2[_a];
            if (allKeys.indexOf(uniform.name) < 0) {
                continue;
            }
            if (!uniform.textureUnits) {
                uniform.textureUnits = [];
            }
            uniform.textureUnits.length = uniform.size;
            for (var i = 0; i < uniform.size; i++) {
                uniform.textureUnits[i] = textureUint++;
            }
        }
    }
    /**
     * @private
     */
    var WebGLCapabilities = (function (_super) {
        __extends(WebGLCapabilities, _super);
        function WebGLCapabilities() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.precision = "highp";
            return _this;
        }
        WebGLCapabilities.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this);
            WebGLCapabilities.canvas = config.canvas;
            WebGLCapabilities.webgl = config.webgl;
            var webgl = WebGLCapabilities.webgl;
            if (!webgl) {
                return;
            }
            this.version = parseFloat(/^WebGL\ ([0-9])/.exec(webgl.getParameter(webgl.VERSION))[1]);
            this.maxPrecision = _getMaxShaderPrecision(webgl, this.precision);
            this.maxTextures = webgl.getParameter(webgl.MAX_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = webgl.getParameter(webgl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.maxTextureSize = webgl.getParameter(webgl.MAX_TEXTURE_SIZE);
            this.maxCubemapSize = webgl.getParameter(webgl.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxVertexUniformVectors = webgl.getParameter(webgl.MAX_VERTEX_UNIFORM_VECTORS);
            this.floatTextures = !!_getExtension(webgl, "OES_texture_float");
            this.anisotropyExt = _getExtension(webgl, "EXT_texture_filter_anisotropic");
            this.shaderTextureLOD = _getExtension(webgl, "EXT_shader_texture_lod");
            this.maxAnisotropy = (this.anisotropyExt !== null) ? webgl.getParameter(this.anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            // use dfdx and dfdy must enable OES_standard_derivatives
            _getExtension(webgl, "OES_standard_derivatives");
            // GL_OES_standard_derivatives
            _getExtension(webgl, "GL_OES_standard_derivatives");
            //TODO
            WebGLCapabilities.commonDefines = _getConstDefines(this.maxPrecision);
            egret3d.SkinnedMeshRendererSystem.maxBoneCount = Math.floor((this.maxVertexUniformVectors - 20) / 4);
            console.info("WebGL version:", this.version);
            console.info("Maximum shader precision:", this.maxPrecision);
            console.info("Maximum texture count:", this.maxTextures);
            console.info("Maximum vertex texture count:", this.maxVertexTextures);
            console.info("Maximum texture size:", this.maxTextureSize);
            console.info("Maximum cube map texture size:", this.maxCubemapSize);
            console.info("Maximum vertex uniform vectors:", this.maxVertexUniformVectors);
            console.info("Maximum GPU skinned bone count:", egret3d.SkinnedMeshRendererSystem.maxBoneCount);
        };
        /**
         * @deprecated
         */
        WebGLCapabilities.canvas = null;
        /**
         * @deprecated
         */
        WebGLCapabilities.webgl = null;
        WebGLCapabilities.commonDefines = "";
        return WebGLCapabilities;
    }(paper.SingletonComponent));
    egret3d.WebGLCapabilities = WebGLCapabilities;
    __reflect(WebGLCapabilities.prototype, "egret3d.WebGLCapabilities");
    /**
     * @private
     */
    var WebGLRenderState = (function (_super) {
        __extends(WebGLRenderState, _super);
        function WebGLRenderState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._stateEnables = [3042 /* BLEND */, 2884 /* CULL_FACE */, 2929 /* DEPTH_TEST */]; // TODO
            _this._programs = {};
            _this._vsShaders = {};
            _this._fsShaders = {};
            _this._cacheStateEnable = {};
            _this._cacheProgram = null;
            _this._cacheState = null;
            return _this;
        }
        WebGLRenderState.prototype._getWebGLProgram = function (vs, fs, customDefines) {
            var webgl = WebGLCapabilities.webgl;
            var program = webgl.createProgram();
            var key = vs.name + customDefines;
            var vertexShader = this._vsShaders[key];
            if (!vertexShader) {
                vertexShader = _getWebGLShader(webgl.VERTEX_SHADER, webgl, vs, WebGLCapabilities.commonDefines + customDefines + egret3d.ShaderChunk.common_vert_def);
                this._vsShaders[key] = vertexShader;
            }
            key = fs.name + customDefines;
            var fragmentShader = this._fsShaders[key];
            if (!fragmentShader) {
                fragmentShader = _getWebGLShader(webgl.FRAGMENT_SHADER, webgl, fs, WebGLCapabilities.commonDefines + customDefines + egret3d.ShaderChunk.common_frag_def);
                this._fsShaders[key] = fragmentShader;
            }
            webgl.attachShader(program, vertexShader);
            webgl.attachShader(program, fragmentShader);
            webgl.linkProgram(program);
            var parameter = webgl.getProgramParameter(program, webgl.LINK_STATUS);
            if (!parameter) {
                alert("program compile: " + vs.name + "_" + fs.name + " error! ->" + webgl.getProgramInfoLog(program));
                webgl.deleteProgram(program);
                return null;
            }
            return program;
        };
        WebGLRenderState.prototype.clearState = function () {
            for (var key in this._cacheStateEnable) {
                delete this._cacheStateEnable[key];
            }
            this._cacheProgram = null;
            this._cacheState = null;
        };
        WebGLRenderState.prototype.updateState = function (state) {
            if (this._cacheState === state) {
                return;
            }
            this._cacheState = state;
            var webgl = WebGLCapabilities.webgl;
            var stateEnables = this._stateEnables;
            var cacheStateEnable = this._cacheStateEnable;
            //TODO WebGLKit.draw(context, drawCall.material, drawCall.mesh, drawCall.subMeshIndex, drawType, transform._worldMatrixDeterminant < 0);
            for (var _i = 0, stateEnables_1 = stateEnables; _i < stateEnables_1.length; _i++) {
                var e = stateEnables_1[_i];
                var b = state ? state.enable && state.enable.indexOf(e) >= 0 : false;
                if (cacheStateEnable[e] !== b) {
                    cacheStateEnable[e] = b;
                    b ? webgl.enable(e) : webgl.disable(e);
                }
            }
            // Functions.
            if (state) {
                var functions = state.functions;
                if (functions) {
                    for (var fun in functions) {
                        webgl[fun].apply(webgl, functions[fun]);
                    }
                }
            }
        };
        WebGLRenderState.prototype.useProgram = function (program) {
            if (this._cacheProgram !== program) {
                this._cacheProgram = program;
                WebGLCapabilities.webgl.useProgram(program.program);
                return true;
            }
            return false;
        };
        WebGLRenderState.prototype.getProgram = function (material, technique, defines) {
            var shader = material._shader;
            var extensions = shader.config.extensions.KHR_techniques_webgl;
            var vertexShader = extensions.shaders[0];
            var fragShader = extensions.shaders[1];
            var name = vertexShader.name + "_" + fragShader.name + "_" + defines; //TODO材质标脏可以优化
            var webgl = WebGLCapabilities.webgl;
            var program = this._programs[name];
            if (!program) {
                var webglProgram = this._getWebGLProgram(vertexShader, fragShader, defines);
                if (webglProgram) {
                    program = new egret3d.GlProgram(webglProgram);
                    this._programs[name] = program;
                    _extractAttributes(webgl, program);
                    _extractUniforms(webgl, program, technique);
                    _extractTextureUnits(program);
                }
            }
            if (technique.program !== program.id) {
                technique.program = program.id;
            }
            return program;
        };
        WebGLRenderState.prototype.clear = function (clearOptColor, clearOptDepath, clearColor) {
            var webgl = WebGLCapabilities.webgl;
            if (clearOptColor && clearOptDepath) {
                webgl.depthMask(true);
                webgl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            }
            else if (clearOptDepath) {
                webgl.depthMask(true);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.DEPTH_BUFFER_BIT);
            }
            else if (clearOptColor) {
                webgl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
                webgl.clear(webgl.COLOR_BUFFER_BIT);
            }
        };
        return WebGLRenderState;
    }(paper.SingletonComponent));
    egret3d.WebGLRenderState = WebGLRenderState;
    __reflect(WebGLRenderState.prototype, "egret3d.WebGLRenderState");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 应用程序运行模式。
     */
    var PlayerMode;
    (function (PlayerMode) {
        PlayerMode[PlayerMode["Player"] = 0] = "Player";
        PlayerMode[PlayerMode["DebugPlayer"] = 1] = "DebugPlayer";
        PlayerMode[PlayerMode["Editor"] = 2] = "Editor";
    })(PlayerMode = paper.PlayerMode || (paper.PlayerMode = {}));
    /**
     * 应用程序。
     */
    var ECS = (function () {
        function ECS() {
            /**
             * 当应用程序的播放模式改变时派发事件。
             */
            this.onPlayerModeChange = new signals.Signal();
            /**
             * 引擎版本。
             */
            this.version = "1.3.0.001";
            /**
             * 系统管理器。
             */
            this.systemManager = paper.SystemManager.getInstance();
            /**
             * 场景管理器。
             */
            this.sceneManager = paper.SceneManager.getInstance();
            this._isFocused = false;
            this._isRunning = false;
            this._playerMode = 0 /* Player */;
            this._bindUpdate = null;
        }
        /**
         * 应用程序单例。
         */
        ECS.getInstance = function () {
            if (!this._instance) {
                this._instance = new ECS();
            }
            return this._instance;
        };
        ECS.prototype._update = function () {
            if (this._isRunning) {
                requestAnimationFrame(this._bindUpdate);
            }
            paper.clock && paper.clock.update(); // TODO
            paper.GameObjectGroup.update();
            this.systemManager.update();
        };
        ECS.prototype._updatePlayerMode = function () {
            // if (this._playerMode !== PlayerMode.Player) { TODO
            //     egret3d.Camera.editor; // Active editor camera.
            // }
        };
        /**
         * @internal
         */
        ECS.prototype.initialize = function (options) {
            this._playerMode = options.playerMode || 0 /* Player */;
            this.systemManager.register(paper.EnableSystem, 1000 /* Enable */);
            this.systemManager.register(paper.StartSystem, 2000 /* Start */);
            this.systemManager.register(paper.FixedUpdateSystem, 3000 /* FixedUpdate */);
            this.systemManager.register(paper.UpdateSystem, 4000 /* Update */);
            this.systemManager.register(paper.LateUpdateSystem, 6000 /* LaterUpdate */);
            this.systemManager.register(paper.DisableSystem, 9000 /* Disable */);
            this._updatePlayerMode();
            this.resume();
        };
        /**
         * TODO
         * @internal
         */
        ECS.prototype.pause = function () {
            this._isRunning = false;
        };
        /**
         * TODO
         * @internal
         */
        ECS.prototype.resume = function () {
            if (this._isRunning) {
                return;
            }
            this._isRunning = true;
            if (!this._bindUpdate) {
                this._bindUpdate = this._update.bind(this);
            }
            this._update();
        };
        Object.defineProperty(ECS.prototype, "isMobile", {
            /**
             *
             */
            get: function () {
                var userAgent = (navigator && navigator.userAgent) ? navigator.userAgent.toLowerCase() : "";
                return userAgent.indexOf("mobile") >= 0 || userAgent.indexOf("android") >= 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isFocused", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                return this._isFocused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isRunning", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                return this._isRunning;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "playerMode", {
            /**
             * 运行模式。
             */
            get: function () {
                return this._playerMode;
            },
            set: function (value) {
                if (this._playerMode === value) {
                    return;
                }
                this._playerMode = value;
                this.onPlayerModeChange.dispatch(this.playerMode);
            },
            enumerable: true,
            configurable: true
        });
        ECS._instance = null;
        return ECS;
    }());
    paper.ECS = ECS;
    __reflect(ECS.prototype, "paper.ECS");
    /**
     * 应用程序单例。
     */
    paper.Application = ECS.getInstance();
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 3×3矩阵
     */
    var Matrix3 = (function (_super) {
        __extends(Matrix3, _super);
        /**
         * @deprecated
         */
        function Matrix3(rawData) {
            if (rawData === void 0) { rawData = null; }
            var _this = _super.call(this) || this;
            /**
             * 矩阵原始数据
             * @readonly
             */
            _this.rawData = null;
            if (rawData) {
                _this.rawData = rawData;
            }
            else {
                _this.rawData = new Float32Array([
                    1.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 1.0,
                ]);
            }
            return _this;
        }
        Matrix3.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new Matrix3();
        };
        /**
         * 序列化
         * @returns 序列化后的数据
         */
        Matrix3.prototype.serialize = function () {
            return this.rawData;
        };
        /**
         * 反序列化
         * @param value 序列化后的数据
         */
        Matrix3.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Matrix3.prototype.copy = function (value) {
            this.fromArray(value.rawData);
            return this;
        };
        Matrix3.prototype.clone = function () {
            var value = new Matrix3();
            value.copy(this);
            return value;
        };
        Matrix3.prototype.set = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            this.rawData[0] = n11;
            this.rawData[3] = n12;
            this.rawData[6] = n13;
            this.rawData[1] = n21;
            this.rawData[4] = n22;
            this.rawData[7] = n23;
            this.rawData[2] = n31;
            this.rawData[5] = n32;
            this.rawData[8] = n33;
            return this;
        };
        Matrix3.prototype.identity = function () {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
        };
        Matrix3.prototype.inverse = function (matrix) {
            var me = matrix.rawData, te = this.rawData, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) {
                // TODO
                // var msg = "can't invert matrix, determinant is 0";
                // console.warn(msg);
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        };
        Matrix3.prototype.getNormalMatrix = function (matrix4) {
            return this.setFromMatrix4(matrix4).inverse(this).transpose();
        };
        Matrix3.prototype.transpose = function () {
            var tmp, m = this.rawData;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        };
        Matrix3.prototype.setFromMatrix4 = function (m) {
            var me = m.rawData;
            this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
            // this.set(
            //     me[0], me[1], me[2],
            //     me[4], me[5], me[6],
            //     me[8], me[9], me[10]
            // );
            return this;
        };
        Matrix3.prototype.determinant = function () {
            var te = this.rawData;
            var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        };
        Matrix3.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            for (var i = 0; i < 9; ++i) {
                this.rawData[i] = value[i + offset];
            }
            return this;
        };
        Matrix3.prototype.fromBuffer = function (value, byteOffset) {
            if (byteOffset === void 0) { byteOffset = 0; }
            this.rawData = new Float32Array(value, byteOffset, 9);
            return this;
        };
        Matrix3._instances = [];
        return Matrix3;
    }(paper.BaseRelease));
    egret3d.Matrix3 = Matrix3;
    __reflect(Matrix3.prototype, "egret3d.Matrix3", ["paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @deprecated
     */
    egret3d.Matrix = egret3d.Matrix4;
    /**
     * @deprecated
     */
    egret3d.Prefab = paper.Prefab;
    /**
     * @deprecated
     */
    egret3d.RawScene = paper.RawScene;
    /**
     * @deprecated
     */
    egret3d.InputManager = {
        /**
         * @deprecated
         * @see egret3d.inputCollecter
         */
        mouse: {
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer.isHold()
             */
            isPressed: function (button) {
                var buttons = [1 /* LeftMouse */, 4 /* MiddleMouse */, 2 /* RightMouse */];
                return egret3d.inputCollecter.defaultPointer.isHold(buttons[button]);
            },
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer.isDown()
             */
            wasPressed: function (button) {
                var buttons = [1 /* LeftMouse */, 4 /* MiddleMouse */, 2 /* RightMouse */];
                return egret3d.inputCollecter.defaultPointer.isDown(buttons[button]);
            },
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer.isUp()
             */
            wasReleased: function (button) {
                var buttons = [1 /* LeftMouse */, 4 /* MiddleMouse */, 2 /* RightMouse */];
                return egret3d.inputCollecter.defaultPointer.isUp(buttons[button]);
            },
        },
        /**
         * @deprecated
         * @see egret3d.inputCollecter
         */
        touch: {
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer
             */
            getTouch: function (button) {
                return undefined;
            },
        },
        /**
         * @deprecated
         * @see egret3d.inputCollecter
         */
        keyboard: {
            /**
             * @deprecated
             * @see egret3d.inputCollecter.getKey()
             */
            isPressed: function (key) {
                return egret3d.inputCollecter.getKey("Key" + key.toUpperCase()).isHold();
            },
            /**
             * @deprecated
             * @see egret3d.inputCollecter.getKey()
             */
            wasPressed: function (key) {
                return egret3d.inputCollecter.getKey("Key" + key.toUpperCase()).isUp();
            },
        },
    };
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    /**
     * 提供默认的几何网格资源，以及创建几何网格或几何网格实体的方式。
     */
    var MeshBuilder = (function () {
        function MeshBuilder() {
        }
        /**
         * 创建平面网格。
         * @param width 宽度。
         * @param height 高度。
         * @param centerOffsetX 中心点偏移 X。
         * @param centerOffsetY 中心点偏移 Y。
         * @param widthSegments 宽度分段。
         * @param heightSegments 高度分段。
         */
        MeshBuilder.createPlane = function (width, height, centerOffsetX, centerOffsetY, widthSegments, heightSegments) {
            if (width === void 0) { width = 1.0; }
            if (height === void 0) { height = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            var widthHalf = width / 2;
            var heightHalf = height / 2;
            var gridX1 = widthSegments + 1;
            var gridY1 = heightSegments + 1;
            var segmentWidth = width / widthSegments;
            var segmentHeight = height / heightSegments;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // generate vertices, normals and uvs
            for (var iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (var ix = 0; ix < gridX1; ix++) {
                    var x = ix * segmentWidth - widthHalf;
                    vertices.push(x + centerOffsetX, -y + centerOffsetY, 0.0);
                    normals.push(0.0, 0.0, -1.0);
                    uvs.push(ix / widthSegments, iy / heightSegments);
                }
            }
            // indices
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = ix + gridX1 * iy;
                    var b = ix + gridX1 * (iy + 1);
                    var c = (ix + 1) + gridX1 * (iy + 1);
                    var d = (ix + 1) + gridX1 * iy;
                    // faces
                    // a - d
                    // | / |
                    // b - c
                    indices.push(a, b, d, d, b, c);
                }
            }
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
         * 创建立方体网格。
         * @param width 宽度。
         * @param height 高度。
         * @param depth 深度。
         * @param centerOffsetX 中心点偏移 X。
         * @param centerOffsetY 中心点偏移 Y。
         * @param centerOffsetZ 中心点偏移 Z。
         * @param widthSegments 宽度分段。
         * @param heightSegments 高度分段。
         * @param depthSegments 深度分段。
         * @param differentFace 是否使用不同材质。
         */
        MeshBuilder.createCube = function (width, height, depth, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, depthSegments, differentFace) {
            if (width === void 0) { width = 1.0; }
            if (height === void 0) { height = 1.0; }
            if (depth === void 0) { depth = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (depthSegments === void 0) { depthSegments = 1; }
            if (differentFace === void 0) { differentFace = false; }
            // helper variables
            var meshVertexCount = 0;
            var vector3 = _helpVector3;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // build each side of the box geometry
            buildPlane("z", "y", "x", -1, -1, depth, height, -width, depthSegments, heightSegments); // px
            buildPlane("z", "y", "x", 1, -1, depth, height, width, depthSegments, heightSegments); // nx
            buildPlane("x", "z", "y", 1, 1, width, depth, -height, widthSegments, depthSegments); // py
            buildPlane("x", "z", "y", 1, -1, width, depth, height, widthSegments, depthSegments); // ny
            buildPlane("x", "y", "z", 1, -1, width, height, -depth, widthSegments, heightSegments); // pz
            buildPlane("x", "y", "z", -1, -1, width, height, depth, widthSegments, heightSegments); // nz
            // build geometry
            if (differentFace) {
                var faceIndexCount = indices.length / 6;
                var mesh = egret3d.Mesh.create(vertices.length / 3, 0);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                for (var i = 0; i < 6; ++i) {
                    mesh.addSubMesh(faceIndexCount, i);
                    mesh.setIndices(indices, i, faceIndexCount * i);
                }
                return mesh;
            }
            else {
                var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                mesh.setIndices(indices);
                return mesh;
            }
            function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY) {
                var segmentWidth = width / gridX;
                var segmentHeight = height / gridY;
                var widthHalf = width / 2;
                var heightHalf = height / 2;
                var depthHalf = depth / 2;
                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;
                var vertexCount = 0;
                // generate vertices, normals and uvs
                for (var iy = 0; iy < gridY1; iy++) {
                    var y = iy * segmentHeight - heightHalf;
                    for (var ix = 0; ix < gridX1; ix++) {
                        var x = ix * segmentWidth - widthHalf;
                        // set values to correct vector component
                        vector3[u] = x * udir;
                        vector3[v] = y * vdir;
                        vector3[w] = depthHalf;
                        // now apply vector to vertex buffer
                        vertices.push(vector3.x + centerOffsetX, vector3.y + centerOffsetY, vector3.z + centerOffsetZ);
                        // set values to correct vector component
                        vector3[u] = 0.0;
                        vector3[v] = 0.0;
                        vector3[w] = depth > 0.0 ? 1.0 : -1.0;
                        // now apply vector to normal buffer
                        normals.push(vector3.x, vector3.y, vector3.z);
                        // uvs
                        uvs.push(ix / gridX, iy / gridY);
                        // counters
                        vertexCount += 1;
                    }
                }
                // indices
                // 1. you need three indices to draw a single face
                // 2. a single segment consists of two faces
                // 3. so we need to generate six (2*3) indices per segment
                for (var iy = 0; iy < gridY; iy++) {
                    for (var ix = 0; ix < gridX; ix++) {
                        var a = meshVertexCount + ix + gridX1 * iy;
                        var b = meshVertexCount + ix + gridX1 * (iy + 1);
                        var c = meshVertexCount + (ix + 1) + gridX1 * (iy + 1);
                        var d = meshVertexCount + (ix + 1) + gridX1 * iy;
                        // faces
                        // a - d
                        // | / |
                        // b - c
                        indices.push(a, b, d, b, c, d);
                    }
                }
                // update total number of vertices
                meshVertexCount += vertexCount;
            }
        };
        /**
         * 创建圆柱体网格。
         * @param radiusTop 顶部半径。
         * @param radiusBottom 底部半径。
         * @param height 高度。
         * @param centerOffsetX 中心点偏移 X。
         * @param centerOffsetY 中心点偏移 Y。
         * @param centerOffsetZ 中心点偏移 Z。
         * @param radialSegments 径向分段。
         * @param heightSegments 高度分段。
         * @param openEnded 是否开口。
         * @param thetaStart 起始弧度。
         * @param thetaLength 覆盖弧度。
         * @param differentFace 是否使用不同材质。
         */
        MeshBuilder.createCylinder = function (radiusTop, radiusBottom, height, centerOffsetX, centerOffsetY, centerOffsetZ, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, differentFace) {
            if (radiusTop === void 0) { radiusTop = 0.5; }
            if (radiusBottom === void 0) { radiusBottom = 0.5; }
            if (height === void 0) { height = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (radialSegments === void 0) { radialSegments = 16; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (openEnded === void 0) { openEnded = false; }
            if (thetaStart === void 0) { thetaStart = 0.0; }
            if (thetaLength === void 0) { thetaLength = Math.PI * 2.0; }
            if (differentFace === void 0) { differentFace = false; }
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var index = 0;
            var groupStart = 0;
            var halfHeight = height / 2;
            var vector3 = _helpVector3;
            var indexArray = [];
            var subIndices = [];
            // generate geometry
            generateTorso();
            if (openEnded === false) {
                if (radiusTop > 0.0)
                    generateCap(true);
                if (radiusBottom > 0.0)
                    generateCap(false);
            }
            // build geometry
            if (differentFace) {
                var mesh = egret3d.Mesh.create(vertices.length / 3, 0);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                for (var i = 0; i < subIndices.length; i += 3) {
                    mesh.addSubMesh(subIndices[1], subIndices[2]);
                    mesh.setIndices(indices, i, subIndices[0]);
                }
                return mesh;
            }
            else {
                var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                mesh.setIndices(indices);
                return mesh;
            }
            function generateTorso() {
                var groupCount = 0;
                // this will be used to calculate the normal
                var slope = (radiusBottom - radiusTop) / height;
                // generate vertices, normals and uvs
                for (var iY = 0; iY <= heightSegments; iY++) {
                    var indexRow = [];
                    var v = iY / heightSegments;
                    // calculate the radius of the current row
                    var radius = v * (radiusBottom - radiusTop) + radiusTop;
                    for (var iX = 0; iX <= radialSegments; iX++) {
                        var u = iX / radialSegments;
                        var theta = u * thetaLength + thetaStart;
                        var sinTheta = Math.sin(theta);
                        var cosTheta = Math.cos(theta);
                        // vertex
                        vector3.x = radius * sinTheta;
                        vector3.y = -v * height + halfHeight;
                        // vertex.z = radius * cosTheta; // Right-hand coordinates system.
                        vector3.z = -radius * cosTheta; // Left-hand coordinates system.
                        vertices.push(vector3.x + centerOffsetX, vector3.y + centerOffsetY, vector3.z + centerOffsetZ);
                        // normal
                        vector3.set(sinTheta, slope, cosTheta).normalize();
                        // normals.push(vector3.x, vector3.y, vector3.z); // Right-hand coordinates system.
                        normals.push(vector3.x, vector3.y, -vector3.z); // Left-hand coordinates system.
                        // uv
                        uvs.push(u, v);
                        // save index of vertex in respective row
                        indexRow.push(index++);
                    }
                    // now save vertices of the row in our index array
                    indexArray.push(indexRow);
                }
                // generate indices
                for (var iX = 0; iX < radialSegments; iX++) {
                    for (var iY = 0; iY < heightSegments; iY++) {
                        // we use the index array to access the correct indices
                        var a = indexArray[iY][iX];
                        var b = indexArray[iY + 1][iX];
                        var c = indexArray[iY + 1][iX + 1];
                        var d = indexArray[iY][iX + 1];
                        // faces
                        indices.push(a, b, d, b, c, d);
                        // update group counter
                        groupCount += 6;
                    }
                }
                // add a group to the geometry. this will ensure multi material support
                subIndices.push(groupStart, groupCount, 0);
                // calculate new start value for groups
                groupStart += groupCount;
            }
            function generateCap(top) {
                var centerIndexStart = 0, centerIndexEnd = 0;
                var groupCount = 0;
                var radius = top ? radiusTop : radiusBottom;
                var sign = top ? 1 : -1;
                // save the index of the first center vertex
                centerIndexStart = index;
                // first we generate the center vertex data of the cap.
                // because the geometry needs one set of uvs per face,
                // we must generate a center vertex per face/segment
                for (var iX = 1; iX <= radialSegments; iX++) {
                    // vertex
                    vertices.push(0.0, halfHeight * sign, 0.0);
                    // normal
                    normals.push(0.0, sign, 0.0);
                    // uv
                    uvs.push(0.5, 0.5);
                    // increase index
                    index++;
                }
                // save the index of the last center vertex
                centerIndexEnd = index;
                // now we generate the surrounding vertices, normals and uvs
                for (var iX = 0; iX <= radialSegments; iX++) {
                    var u = iX / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var cosTheta = Math.cos(theta);
                    var sinTheta = Math.sin(theta);
                    // vertex
                    vector3.x = radius * sinTheta;
                    vector3.y = halfHeight * sign;
                    // vector3.z = radius * cosTheta; // Right-hand coordinates system.
                    vector3.z = -radius * cosTheta; // Left-hand coordinates system.
                    vertices.push(vector3.x + centerOffsetX, vector3.y + centerOffsetY, vector3.z + centerOffsetZ);
                    // normal
                    normals.push(0.0, sign, 0.0);
                    // uv
                    uvs.push((sinTheta * 0.5 * sign) + 0.5, (cosTheta * 0.5) + 0.5);
                    // increase index
                    index++;
                }
                // generate indices
                for (var iX = 0; iX < radialSegments; iX++) {
                    var c = centerIndexStart + iX;
                    var i = centerIndexEnd + iX;
                    if (top === true) {
                        // face top
                        indices.push(i, i + 1, c);
                    }
                    else {
                        // face bottom
                        indices.push(i + 1, i, c);
                    }
                    groupCount += 3;
                }
                // add a group to the geometry. this will ensure multi material support
                subIndices.push(groupStart, groupCount, top === true ? 1 : 2);
                // calculate new start value for groups
                groupStart += groupCount;
            }
        };
        /**
         * 创建圆形网格。
         */
        MeshBuilder.createCircle = function (radius, arc, axis) {
            if (radius === void 0) { radius = 0.5; }
            if (arc === void 0) { arc = 1.0; }
            if (axis === void 0) { axis = 1; }
            var vertices = [];
            for (var i = 0; i <= 64 * arc; ++i) {
                switch (axis) {
                    case 1:
                        vertices.push(0.0, Math.cos(i / 32 * Math.PI) * radius, -Math.sin(i / 32 * Math.PI) * radius);
                        break;
                    case 2:
                        vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0.0, -Math.sin(i / 32 * Math.PI) * radius);
                        break;
                    case 3:
                        vertices.push(Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius, -0.0);
                        break;
                }
            }
            var mesh = egret3d.Mesh.create(vertices.length / 3, 0, ["POSITION" /* POSITION */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.glTFMesh.primitives[0].mode = 3 /* LineStrip */;
            return mesh;
        };
        /**
         * 创建圆环网格。
         */
        MeshBuilder.createTorus = function (radius, tube, radialSegments, tubularSegments, arc, axis) {
            if (radius === void 0) { radius = 0.5; }
            if (tube === void 0) { tube = 0.1; }
            if (radialSegments === void 0) { radialSegments = 4; }
            if (tubularSegments === void 0) { tubularSegments = 12; }
            if (arc === void 0) { arc = 1.0; }
            if (axis === void 0) { axis = 1; }
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var center = egret3d.Vector3.create();
            var vertex = egret3d.Vector3.create();
            var normal = egret3d.Vector3.create();
            var j, i;
            // generate vertices, normals and uvs
            for (j = 0; j <= radialSegments; j++) {
                for (i = 0; i <= tubularSegments; i++) {
                    var u = i / tubularSegments * Math.PI * 2 * arc;
                    var v = j / radialSegments * Math.PI * 2;
                    // vertex
                    switch (axis) {
                        case 1:
                            vertex.x = tube * Math.sin(v);
                            vertex.y = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.z = (radius + tube * Math.cos(v)) * Math.sin(u);
                            break;
                        case 2:
                            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.y = tube * Math.sin(v);
                            vertex.z = (radius + tube * Math.cos(v)) * Math.sin(u);
                            break;
                        default:
                            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                            vertex.z = tube * Math.sin(v);
                    }
                    vertices.push(vertex.x, vertex.y, -vertex.z);
                    // normal
                    center.x = radius * Math.cos(u);
                    center.y = radius * Math.sin(u);
                    normal.subtract(vertex, center).normalize();
                    normals.push(normal.x, normal.y, -normal.z);
                    // uv
                    uvs.push(i / tubularSegments);
                    uvs.push(j / radialSegments);
                }
            }
            // generate indices
            for (j = 1; j <= radialSegments; j++) {
                for (i = 1; i <= tubularSegments; i++) {
                    // indices
                    var a = (tubularSegments + 1) * j + i - 1;
                    var b = (tubularSegments + 1) * (j - 1) + i - 1;
                    var c = (tubularSegments + 1) * (j - 1) + i;
                    var d = (tubularSegments + 1) * j + i;
                    // faces
                    indices.push(a, b, d, b, c, d);
                }
            }
            center.release();
            vertex.release();
            normal.release();
            // build geometry
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length, ["POSITION" /* POSITION */, "NORMAL" /* NORMAL */, "TEXCOORD_0" /* TEXCOORD_0 */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
        * 创建球体网格。
        * @param radius 半径。
        * @param centerOffsetX 中心点偏移 X。
        * @param centerOffsetY 中心点偏移 Y。
        * @param centerOffsetZ 中心点偏移 Z。
        * @param widthSegments 宽度分段。
        * @param heightSegments 高度分段。
        * @param phiStart 水平起始弧度。
        * @param phiLength 水平覆盖弧度。
        * @param thetaStart 垂直起始弧度。
        * @param thetaLength 垂直覆盖弧度。
        */
        MeshBuilder.createSphere = function (radius, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            if (radius === void 0) { radius = 0.5; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (widthSegments === void 0) { widthSegments = 24; }
            if (heightSegments === void 0) { heightSegments = 12; }
            if (phiStart === void 0) { phiStart = 0.0; }
            if (phiLength === void 0) { phiLength = Math.PI * 2.0; }
            if (thetaStart === void 0) { thetaStart = 0.0; }
            if (thetaLength === void 0) { thetaLength = Math.PI; }
            widthSegments = Math.max(3, Math.floor(widthSegments));
            heightSegments = Math.max(2, Math.floor(heightSegments));
            var thetaEnd = thetaStart + thetaLength;
            var index = 0;
            var grid = [];
            var vector3 = _helpVector3;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // generate vertices, normals and uvs
            for (var iY = 0; iY <= heightSegments; iY++) {
                var verticesRow = [];
                var v = iY / heightSegments;
                for (var iX = 0; iX <= widthSegments; iX++) {
                    var u = iX / widthSegments;
                    // vertex
                    vector3.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vector3.y = radius * Math.cos(thetaStart + v * thetaLength);
                    vector3.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertices.push(vector3.x + centerOffsetX, vector3.y + centerOffsetY, -vector3.z + centerOffsetZ);
                    // normal
                    vector3.normalize();
                    normals.push(vector3.x, vector3.y, -vector3.z);
                    // uv
                    uvs.push(u, v);
                    verticesRow.push(index++);
                }
                grid.push(verticesRow);
            }
            // indices
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];
                    if (iy !== 0 || thetaStart > 0)
                        indices.push(a, b, d);
                    if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                        indices.push(b, c, d);
                }
            }
            // build geometry
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length, ["POSITION" /* POSITION */, "NORMAL" /* NORMAL */, "TEXCOORD_0" /* TEXCOORD_0 */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        MeshBuilder.prototype.computeLineDistances = function (vertices, out) {
            out[0] = 0;
            for (var i = 3, ii = 1; i > vertices.length; i += 3, ii++) {
                var start = egret3d.Vector3.create(vertices[i - 3], vertices[i - 2], vertices[i - 1]);
                var end = egret3d.Vector3.create(vertices[i], vertices[i + 1], vertices[i + 2]);
                out[ii] = out[ii - 1] + start.getDistance(end);
            }
        };
        return MeshBuilder;
    }());
    egret3d.MeshBuilder = MeshBuilder;
    __reflect(MeshBuilder.prototype, "egret3d.MeshBuilder");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var GroupComponent = (function (_super) {
        __extends(GroupComponent, _super);
        function GroupComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.componentIndex = -1;
            _this.componentClass = null;
            _this.components = [];
            return _this;
        }
        GroupComponent.prototype.addComponent = function (component) {
            this.components.push(component);
        };
        GroupComponent.prototype.removeComponent = function (component) {
            var index = this.components.indexOf(component);
            if (index >= 0) {
                this.components.splice(1, 0);
            }
        };
        return GroupComponent;
    }(paper.BaseComponent));
    paper.GroupComponent = GroupComponent;
    __reflect(GroupComponent.prototype, "paper.GroupComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * Shader 通用宏定义。
     */
    var ShaderDefine;
    (function (ShaderDefine) {
        ShaderDefine["USE_COLOR"] = "USE_COLOR";
        ShaderDefine["USE_MAP"] = "USE_MAP";
        ShaderDefine["USE_SKINNING"] = "USE_SKINNING";
        ShaderDefine["USE_LIGHTMAP"] = "USE_LIGHTMAP";
        ShaderDefine["USE_SHADOWMAP"] = "USE_SHADOWMAP";
        ShaderDefine["USE_SIZEATTENUATION"] = "USE_SIZEATTENUATION";
        //
        ShaderDefine["MAX_BONES"] = "MAX_BONES";
        //
        ShaderDefine["FLIP_V"] = "FLIP_V";
        //
        ShaderDefine["NUM_POINT_LIGHTS"] = "NUM_POINT_LIGHTS";
        ShaderDefine["NUM_SPOT_LIGHTS"] = "NUM_SPOT_LIGHTS";
        ShaderDefine["SHADOWMAP_TYPE_PCF"] = "SHADOWMAP_TYPE_PCF";
        ShaderDefine["SHADOWMAP_TYPE_PCF_SOFT"] = "SHADOWMAP_TYPE_PCF_SOFT";
        ShaderDefine["DEPTH_PACKING_3200"] = "DEPTH_PACKING 3200";
        ShaderDefine["DEPTH_PACKING_3201"] = "DEPTH_PACKING 3201";
        //
        ShaderDefine["USE_FOG"] = "USE_FOG";
        ShaderDefine["FOG_EXP2"] = "FOG_EXP2";
    })(ShaderDefine = egret3d.ShaderDefine || (egret3d.ShaderDefine = {}));
    /**
     * Shader 通用 Uniform 名称。
     */
    var ShaderUniformName;
    (function (ShaderUniformName) {
        ShaderUniformName["Diffuse"] = "diffuse";
        ShaderUniformName["Opacity"] = "opacity";
        ShaderUniformName["Size"] = "size";
        ShaderUniformName["Map"] = "map";
        ShaderUniformName["Specular"] = "specular";
        ShaderUniformName["Shininess"] = "shininess";
        ShaderUniformName["UVTransform"] = "uvTransform";
    })(ShaderUniformName = egret3d.ShaderUniformName || (egret3d.ShaderUniformName = {}));
    /**
     * Shader 资源。
     */
    var Shader = (function (_super) {
        __extends(Shader, _super);
        /**
         * @internal
         */
        function Shader(config, name) {
            var _this = _super.call(this, name) || this;
            _this.config = config;
            return _this;
        }
        return Shader;
    }(egret3d.GLTFAsset));
    egret3d.Shader = Shader;
    __reflect(Shader.prototype, "egret3d.Shader");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //TODO 运行时DrawCall排序优化使用
    var _hashCode = 0;
    /**
     * 材质资源。
     */
    var Material = (function (_super) {
        __extends(Material, _super);
        function Material(shaderOrConfig, name) {
            var _this = _super.call(this, name) || this;
            /**
             *
             */
            _this.renderQueue = 2000 /* Geometry */;
            /**
              * @internal
              */
            _this._id = _hashCode++;
            /**
              * @internal
              */
            _this._version = 0;
            _this._cacheDefines = "";
            /**
              * @internal
              */
            _this._defines = [];
            _this._textures = []; // TODO
            /**
             * @internal
             */
            _this._shader = null;
            /**
            * @internal
            */
            _this._glTFTechnique = null;
            if (!shaderOrConfig) {
                _this._reset(egret3d.DefaultShaders.MESH_BASIC);
            }
            else if (typeof shaderOrConfig === "string") {
                var shader = paper.Asset.find(shaderOrConfig);
                if (!shader) {
                    console.error("Cannot find shader.", shaderOrConfig);
                }
                _this._reset(shader || egret3d.DefaultShaders.MESH_BASIC);
            }
            else {
                _this._reset(shaderOrConfig);
            }
            return _this;
        }
        Material.create = function (shaderOrConfig, name) {
            return new Material(shaderOrConfig, name);
        };
        Material.prototype._reset = function (shaderOrConfig) {
            var glTFMaterial;
            if (shaderOrConfig instanceof egret3d.Shader) {
                this.config = egret3d.GLTFAsset.createGLTFExtensionsConfig(); // TODO
                //
                glTFMaterial = this.config.materials[0] = {
                    extensions: {
                        KHR_techniques_webgl: { technique: shaderOrConfig.name, values: {} },
                        paper: { renderQueue: shaderOrConfig._renderQueue || this.renderQueue }
                    }
                };
                //
                this._shader = shaderOrConfig;
            }
            else {
                this.config = shaderOrConfig;
                //
                glTFMaterial = this.config.materials[0];
                //
                var shaderName = glTFMaterial.extensions.KHR_techniques_webgl.technique;
                var shader = paper.Asset.find(shaderName);
                if (!shader) {
                    console.error("Cannot find shader.", shaderName);
                }
                this._shader = shader || egret3d.DefaultShaders.MESH_BASIC;
            }
            this.renderQueue = glTFMaterial.extensions.paper.renderQueue;
            //
            this._glTFTechnique = egret3d.GLTFAsset.createTechnique(this._shader.config.extensions.KHR_techniques_webgl.techniques[0]);
            //
            var uniformValues = glTFMaterial.extensions.KHR_techniques_webgl.values;
            var uniforms = this._glTFTechnique.uniforms;
            //使用Shader替换Material中没有默认值的Uniform
            for (var k in uniformValues) {
                if (k in uniforms) {
                    var value = uniformValues[k];
                    if (Array.isArray(value)) {
                        uniforms[k].value = value.concat();
                    }
                    else {
                        uniforms[k].value = value;
                    }
                }
            }
            if (glTFMaterial.extensions.paper.states) {
                this._glTFTechnique.states = glTFMaterial.extensions.paper.states; // TODO
            }
            else if (this._shader._states) {
                this._glTFTechnique.states = egret3d.GLTFAsset.copyTechniqueStates(this._shader._states);
            }
            var materialDefines = glTFMaterial.extensions.paper.defines;
            if (materialDefines && materialDefines.length > 0) {
                for (var _i = 0, materialDefines_1 = materialDefines; _i < materialDefines_1.length; _i++) {
                    var define = materialDefines_1[_i];
                    this.addDefine(define);
                }
            }
            else if (this._shader._defines) {
                for (var _a = 0, _b = this._shader._defines; _a < _b.length; _a++) {
                    var define = _b[_a];
                    this.addDefine(define);
                }
            }
        };
        Material.prototype.dispose = function (disposeChildren) {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            if (disposeChildren) {
                for (var _i = 0, _a = this._textures; _i < _a.length; _i++) {
                    var texture = _a[_i];
                    texture.dispose();
                }
            }
            this._version++;
            this._cacheDefines = "";
            this._defines.length = 0;
            this._textures.length = 0;
            this._glTFTechnique = null;
            this._shader = null;
            return true;
        };
        Material.prototype.copy = function (value) {
            this.renderQueue = value.renderQueue;
            var sourceUniforms = value._glTFTechnique.uniforms;
            var targetUniforms = this._glTFTechnique.uniforms;
            for (var k in sourceUniforms) {
                var uniform = sourceUniforms[k];
                var value_2 = Array.isArray(uniform.value) ? uniform.value.concat() : uniform.value; // TODO TypeArray
                targetUniforms[k] = { type: uniform.type, semantic: uniform.semantic, value: value_2 };
            }
            var sourceStates = value._glTFTechnique.states;
            var targetStates = this._glTFTechnique.states;
            if (sourceStates.enable) {
                targetStates.enable = sourceStates.enable.concat();
            }
            if (sourceStates.functions) {
                if (!targetStates.functions) {
                    targetStates.functions = {};
                }
                for (var k in sourceStates.functions) {
                    if (Array.isArray(sourceStates.functions[k])) {
                        targetStates.functions[k] = sourceStates.functions[k].concat();
                    }
                    else {
                        targetStates.functions[k] = sourceStates.functions[k];
                    }
                }
            }
            //
            for (var _i = 0, _a = value._defines; _i < _a.length; _i++) {
                var define = _a[_i];
                this.addDefine(define);
            }
            return this;
        };
        /**
         * 克隆材质资源。
         */
        Material.prototype.clone = function () {
            return new Material(this._shader).copy(this);
        };
        /**
         *
         */
        Material.prototype.addDefine = function (value) {
            if (this._defines.indexOf(value) < 0) {
                this._defines.push(value);
                this._defines.sort();
                this._version++;
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.removeDefine = function (value) {
            var delIndex = this._defines.indexOf(value);
            if (delIndex >= 0) {
                this._defines.splice(delIndex, 1);
                this._version++;
            }
            return this;
        };
        Material.prototype.setBoolean = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setInt = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setIntv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setFloat = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setFloatv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector2 = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector2v = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector3 = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y || uniform.value[2] !== value.z) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    uniform.value[2] = value.z;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector3v = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector4 = function (id, value) {
            //兼容老键值
            if (id === "_MainTex_ST" && this._glTFTechnique.uniforms["uvTransform" /* UVTransform */]) {
                id = "uvTransform" /* UVTransform */;
                console.warn("已废弃的键值_MainTex_ST，建议改为:uvTransform-Matrix3");
                this._glTFTechnique.uniforms[id].value = [value.x, 0, 0, 0, value.y, 0, value.z, value.w, 1];
                return;
            }
            else if ((id === "_MainColor" || id === "_Color") && this._glTFTechnique.uniforms["diffuse" /* Diffuse */]) {
                id = "diffuse" /* Diffuse */;
                console.warn("已废弃的键值_MainColor、_Color，建议改为:diffuse-Vector3");
                this._glTFTechnique.uniforms[id].value = [value.x, value.y, value.z];
                return;
            }
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y || uniform.value[2] !== value.z || uniform.value[3] !== value.w) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    uniform.value[2] = value.z;
                    uniform.value[3] = value.w;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector4v = function (id, value) {
            //兼容老键值
            if (id === "_MainTex_ST" && this._glTFTechnique.uniforms["uvTransform" /* UVTransform */]) {
                id = "uvTransform" /* UVTransform */;
                console.warn("已废弃的键值_MainTex_ST，建议改为:uvTransform-Matrix3");
                this._glTFTechnique.uniforms[id].value = [value[0], 0, 0, 0, value[1], 0, value[2], value[3], 1];
                return;
            }
            else if ((id === "_MainColor" || id === "_Color") && this._glTFTechnique.uniforms["diffuse" /* Diffuse */]) {
                id = "diffuse" /* Diffuse */;
                console.warn("已废弃的键值_MainColor、_Color，建议改为:diffuse-Vector3");
                this._glTFTechnique.uniforms[id].value = [value[0], value[1], value[2]];
                return;
            }
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setMatrix = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value.rawData;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setMatrixv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.getTexture = function (uniformName) {
            if (!uniformName) {
                uniformName = "map" /* Map */;
            }
            var uniform = this._glTFTechnique.uniforms[uniformName];
            return uniform ? uniform.value || null : null;
        };
        Material.prototype.setTexture = function (p1, p2) {
            var uniformName;
            if (p1 === null || p1 instanceof egret3d.Texture) {
                uniformName = "map" /* Map */;
                p2 = p1;
            }
            else {
                uniformName = p1;
            }
            if (!p2) {
                p2 = egret3d.DefaultTextures.WHITE;
            }
            //兼容老键值
            if (uniformName === "_MainTex" && this._glTFTechnique.uniforms["map" /* Map */]) {
                uniformName = "map" /* Map */;
                console.warn("已废弃的键值_MainTex，建议改为:map");
            }
            var uniform = this._glTFTechnique.uniforms[uniformName];
            if (uniform !== undefined) {
                if (uniform.value) {
                    var index = this._textures.indexOf(uniform.value);
                    if (index > -1) {
                        this._textures.splice(index, 1);
                    }
                }
                if (uniform.value !== p2) {
                    uniform.value = p2;
                    this._version++;
                }
            }
            else if (true) {
                console.warn("Try to set an unsupported uniform name.", uniformName);
            }
            if (p2 instanceof egret3d.BaseRenderTarget) {
                this.addDefine("FLIP_V" /* FLIP_V */);
            }
            if (p2) {
                this._textures.push(p2);
            }
            return this;
        };
        Material.prototype.getColor = function (p1, p2) {
            var uniformName;
            if (!p1) {
                uniformName = "diffuse" /* Diffuse */;
                p2 = egret3d.Color.create();
            }
            else if (p1 instanceof egret3d.Color) {
                uniformName = "diffuse" /* Diffuse */;
                p2 = p1;
            }
            else {
                uniformName = p1;
                if (!p2) {
                    p2 = egret3d.Color.create();
                }
            }
            var uniform = this._glTFTechnique.uniforms[uniformName];
            if (uniform.value && Array.isArray(uniform.value)) {
                p2.r = uniform.value[0];
                p2.g = uniform.value[1];
                p2.b = uniform.value[2];
            }
            return p2;
        };
        Material.prototype.setColor = function (p1, p2) {
            var uniformName;
            if (p1.hasOwnProperty("r")) {
                uniformName = "diffuse" /* Diffuse */;
                p2 = p1;
            }
            else {
                uniformName = p1;
            }
            this.setVector3(uniformName, egret3d.Vector3.create(p2.r, p2.g, p2.b).release());
            return this;
        };
        /**
         *
         * @param blend
         */
        Material.prototype.setBlend = function (blend) {
            if (!this._glTFTechnique.states) {
                this._glTFTechnique.states = { enable: [], functions: {} };
            }
            var enables = this._glTFTechnique.states.enable;
            var functions = this._glTFTechnique.states.functions;
            switch (blend) {
                case 3 /* Add */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [770 /* SRC_ALPHA */, 1 /* ONE */, 770 /* SRC_ALPHA */, 1 /* ONE */];
                    break;
                case 4 /* Add_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [1 /* ONE */, 1 /* ONE */, 1 /* ONE */, 1 /* ONE */];
                    break;
                case 1 /* Blend */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [770 /* SRC_ALPHA */, 771 /* ONE_MINUS_SRC_ALPHA */, 1 /* ONE */, 771 /* ONE_MINUS_SRC_ALPHA */];
                    break;
                case 2 /* Blend_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */, 1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */];
                    break;
                case 5 /* Subtractive */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [0 /* ZERO */, 769 /* ONE_MINUS_SRC_COLOR */, 0 /* ZERO */, 769 /* ONE_MINUS_SRC_COLOR */];
                    break;
                case 6 /* Subtractive_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [0 /* ZERO */, 0 /* ZERO */, 769 /* ONE_MINUS_SRC_COLOR */, 771 /* ONE_MINUS_SRC_ALPHA */];
                    break;
                case 7 /* Multiply */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [0 /* ZERO */, 768 /* SRC_COLOR */, 0 /* ZERO */, 768 /* SRC_COLOR */];
                    break;
                case 8 /* Multiply_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [0 /* ZERO */, 768 /* SRC_COLOR */, 0 /* ZERO */, 770 /* SRC_ALPHA */];
                    break;
                default:
                    delete functions.blendEquationSeparate;
                    delete functions.blendFuncSeparate;
                    break;
            }
            var index = enables.indexOf(3042 /* BLEND */);
            if (blend === 0 /* None */) {
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            else {
                if (index < 0) {
                    enables.push(3042 /* BLEND */);
                }
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.setCullFace = function (cull, frontFace, cullFace) {
            if (!this._glTFTechnique.states) {
                this._glTFTechnique.states = { enable: [], functions: {} };
            }
            var enables = this._glTFTechnique.states.enable;
            var functions = this._glTFTechnique.states.functions;
            var index = enables.indexOf(2884 /* CULL_FACE */);
            if (cull && frontFace && cullFace) {
                functions.frontFace = [frontFace];
                functions.cullFace = [cullFace];
                if (index < 0) {
                    enables.push(2884 /* CULL_FACE */);
                }
            }
            else {
                delete functions.frontFace;
                delete functions.cullFace;
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.setDepth = function (zTest, zWrite) {
            if (!this._glTFTechnique.states) {
                this._glTFTechnique.states = { enable: [], functions: {} };
            }
            var enables = this._glTFTechnique.states.enable;
            var functions = this._glTFTechnique.states.functions;
            var index = enables.indexOf(2929 /* DEPTH_TEST */);
            if (zTest) {
                if (index < 0) {
                    enables.push(2929 /* DEPTH_TEST */);
                }
                functions.depthFunc = [515 /* LEQUAL */];
            }
            else {
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            if (zWrite) {
                functions.depthMask = [true];
            }
            else {
                functions.depthMask = [false];
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.setRenderQueue = function (value) {
            this.renderQueue = value;
            return this;
        };
        /**
         *
         */
        Material.prototype.setOpacity = function (value) {
            return this.setFloat("opacity" /* Opacity */, value);
        };
        /**
         *
         */
        Material.prototype.setShader = function (value) {
            if (!value) {
                console.warn("Set shader error.");
                value = egret3d.DefaultShaders.MESH_BASIC;
            }
            if (this._shader === value) {
                return;
            }
            this._reset(value);
            return this;
        };
        /**
         *
         */
        Material.prototype.clearStates = function () {
            if (this._glTFTechnique.states) {
                delete this._glTFTechnique.states;
            }
            return this;
        };
        Object.defineProperty(Material.prototype, "shaderDefine", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                this._cacheDefines = "";
                for (var _i = 0, _a = this._defines; _i < _a.length; _i++) {
                    var key = _a[_i];
                    this._cacheDefines += "#define " + key + " \n";
                }
                return this._cacheDefines;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "opacity", {
            /**
             * 该材质的透明度。
             * - 材质是否透明
             */
            get: function () {
                var uniform = this._glTFTechnique.uniforms["opacity" /* Opacity */];
                return (!uniform || uniform.value !== uniform.value) ? 1.0 : uniform.value;
            },
            set: function (value) {
                this.setFloat("opacity" /* Opacity */, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "shader", {
            /**
             *
             */
            get: function () {
                return this._shader;
            },
            set: function (value) {
                if (!value) {
                    console.warn("Set shader error.");
                    value = egret3d.DefaultShaders.MESH_BASIC;
                }
                if (this._shader === value) {
                    return;
                }
                this._reset(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "glTFTechnique", {
            /**
             *
             */
            get: function () {
                return this._glTFTechnique;
            },
            enumerable: true,
            configurable: true
        });
        return Material;
    }(egret3d.GLTFAsset));
    egret3d.Material = Material;
    __reflect(Material.prototype, "egret3d.Material");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderLib;
    (function (ShaderLib) {
        ShaderLib.cube = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "cube_vert", "type": 35633, "uri": "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_Position.z = gl_Position.w; // set z to camera.far\r\n\r\n}\r\n" }, { "name": "cube_frag", "type": 35632, "uri": "uniform samplerCube tCube;\r\nuniform float tFlip;\r\nuniform float opacity;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\r\n\tgl_FragColor.a *= opacity;\r\n\r\n}\r\n" }], "techniques": [{ "name": "cube", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "tCube": { "type": 35680 }, "tFlip": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.depth = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "depth_vert", "type": 35633, "uri": "#include <common>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n}\r\n" }, { "name": "depth_frag", "type": 35632, "uri": "#if DEPTH_PACKING == 3200\r\n\r\n\tuniform float opacity;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tdiffuseColor.a = opacity;\r\n\r\n\t#endif\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\r\n\r\n\t#elif DEPTH_PACKING == 3201\r\n\r\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\r\n\r\n\t#endif\r\n\r\n}\r\n" }], "techniques": [{ "name": "depth", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "logDepthBufFC": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.distanceRGBA = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "distanceRGBA_vert", "type": 35633, "uri": "#define DISTANCE\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvWorldPosition = worldPosition.xyz;\r\n\r\n}\r\n" }, { "name": "distanceRGBA_frag", "type": 35632, "uri": "#define DISTANCE\r\n\r\nuniform vec3 referencePosition;\r\nuniform float nearDistance;\r\nuniform float farDistance;\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main () {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\tfloat dist = length( vWorldPosition - referencePosition );\r\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\r\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\r\n\r\n\tgl_FragColor = packDepthToRGBA( dist );\r\n\r\n}\r\n" }], "techniques": [{ "name": "distanceRGBA", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "referencePosition": { "type": 35665, "semantic": "_REFERENCEPOSITION" }, "nearDistance": { "type": 5126, "semantic": "_NEARDICTANCE" }, "farDistance": { "type": 5126, "semantic": "_FARDISTANCE" }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.equirect = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "equirect_vert", "type": 35633, "uri": "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n}\r\n" }, { "name": "equirect_frag", "type": 35632, "uri": "uniform sampler2D tEquirect;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvec3 direction = normalize( vWorldPosition );\r\n\r\n\tvec2 sampleUV;\r\n\r\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\r\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\r\n\r\n}\r\n" }], "techniques": [{ "name": "equirect", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "tEquirect": { "type": 35678 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.linebasic = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "linebasic_vert", "type": 35633, "uri": "#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\nuniform float linewidth;\r\nuniform vec2 resolution;\r\nattribute vec3 instanceStart;\r\nattribute vec3 instanceEnd;\r\nattribute vec3 instanceColorStart;\r\nattribute vec3 instanceColorEnd;\r\nvarying vec2 vUv;\r\n#ifdef USE_DASH\r\n\tuniform float dashScale;\r\n\tattribute float instanceDistanceStart;\r\n\tattribute float instanceDistanceEnd;\r\n\tvarying float vLineDistance;\r\n#endif\r\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\r\n\t// trim end segment so it terminates between the camera plane and the near plane\r\n\t// conservative estimate of the near plane\r\n\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\r\n\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\r\n\tfloat nearEstimate = - 0.5 * b / a;\r\n\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\r\n\tend.xyz = mix( start.xyz, end.xyz, alpha );\r\n}\r\nvoid main() {\r\n\t#ifdef USE_COLOR\r\n\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\r\n\t#endif\r\n\t#ifdef USE_DASH\r\n\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\r\n\t#endif\r\n\tfloat aspect = resolution.x / resolution.y;\r\n\tvUv = uv;\r\n\t// camera space\r\n\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\r\n\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\r\n\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\r\n\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\r\n\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\r\n\t// perhaps there is a more elegant solution -- WestLangley\r\n\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\r\n\tif ( perspective ) {\r\n\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\r\n\t\t\ttrimSegment( start, end );\r\n\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\r\n\t\t\ttrimSegment( end, start );\r\n\t\t}\r\n\t}\r\n\t// clip space\r\n\tvec4 clipStart = projectionMatrix * start;\r\n\tvec4 clipEnd = projectionMatrix * end;\r\n\t// ndc space\r\n\tvec2 ndcStart = clipStart.xy / clipStart.w;\r\n\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\r\n\t// direction\r\n\tvec2 dir = ndcEnd - ndcStart;\r\n\t// account for clip-space aspect ratio\r\n\tdir.x *= aspect;\r\n\tdir = normalize( dir );\r\n\t// perpendicular to dir\r\n\tvec2 offset = vec2( dir.y, - dir.x );\r\n\t// undo aspect ratio adjustment\r\n\tdir.x /= aspect;\r\n\toffset.x /= aspect;\r\n\t// sign flip\r\n\tif ( position.x < 0.0 ) offset *= - 1.0;\r\n\t// endcaps\r\n\tif ( position.y < 0.0 ) {\r\n\t\toffset += - dir;\r\n\t} else if ( position.y > 1.0 ) {\r\n\t\toffset += dir;\r\n\t}\r\n\t// adjust for linewidth\r\n\toffset *= linewidth;\r\n\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\r\n\toffset /= resolution.y;\r\n\t// select end\r\n\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\r\n\t// back to clip space\r\n\toffset *= clip.w;\r\n\tclip.xy += offset;\r\n\tgl_Position = clip;\r\n\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n}" }, { "name": "linebasic_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#ifdef USE_DASH\r\n\r\n\tuniform float dashSize;\r\n\tuniform float gapSize;\r\n\r\n#endif\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\t#ifdef USE_DASH\r\n\r\n\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\r\n\r\n\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\r\n\r\n\t#endif\r\n\r\n\tif ( abs( vUv.y ) > 1.0 ) {\r\n\r\n\t\tfloat a = vUv.x;\r\n\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n\t\tfloat len2 = a * a + b * b;\r\n\r\n\t\tif ( len2 > 1.0 ) discard;\r\n\r\n\t}\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <color_fragment>\r\n\r\n\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}" }], "techniques": [{ "name": "linebasic", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "instanceStart": { "semantic": "_INSTANCE_START" }, "instanceEnd": { "semantic": "_INSTANCE_END" }, "instanceColorStart": { "semantic": "_INSTANCE_COLOR_START" }, "instanceColorEnd": { "semantic": "_INSTANCE_COLOR_END" }, "instanceDistanceStart": { "semantic": "_INSTANCE_DISTANCE_START" }, "instanceDistanceEnd": { "semantic": "_INSTANCE_DISTANCE_END" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "logDepthBufFC": { "type": 5126 }, "linewidth": { "type": 5126, "value": 1 }, "resolution": { "type": 35664, "semantic": "_RESOLUTION" }, "dashScale": { "type": 5126, "value": 1 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "dashSize": { "type": 5126, "value": 1 }, "gapSize": { "type": 5126, "value": 1 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.linedashed = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "linedashed_vert", "type": 35633, "uri": "uniform float scale;\r\nattribute float lineDistance;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\r\n\tvLineDistance = scale * lineDistance;\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "linedashed_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\nuniform float dashSize;\r\nuniform float totalSize;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <color_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb; // simple shader\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "linedashed", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "lineDistance": { "semantic": "_INSTANCE_DISTANCE" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "scale": { "type": 5126, "value": 1 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "dashSize": { "type": 5126, "value": 1 }, "totalSize": { "type": 5126, "value": 1 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshbasic = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshbasic_vert", "type": 35633, "uri": "#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_ENVMAP\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshbasic_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\r\n\t// accumulation (baked indirect lighting only)\r\n\t#ifdef USE_LIGHTMAP\r\n\t\t  reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\r\n\r\n\t#endif\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\r\n\r\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t// #include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshbasic", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "refractionRatio": { "type": 5126, "value": [] }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshlambert = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshlambert_vert", "type": 35633, "uri": "#define LAMBERT\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_pars_maps>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <lights_lambert_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshlambert_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float opacity;\r\n\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_pars_maps>\r\n#include <fog_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\t#include <lightmap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n\r\n\t#ifdef DOUBLE_SIDED\r\n\r\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.directDiffuse = vLightFront;\r\n\r\n\t#endif\r\n\r\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t// #include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshlambert", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "refractionRatio": { "type": 5126, "value": [] }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAP" }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshphong = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshphong_vert", "type": 35633, "uri": "#define PHONG\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshphong_frag", "type": 35632, "uri": "#define PHONG\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <gradientmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_phong_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_phong_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshphong", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "refractionRatio": { "type": 5126, "value": [] }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "specular": { "type": 35665, "value": [1, 1, 1] }, "shininess": { "type": 5126, "value": 1 }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "gradientMap": { "type": 35678 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAP" }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664 }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshphysical = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshphysical_vert", "type": 35633, "uri": "#define PHYSICAL\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshphysical_frag", "type": 35632, "uri": "#define PHYSICAL\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n\r\n#ifndef STANDARD\r\n\tuniform float clearCoat;\r\n\tuniform float clearCoatRoughness;\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <bsdfs>\r\n#include <cube_uv_reflection_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <envmap_physical_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <lights_pars_begin>\r\n#include <lights_physical_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <roughnessmap_fragment>\r\n\t#include <metalnessmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_physical_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshphysical", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "roughness": { "type": 5126 }, "metalness": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "clearCoat": { "type": 5126 }, "clearCoatRoughness": { "type": 5126 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "refractionRatio": { "type": 5126, "value": [] }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAP" }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664 }, "roughnessMap": { "type": 35678 }, "metalnessMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.normal = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "normal_vert", "type": 35633, "uri": "#define NORMAL\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n#endif\r\n\r\n}\r\n" }, { "name": "normal_frag", "type": 35632, "uri": "#define NORMAL\r\n\r\nuniform float opacity;\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\r\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\r\n\r\n}\r\n" }], "techniques": [{ "name": "normal", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "logDepthBufFC": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.particle = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "particle_vert", "type": 35633, "uri": "//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.vs\r\n#include <common>\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec2 corner;\r\n#endif\r\nattribute vec3 startPosition;\r\nattribute vec3 startVelocity;\r\nattribute vec4 startColor;\r\nattribute vec3 startSize;\r\nattribute vec3 startRotation;\r\nattribute vec2 time;\r\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)||defined(ROTATIONTWOCONSTANTS)||defined(ROTATIONTWOCURVES)\r\n  attribute vec4 random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONTWOCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\r\n  attribute vec4 random1;\r\n#endif\r\nattribute vec3 startWorldPosition;\r\nattribute vec4 startWorldRotation;\r\n\r\n#include <particle_common>\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_currentTime - time.y;\r\n\tfloat t = age/time.x;\r\n\tif(t>1.0){ \t\t\t\r\n\t\t\tv_discard=1.0;\r\n\t\t\treturn;\r\n  }\r\n\t  \r\n\t#include <particle_affector>\r\n\tgl_Position=viewProjectionMatrix*vec4(center,1.0);\r\n\tv_color = computeColor(startColor, t);\r\n\tv_texcoord =computeUV(uv, t);\r\n\tv_discard=0.0;\r\n}\r\n\r\n" }, { "name": "particle_frag", "type": 35632, "uri": "//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.ps\r\n#include <common>\r\nuniform sampler2D map;\r\nuniform vec3 diffuse;\r\nuniform float opacity;\r\nvarying float v_discard;\r\nvarying vec4 v_color;\r\nvarying vec2 v_texcoord;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_mesh_color;\r\n#endif\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_mesh_color;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\r\n\tif(v_discard!=0.0)\r\n\t\tdiscard;\r\n\tgl_FragColor*=texture2D(map,v_texcoord)*vec4(diffuse, opacity)*v_color*2.0;\r\n}" }], "techniques": [{ "name": "particle", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "corner": { "semantic": "_CORNER" }, "startPosition": { "semantic": "_START_POSITION" }, "startVelocity": { "semantic": "_START_VELOCITY" }, "startColor": { "semantic": "_START_COLOR" }, "startSize": { "semantic": "_START_SIZE" }, "startRotation": { "semantic": "_START_ROTATION" }, "time": { "semantic": "_TIME" }, "random0": { "semantic": "_RANDOM0" }, "random1": { "semantic": "_RANDOM1" }, "startWorldPosition": { "semantic": "_WORLD_POSITION" }, "startWorldRotation": { "semantic": "_WORLD_ROTATION" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "u_currentTime": { "type": 5126 }, "u_gravity": { "type": 35665 }, "u_worldPosition": { "type": 35665, "value": [0, 0, 0] }, "u_worldRotation": { "type": 35666, "value": [0, 0, 0, 1] }, "u_startRotation3D": { "type": 35670 }, "u_scalingMode": { "type": 5124 }, "u_positionScale": { "type": 35665 }, "u_sizeScale": { "type": 35665 }, "viewProjectionMatrix": { "type": 35676, "semantic": "_VIEWPROJECTION" }, "cameraForward": { "type": 35665, "semantic": "_CAMERA_FORWARD" }, "cameraUp": { "type": 35665, "semantic": "CAMERA_UP" }, "u_lengthScale": { "type": 5126 }, "u_speeaScale": { "type": 5126 }, "u_simulationSpace": { "type": 5124 }, "u_spaceType": { "type": 5124 }, "u_velocityConst": { "type": 35665 }, "u_velocityCurveX[0]": { "type": 35664 }, "u_velocityCurveY[0]": { "type": 35664 }, "u_velocityCurveZ[0]": { "type": 35664 }, "u_velocityConstMax": { "type": 35665 }, "u_velocityCurveMaxX[0]": { "type": 35664 }, "u_velocityCurveMaxY[0]": { "type": 35664 }, "u_velocityCurveMaxZ[0]": { "type": 35664 }, "u_colorGradient[0]": { "type": 35666 }, "u_alphaGradient[0]": { "type": 35664 }, "u_colorGradientMax[0]": { "type": 35666 }, "u_alphaGradientMax[0]": { "type": 35664 }, "u_sizeCurve[0]": { "type": 35664 }, "u_sizeCurveMax[0]": { "type": 35664 }, "u_sizeCurveX[0]": { "type": 35664 }, "u_sizeCurveY[0]": { "type": 35664 }, "u_sizeCurveZ[0]": { "type": 35664 }, "u_sizeCurveMaxX[0]": { "type": 35664 }, "u_sizeCurveMaxY[0]": { "type": 35664 }, "u_sizeCurveMaxZ[0]": { "type": 35664 }, "u_rotationConst": { "type": 5126 }, "u_rotationConstMax": { "type": 5126 }, "u_rotationCurve[0]": { "type": 35664 }, "u_rotationCurveMax[0]": { "type": 35664 }, "u_rotationConstSeprarate": { "type": 35665 }, "u_rotationConstMaxSeprarate": { "type": 35665 }, "u_rotationCurveX[0]": { "type": 35664 }, "u_rotationCurveY[0]": { "type": 35664 }, "u_rotationCurveZ[0]": { "type": 35664 }, "u_rotationCurveW[0]": { "type": 35664 }, "u_rotationCurveMaxX[0]": { "type": 35664 }, "u_rotationCurveMaxY[0]": { "type": 35664 }, "u_rotationCurveMaxZ[0]": { "type": 35664 }, "u_rotationCurveMaxW[0]": { "type": 35664 }, "u_cycles": { "type": 5126 }, "u_subUV": { "type": 35666 }, "u_uvCurve[0]": { "type": 35664 }, "u_uvCurveMax[0]": { "type": 35664 }, "map": { "type": 35678 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.points = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "points_vert", "type": 35633, "uri": "uniform float size;\r\nuniform float scale;\r\n\r\n#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_PointSize = size;\r\n\r\n\t#ifdef USE_SIZEATTENUATION\r\n\r\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\r\n\r\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\r\n\r\n\t#endif\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "points_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <map_particle_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_particle_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "points", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "size": { "type": 5126 }, "scale": { "type": 5126, "value": 1 }, "morphTargetInfluences[0]": { "type": 5126 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "map": { "type": 35678 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.shadow = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "shadow_vert", "type": 35633, "uri": "\r\n#include <fog_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "shadow_frag", "type": 35632, "uri": "uniform vec3 color;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\r\n\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "shadow", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "color": { "type": 35665 }, "opacity": { "type": 5126, "value": 1 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAP" } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.sprite = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "sprite_vert", "type": 35633, "uri": "uniform float rotation;\r\nuniform vec2 center;\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\n\tvec2 scale;\r\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\r\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\r\n\r\n\t#ifndef USE_SIZEATTENUATION\r\n\r\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\r\n\r\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\r\n\r\n\t#endif\r\n\r\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\r\n\r\n\tvec2 rotatedPosition;\r\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\r\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\r\n\r\n\tmvPosition.xy += rotatedPosition;\r\n\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "sprite_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "sprite", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "rotation": { "type": 5126 }, "center": { "type": 35664 }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
    })(ShaderLib = egret3d.ShaderLib || (egret3d.ShaderLib = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderChunk;
    (function (ShaderChunk) {
        ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
        ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n uniform sampler2D alphaMap;\n\n#endif\n";
        ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
        ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n\n // reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n #if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n  float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n  reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n #endif\n\n#endif\n";
        ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n\n uniform sampler2D aoMap;\n uniform float aoMapIntensity;\n\n#endif";
        ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
        ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n";
        ShaderChunk.bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n if( decayExponent > 0.0 ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n  // based upon Frostbite 3 Moving to Physically-based Rendering\n  // page 32, equation 26: E[window1]\n  // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n  // this is intended to be used on spot and point lights who are represented as luminous intensity\n  // but who must be converted to luminous irradiance for surface lighting calculation\n  float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n  float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n  return distanceFalloff * maxDistanceCutoffFactor;\n\n#else\n\n  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n#endif\n\n }\n\n return 1.0;\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n return RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n // Original approximation by Christophe Schlick '94\n // float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n // Optimized variant (presented by Epic at SIGGRAPH '13)\n // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n // geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n // also see #12151\n\n float a2 = pow2( alpha );\n\n float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n return 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n float a2 = pow2( alpha );\n\n // dotNL and dotNV are explicitly swapped. This is not a mistake.\n float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n return 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n float a2 = pow2( alpha );\n\n float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n return RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n float alpha = pow2( roughness ); // UE4's roughness\n\n vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n float dotNH = saturate( dot( geometry.normal, halfDir ) );\n float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n float D = D_GGX( alpha, dotNH );\n\n return F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n const float LUT_SIZE  = 64.0;\n const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n const float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n float dotNV = saturate( dot( N, V ) );\n\n // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n uv = uv * LUT_SCALE + LUT_BIAS;\n\n return uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n // Real-Time Area Lighting: a Journey from Research to Production (p.102)\n // An approximation of the form factor of a horizon-clipped rectangle.\n\n float l = length( f );\n\n return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n float x = dot( v1, v2 );\n\n float y = abs( x );\n\n // rational polynomial approximation to theta / sin( theta ) / 2PI\n float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n float b = 3.4175940 + ( 4.1616724 + y ) * y;\n float v = a / b;\n\n float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n return cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n // bail if point is on back side of plane of light\n // assumes ccw winding order of light vertices\n vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n vec3 lightNormal = cross( v1, v2 );\n\n if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n // construct orthonormal basis around N\n vec3 T1, T2;\n T1 = normalize( V - N * dot( V, N ) );\n T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n // compute transform\n mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n // transform rect\n vec3 coords[ 4 ];\n coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n // project rect onto sphere\n coords[ 0 ] = normalize( coords[ 0 ] );\n coords[ 1 ] = normalize( coords[ 1 ] );\n coords[ 2 ] = normalize( coords[ 2 ] );\n coords[ 3 ] = normalize( coords[ 3 ] );\n\n // calculate vector form factor\n vec3 vectorFormFactor = vec3( 0.0 );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n // adjust for horizon clipping\n float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n // alternate method of adjusting for horizon clipping (see referece)\n // refactoring required\n float len = length( vectorFormFactor );\n float z = vectorFormFactor.z / len;\n\n const float LUT_SIZE  = 64.0;\n const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n const float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n // tabulated horizon-clipped sphere, apparently...\n vec2 uv = vec2( z * 0.5 + 0.5, len );\n uv = uv * LUT_SCALE + LUT_BIAS;\n\n float scale = texture2D( ltc_2, uv ).w;\n\n float result = len * scale;\n*/\n\n return vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n vec4 r = roughness * c0 + c1;\n\n float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n return specularColor * AB.x + AB.y;\n\n} // validated\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n return 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n //float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n //float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n float dotNH = saturate( dot( geometry.normal, halfDir ) );\n float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n float D = D_BlinnPhong( shininess, dotNH );\n\n return F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
        ShaderChunk.bumpMap_pars_frag = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n uniform float bumpScale;\n\n // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd(vec2 uv) {\n\n  vec2 dSTdx = dFdx( uv );\n  vec2 dSTdy = dFdy( uv );\n\n  float Hll = bumpScale * texture2D( bumpMap, uv ).x;\n  float dBx = bumpScale * texture2D( bumpMap, uv + dSTdx ).x - Hll;\n  float dBy = bumpScale * texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\n  return vec2( dBx, dBy );\n\n }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\n  vec3 vSigmaX = dFdx( surf_pos );\n  vec3 vSigmaY = dFdy( surf_pos );\n  vec3 vN = surf_norm;  // normalized\n\n  vec3 R1 = cross( vSigmaY, vN );\n  vec3 R2 = cross( vN, vSigmaX );\n\n  float fDet = dot( vSigmaX, R1 );\n\n  vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n  return normalize( abs( fDet ) * surf_norm - vGrad );\n\n }\n\n#endif\n";
        ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n uniform float bumpScale;\n\n // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n // http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd() {\n\n  vec2 dSTdx = dFdx( vUv );\n  vec2 dSTdy = dFdy( vUv );\n\n  float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n  float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n  float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n  return vec2( dBx, dBy );\n\n }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n  // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n  vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n  vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n  vec3 vN = surf_norm;  // normalized\n\n  vec3 R1 = cross( vSigmaY, vN );\n  vec3 R2 = cross( vN, vSigmaX );\n\n  float fDet = dot( vSigmaX, R1 );\n\n  fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n  vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n  return normalize( abs( fDet ) * surf_norm - vGrad );\n\n }\n\n#endif\n";
        ShaderChunk.clipping_planes_fragment = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0\n\n vec4 plane;\n\n // #pragma unroll_loop\n for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n  plane = clippingPlanes[ i ];\n  if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\n }\n\n #if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n  bool clipped = true;\n\n  // #pragma unroll_loop\n  for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n   plane = clippingPlanes[ i ];\n   clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\n  }\n\n  if ( clipped ) discard;\n\n #endif\n\n#endif\n";
        ShaderChunk.clipping_planes_pars_fragment = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0\n\n #if ! defined( PHYSICAL ) && ! defined( PHONG )\n  varying vec3 vViewPosition;\n #endif\n\n uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n";
        ShaderChunk.clipping_planes_pars_vertex = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n varying vec3 vViewPosition;\n#endif\n";
        ShaderChunk.clipping_planes_vertex = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n vViewPosition = - mvPosition.xyz;\n#endif\n\n";
        ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n diffuseColor.rgb *= vColor;\n\n#endif";
        ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif\n";
        ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif";
        ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n vColor.xyz = color.xyz;\n\n#endif";
        ShaderChunk.common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n return fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n vec3 color;\n vec3 direction;\n bool visible;\n};\n\nstruct ReflectedLight {\n vec3 directDiffuse;\n vec3 directSpecular;\n vec3 indirectDiffuse;\n vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n vec3 position;\n vec3 normal;\n vec3 viewDir;\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n float distance = dot( planeNormal, point - pointOnPlane );\n\n return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n mat3 tmp;\n\n tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n return tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n return dot( weights, color.rgb );\n\n}\n";
        ShaderChunk.common_frag_def = "//------------------------------------------------\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n//------------------------------------------------\n";
        ShaderChunk.common_vert_def = "\n//------------------------------------------------\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\n#ifdef USE_COLOR\n\n attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n attribute vec3 morphTarget0;\n attribute vec3 morphTarget1;\n attribute vec3 morphTarget2;\n attribute vec3 morphTarget3;\n #ifdef USE_MORPHNORMALS\n  attribute vec3 morphNormal0;\n  attribute vec3 morphNormal1;\n  attribute vec3 morphNormal2;\n  attribute vec3 morphNormal3;\n #else\n  attribute vec3 morphTarget4;\n  attribute vec3 morphTarget5;\n  attribute vec3 morphTarget6;\n  attribute vec3 morphTarget7;\n #endif\n#endif\n#ifdef USE_SKINNING\n attribute vec4 skinIndex;\n attribute vec4 skinWeight;\n#endif\n//------------------------------------------------\n";
        ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_textureSize (1024.0)\n\nint getFaceFromDirection(vec3 direction) {\n vec3 absDirection = abs(direction);\n int face = -1;\n if( absDirection.x > absDirection.z ) {\n  if(absDirection.x > absDirection.y )\n   face = direction.x > 0.0 ? 0 : 3;\n  else\n   face = direction.y > 0.0 ? 1 : 4;\n }\n else {\n  if(absDirection.z > absDirection.y )\n   face = direction.z > 0.0 ? 2 : 5;\n  else\n   face = direction.y > 0.0 ? 1 : 4;\n }\n return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\n\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n float dxRoughness = dFdx(roughness);\n float dyRoughness = dFdy(roughness);\n vec3 dx = dFdx( vec * scale * dxRoughness );\n vec3 dy = dFdy( vec * scale * dyRoughness );\n float d = max( dot( dx, dx ), dot( dy, dy ) );\n // Clamp the value to the max mip level counts. hard coded to 6 mips\n d = clamp(d, 1.0, cubeUV_rangeClamp);\n float mipLevel = 0.5 * log2(d);\n return vec2(floor(mipLevel), fract(mipLevel));\n}\n\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\n\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n float a = 16.0 * cubeUV_rcpTextureSize;\n\n vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n // float powScale = exp2(roughnessLevel + mipLevel);\n float powScale = exp2_packed.x * exp2_packed.y;\n // float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\n float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n // float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\n float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\n bool bRes = mipLevel == 0.0;\n scale =  bRes && (scale < a) ? a : scale;\n\n vec3 r;\n vec2 offset;\n int face = getFaceFromDirection(direction);\n\n float rcpPowScale = 1.0 / powScale;\n\n if( face == 0) {\n  r = vec3(direction.x, -direction.z, direction.y);\n  offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 1) {\n  r = vec3(direction.y, direction.x, direction.z);\n  offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 2) {\n  r = vec3(direction.z, direction.x, direction.y);\n  offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 3) {\n  r = vec3(direction.x, direction.z, direction.y);\n  offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n else if( face == 4) {\n  r = vec3(direction.y, direction.x, -direction.z);\n  offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n else {\n  r = vec3(direction.z, -direction.x, direction.y);\n  offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n r = normalize(r);\n float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n vec2 base = offset + vec2( texelOffset );\n return base + s * ( scale - 2.0 * texelOffset );\n}\n\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\n\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n float roughnessVal = roughness* cubeUV_maxLods3;\n float r1 = floor(roughnessVal);\n float r2 = r1 + 1.0;\n float t = fract(roughnessVal);\n vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n float s = mipInfo.y;\n float level0 = mipInfo.x;\n float level1 = level0 + 1.0;\n level1 = level1 > 5.0 ? 5.0 : level1;\n\n // round to nearest mipmap if we are not interpolating.\n level0 += min( floor( s + 0.5 ), 5.0 );\n\n // Tri linear interpolation.\n vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\n vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\n vec4 result = mix(color10, color20, t);\n\n return vec4(result.rgb, 1.0);\n}\n\n#endif\n";
        ShaderChunk.defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifdef FLIP_SIDED\n\n transformedNormal = - transformedNormal;\n\n#endif\n";
        ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\n uniform sampler2D displacementMap;\n uniform float displacementScale;\n uniform float displacementBias;\n\n#endif\n";
        ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\n transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";
        ShaderChunk.dithering_fragment = "#if defined( DITHERING )\n\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n";
        ShaderChunk.dithering_pars_fragment = "#if defined( DITHERING )\n\n // based on https://www.shadertoy.com/view/MslGR8\n vec3 dithering( vec3 color ) {\n  //Calculate grid position\n  float grid_position = rand( gl_FragCoord.xy );\n\n  //Shift the individual colors differently, thus making it even harder to see the dithering pattern\n  vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n  //modify shift acording to grid position.\n  dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n  //shift the color by dither_shift\n  return color + dither_shift_RGB;\n }\n\n#endif\n";
        ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\n vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n totalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n";
        ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\n uniform sampler2D emissiveMap;\n\n#endif\n";
        ShaderChunk.encodings_fragment = "  // gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
        ShaderChunk.encodings_pars_fragment = "// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n return value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n float maxComponent = max( max( value.r, value.g ), value.b );\n float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n float maxRGB = max( value.x, max( value.g, value.b ) );\n float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n M            = ceil( M * 255.0 ) / 255.0;\n return vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n float maxRGB = max( value.x, max( value.g, value.b ) );\n float D      = max( maxRange / maxRGB, 1.0 );\n D            = min( floor( D ) / 255.0, 1.0 );\n return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n vec4 vResult;\n vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n vResult.w = fract(Le);\n vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n return vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n float Le = value.z * 255.0 + value.w;\n vec3 Xp_Y_XYZp;\n Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
        ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n  vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n  // Transforming Normal Vectors with the Inverse Transformation\n  vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n  #endif\n\n #else\n\n  vec3 reflectVec = vReflect;\n\n #endif\n\n #ifdef ENVMAP_TYPE_CUBE\n\n  vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n #elif defined( ENVMAP_TYPE_EQUIREC )\n\n  vec2 sampleUV;\n\n  reflectVec = normalize( reflectVec );\n\n  sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n  sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n  vec4 envColor = texture2D( envMap, sampleUV );\n\n #elif defined( ENVMAP_TYPE_SPHERE )\n\n  reflectVec = normalize( reflectVec );\n\n  vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n  vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n #else\n\n  vec4 envColor = vec4( 0.0 );\n\n #endif\n\n envColor = envMapTexelToLinear( envColor );\n\n #ifdef ENVMAP_BLENDING_MULTIPLY\n\n  outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n #elif defined( ENVMAP_BLENDING_MIX )\n\n  outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n #elif defined( ENVMAP_BLENDING_ADD )\n\n  outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n #endif\n\n#endif\n";
        ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n uniform float reflectivity;\n uniform float envMapIntensity;\n#endif\n\n#ifdef USE_ENVMAP\n\n #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n  varying vec3 vWorldPosition;\n #endif\n\n #ifdef ENVMAP_TYPE_CUBE\n  uniform samplerCube envMap;\n #else\n  uniform sampler2D envMap;\n #endif\n uniform float flipEnvMap;\n uniform int maxMipLevel;\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n  uniform float refractionRatio;\n #else\n  varying vec3 vReflect;\n #endif\n\n#endif\n";
        ShaderChunk.envmap_pars_vertex = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n  varying vec3 vWorldPosition;\n\n #else\n\n  varying vec3 vReflect;\n  uniform float refractionRatio;\n\n #endif\n\n#endif\n";
        ShaderChunk.envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n  vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n   // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n   // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n   #else\n\n    // force the bias high to get the last LOD level as it is the most blurred.\n    vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n   vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\n  #else\n\n   vec4 envMapColor = vec4( 0.0 );\n\n  #endif\n\n  return PI * envMapColor.rgb * envMapIntensity;\n\n }\n\n // taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n  //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  float maxMIPLevelScalar = float( maxMIPLevel );\n  float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  // clamp to allowable LOD ranges.\n  return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n }\n\n vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n  #else\n\n   vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n  #endif\n\n  reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n  float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n   vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\n  #elif defined( ENVMAP_TYPE_EQUIREC )\n\n   vec2 sampleUV;\n   sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n   sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n\n   vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #endif\n\n  return envMapColor.rgb * envMapIntensity;\n\n }\n\n#endif\n";
        ShaderChunk.envmap_vertex = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n  vWorldPosition = worldPosition.xyz;\n\n #else\n\n  vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n  vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vReflect = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n  #endif\n\n #endif\n\n#endif\n";
        ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n float fogDepth = length( vFogPosition );\n\n #ifdef FOG_EXP2\n\n  float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n #else\n\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n #endif\n\n gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n";
        ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n uniform vec3 fogColor;\n varying vec3 vFogPosition;\n\n #ifdef FOG_EXP2\n\n  uniform float fogDensity;\n\n #else\n\n  uniform float fogNear;\n  uniform float fogFar;\n\n #endif\n\n#endif\n";
        ShaderChunk.fog_pars_vertex = "#ifdef USE_FOG\n\n varying vec3 vFogPosition;\n\n#endif\n";
        ShaderChunk.fog_vertex = "#ifdef USE_FOG\n\n vFogPosition = mvPosition.xyz;\n\n#endif\n";
        ShaderChunk.gradientmap_pars_fragment = "#ifdef TOON\n\n uniform sampler2D gradientMap;\n\n vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n  // dotNL will be from -1.0 to 1.0\n  float dotNL = dot( normal, lightDirection );\n  vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n  #ifdef USE_GRADIENTMAP\n\n   return texture2D( gradientMap, coord ).rgb;\n\n  #else\n\n   return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n  #endif\n\n\n }\n\n#endif\n";
        ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n";
        ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n uniform sampler2D lightMap;\n uniform float lightMapIntensity;\n\n#endif";
        ShaderChunk.lights_fragment_begin = "/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\nIncidentLight directLight;\n\n#if (defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n PointLight pointLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  // pointLight = pointLights[ i ];\n  pointLight.position = vec3(pointLights[i* 15 + 0], pointLights[i * 15 + 1], pointLights[i * 15 + 2]);\n  pointLight.color = vec3(pointLights[i* 15 + 3], pointLights[i * 15 + 4], pointLights[i * 15 + 5]);\n  pointLight.distance = pointLights[i * 15 + 6];\n  pointLight.decay = pointLights[i * 15 + 7];\n\n  getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n SpotLight spotLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  // spotLight = spotLights[ i ];\n  spotLight.position = vec3(spotLights[i * 18 + 0], spotLights[i * 18 + 1], spotLights[i * 18 + 2]);\n  spotLight.direction = vec3(spotLights[i * 18 + 3], spotLights[i * 18 + 4], spotLights[i * 18 + 5]);\n  spotLight.color = vec3(spotLights[i * 18 + 6], spotLights[i * 18 + 7], spotLights[i * 18 + 8]);\n  spotLight.distance = spotLights[i * 18 + 9];\n  spotLight.decay = spotLights[i * 18 + 10];\n  spotLight.coneCos = spotLights[i * 18 + 11];\n  spotLight.penumbraCos = spotLights[i * 18 + 12];\n  getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n DirectionalLight directionalLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  // directionalLight = directionalLights[ i ];\n  directionalLight.direction = vec3(directionalLights[i * 11 + 0], directionalLights[i * 11 + 1], directionalLights[i * 11 + 2]);\n  directionalLight.color = vec3(directionalLights[i * 11 + 3], directionalLights[i * 11 + 4], directionalLights[i * 11 + 5]);\n  getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_RECT_AREA_LIGHTS) &&  NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n RectAreaLight rectAreaLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  rectAreaLight = rectAreaLights[ i ];\n  RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n #if (defined(NUM_HEMI_LIGHTS) &&  NUM_HEMI_LIGHTS > 0 )\n\n  // #pragma unroll_loop\n  for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n   irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n  }\n\n #endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n vec3 radiance = vec3( 0.0 );\n vec3 clearCoatRadiance = vec3( 0.0 );\n\n#endif\n";
        ShaderChunk.lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\n RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n\n#endif\n";
        ShaderChunk.lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\n #ifdef USE_LIGHTMAP\n\n  vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n   lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n  #endif\n\n  irradiance += lightMapIrradiance;\n\n #endif\n\n #if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n  irradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\n #ifndef STANDARD\n  clearCoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n #endif\n\n#endif\n";
        ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n vLightBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0\n PointLight pointLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  pointLight.position = vec3(pointLights[i* 15 + 0], pointLights[i * 15 + 1], pointLights[i * 15 + 2]);\n  pointLight.color = vec3(pointLights[i* 15 + 3], pointLights[i * 15 + 4], pointLights[i * 15 + 5]);\n  pointLight.distance = pointLights[i * 15 + 6];\n  pointLight.decay = pointLights[i * 15 + 7];\n  getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n\n }\n\n#endif\n\n#if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0\n SpotLight spotLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n  spotLight.position = vec3(spotLights[i * 18 + 0], spotLights[i * 18 + 1], spotLights[i * 18 + 2]);\n  spotLight.direction = vec3(spotLights[i * 18 + 3], spotLights[i * 18 + 4], spotLights[i * 18 + 5]);\n  spotLight.color = vec3(spotLights[i * 18 + 6], spotLights[i * 18 + 7], spotLights[i * 18 + 8]);\n  spotLight.distance = spotLights[i * 18 + 9];\n  spotLight.decay = spotLights[i * 18 + 10];\n  spotLight.coneCos = spotLights[i * 18 + 11];\n  spotLight.penumbraCos = spotLights[i * 18 + 12];\n\n  getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n }\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  // TODO (abelnation): implement\n\n }\n\n#endif\n*/\n\n#if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0\n DirectionalLight directionalLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  directionalLight.direction = vec3(directionalLights[i * 11 + 0], directionalLights[i * 11 + 1], directionalLights[i * 11 + 2]);\n  directionalLight.color = vec3(directionalLights[i * 11 + 3], directionalLights[i * 11 + 4], directionalLights[i * 11 + 5]);\n  getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n  // directLightColor_Diffuse = directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n  // vLightFront += directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n\n }\n\n#endif\n\n#if defined(NUM_HEMI_LIGHTS) && NUM_HEMI_LIGHTS > 0\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n  vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n  #endif\n\n }\n\n#endif\n";
        ShaderChunk.lights_pars_begin = "uniform vec3 ambientLightColor;\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n vec3 irradiance = ambientLightColor;\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI;\n\n #endif\n\n return irradiance;\n\n}\n\n#if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0\n\n struct DirectionalLight {\n  vec3 direction;\n  vec3 color;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n };\n\n uniform float directionalLights[NUM_DIR_LIGHTS * 11];\n\n void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n  directLight.direction = directionalLight.direction;\n  directLight.color = directionalLight.color;\n  directLight.visible = true;\n }\n\n#endif\n\n\n#if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0\n\n struct PointLight {\n  vec3 position;\n  vec3 color;\n  float distance;\n  float decay;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n  float shadowCameraNear;\n  float shadowCameraFar;\n };\n\n uniform float pointLights[NUM_POINT_LIGHTS * 15 ];\n\n // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n  vec3 lVector = pointLight.position - geometry.position;\n  directLight.direction = normalize( lVector );\n\n  float lightDistance = length( lVector );\n\n  directLight.color = pointLight.color;\n  directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n  directLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n }\n\n#endif\n\n\n#if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0\n\n struct SpotLight {\n  vec3 position;\n  vec3 direction;\n  vec3 color;\n  float distance;\n  float decay;\n  float coneCos;\n  float penumbraCos;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n };\n\n uniform float spotLights[NUM_SPOT_LIGHTS * 18];\n\n // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n  vec3 lVector = spotLight.position - geometry.position;\n  directLight.direction = normalize( lVector );\n\n  float lightDistance = length( lVector );\n  float angleCos = dot( directLight.direction, spotLight.direction );\n\n  if ( angleCos > spotLight.coneCos ) {\n\n   float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n   directLight.color = spotLight.color;\n   directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n   directLight.visible = true;\n\n  } else {\n\n   directLight.color = vec3( 0.0 );\n   directLight.visible = false;\n\n  }\n }\n\n#endif\n\n\n#if defined(NUM_RECT_AREA_LIGHTS) && NUM_RECT_AREA_LIGHTS > 0\n\n struct RectAreaLight {\n  vec3 color;\n  vec3 position;\n  vec3 halfWidth;\n  vec3 halfHeight;\n };\n\n // Pre-computed values of LinearTransformedCosine approximation of BRDF\n // BRDF approximation Texture is 64x64\n uniform sampler2D ltc_1; // RGBA Float\n uniform sampler2D ltc_2; // RGBA Float\n\n uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if defined(NUM_HEMI_LIGHTS) && NUM_HEMI_LIGHTS > 0\n\n struct HemisphereLight {\n  vec3 direction;\n  vec3 skyColor;\n  vec3 groundColor;\n };\n\n uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n  float dotNL = dot( geometry.normal, hemiLight.direction );\n  float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n  vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n   irradiance *= PI;\n\n  #endif\n\n  return irradiance;\n\n }\n\n#endif\n";
        ShaderChunk.lights_pars_maps = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n  vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n   // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n   // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n   #else\n\n    // force the bias high to get the last LOD level as it is the most blurred.\n    vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n   vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\n  #else\n\n   vec4 envMapColor = vec4( 0.0 );\n\n  #endif\n\n  return PI * envMapColor.rgb * envMapIntensity;\n\n }\n\n // taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n  //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  float maxMIPLevelScalar = float( maxMIPLevel );\n  float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  // clamp to allowable LOD ranges.\n  return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n }\n\n vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n  #else\n\n   vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n  #endif\n\n  reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n  float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n   vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\n  #elif defined( ENVMAP_TYPE_EQUIREC )\n\n   vec2 sampleUV;\n   sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n   sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n\n   vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #endif\n\n  return envMapColor.rgb * envMapIntensity;\n\n }\n\n#endif\n";
        ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
        ShaderChunk.lights_phong_pars_fragment = "varying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n varying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n vec3 diffuseColor;\n vec3 specularColor;\n float specularShininess;\n float specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n #ifdef TOON\n\n  vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n #else\n\n  float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n  vec3 irradiance = dotNL * directLight.color;\n\n #endif\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI; // punctual light\n\n #endif\n\n reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct    RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material ) (0)\n";
        ShaderChunk.lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n material.clearCoat = saturate( clearCoat ); // Burley clearcoat model\n material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
        ShaderChunk.lights_physical_pars_fragment = "struct PhysicalMaterial {\n\n vec3 diffuseColor;\n float specularRoughness;\n vec3 specularColor;\n\n #ifndef STANDARD\n  float clearCoat;\n  float clearCoatRoughness;\n #endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n  vec3 normal = geometry.normal;\n  vec3 viewDir = geometry.viewDir;\n  vec3 position = geometry.position;\n  vec3 lightPos = rectAreaLight.position;\n  vec3 halfWidth = rectAreaLight.halfWidth;\n  vec3 halfHeight = rectAreaLight.halfHeight;\n  vec3 lightColor = rectAreaLight.color;\n  float roughness = material.specularRoughness;\n\n  vec3 rectCoords[ 4 ];\n  rectCoords[ 0 ] = lightPos - halfWidth - halfHeight; // counterclockwise\n  rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n  rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n  rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\n  vec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n  vec4 t1 = texture2D( ltc_1, uv );\n  vec4 t2 = texture2D( ltc_2, uv );\n\n  mat3 mInv = mat3(\n   vec3( t1.x, 0, t1.y ),\n   vec3(    0, 1,    0 ),\n   vec3( t1.z, 0, t1.w )\n  );\n\n  // LTC Fresnel Approximation by Stephen Hill\n  // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n  vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n  reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n  reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n }\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n vec3 irradiance = dotNL * directLight.color;\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI; // punctual light\n\n #endif\n\n #ifndef STANDARD\n  float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n #else\n  float clearCoatDHR = 0.0;\n #endif\n\n reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n #ifndef STANDARD\n\n  reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n #endif\n\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n #ifndef STANDARD\n  float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n  float dotNL = dotNV;\n  float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n #else\n  float clearCoatDHR = 0.0;\n #endif\n\n reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n #ifndef STANDARD\n\n  reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n #endif\n\n}\n\n#define RE_Direct    RE_Direct_Physical\n#define RE_Direct_RectArea  RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular  RE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n";
        ShaderChunk.logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif";
        ShaderChunk.logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n uniform float logDepthBufFC;\n varying float vFragDepth;\n\n#endif\n";
        ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n  varying float vFragDepth;\n\n #else\n\n  uniform float logDepthBufFC;\n\n #endif\n\n#endif\n";
        ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n  vFragDepth = 1.0 + gl_Position.w;\n\n #else\n\n  gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n  gl_Position.z *= gl_Position.w;\n\n #endif\n\n#endif\n";
        ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n vec4 texelColor = texture2D( map, vUv );\n\n // texelColor = mapTexelToLinear( texelColor );TODO\n diffuseColor *= texelColor;\n\n#endif\n";
        ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n\n uniform sampler2D map;\n\n#endif\n";
        ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n vec4 mapTexel = texture2D( map, uv );\n diffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n";
        ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n uniform mat3 uvTransform;\n uniform sampler2D map;\n\n#endif\n";
        ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n vec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n // reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n metalnessFactor *= texelMetalness.b;\n\n#endif\n";
        ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\n uniform sampler2D metalnessMap;\n\n#endif";
        ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";
        ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n #ifndef USE_MORPHNORMALS\n\n uniform float morphTargetInfluences[ 8 ];\n\n #else\n\n uniform float morphTargetInfluences[ 4 ];\n\n #endif\n\n#endif";
        ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n #ifndef USE_MORPHNORMALS\n\n transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n #endif\n\n#endif\n";
        ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n uniform sampler2D normalMap;\n uniform vec2 normalScale;\n\n #ifdef OBJECTSPACE_NORMALMAP\n\n  uniform mat3 normalMatrix;\n\n #else\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n   // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n   vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n   vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n   vec2 st0 = dFdx( vUv.st );\n   vec2 st1 = dFdy( vUv.st );\n\n   float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n   vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n   vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n   vec3 N = normalize( surf_norm );\n   mat3 tsn = mat3( S, T, N );\n\n   vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\n   mapN.xy *= normalScale;\n   mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n   return normalize( tsn * mapN );\n\n  }\n\n #endif\n\n#endif\n";
        ShaderChunk.normal_fragment_begin = "#ifdef FLAT_SHADED\n\n // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n vec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n vec3 normal = normalize( vNormal );\n\n #ifdef DOUBLE_SIDED\n\n  normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n #endif\n\n#endif\n";
        ShaderChunk.normal_fragment_maps = "#ifdef USE_NORMALMAP\n\n #ifdef OBJECTSPACE_NORMALMAP\n\n  normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n  #ifdef FLIP_SIDED\n\n   normal = - normal;\n\n  #endif\n\n  #ifdef DOUBLE_SIDED\n\n   normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n  #endif\n\n  normal = normalize( normalMatrix * normal );\n\n #else // tangent-space normal map\n\n  normal = perturbNormal2Arb( -vViewPosition, normal );\n\n #endif\n\n#elif defined( USE_BUMPMAP )\n\n normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n";
        ShaderChunk.packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n return normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n return 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n vec4 r = vec4( fract( v * PackFactors ), v );\n r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n return r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n return dot( v, UnpackFactors );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n return linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
        ShaderChunk.particle_affector = "vec3 lifeVelocity = computeVelocity(t);\nvec4 worldRotation;\nif(u_simulationSpace==1)\n worldRotation=startWorldRotation;\nelse\n worldRotation=u_worldRotation;\nvec3 gravity=u_gravity*age;\n\nvec3 center=computePosition(startVelocity, lifeVelocity, age, t,gravity,worldRotation); \n#ifdef SPHERHBILLBOARD\n   vec2 corner=corner.xy;\n      vec3 cameraUpVector =normalize(cameraUp);\n      vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n      vec3 upVector = normalize(cross(sideVector,cameraForward));\n     corner*=computeBillbardSize(startSize.xy,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n   if(u_startRotation3D){\n    vec3 rotation=vec3(startRotation.xy,computeRotation(startRotation.z,age,t));\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,rotation);\n   }\n   else{\n    float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #else\n   if(u_startRotation3D){\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,startRotation);\n   }\n   else{\n    float c = cos(startRotation.x);\n    float s = sin(startRotation.x);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #endif\n #endif\n #ifdef STRETCHEDBILLBOARD\n  vec2 corner=corner.xy;\n  vec3 velocity;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n      if(u_spaceType==0)\n       velocity=rotation_quaternions(u_sizeScale*(startVelocity+lifeVelocity),worldRotation)+gravity;\n      else\n       velocity=rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+lifeVelocity+gravity;\n   #else\n      velocity= rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+gravity;\n   #endif \n  vec3 cameraUpVector = normalize(velocity);\n  vec3 direction = normalize(center-cameraPosition);\n    vec3 sideVector = normalize(cross(direction,normalize(velocity)));\n  sideVector=u_sizeScale.xzy*sideVector;\n  cameraUpVector=length(vec3(u_sizeScale.x,0.0,0.0))*cameraUpVector;\n    vec2 size=computeBillbardSize(startSize.xy,t);\n    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n    corner=rotaionZHalfPI*corner;\n    corner.y=corner.y-abs(corner.y);\n    float speed=length(velocity);\n    center +=sign(u_sizeScale.x)*(sign(u_lengthScale)*size.x*corner.x*sideVector+(speed*u_speeaScale+size.y*u_lengthScale)*corner.y*cameraUpVector);\n #endif\n #ifdef HORIZONTALBILLBOARD\n  vec2 corner=corner.xy;\n    const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n  float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef VERTICALBILLBOARD\n  vec2 corner=corner.xy;\n    const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n    vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n  float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef RENDERMESH\n    vec3 size=computeMeshSize(startSize,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n    if(u_startRotation3D){\n     vec3 rotation=vec3(startRotation.xy,-computeRotation(startRotation.z, age,t));\n     center+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,rotation),worldRotation);\n    }\n    else{\n     #ifdef ROTATIONOVERLIFETIME\n      float angle=computeRotation(startRotation.x, age,t);\n      if(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n       center+= (rotation_quaternions(rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),angle),worldRotation));//已验证\n      }\n      else{\n       #ifdef SHAPE\n        center+= u_sizeScale.xzy*(rotation_quaternions(rotation_axis(position*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n       #else\n        if(u_simulationSpace==1)\n         center+=rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),angle);\n        else if(u_simulationSpace==0)\n         center+=rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),angle),worldRotation);\n       #endif\n      }\n     #endif\n     #ifdef ROTATIONSEPERATE\n      vec3 angle=compute3DRotation(vec3(0.0,0.0,startRotation.z), age,t);\n      center+= (rotation_quaternions(rotation_euler(u_sizeScale*position*size,vec3(angle.x,angle.y,angle.z)),worldRotation));\n     #endif \n    }\n  #else\n  if(u_startRotation3D){\n   center+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,startRotation),worldRotation);\n  }\n  else{\n   if(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n    if(u_simulationSpace==1)\n     center+= rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x);\n    else if(u_simulationSpace==0)\n     center+= (rotation_quaternions(u_sizeScale*rotation_axis(position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x),worldRotation));\n   }\n   else{\n    #ifdef SHAPE\n     if(u_simulationSpace==1)\n      center+= u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x),worldRotation); \n    #else\n     if(u_simulationSpace==1)\n      center+= rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),startRotation.x),worldRotation);\n    #endif\n   }\n  }\n  #endif\n  v_mesh_color=vec4(color, 1.0);\n  #endif";
        ShaderChunk.particle_common = "\n\nuniform float u_currentTime;\nuniform vec3 u_gravity;\n\nuniform vec3 u_worldPosition;\nuniform vec4 u_worldRotation;\nuniform bool u_startRotation3D;\nuniform int u_scalingMode;\nuniform vec3 u_positionScale;\nuniform vec3 u_sizeScale;\nuniform mat4 viewProjectionMatrix;\n\nuniform vec3 cameraForward;\nuniform vec3 cameraUp;\n\nuniform float u_lengthScale;\nuniform float u_speeaScale;\nuniform int u_simulationSpace;\n\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  uniform int u_spaceType;\n#endif\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYTWOCONSTANT)\n  uniform vec3 u_velocityConst;\n#endif\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)\n  uniform vec2 u_velocityCurveX[4];\n  uniform vec2 u_velocityCurveY[4];\n  uniform vec2 u_velocityCurveZ[4];\n#endif\n#ifdef VELOCITYTWOCONSTANT\n  uniform vec3 u_velocityConstMax;\n#endif\n#ifdef VELOCITYTWOCURVE\n  uniform vec2 u_velocityCurveMaxX[4];\n  uniform vec2 u_velocityCurveMaxY[4];\n  uniform vec2 u_velocityCurveMaxZ[4];\n#endif\n\n#ifdef COLOROGRADIENT\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n#endif\n#ifdef COLORTWOGRADIENTS\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n  uniform vec4 u_colorGradientMax[4];\n  uniform vec2 u_alphaGradientMax[4];\n#endif\n\n#if defined(SIZECURVE)||defined(SIZETWOCURVES)\n  uniform vec2 u_sizeCurve[4];\n#endif\n#ifdef SIZETWOCURVES\n  uniform vec2 u_sizeCurveMax[4];\n#endif\n#if defined(SIZECURVESEPERATE)||defined(SIZETWOCURVESSEPERATE)\n  uniform vec2 u_sizeCurveX[4];\n  uniform vec2 u_sizeCurveY[4];\n  uniform vec2 u_sizeCurveZ[4];\n#endif\n#ifdef SIZETWOCURVESSEPERATE\n  uniform vec2 u_sizeCurveMaxX[4];\n  uniform vec2 u_sizeCurveMaxY[4];\n  uniform vec2 u_sizeCurveMaxZ[4];\n#endif\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform float u_rotationConst;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform float u_rotationConstMax;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurve[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMax[4];\n  #endif\n#endif\n#ifdef ROTATIONSEPERATE\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform vec3 u_rotationConstSeprarate;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform vec3 u_rotationConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurveX[4];\n    uniform vec2 u_rotationCurveY[4];\n    uniform vec2 u_rotationCurveZ[4];\n  uniform vec2 u_rotationCurveW[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMaxX[4];\n    uniform vec2 u_rotationCurveMaxY[4];\n    uniform vec2 u_rotationCurveMaxZ[4];\n  uniform vec2 u_rotationCurveMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\n  uniform float u_cycles;\n  uniform vec4 u_subUV;\n  uniform vec2 u_uvCurve[4];\n#endif\n#ifdef TEXTURESHEETANIMATIONTWOCURVE\n  uniform vec2 u_uvCurveMax[4];\n#endif\n\nvarying float v_discard;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\n#ifdef RENDERMESH\n varying vec4 v_mesh_color;\n#endif\n\nvec3 rotation_euler(in vec3 vector,in vec3 euler)\n{\n  float halfPitch = euler.x * 0.5;\n float halfYaw = euler.y * 0.5;\n float halfRoll = euler.z * 0.5;\n\n float sinPitch = sin(halfPitch);\n float cosPitch = cos(halfPitch);\n float sinYaw = sin(halfYaw);\n float cosYaw = cos(halfYaw);\n float sinRoll = sin(halfRoll);\n float cosRoll = cos(halfRoll);\n\n float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n \n}\n\nvec3 rotation_axis(in vec3 vector,in vec3 axis, in float angle)\n{\n float halfAngle = angle * 0.5;\n float sin = sin(halfAngle);\n \n float quaX = axis.x * sin;\n float quaY = axis.y * sin;\n float quaZ = axis.z * sin;\n float quaW = cos(halfAngle);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n}\n\nvec3 rotation_quaternions(in vec3 v,in vec4 q) \n{\n return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(SIZECURVE)||defined(SIZECURVESEPERATE)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)\nfloat evaluate_curve_float(in vec2 curves[4],in float t)\n{\n float res;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  if(curTime>=t)\n  {\n   vec2 lastCurve=curves[i-1];\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res=mix(lastCurve.y,curve.y,tt);\n   break;\n  }\n }\n return res;\n}\n#endif\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\nfloat evaluate_curve_total(in vec2 curves[4],in float t)\n{\n float res=0.0;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  vec2 lastCurve=curves[i-1];\n  float lastValue=lastCurve.y;\n  \n  if(curTime>=t){\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res+=(lastValue+mix(lastValue,curve.y,tt))/2.0*time.x*(t-lastTime);\n   break;\n  }\n  else{\n   res+=(lastValue+curve.y)/2.0*time.x*(curTime-lastCurve.x);\n  }\n }\n return res;\n}\n#endif\n\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)\nvec4 evaluate_curve_color(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float t)\n{\n vec4 overTimeColor;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientAlpha=gradientAlphas[i];\n  float alphaKey=gradientAlpha.x;\n  if(alphaKey>=t)\n  {\n   vec2 lastGradientAlpha=gradientAlphas[i-1];\n   float lastAlphaKey=lastGradientAlpha.x;\n   float age=(t-lastAlphaKey)/(alphaKey-lastAlphaKey);\n   overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n   break;\n  }\n }\n \n for(int i=1;i<4;i++)\n {\n  vec4 gradientColor=gradientColors[i];\n  float colorKey=gradientColor.x;\n  if(colorKey>=t)\n  {\n   vec4 lastGradientColor=gradientColors[i-1];\n   float lastColorKey=lastGradientColor.x;\n   float age=(t-lastColorKey)/(colorKey-lastColorKey);\n   overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n   break;\n  }\n }\n return overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\nfloat evaluate_curve_frame(in vec2 gradientFrames[4],in float t)\n{\n float overTimeFrame;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientFrame=gradientFrames[i];\n  float key=gradientFrame.x;\n  if(key>=t)\n  {\n   vec2 lastGradientFrame=gradientFrames[i-1];\n   float lastKey=lastGradientFrame.x;\n   float age=(t-lastKey)/(key-lastKey);\n   overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n   break;\n  }\n }\n return floor(overTimeFrame);\n}\n#endif\n\nvec3 computeVelocity(in float t)\n{\n  vec3 res;\n  #ifdef VELOCITYCONSTANT\n  res=u_velocityConst; \n  #endif\n  #ifdef VELOCITYCURVE\n     res= vec3(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveZ,t));\n  #endif\n  #ifdef VELOCITYTWOCONSTANT\n  res=mix(u_velocityConst,u_velocityConstMax,vec3(random1.y,random1.z,random1.w)); \n  #endif\n  #ifdef VELOCITYTWOCURVE\n     res=vec3(mix(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveMaxX,t),random1.y),\n             mix(evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveMaxY,t),random1.z),\n        mix(evaluate_curve_float(u_velocityCurveZ,t),evaluate_curve_float(u_velocityCurveMaxZ,t),random1.w));\n  #endif\n     \n  return res;\n} \n\nvec3 computePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float t,vec3 gravityVelocity,vec4 worldRotation)\n{\n    vec3 startPosition;\n    vec3 lifePosition;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n   #ifdef VELOCITYCONSTANT\n      startPosition=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYCURVE\n      startPosition=startVelocity*age;\n      lifePosition=vec3(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveZ,t));\n   #endif\n   #ifdef VELOCITYTWOCONSTANT\n      startPosition=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYTWOCURVE\n      startPosition=startVelocity*age;\n      lifePosition=vec3(mix(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveMaxX,t),random1.y)\n                 ,mix(evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveMaxY,t),random1.z)\n                 ,mix(evaluate_curve_total(u_velocityCurveZ,t),evaluate_curve_total(u_velocityCurveMaxZ,t),random1.w));\n   #endif\n\n   vec3 finalPosition;\n   if(u_spaceType==0){\n     if(u_scalingMode!=2)\n      finalPosition =rotation_quaternions(u_positionScale*(startPosition.xyz+startPosition+lifePosition),worldRotation);\n     else\n      finalPosition =rotation_quaternions(u_positionScale*startPosition.xyz+startPosition+lifePosition,worldRotation);\n   }\n   else{\n     if(u_scalingMode!=2)\n       finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+startPosition),worldRotation)+lifePosition;\n     else\n       finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+startPosition,worldRotation)+lifePosition;\n   }\n    #else\n    startPosition=startVelocity*age;\n    vec3 finalPosition;\n    if(u_scalingMode!=2)\n      finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+startPosition),worldRotation);\n    else\n      finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+startPosition,worldRotation);\n  #endif\n  \n  if(u_simulationSpace==1)\n    finalPosition=finalPosition+startWorldPosition;\n  else if(u_simulationSpace==0) \n    finalPosition=finalPosition+u_worldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return finalPosition;\n}\n\n\nvec4 computeColor(in vec4 color,in float t)\n{\n #ifdef COLOROGRADIENT\n   color*=evaluate_curve_color(u_alphaGradient,u_colorGradient,t);\n #endif \n #ifdef COLORTWOGRADIENTS\n   color*=mix(evaluate_curve_color(u_alphaGradient,u_colorGradient,t),evaluate_curve_color(u_alphaGradientMax,u_colorGradientMax,t),random0.y);\n #endif\n\n  return color;\n}\n\nvec2 computeBillbardSize(in vec2 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec2(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec2(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z));\n #endif\n return size;\n}\n\n#ifdef RENDERMESH\nvec3 computeMeshSize(in vec3 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec3(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveZ,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec3(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z)\n       ,mix(evaluate_curve_float(u_sizeCurveZ,t),evaluate_curve_float(u_sizeCurveMaxZ,t),random0.z));\n #endif\n return size;\n}\n#endif\n\nfloat computeRotation(in float rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConst*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurve,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n     rotation+=ageRot;\n   #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n  #endif\n #endif\n #ifdef ROTATIONSEPERATE\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConstSeprarate.z*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurveZ,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConstSeprarate.z,u_rotationConstMaxSeprarate.z,random0.w)*age;\n         rotation+=ageRot;\n     #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n  #endif\n #endif\n return rotation;\n}\n\n#if defined(RENDERMESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE))\nvec3 compute3DRotation(in vec3 rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n   #ifdef ROTATIONCONSTANT\n     float ageRot=u_rotationConst*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONCURVE\n     rotation+=evaluate_curve_total(u_rotationCurve,t);\n   #endif\n   #ifdef ROTATIONTWOCONSTANTS\n     float ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONTWOCURVES\n     rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n   #endif\n #endif\n #ifdef ROTATIONSEPERATE\n    #ifdef ROTATIONCONSTANT\n     vec3 ageRot=u_rotationConstSeprarate*age;\n           rotation+=ageRot;\n    #endif\n    #ifdef ROTATIONCURVE\n     rotation+=vec3(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveZ,t));\n    #endif\n    #ifdef ROTATIONTWOCONSTANTS\n     vec3 ageRot=mix(u_rotationConstSeprarate,u_rotationConstMaxSeprarate,random0.w)*age;\n           rotation+=ageRot;\n     #endif\n    #ifdef ROTATIONTWOCURVES\n     rotation+=vec3(mix(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveMaxX,t),random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveMaxY,t),random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n    #endif\n #endif\n return rotation;\n}\n#endif\n\nvec2 computeUV(in vec2 uv,in float t)\n{ \n #ifdef TEXTURESHEETANIMATIONCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n  float frame=evaluate_curve_frame(u_uvCurve,uvNormalizedAge);\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n #ifdef TEXTURESHEETANIMATIONTWOCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n   float frame=floor(mix(evaluate_curve_frame(u_uvCurve,uvNormalizedAge),evaluate_curve_frame(u_uvCurveMax,uvNormalizedAge),random1.x));\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n return uv;\n}";
        ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\n // Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n gl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n";
        ShaderChunk.project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\ngl_Position = projectionMatrix * mvPosition;\n";
        ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n vec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n roughnessFactor *= texelRoughness.g;\n\n#endif\n";
        ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\n uniform sampler2D roughnessMap;\n\n#endif";
        ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n  uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n  varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n  uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n  varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n  uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n  varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): create uniforms for area light shadows\n\n #endif\n */\n\n float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n  return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n }\n\n float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n  const vec2 offset = vec2( 0.0, 1.0 );\n\n  vec2 texelSize = vec2( 1.0 ) / size;\n  vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n  float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n  float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n  float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n  float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n  vec2 f = fract( uv * size + 0.5 );\n\n  float a = mix( lb, lt, f.y );\n  float b = mix( rb, rt, f.y );\n  float c = mix( a, b, f.x );\n\n  return c;\n\n }\n\n float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n  float shadow = 1.0;\n\n  shadowCoord.xyz /= shadowCoord.w;\n  shadowCoord.z += shadowBias;//Egret Right-hand\n\n  // if ( something && something ) breaks ATI OpenGL shader compiler\n  // if ( all( something, something ) ) using this instead\n\n  bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n  bool inFrustum = all( inFrustumVec );\n\n  bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n  bool frustumTest = all( frustumTestVec );\n\n  if ( frustumTest ) {\n\n  #if defined( SHADOWMAP_TYPE_PCF )\n\n   vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n   float dx0 = - texelSize.x * shadowRadius;\n   float dy0 = - texelSize.y * shadowRadius;\n   float dx1 = + texelSize.x * shadowRadius;\n   float dy1 = + texelSize.y * shadowRadius;\n\n   shadow = (\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n   ) * ( 1.0 / 9.0 );\n\n  #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n   vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n   float dx0 = - texelSize.x * shadowRadius;\n   float dy0 = - texelSize.y * shadowRadius;\n   float dx1 = + texelSize.x * shadowRadius;\n   float dy1 = + texelSize.y * shadowRadius;\n\n   shadow = (\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n   ) * ( 1.0 / 9.0 );\n\n  #else // no percentage-closer filtering:\n\n   shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n  #endif\n\n  }\n\n  return shadow;\n\n }\n\n // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n // vector suitable for 2D texture mapping. This code uses the following layout for the\n // 2D texture:\n //\n // xzXZ\n //  y Y\n //\n // Y - Positive y direction\n // y - Negative y direction\n // X - Positive x direction\n // x - Negative x direction\n // Z - Positive z direction\n // z - Negative z direction\n //\n // Source and test bed:\n // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n  // Number of texels to avoid at the edge of each square\n\n  vec3 absV = abs( v );\n\n  // Intersect unit cube\n\n  float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n  absV *= scaleToCube;\n\n  // Apply scale to avoid seams\n\n  // two texels less per square (one texel will do for NEAREST)\n  v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n  // Unwrap\n\n  // space: -1 ... 1 range for each square\n  //\n  // #X##  dim    := ( 4 , 2 )\n  //  # #  center := ( 1 , 1 )\n\n  vec2 planar = v.xy;\n\n  float almostATexel = 1.5 * texelSizeY;\n  float almostOne = 1.0 - almostATexel;\n\n  if ( absV.z >= almostOne ) {\n\n   if ( v.z > 0.0 )\n    planar.x = 4.0 - v.x;\n\n  } else if ( absV.x >= almostOne ) {\n\n   float signX = sign( v.x );\n   planar.x = v.z * signX + 2.0 * signX;\n\n  } else if ( absV.y >= almostOne ) {\n\n   float signY = sign( v.y );\n   planar.x = v.x + 2.0 * signY + 2.0;\n   planar.y = v.z * signY - 2.0;\n\n  }\n\n  // Transform to UV space\n\n  // scale := 0.5 / dim\n  // translate := ( center + 0.5 ) / dim\n  return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n }\n\n float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n  vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n  // for point lights, the uniform @vShadowCoord is re-purposed to hold\n  // the vector from the light to the world-space position of the fragment.\n  vec3 lightToPosition = shadowCoord.xyz;\n\n  // dp = normalized distance from light to fragment position\n  float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n  dp += shadowBias;\n\n  // bd3D = base direction 3D\n  vec3 bd3D = normalize( lightToPosition );\n\n  #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n   vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n   return (\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n   ) * ( 1.0 / 9.0 );\n\n  #else // no percentage-closer filtering\n\n   return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n  #endif\n\n }\n\n#endif\n";
        ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n  uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n  varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n  uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n  varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n  uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n  varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): uniforms for area light shadows\n\n #endif\n */\n\n#endif\n";
        ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): update vAreaShadowCoord with area light info\n\n #endif\n */\n\n#endif\n";
        ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n\n float shadow = 1.0;\n\n #ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n DirectionalLight directionalLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  // directionalLight = directionalLights[ i ];\n  directionalLight.shadow = int(directionalLights[i * 11 + 6]);\n  directionalLight.shadowBias = directionalLights[i * 11 + 7];\n  directionalLight.shadowRadius = directionalLights[i * 11 + 8];\n  directionalLight.shadowMapSize = vec2(directionalLights[i * 11 + 9], directionalLights[i * 11 + 10]);\n  shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n }\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n SpotLight spotLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  // spotLight = spotLights[ i ];\n  spotLight.shadow = int(spotLights[i * 18 + 13]);\n  spotLight.shadowBias = spotLights[i * 18 + 14];\n  spotLight.shadowRadius = spotLights[i * 18 + 15];\n  spotLight.shadowMapSize = vec2(spotLights[i * 18 + 16], spotLights[i * 18 + 17]);\n  shadow *= bool(spotLight.shadow) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n }\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n PointLight pointLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  // pointLight = pointLights[ i ];\n  pointLight.shadow = int(pointLights[i * 15 + 8]);\n  pointLight.shadowBias = pointLights[i * 15 + 9];\n  pointLight.shadowRadius = pointLights[i * 15 + 10];\n  pointLight.shadowMapSize = vec2(pointLights[i * 15 + 11],pointLights[i * 15 + 12]);\n  pointLight.shadowCameraNear = pointLights[i * 15 + 13];\n  pointLight.shadowCameraFar = pointLights[i * 15 + 14];\n  shadow *= bool(pointLight.shadow) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n }\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): update shadow for Area light\n\n #endif\n */\n\n #endif\n\n return shadow;\n\n}\n";
        ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
        ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n // Modify egret.\n // uniform_mat4 bindMatrix;\n // uniform_mat4 bindMatrixInverse;\n\n #ifdef BONE_TEXTURE\n\n  uniform sampler2D boneTexture;\n  uniform int boneTextureSize;\n\n  mat4 getBoneMatrix( const in float i ) {\n\n   float j = i * 4.0;\n   float x = mod( j, float( boneTextureSize ) );\n   float y = floor( j / float( boneTextureSize ) );\n\n   float dx = 1.0 / float( boneTextureSize );\n   float dy = 1.0 / float( boneTextureSize );\n\n   y = dy * ( y + 0.5 );\n\n   vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n   vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n   vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n   vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n   mat4 bone = mat4( v1, v2, v3, v4 );\n\n   return bone;\n\n  }\n\n #else\n\n  uniform mat4 boneMatrices[ MAX_BONES ];\n\n  mat4 getBoneMatrix( const in float i ) {\n\n   mat4 bone = boneMatrices[ int(i) ];\n   return bone;\n\n  }\n\n #endif\n\n#endif\n";
        ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n // Modify Egret.\n // vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n vec4 skinVertex = vec4( transformed, 1.0 );\n\n vec4 skinned = vec4( 0.0 );\n skinned += boneMatX * skinVertex * skinWeight.x;\n skinned += boneMatY * skinVertex * skinWeight.y;\n skinned += boneMatZ * skinVertex * skinWeight.z;\n skinned += boneMatW * skinVertex * skinWeight.w;\n\n // Modify Egret.\n // transformed = ( bindMatrixInverse * skinned ).xyz;\n transformed = skinned.xyz;\n\n#endif\n";
        ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n mat4 skinMatrix = mat4( 0.0 );\n skinMatrix += skinWeight.x * boneMatX;\n skinMatrix += skinWeight.y * boneMatY;\n skinMatrix += skinWeight.z * boneMatZ;\n skinMatrix += skinWeight.w * boneMatW;\n \n // Modify egret.\n // skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";
        ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n vec4 texelSpecular = texture2D( specularMap, vUv );\n specularStrength = texelSpecular.r;\n\n#else\n\n specularStrength = 1.0;\n\n#endif";
        ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n uniform sampler2D specularMap;\n\n#endif";
        ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n";
        ShaderChunk.tonemapping_pars_fragment = "#ifndef saturate\n #define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n return toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n color *= toneMappingExposure;\n return saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n // John Hable's filmic operator from Uncharted 2 video game\n color *= toneMappingExposure;\n return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n color *= toneMappingExposure;\n color = max( vec3( 0.0 ), color - 0.004 );\n return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n";
        ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n varying vec2 vUv2;\n\n#endif";
        ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n attribute vec2 uv2;\n varying vec2 vUv2;\n\n#endif";
        ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n vUv2 = uv2;\n\n#endif";
        ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n varying vec2 vUv;\n\n#endif";
        ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n varying vec2 vUv;\n uniform mat3 uvTransform;\n\n#endif\n";
        ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n #if defined FLIP_V \n  vUv = ( uvTransform * vec3( uv.x, 1.0 - uv.y, 1 ) ).xy;//modify egret\n #else\n  vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n #endif\n#endif";
        ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n#endif\n";
    })(ShaderChunk = egret3d.ShaderChunk || (egret3d.ShaderChunk = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 雾的模式。
     */
    var FogMode;
    (function (FogMode) {
        FogMode[FogMode["NONE"] = 0] = "NONE";
        FogMode[FogMode["FOG"] = 1] = "FOG";
        FogMode[FogMode["FOG_EXP2"] = 2] = "FOG_EXP2";
    })(FogMode = egret3d.FogMode || (egret3d.FogMode = {}));
    /**
     * 雾。
     */
    var Fog = (function () {
        /**
         * 禁止实例化。
         */
        function Fog() {
            /**
             * 雾的模式。
             */
            this.mode = 0 /* NONE */;
            /**
             * 雾的强度。
             */
            this.density = 0.01;
            /**
             * 雾的近平面。
             * - 最小值 0.01。
             */
            this.near = 0.01;
            /**
             * 雾的远平面。
             * - 最小值 0.02。
             */
            this.far = 100.0;
            /**
             * 雾的颜色。
             */
            this.color = egret3d.Color.create(0.5, 0.5, 0.5, 1);
        }
        /**
         * @internal
         */
        Fog.create = function () {
            return new Fog();
        };
        Fog.prototype.serialize = function () {
            return [this.mode, this.density, this.near, this.far]
                .concat(this.color.serialize());
        };
        Fog.prototype.deserialize = function (data) {
            this.mode = data[0];
            this.density = data[1];
            this.near = data[2];
            this.far = data[3];
            this.color.fromArray(data, 4);
            return this;
        };
        __decorate([
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(FogMode) })
        ], Fog.prototype, "mode", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Fog.prototype, "density", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, step: 1.0 })
        ], Fog.prototype, "near", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.02, step: 1.0 })
        ], Fog.prototype, "far", void 0);
        __decorate([
            paper.editor.property("COLOR" /* COLOR */)
        ], Fog.prototype, "color", void 0);
        return Fog;
    }());
    egret3d.Fog = Fog;
    __reflect(Fog.prototype, "egret3d.Fog", ["paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * TODO
     */
    egret3d.resRoot = "";
    function promisify(loader, resource) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var onSuccess = function () {
                var texture = loader['data'] ? loader['data'] : loader['response'];
                resolve(texture);
            };
            var onError = function () {
                var e = new RES.ResourceManagerError(1001, resource.url);
                reject(e);
            };
            loader.addEventListener(egret.Event.COMPLETE, onSuccess, _this);
            loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
        });
    }
    egret3d.BitmapDataProcessor = {
        onLoadStart: function (host, resource) {
            var _this = this;
            var loader = new egret.ImageLoader();
            loader.load(resource.root + resource.url);
            return new Promise(function (resolve, reject) {
                var onSuccess = function () {
                    var bitmapData = loader.data;
                    loader.removeEventListener(egret.Event.COMPLETE, onSuccess, _this);
                    loader.removeEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                    resolve(bitmapData);
                };
                var onError = function () {
                    loader.removeEventListener(egret.Event.COMPLETE, onSuccess, _this);
                    loader.removeEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                    var e = new RES.ResourceManagerError(1001, resource.url);
                    reject(e);
                };
                loader.addEventListener(egret.Event.COMPLETE, onSuccess, _this);
                loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
            });
        },
        onRemoveStart: function (host, resource) {
            return Promise.resolve();
        }
    };
    egret3d.ShaderProcessor = {
        onLoadStart: function (host, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var result, shaders, _i, shaders_1, shader, source, shaderSource, glTF;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, host.load(resource, 'json')];
                        case 1:
                            result = _a.sent();
                            if (!(result.extensions.KHR_techniques_webgl.shaders && result.extensions.KHR_techniques_webgl.shaders.length === 2)) return [3 /*break*/, 6];
                            shaders = result.extensions.KHR_techniques_webgl.shaders;
                            _i = 0, shaders_1 = shaders;
                            _a.label = 2;
                        case 2:
                            if (!(_i < shaders_1.length)) return [3 /*break*/, 5];
                            shader = shaders_1[_i];
                            source = RES.host.resourceConfig["getResource"](shader.uri);
                            if (!source) return [3 /*break*/, 4];
                            return [4 /*yield*/, host.load(source)];
                        case 3:
                            shaderSource = _a.sent();
                            if (shaderSource) {
                                shader.uri = shaderSource;
                            }
                            else {
                                console.error("Load shader error.", shader.uri);
                            }
                            _a.label = 4;
                        case 4:
                            _i++;
                            return [3 /*break*/, 2];
                        case 5: return [3 /*break*/, 7];
                        case 6:
                            console.error("错误的Shader格式数据");
                            _a.label = 7;
                        case 7:
                            glTF = new egret3d.Shader(result, resource.name);
                            paper.Asset.register(glTF);
                            return [2 /*return*/, glTF];
                    }
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.TextureDescProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                var name = data.name;
                var filterMode = data.filterMode;
                var format = data.format;
                var mipmap = data.mipmap;
                var wrap = data.wrap;
                var _textureFormat = 1 /* RGBA */;
                if (format == "RGB") {
                    _textureFormat = 2 /* RGB */;
                }
                else if (format == "Gray") {
                    _textureFormat = 3 /* Gray */;
                }
                var _linear = true;
                if (filterMode.indexOf("linear") < 0) {
                    _linear = false;
                }
                var _repeat = false;
                if (wrap.indexOf("Repeat") >= 0) {
                    _repeat = true;
                }
                var _premultiply = false;
                if (data["premultiply"] !== undefined) {
                    _premultiply = data["premultiply"] > 0;
                }
                var imgResource = RES.host.resourceConfig["getResource"](name);
                if (imgResource) {
                    return host.load(imgResource, "bitmapdata").then(function (bitmapData) {
                        var texture = new egret3d.GLTexture2D(resource.name, bitmapData.source.width, bitmapData.source.height, _textureFormat);
                        texture.uploadImage(bitmapData.source, mipmap, _linear, _premultiply, _repeat);
                        paper.Asset.register(texture);
                        return texture;
                    });
                }
                if (egret3d.resRoot) {
                    return getResByURL(name, egret3d.resRoot).then(function (bitmapData) {
                        var texture = new egret3d.GLTexture2D(resource.name, bitmapData.source.width, bitmapData.source.height, _textureFormat);
                        texture.uploadImage(bitmapData.source, mipmap, _linear, _premultiply, _repeat);
                        paper.Asset.register(texture);
                        return texture;
                    });
                }
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.TextureProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bitmapdata").then(function (bitmapData) {
                var texture = new egret3d.GLTexture2D(resource.name, bitmapData.source.width, bitmapData.source.height, 1 /* RGBA */);
                texture.uploadImage(bitmapData.source, true, true, false, true);
                paper.Asset.register(texture);
                return texture;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.MaterialProcessor = {
        onLoadStart: function (host, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var result, _i, _a, mat, values, _b, _c, _d, key, value, r, texture, texture, material;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0: return [4 /*yield*/, host.load(resource, 'json')];
                        case 1:
                            result = _e.sent();
                            if (!(result.materials && result.materials.length > 0)) return [3 /*break*/, 10];
                            _i = 0, _a = result.materials;
                            _e.label = 2;
                        case 2:
                            if (!(_i < _a.length)) return [3 /*break*/, 10];
                            mat = _a[_i];
                            values = mat.extensions.KHR_techniques_webgl.values;
                            _b = [];
                            for (_c in values)
                                _b.push(_c);
                            _d = 0;
                            _e.label = 3;
                        case 3:
                            if (!(_d < _b.length)) return [3 /*break*/, 9];
                            key = _b[_d];
                            value = values[key];
                            if (!(value && typeof value === "string")) return [3 /*break*/, 8];
                            r = RES.host.resourceConfig["getResource"](value);
                            if (!r) return [3 /*break*/, 5];
                            return [4 /*yield*/, host.load(r, "TextureDesc")];
                        case 4:
                            texture = _e.sent();
                            values[key] = texture;
                            return [3 /*break*/, 8];
                        case 5:
                            if (!egret3d.resRoot) return [3 /*break*/, 7];
                            return [4 /*yield*/, getResByURL(value, egret3d.resRoot)];
                        case 6:
                            texture = _e.sent();
                            values[key] = texture;
                            return [3 /*break*/, 8];
                        case 7:
                            console.log("Load image error.", value);
                            values[key] = egret3d.DefaultTextures.MISSING;
                            _e.label = 8;
                        case 8:
                            _d++;
                            return [3 /*break*/, 3];
                        case 9:
                            _i++;
                            return [3 /*break*/, 2];
                        case 10:
                            material = new egret3d.Material(result, resource.name);
                            paper.Asset.register(material);
                            return [2 /*return*/, material];
                    }
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.MeshProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bin").then(function (result) {
                var parseResult = egret3d.GLTFAsset.parseFromBinary(new Uint32Array(result));
                var glb;
                if (parseResult.config.meshes) {
                    glb = new egret3d.Mesh(parseResult.config, parseResult.buffers, resource.name);
                }
                else {
                    glb = new egret3d.GLTFAsset();
                    glb.name = resource.name;
                    glb.config = parseResult.config;
                    for (var _i = 0, _a = parseResult.buffers; _i < _a.length; _i++) {
                        var b = _a[_i];
                        glb.buffers.push(b);
                    }
                }
                paper.Asset.register(glb);
                return glb;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.AnimationProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bin").then(function (result) {
                var parseResult = egret3d.GLTFAsset.parseFromBinary(new Uint32Array(result));
                var animation = new egret3d.GLTFAsset();
                animation.name = resource.name;
                animation.config = parseResult.config;
                for (var _i = 0, _a = parseResult.buffers; _i < _a.length; _i++) {
                    var b = _a[_i];
                    animation.buffers.push(b);
                }
                paper.Asset.register(animation);
                return animation;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.PrefabProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                var prefab = new paper.Prefab(resource.name);
                return loadSubAssets(data, resource).then(function () {
                    prefab.parse(data);
                    paper.Asset.register(prefab);
                    return prefab;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.SceneProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                var rawScene = new paper.RawScene(resource.name);
                return loadSubAssets(data, resource).then(function () {
                    rawScene.parse(data);
                    paper.Asset.register(rawScene);
                    return rawScene;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    function loadSubAssets(data, resource) {
        return Promise.all(data.assets.map((function (item) {
            var host = RES.host;
            var r = host.resourceConfig["getResource"](item);
            if (r) {
                return host.load(r);
            }
            else if (egret3d.resRoot) {
                return getResByURL(item, egret3d.resRoot);
            }
            else {
                if (item.indexOf("builtin/") !== 0) {
                    console.error("加载不存在的资源", item);
                }
                return Promise.resolve();
            }
        })));
    }
    function getResType(uri) {
        var file = uri.substr(uri.lastIndexOf("/") + 1);
        var i = file.indexOf(".", 0);
        var extname = "";
        while (i >= 0) {
            extname = file.substr(i);
            if (extname === ".assetbundle.json") {
                return 'Bundle';
            }
            else if (extname === ".png" || extname === ".jpg") {
                return 'Texture';
            }
            else if (extname === ".pvr.bin" || extname === ".pvr") {
                return 'PVR';
            }
            else if (extname === ".atlas.json") {
                return 'Atlas';
            }
            else if (extname === ".font.json") {
                return 'Font';
            }
            else if (extname === ".json" || extname === ".txt" || extname === ".effect.json") {
                return 'TextAsset';
            }
            else if (extname === ".packs.bin") {
                return 'PackBin';
            }
            else if (extname === ".packs.txt") {
                return 'PackTxt';
            }
            else if (extname === ".path.json") {
                return 'pathAsset';
            }
            else if (extname === ".mp3" || extname === ".ogg") {
                return 'Sound';
            }
            else if (extname === ".prefab.json") {
                return 'Prefab';
            }
            else if (extname === ".scene.json") {
                return 'Scene';
            }
            else if (extname === ".vs.glsl") {
                return 'GLVertexShader';
            }
            else if (extname === ".fs.glsl") {
                return 'GLFragmentShader';
            }
            else if (extname === ".shader.json") {
                return 'Shader';
            }
            else if (extname === ".image.json") {
                return 'TextureDesc';
            }
            else if (extname === ".mat.json") {
                return 'Material';
            }
            else if (extname === ".mesh.bin") {
                return 'Mesh';
            }
            else if (extname === ".ani.bin") {
                return 'Animation';
            }
            i = file.indexOf(".", i + 1);
        }
        return "Unknown";
    }
    function getResByURL(uri, root) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (r) {
                        RES.getResByUrl(root + uri, function (data) {
                            paper.Asset.register(data);
                            r(data);
                        }, RES, getResType(uri));
                    })];
            });
        });
    }
    RES.processor.map("Shader", egret3d.ShaderProcessor);
    RES.processor.map("Texture", egret3d.TextureProcessor);
    RES.processor.map("TextureDesc", egret3d.TextureDescProcessor);
    RES.processor.map("Material", egret3d.MaterialProcessor);
    RES.processor.map("Mesh", egret3d.MeshProcessor);
    RES.processor.map("Animation", egret3d.AnimationProcessor);
    RES.processor.map("Prefab", egret3d.PrefabProcessor);
    RES.processor.map("Scene", egret3d.SceneProcessor);
    RES.processor.map("bitmapdata", egret3d.BitmapDataProcessor);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 正则表达式的工具类，提供一些引擎用到的正则表达式
     */
    var RegexpUtil = (function () {
        function RegexpUtil() {
        }
        // shader properties
        RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
        RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        // material
        RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        // 特效解析，[1,2],2,1
        RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
        return RegexpUtil;
    }());
    egret3d.RegexpUtil = RegexpUtil;
    __reflect(RegexpUtil.prototype, "egret3d.RegexpUtil");
})(egret3d || (egret3d = {}));
// 0.04 处理utf8 string 不能用encode decode
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        var BinReader = (function () {
            function BinReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            BinReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinReader.prototype.peek = function () {
                return this._seek;
            };
            BinReader.prototype.length = function () {
                return this._data.byteLength;
            };
            BinReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            BinReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            BinReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            BinReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            BinReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUint8Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            BinReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            BinReader.prototype.readUint16Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this.readUInt16();
                }
                return target;
            };
            BinReader.prototype.readSingleArray = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                // console.log(this._data.byteLength, this._data.byteOffset);
                for (var i = 0; i < length; i++) {
                    // target[i] = this._data.getFloat32(this._seek, true);
                    // this._seek += 4;
                    target[i] = this.readSingle();
                }
                return target;
            };
            Object.defineProperty(BinReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            BinReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            BinReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            BinReader.prototype.readBytes = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            BinReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            BinReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            BinReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            BinReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return BinReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            BinReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            BinReader.prototype.readShort = function () {
                return this.readInt16();
            };
            BinReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return BinReader;
        }());
        io.BinReader = BinReader;
        __reflect(BinReader.prototype, "egret3d.io.BinReader");
        var BinWriter = (function () {
            function BinWriter() {
                var buf = new ArrayBuffer(1024);
                this._length = 0;
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            BinWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            BinWriter.prototype.getLength = function () {
                return length;
            };
            BinWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            BinWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinWriter.prototype.peek = function () {
                return this._seek;
            };
            BinWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            BinWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            BinWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            BinWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            BinWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            BinWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(BinWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            BinWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            BinWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            BinWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            BinWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            BinWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            BinWriter.prototype.writeUTFBytes = function (str) {
                var strArray = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            BinWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            BinWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            BinWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return BinWriter;
        }());
        io.BinWriter = BinWriter;
        __reflect(BinWriter.prototype, "egret3d.io.BinWriter");
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var utils;
    (function (utils) {
        function getRelativePath(targetPath, sourcePath) {
            var relPath = "";
            targetPath = targetPath.replace("\\", "/");
            sourcePath = sourcePath.replace("\\", "/");
            var targetPathArr = targetPath.split('/');
            var sourcePathArr = sourcePath.split('/');
            var targetPathLen = targetPathArr.length;
            var sourcePathLen = sourcePathArr.length;
            var i = 0;
            while (targetPathArr[i] == sourcePathArr[i] && i < targetPathLen && i < sourcePathLen) {
                i++;
            }
            for (var j = 0; j < sourcePathLen - i - 1; j++) {
                relPath += "../";
            }
            targetPathArr = targetPathArr.slice(i, targetPathArr.length);
            relPath = relPath + targetPathArr.join("/");
            relPath = relPath.replace(" ", "_");
            return relPath;
        }
        utils.getRelativePath = getRelativePath;
    })(utils = egret3d.utils || (egret3d.utils = {}));
})(egret3d || (egret3d = {}));
var Stats;
(function (Stats_1) {
    var stats;
    var loop;
    /**
     * 显示调试面板
     */
    function show(container, refreshTime) {
        if (refreshTime === void 0) { refreshTime = 500; }
        if (stats == null) {
            stats = new Stats();
            stats.container.style.position = 'absolute';
            stats.container.style.left = '0px';
            stats.container.style.top = '0px';
            container.appendChild(stats.container);
        }
        else {
            container.appendChild(stats.container);
        }
        if (loop) {
            hide();
        }
        loop = setInterval(function () {
            stats.update();
        }, refreshTime);
        egret3d.Performance.enable = true;
    }
    Stats_1.show = show;
    /**
     * 关闭调试面板
     */
    function hide() {
        if (loop) {
            clearInterval(loop);
        }
        if (stats != null && stats.container.parentNode) {
            stats.container.parentNode.removeChild(stats.container);
        }
        egret3d.Performance.enable = false;
    }
    Stats_1.hide = hide;
    /**
     *
     * @author mrdoob / http://mrdoob.com/
     * @modify egret
     */
    var Stats = (function () {
        function Stats() {
            var _this = this;
            this.mode = 0;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', function (event) {
                event.preventDefault();
                _this.showPanel(++_this.mode % _this.container.children.length);
            }, false);
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            this.renderPanel = this.addPanel(new Panel('R%', '#0f0', '#020'));
            if (self.performance && self.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        Stats.prototype.update = function () {
            var fps = egret3d.Performance.getFPS();
            var fpsEntity = egret3d.Performance.getEntity("fps");
            var allEntity = egret3d.Performance.getEntity("all");
            var renderEntity = egret3d.Performance.getEntity("render");
            this.fpsPanel.update(fps, 100);
            this.msPanel.update(allEntity.delta, 200);
            this.renderPanel.update(Math.floor(renderEntity.delta / fpsEntity.delta * 100), 100);
            if (this.memPanel) {
                var memory = performance["memory"];
                this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
            }
        };
        Stats.prototype.showPanel = function (id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        };
        Stats.prototype.addPanel = function (panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        };
        return Stats;
    }());
    __reflect(Stats.prototype, "Stats");
    /**
     *
     */
    var Panel = (function () {
        function Panel(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        Panel.prototype.update = function (value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        };
        return Panel;
    }());
    __reflect(Panel.prototype, "Panel");
})(Stats || (Stats = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格。
     */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        function Mesh() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._ibos = [];
            /**
             * @internal
             */
            _this._vbo = null;
            return _this;
        }
        Mesh.create = function (vertexCountOrConfig, indexCountOrBuffers, attributeNamesOrName, attributeTypes, drawMode) {
            return new Mesh(vertexCountOrConfig, indexCountOrBuffers, attributeNamesOrName, attributeTypes, drawMode);
        };
        Mesh.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (webgl) {
                for (var _i = 0, _a = this._ibos; _i < _a.length; _i++) {
                    var ibo = _a[_i];
                    webgl.deleteBuffer(ibo);
                }
                if (this._vbo) {
                    webgl.deleteBuffer(this._vbo);
                }
            }
            this._ibos.length = 0;
            this._vbo = null;
            return true;
        };
        Mesh.prototype._createBuffer = function () {
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (this._vbo || !webgl) {
                return;
            }
            var vertexBufferViewAccessor = this.getAccessor(this._glTFMesh.primitives[0].attributes.POSITION || 0);
            var vertexBuffer = this.createTypeArrayFromBufferView(this.getBufferView(vertexBufferViewAccessor), 5126 /* Float */);
            var vbo = webgl.createBuffer();
            if (vbo) {
                this._vbo = vbo;
                var attributeNames = [];
                for (var k in this._glTFMesh.primitives[0].attributes) {
                    attributeNames.push(k);
                }
                var subMeshIndex = 0;
                for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                    var primitive = _a[_i];
                    if (primitive.indices !== undefined) {
                        if (this._ibos.length === subMeshIndex) {
                            var ibo = webgl.createBuffer();
                            if (ibo) {
                                this._ibos.push(ibo);
                                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, this.getBufferLength(this.getAccessor(primitive.indices)), this.drawMode);
                                this.uploadSubIndexBuffer(subMeshIndex);
                            }
                            else {
                                console.error("Create webgl element buffer error.");
                            }
                        }
                        else {
                            console.error("Error arguments.");
                        }
                    }
                    else if (this._ibos.length > 0) {
                        console.error("Error arguments.");
                    }
                    subMeshIndex++;
                }
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this._vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, vertexBuffer.byteLength, this.drawMode);
                this.uploadVertexBuffer(attributeNames);
            }
            else {
                console.error("Create webgl buffer error.");
            }
        };
        Mesh.prototype.uploadVertexBuffer = function (uploadAttributes, offset, count) {
            if (uploadAttributes === void 0) { uploadAttributes = null; }
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!this._vbo || !webgl) {
                return;
            }
            var attributes = this._glTFMesh.primitives[0].attributes;
            webgl.bindBuffer(webgl.ARRAY_BUFFER, this._vbo);
            if (!uploadAttributes) {
                uploadAttributes = [];
                for (var attributeName in this._glTFMesh.primitives[0].attributes) {
                    uploadAttributes.push(attributeName);
                }
            }
            if (Array.isArray(uploadAttributes)) {
                for (var _i = 0, uploadAttributes_1 = uploadAttributes; _i < uploadAttributes_1.length; _i++) {
                    var attributeName = uploadAttributes_1[_i];
                    var accessorIndex = attributes[attributeName];
                    if (accessorIndex !== undefined) {
                        var accessor = this.getAccessor(accessorIndex);
                        var bufferOffset = this.getBufferOffset(accessor);
                        var subVertexBuffer = this.createTypeArrayFromAccessor(accessor, offset, count);
                        webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
            }
            else {
                var accessorIndex = attributes[uploadAttributes];
                if (accessorIndex !== undefined) {
                    var accessor = this.getAccessor(accessorIndex);
                    var bufferOffset = this.getBufferOffset(accessor);
                    var subVertexBuffer = this.createTypeArrayFromAccessor(accessor);
                    webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                }
                else {
                    console.warn("Error arguments.");
                }
            }
        };
        Mesh.prototype.uploadSubIndexBuffer = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!this._vbo || !webgl) {
                return;
            }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var primitive = this._glTFMesh.primitives[subMeshIndex];
                if (primitive.indices !== undefined) {
                    var accessor = this.getAccessor(primitive.indices);
                    var subIndexBuffer = this.createTypeArrayFromAccessor(accessor);
                    var ibo = this._ibos[subMeshIndex];
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                    webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, 0, subIndexBuffer);
                }
                else {
                    console.warn("Error arguments.");
                }
            }
            else {
                console.warn("Error arguments.");
            }
        };
        return Mesh;
    }(egret3d.BaseMesh));
    egret3d.Mesh = Mesh;
    __reflect(Mesh.prototype, "egret3d.Mesh");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var TextureFormatEnum;
    (function (TextureFormatEnum) {
        TextureFormatEnum[TextureFormatEnum["RGBA"] = 1] = "RGBA";
        TextureFormatEnum[TextureFormatEnum["RGB"] = 2] = "RGB";
        TextureFormatEnum[TextureFormatEnum["Gray"] = 3] = "Gray";
        TextureFormatEnum[TextureFormatEnum["PVRTC4_RGB"] = 4] = "PVRTC4_RGB";
        TextureFormatEnum[TextureFormatEnum["PVRTC4_RGBA"] = 4] = "PVRTC4_RGBA";
        TextureFormatEnum[TextureFormatEnum["PVRTC2_RGB"] = 4] = "PVRTC2_RGB";
        TextureFormatEnum[TextureFormatEnum["PVRTC2_RGBA"] = 4] = "PVRTC2_RGBA";
    })(TextureFormatEnum = egret3d.TextureFormatEnum || (egret3d.TextureFormatEnum = {}));
    var GLTexture = (function (_super) {
        __extends(GLTexture, _super);
        function GLTexture(name, width, height) {
            if (name === void 0) { name = ""; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            var _this = _super.call(this, name) || this;
            _this._width = width;
            _this._height = height;
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (webgl) {
                _this._texture = webgl.createTexture();
            }
            return _this;
        }
        Object.defineProperty(GLTexture.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GLTexture.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GLTexture.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        return GLTexture;
    }(egret3d.Texture));
    egret3d.GLTexture = GLTexture;
    __reflect(GLTexture.prototype, "egret3d.GLTexture", ["egret3d.ITexture"]);
    /**
     *
     */
    var GLTexture2D = (function (_super) {
        __extends(GLTexture2D, _super);
        function GLTexture2D(name, width, height, format) {
            if (name === void 0) { name = ""; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            if (format === void 0) { format = 1 /* RGBA */; }
            var _this = _super.call(this, name, width, height) || this;
            //
            _this._mipmap = false;
            //
            _this._format = format;
            return _this;
        }
        GLTexture2D.createColorTexture = function (name, r, g, b) {
            var mipmap = false;
            var linear = true;
            var width = 1;
            var height = 1;
            var data = new Uint8Array([r, g, b, 255]);
            var texture = new GLTexture2D(name, width, height, 1 /* RGBA */);
            texture.uploadImage(data, mipmap, linear, true, false);
            return texture;
        };
        GLTexture2D.createGridTexture = function (name) {
            var mipmap = false;
            var linear = true;
            var width = 128;
            var height = 128;
            var data = new Uint8Array(width * height * 4);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var seek = (y * width + x) * 4;
                    var bool = ((x - width * 0.5) * (y - height * 0.5)) > 0;
                    data[seek] = data[seek + 1] = data[seek + 2] = bool ? 0 : 255;
                    data[seek + 3] = 255;
                }
            }
            var texture = new GLTexture2D(name, width, height, 1 /* RGBA */);
            texture.uploadImage(data, mipmap, linear, true, true);
            return texture;
        };
        GLTexture2D.prototype.uploadImage = function (img, mipmap, linear, premultiply, repeat, mirroredU, mirroredV) {
            if (premultiply === void 0) { premultiply = true; }
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this._mipmap = mipmap;
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!webgl) {
                return;
            }
            webgl.bindTexture(webgl.TEXTURE_2D, this._texture);
            webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
            webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, 0);
            var formatGL = webgl.RGBA;
            if (this._format === 2 /* RGB */) {
                formatGL = webgl.RGB;
            }
            else if (this._format === 3 /* Gray */) {
                formatGL = webgl.LUMINANCE;
            }
            //
            if (ArrayBuffer.isView(img)) {
                webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, this._width, this._height, 0, formatGL, webgl.UNSIGNED_BYTE, img);
            }
            else {
                webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, formatGL, webgl.UNSIGNED_BYTE, img);
            }
            if (mipmap) {
                webgl.generateMipmap(webgl.TEXTURE_2D);
                if (linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR_MIPMAP_LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST_MIPMAP_NEAREST);
                }
            }
            else {
                if (linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
                }
            }
            var wrap_s_param = webgl.CLAMP_TO_EDGE;
            var wrap_t_param = webgl.CLAMP_TO_EDGE;
            if (repeat) {
                wrap_s_param = mirroredU ? webgl.MIRRORED_REPEAT : webgl.REPEAT;
                wrap_t_param = mirroredV ? webgl.MIRRORED_REPEAT : webgl.REPEAT;
            }
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, wrap_s_param);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, wrap_t_param);
        };
        GLTexture2D.prototype.caclByteLength = function () {
            var pixellen = 1;
            if (this._format === 1 /* RGBA */) {
                pixellen = 4;
            }
            else if (this._format === 2 /* RGB */) {
                pixellen = 3;
            }
            var len = this.width * this.height * pixellen;
            if (this._mipmap) {
                len = len * (1 - Math.pow(0.25, 10)) / 0.75;
            }
            return len;
        };
        GLTexture2D.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            if (this._texture !== null) {
                egret3d.WebGLCapabilities.webgl.deleteTexture(this._texture);
                this._texture = null;
            }
            return true;
        };
        GLTexture2D.prototype.getReader = function (redOnly) {
            if (redOnly === void 0) { redOnly = false; }
            if (this._reader !== null) {
                if (this._reader.gray !== redOnly) {
                    throw new Error("get param diff with this.reader");
                }
                return this._reader;
            }
            if (this._format !== 1 /* RGBA */) {
                throw new Error("only rgba texture can read");
            }
            if (this._texture === null) {
                return null;
            }
            if (this._reader === null)
                this._reader = new TextureReader(this._texture, this._width, this._height, redOnly);
            return this._reader;
        };
        return GLTexture2D;
    }(GLTexture));
    egret3d.GLTexture2D = GLTexture2D;
    __reflect(GLTexture2D.prototype, "egret3d.GLTexture2D");
    var TextureReader = (function () {
        function TextureReader(texRGBA, width, height, gray) {
            if (gray === void 0) { gray = true; }
            this.gray = gray;
            this.width = width;
            this.height = height;
            var readData = new Uint8Array(this.width * this.height * 4);
            readData[0] = 2;
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (webgl) {
                var fbo = webgl.createFramebuffer();
                var fbold = webgl.getParameter(webgl.FRAMEBUFFER_BINDING);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbo);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, texRGBA, 0);
                webgl.readPixels(0, 0, this.width, this.height, webgl.RGBA, webgl.UNSIGNED_BYTE, readData);
                webgl.deleteFramebuffer(fbo);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbold);
            }
            if (gray) {
                this.data = new Uint8Array(this.width * this.height);
                for (var i = 0; i < width * height; i++) {
                    this.data[i] = readData[i * 4];
                }
            }
            else {
                this.data = readData;
            }
        }
        TextureReader.prototype.getPixel = function (u, v) {
            var x = (u * this.width) | 0;
            var y = (v * this.height) | 0;
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
                return 0;
            }
            if (this.gray) {
                return this.data[y * this.width + x];
            }
            else {
                var i = (y * this.width + x) * 4;
                return egret3d.Color.create(this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]);
            }
        };
        return TextureReader;
    }());
    egret3d.TextureReader = TextureReader;
    __reflect(TextureReader.prototype, "egret3d.TextureReader");
    var WriteableTexture2D = (function () {
        function WriteableTexture2D(format, width, height, linear, premultiply, repeat, mirroredU, mirroredV) {
            if (format === void 0) { format = 1 /* RGBA */; }
            if (premultiply === void 0) { premultiply = true; }
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this.width = 0;
            this.height = 0;
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!webgl) {
                return;
            }
            this.texture = webgl.createTexture();
            webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
            webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, 0);
            webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            this.format = format;
            var formatGL = webgl.RGBA;
            if (format === 2 /* RGB */) {
                formatGL = webgl.RGB;
            }
            else if (format === 3 /* Gray */) {
                formatGL = webgl.LUMINANCE;
            }
            var data = null;
            webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, webgl.UNSIGNED_BYTE, data);
            if (linear) {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            }
            else {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
            }
            if (repeat) {
                if (mirroredU) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.MIRRORED_REPEAT);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.REPEAT);
                }
                if (mirroredV) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.MIRRORED_REPEAT);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.REPEAT);
                }
            }
            else {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.CLAMP_TO_EDGE);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.CLAMP_TO_EDGE);
            }
        }
        WriteableTexture2D.prototype.dispose = function () {
            if (this.texture) {
                egret3d.WebGLCapabilities.webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        WriteableTexture2D.prototype.caclByteLength = function () {
            var pixellen = 1;
            if (this.format === 1 /* RGBA */) {
                pixellen = 4;
            }
            else if (this.format === 2 /* RGB */) {
                pixellen = 3;
            }
            var len = this.width * this.height * pixellen;
            return len;
        };
        return WriteableTexture2D;
    }());
    egret3d.WriteableTexture2D = WriteableTexture2D;
    __reflect(WriteableTexture2D.prototype, "egret3d.WriteableTexture2D", ["egret3d.ITexture"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var BaseRenderTarget = (function (_super) {
        __extends(BaseRenderTarget, _super);
        function BaseRenderTarget(name, width, height, depth, stencil, mipmap, linear) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            if (mipmap === void 0) { mipmap = false; }
            if (linear === void 0) { linear = false; }
            var _this = _super.call(this, name) || this;
            _this._width = width;
            _this._height = height;
            _this._depth = depth;
            _this._stencil = stencil;
            _this._mipmap = mipmap;
            _this._linear = linear;
            _this.uploadTexture();
            return _this;
        }
        BaseRenderTarget.prototype.uploadTexture = function () {
            var width = this._width;
            var height = this._height;
            var depth = this._depth;
            var stencil = this._stencil;
            var webgl = egret3d.WebGLCapabilities.webgl;
            this._texture = webgl.createTexture();
            this._fbo = webgl.createFramebuffer();
            this._fbo["width"] = width;
            this._fbo["height"] = height;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this._fbo);
            if (depth || stencil) {
                this._renderbuffer = webgl.createRenderbuffer();
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this._renderbuffer);
                if (depth && stencil) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this._renderbuffer);
                }
                else if (depth) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this._renderbuffer);
                }
                else {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this._renderbuffer);
                }
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            }
        };
        BaseRenderTarget.prototype.use = function () {
        };
        BaseRenderTarget.prototype.generateMipmap = function () {
            return false;
        };
        BaseRenderTarget.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            if (this._texture !== null) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                webgl.deleteFramebuffer(this._renderbuffer);
                webgl.deleteTexture(this._texture);
                this._renderbuffer = null;
                this._texture = null;
            }
        };
        BaseRenderTarget.prototype.caclByteLength = function () {
            return this.width * this.height * 4;
        };
        Object.defineProperty(BaseRenderTarget.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderTarget.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderTarget.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        return BaseRenderTarget;
    }(egret3d.Texture));
    egret3d.BaseRenderTarget = BaseRenderTarget;
    __reflect(BaseRenderTarget.prototype, "egret3d.BaseRenderTarget");
    var GlRenderTarget = (function (_super) {
        __extends(GlRenderTarget, _super);
        function GlRenderTarget() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GlRenderTarget.prototype.uploadTexture = function () {
            _super.prototype.uploadTexture.call(this);
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            webgl.pixelStorei(webgl.UNPACK_ALIGNMENT, 4);
            webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, this._width, this._height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
            if (this._mipmap) {
                webgl.generateMipmap(webgl.TEXTURE_2D);
                if (this._linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR_MIPMAP_LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST_MIPMAP_NEAREST);
                }
            }
            else {
                if (this._linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
                }
            }
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
        };
        GlRenderTarget.prototype.use = function () {
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this._fbo);
        };
        GlRenderTarget.prototype.generateMipmap = function () {
            if (this._mipmap) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
                webgl.generateMipmap(webgl.TEXTURE_2D);
                webgl.bindTexture(webgl.TEXTURE_2D, null);
                return true;
            }
            return false;
        };
        return GlRenderTarget;
    }(BaseRenderTarget));
    egret3d.GlRenderTarget = GlRenderTarget;
    __reflect(GlRenderTarget.prototype, "egret3d.GlRenderTarget");
    var GlRenderTargetCube = (function (_super) {
        __extends(GlRenderTargetCube, _super);
        function GlRenderTargetCube(name, width, height, depth, stencil) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            var _this = _super.call(this, name, width, height, depth, stencil) || this;
            _this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindTexture(webgl.TEXTURE_CUBE_MAP, _this.texture);
            webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
            webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            for (var i = 0; i < 6; i++) {
                webgl.texImage2D(webgl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
            }
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_CUBE_MAP_POSITIVE_X + _this.activeCubeFace, _this.texture, 0);
            return _this;
        }
        GlRenderTargetCube.prototype.use = function () {
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this._fbo);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_CUBE_MAP_POSITIVE_X + this.activeCubeFace, this.texture, 0);
        };
        return GlRenderTargetCube;
    }(BaseRenderTarget));
    egret3d.GlRenderTargetCube = GlRenderTargetCube;
    __reflect(GlRenderTargetCube.prototype, "egret3d.GlRenderTargetCube");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    // 运行时 draw call 排序优化使用。
    var _hashCode = 0;
    /**
     * @private
     */
    var GlProgram = (function () {
        function GlProgram(webglProgram) {
            this.id = _hashCode++;
            this.attributes = [];
            this.contextUniforms = [];
            this.uniforms = [];
            this.program = webglProgram;
        }
        return GlProgram;
    }());
    egret3d.GlProgram = GlProgram;
    __reflect(GlProgram.prototype, "egret3d.GlProgram");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var BeginSystem = (function (_super) {
            __extends(BeginSystem, _super);
            function BeginSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._canvas = null;
                return _this;
            }
            BeginSystem.prototype._updateCanvas = function (stage) {
                var canvas = this._canvas;
                var screenSize = stage.screenSize;
                var viewport = stage.viewport;
                // Update canvas size and rotate.
                var parentElement = canvas.parentElement;
                canvas.width = viewport.w;
                canvas.height = viewport.h;
                canvas.style.top = (parentElement ? parentElement.offsetTop : 0) + "px";
                canvas.style.position = "absolute";
                canvas.style[egret.web.getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
                if (stage.rotated) {
                    // canvas.style.width = h + "px";
                    // canvas.style.height = w + "px";
                    canvas.style.left = (parentElement ? parentElement.offsetLeft : 0) + screenSize.w + "px";
                    var transform = "matrix(0," + screenSize.h / canvas.width + "," + -screenSize.w / canvas.height + ",0,0,0)";
                    canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
                }
                else {
                    // canvas.style.width = w + "px";
                    // canvas.style.height = h + "px";
                    // canvas.style[egret.web.getPrefixStyleName("transform")] = null;
                    canvas.style.left = (parentElement ? parentElement.offsetLeft : 0) + "px";
                    var transform = "matrix(" + screenSize.w / canvas.width + ",0,0," + screenSize.h / canvas.height + ",0,0)";
                    canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
                }
            };
            BeginSystem.prototype.onAwake = function (config) {
                var _this = this;
                var globalGameObject = paper.GameObject.globalGameObject;
                // Add stage, set stage, update canvas.
                this._canvas = config.canvas;
                var isWX = egret.Capabilities.runtimeType === egret.RuntimeType.WXGAME || this._canvas.parentElement === undefined;
                var screenWidth = isWX ? window.innerWidth : this._canvas.parentElement.clientWidth;
                var screenHeight = isWX ? window.innerHeight : this._canvas.parentElement.clientHeight;
                globalGameObject.addComponent(egret3d.Stage, {
                    size: { w: config.option.contentWidth, h: config.option.contentHeight },
                    screenSize: { w: screenWidth, h: screenHeight },
                });
                globalGameObject.getOrAddComponent(egret3d.WebGLCapabilities, false, config);
                globalGameObject.getOrAddComponent(egret3d.DefaultMeshes);
                globalGameObject.getOrAddComponent(egret3d.DefaultShaders);
                globalGameObject.getOrAddComponent(egret3d.DefaultTextures);
                globalGameObject.getOrAddComponent(egret3d.DefaultMaterials);
                globalGameObject.getOrAddComponent(egret3d.InputCollecter);
                globalGameObject.getOrAddComponent(egret3d.ContactCollecter);
                // Update canvas when screen resized.
                this._updateCanvas(egret3d.stage); // First update.
                egret3d.stage.onScreenResize.add(function () {
                    _this._updateCanvas(egret3d.stage);
                }, this);
            };
            BeginSystem.prototype.onUpdate = function () {
                // TODO 
                egret3d.Performance.startCounter("all" /* All */);
                // TODO 查询是否有性能问题。
                var isWX = egret.Capabilities.runtimeType === egret.RuntimeType.WXGAME || this._canvas.parentElement === undefined;
                var screenWidth = isWX ? window.innerWidth : this._canvas.parentElement.clientWidth;
                var screenHeight = isWX ? window.innerHeight : this._canvas.parentElement.clientHeight;
                var screenSize = egret3d.stage.screenSize;
                if (screenWidth !== screenSize.w || screenHeight !== screenSize.h) {
                    egret3d.stage.screenSize = { w: screenWidth, h: screenHeight };
                }
            };
            return BeginSystem;
        }(paper.BaseSystem));
        web.BeginSystem = BeginSystem;
        __reflect(BeginSystem.prototype, "egret3d.web.BeginSystem");
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var WebGLRenderSystem = (function (_super) {
            __extends(WebGLRenderSystem, _super);
            function WebGLRenderSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._interests = [
                    [
                        { componentClass: egret3d.Camera }
                    ],
                    [
                        { componentClass: egret3d.Egret2DRenderer }
                    ],
                    [
                        { componentClass: [egret3d.DirectionalLight, egret3d.SpotLight, egret3d.PointLight] }
                    ]
                ];
                _this._egret2dOrderCount = 0;
                _this._drawCallCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCallCollecter);
                _this._cameraAndLightCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.CameraAndLightCollecter);
                _this._renderState = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.WebGLRenderState);
                _this._lightCamera = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.Camera);
                //
                _this._cacheLightCount = 0;
                //
                _this._cacheMaterialVerision = -1;
                _this._cacheMaterial = null;
                //
                _this._cacheSubMeshIndex = -1;
                _this._cacheMesh = null;
                return _this;
            }
            WebGLRenderSystem.prototype._renderLightShadow = function (light) {
                var camera = this._lightCamera;
                var renderState = this._renderState;
                var isPointLight = light.constructor === egret3d.PointLight;
                var shadowMaterial = isPointLight ? egret3d.DefaultMaterials.SHADOW_DISTANCE : egret3d.DefaultMaterials.SHADOW_DEPTH;
                var drawCalls = this._drawCallCollecter;
                var shadowCalls = drawCalls.shadowCalls;
                var webgl = egret3d.WebGLCapabilities.webgl;
                light.updateShadow(camera);
                light.renderTarget.use();
                renderState.clear(true, true, egret3d.Color.WHITE);
                for (var i = 0, l = isPointLight ? 6 : 1; i < l; ++i) {
                    var context = camera.context;
                    if (isPointLight) {
                        light.updateFace(camera, i);
                    }
                    webgl.viewport(light.viewPortPixel.x, light.viewPortPixel.y, light.viewPortPixel.w, light.viewPortPixel.h);
                    webgl.depthRange(0, 1);
                    drawCalls.shadowFrustumCulling(camera);
                    for (var _i = 0, shadowCalls_1 = shadowCalls; _i < shadowCalls_1.length; _i++) {
                        var drawCall = shadowCalls_1[_i];
                        this._draw(context, drawCall, shadowMaterial);
                    }
                }
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
            };
            WebGLRenderSystem.prototype._renderCamera = function (camera, renderEnabled) {
                if (renderEnabled) {
                    //在这里先剔除，然后排序，最后绘制
                    var drawCalls = this._drawCallCollecter;
                    drawCalls.frustumCulling(camera);
                    //
                    var opaqueCalls = drawCalls.opaqueCalls;
                    var transparentCalls = drawCalls.transparentCalls;
                    // Step 1 draw opaques.
                    for (var _i = 0, opaqueCalls_1 = opaqueCalls; _i < opaqueCalls_1.length; _i++) {
                        var drawCall = opaqueCalls_1[_i];
                        this._draw(camera.context, drawCall, drawCall.material);
                    }
                    // Step 2 draw transparents.
                    for (var _a = 0, transparentCalls_1 = transparentCalls; _a < transparentCalls_1.length; _a++) {
                        var drawCall = transparentCalls_1[_a];
                        this._draw(camera.context, drawCall, drawCall.material);
                    }
                }
                // Egret2D渲染不加入DrawCallList的排序
                for (var _b = 0, _c = this._groups[1].gameObjects; _b < _c.length; _b++) {
                    var gameObject = _c[_b];
                    var egret2DRenderer = gameObject.getComponent(egret3d.Egret2DRenderer);
                    if (camera.cullingMask & egret2DRenderer.gameObject.layer) {
                        if (egret2DRenderer._order < 0) {
                            egret2DRenderer._order = this._egret2dOrderCount++;
                        }
                        egret2DRenderer._draw();
                        this._renderState.clearState();
                    }
                }
            };
            WebGLRenderSystem.prototype._draw = function (context, drawCall, material) {
                context.update(drawCall);
                //
                var webgl = egret3d.WebGLCapabilities.webgl;
                var technique = material._glTFTechnique;
                var renderState = this._renderState;
                // Get program.
                var program = renderState.getProgram(material, technique, context.shaderContextDefine + material.shaderDefine);
                // Use program.
                var force = renderState.useProgram(program);
                // Update states.
                renderState.updateState(technique.states || null);
                // Update static uniforms.
                this._updateContextUniforms(program, context, technique);
                // Update uniforms.
                this._updateUniforms(program, material, technique, force);
                // Update attributes.
                this._updateAttributes(program, drawCall.mesh, drawCall.subMeshIndex, technique, force);
                // Draw.
                var mesh = drawCall.mesh;
                var glTFMesh = mesh.glTFMesh;
                var primitive = glTFMesh.primitives[drawCall.subMeshIndex];
                var vertexAccessor = mesh.getAccessor(glTFMesh.primitives[0].attributes.POSITION || 0);
                var bufferOffset = mesh.getBufferOffset(vertexAccessor);
                var drawMode = primitive.mode === undefined ? 4 /* Triangles */ : primitive.mode;
                if (primitive.indices !== undefined) {
                    var indexAccessor = mesh.getAccessor(primitive.indices);
                    webgl.drawElements(drawMode, indexAccessor.count, webgl.UNSIGNED_SHORT, bufferOffset);
                }
                else {
                    webgl.drawArrays(drawMode, bufferOffset, vertexAccessor.count);
                }
            };
            WebGLRenderSystem.prototype._updateContextUniforms = function (program, context, technique) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                var uniforms = technique.uniforms;
                var glUniforms = program.contextUniforms;
                for (var _i = 0, glUniforms_1 = glUniforms; _i < glUniforms_1.length; _i++) {
                    var glUniform = glUniforms_1[_i];
                    var uniform = uniforms[glUniform.name];
                    if (!uniform.semantic) {
                        continue;
                    }
                    var location_3 = glUniform.location;
                    switch (uniform.semantic) {
                        case "MODEL" /* MODEL */:
                            webgl.uniformMatrix4fv(location_3, false, context.matrix_m.rawData);
                            break;
                        case "MODELVIEW" /* MODELVIEW */:
                            webgl.uniformMatrix4fv(location_3, false, context.matrix_mv.rawData);
                            break;
                        case "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */:
                            webgl.uniformMatrix4fv(location_3, false, context.matrix_mvp.rawData);
                            break;
                        case "MODELVIEWINVERSE" /* MODELVIEWINVERSE */:
                            webgl.uniformMatrix3fv(location_3, false, context.matrix_mv_inverse.rawData);
                            break;
                        case "VIEW" /* VIEW */:
                            webgl.uniformMatrix4fv(location_3, false, context.matrix_v.rawData);
                            break;
                        case "PROJECTION" /* PROJECTION */:
                            webgl.uniformMatrix4fv(location_3, false, context.matrix_p.rawData);
                            break;
                        case "_VIEWPROJECTION" /* _VIEWPROJECTION */:
                            webgl.uniformMatrix4fv(location_3, false, context.matrix_vp.rawData);
                            break;
                        case "_CAMERA_POS" /* _CAMERA_POS */:
                            webgl.uniform3fv(location_3, context.cameraPosition);
                            break;
                        case "_CAMERA_FORWARD" /* _CAMERA_FORWARD */:
                            webgl.uniform3fv(location_3, context.cameraForward);
                            break;
                        case "CAMERA_UP" /* _CAMERA_UP */:
                            webgl.uniform3fv(location_3, context.cameraUp);
                            break;
                        case "JOINTMATRIX" /* JOINTMATRIX */:
                            webgl.uniformMatrix4fv(location_3, false, context.drawCall.renderer.boneMatrices);
                            break;
                        case "_DIRECTLIGHTS" /* _DIRECTLIGHTS */:
                            if (context.directLightCount > 0) {
                                webgl.uniform1fv(location_3, context.directLightArray);
                            }
                            break;
                        case "_POINTLIGHTS" /* _POINTLIGHTS */:
                            if (context.pointLightCount > 0) {
                                webgl.uniform1fv(location_3, context.pointLightArray);
                            }
                            break;
                        case "_SPOTLIGHTS" /* _SPOTLIGHTS */:
                            if (context.spotLightCount > 0) {
                                webgl.uniform1fv(location_3, context.spotLightArray);
                            }
                            break;
                        case "_AMBIENTLIGHTCOLOR" /* _AMBIENTLIGHTCOLOR */:
                            var currenAmbientColor = paper.Scene.activeScene.ambientColor;
                            webgl.uniform3f(location_3, currenAmbientColor.r, currenAmbientColor.g, currenAmbientColor.b);
                            // webgl.uniform3fv(location, context.ambientLightColor);
                            break;
                        case "_DIRECTIONSHADOWMAT" /* _DIRECTIONSHADOWMAT */:
                            webgl.uniformMatrix4fv(location_3, false, context.directShadowMatrix);
                            break;
                        case "_SPOTSHADOWMAT" /* _SPOTSHADOWMAT */:
                            webgl.uniformMatrix4fv(location_3, false, context.spotShadowMatrix);
                            break;
                        case "_POINTSHADOWMAT" /* _POINTSHADOWMAT */:
                            webgl.uniformMatrix4fv(location_3, false, context.pointShadowMatrix);
                            break;
                        case "_DIRECTIONSHADOWMAP" /* _DIRECTIONSHADOWMAP */:
                            var directShadowLen = context.directShadowMaps.length;
                            if (directShadowLen > 0 && glUniform.textureUnits) {
                                var units = glUniform.textureUnits;
                                webgl.uniform1iv(location_3, units);
                                for (var i = 0, l = units.length; i < l; i++) {
                                    if (context.directShadowMaps[i]) {
                                        webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                        webgl.bindTexture(webgl.TEXTURE_2D, context.directShadowMaps[i]);
                                    }
                                }
                            }
                            break;
                        case "_POINTSHADOWMAP" /* _POINTSHADOWMAP */:
                            var pointShadowLen = context.pointShadowMaps.length;
                            if (pointShadowLen > 0 && glUniform.textureUnits) {
                                var units = glUniform.textureUnits;
                                webgl.uniform1iv(location_3, units);
                                for (var i = 0, l = units.length; i < l; i++) {
                                    if (context.pointShadowMaps[i]) {
                                        webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                        webgl.bindTexture(webgl.TEXTURE_2D, context.pointShadowMaps[i]);
                                    }
                                }
                            }
                            break;
                        case "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */:
                            var spotShadowLen = context.spotShadowMaps.length;
                            if (spotShadowLen > 0 && glUniform.textureUnits) {
                                var units = glUniform.textureUnits;
                                webgl.uniform1iv(location_3, units);
                                for (var i = 0, l = units.length; i < l; i++) {
                                    if (context.spotShadowMaps[i]) {
                                        webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                        webgl.bindTexture(webgl.TEXTURE_2D, context.spotShadowMaps[i]);
                                    }
                                }
                            }
                            break;
                        case "_LIGHTMAPTEX" /* _LIGHTMAPTEX */:
                            if (glUniform.textureUnits && glUniform.textureUnits.length === 1 && context.lightmap) {
                                var unit = glUniform.textureUnits[0];
                                webgl.uniform1i(location_3, unit);
                                webgl.activeTexture(webgl.TEXTURE0 + unit);
                                webgl.bindTexture(webgl.TEXTURE_2D, context.lightmap._texture);
                            }
                            else {
                                console.error("Error texture unit.");
                            }
                            break;
                        case "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */:
                            webgl.uniform1f(location_3, context.lightmapIntensity);
                            break;
                        case "_REFERENCEPOSITION" /* _REFERENCEPOSITION */:
                            webgl.uniform3fv(location_3, context.lightPosition);
                            break;
                        case "_NEARDICTANCE" /* _NEARDICTANCE */:
                            webgl.uniform1f(location_3, context.lightShadowCameraNear);
                            break;
                        case "_FARDISTANCE" /* _FARDISTANCE */:
                            webgl.uniform1f(location_3, context.lightShadowCameraFar);
                            break;
                        case "_FOG_COLOR" /* _FOG_COLOR */:
                            webgl.uniform3fv(location_3, context.fogColor);
                            break;
                        case "_FOG_DENSITY" /* _FOG_DENSITY */:
                            webgl.uniform1f(location_3, context.fogDensity);
                            break;
                        case "_FOG_NEAR" /* _FOG_NEAR */:
                            webgl.uniform1f(location_3, context.fogNear);
                            break;
                        case "_FOG_FAR" /* _FOG_FAR */:
                            webgl.uniform1f(location_3, context.fogFar);
                            break;
                        default:
                            console.warn("不识别的Uniform语义:" + uniform.semantic);
                            break;
                    }
                }
            };
            WebGLRenderSystem.prototype._updateUniforms = function (program, material, technique, forceUpdate) {
                var needUpdate = this._cacheMaterial !== material || this._cacheMaterialVerision !== material._version || forceUpdate;
                if (!needUpdate) {
                    return;
                }
                this._cacheMaterial = material;
                this._cacheMaterialVerision = material._version;
                var webgl = egret3d.WebGLCapabilities.webgl;
                var unifroms = technique.uniforms;
                var glUniforms = program.uniforms;
                for (var _i = 0, glUniforms_2 = glUniforms; _i < glUniforms_2.length; _i++) {
                    var glUniform = glUniforms_2[_i];
                    var uniform = unifroms[glUniform.name];
                    if (uniform.semantic) {
                        continue;
                    }
                    var location_4 = glUniform.location;
                    var value = uniform.value;
                    switch (uniform.type) {
                        case 35670 /* BOOL */:
                        case 5124 /* INT */:
                            if (glUniform.size > 1) {
                                webgl.uniform1iv(location_4, value);
                            }
                            else {
                                webgl.uniform1i(location_4, value);
                            }
                            break;
                        case 35671 /* BOOL_VEC2 */:
                        case 35667 /* INT_VEC2 */:
                            webgl.uniform2iv(location_4, value);
                            break;
                        case 35672 /* BOOL_VEC3 */:
                        case 35668 /* INT_VEC3 */:
                            webgl.uniform3iv(location_4, value);
                            break;
                        case 35673 /* BOOL_VEC4 */:
                        case 35669 /* INT_VEC4 */:
                            webgl.uniform4iv(location_4, value);
                            break;
                        case 5126 /* FLOAT */:
                            if (glUniform.size > 1) {
                                webgl.uniform1fv(location_4, value);
                            }
                            else {
                                webgl.uniform1f(location_4, value);
                            }
                            break;
                        case 35664 /* FLOAT_VEC2 */:
                            webgl.uniform2fv(location_4, value);
                            break;
                        case 35665 /* FLOAT_VEC3 */:
                            webgl.uniform3fv(location_4, value);
                            break;
                        case 35666 /* FLOAT_VEC4 */:
                            webgl.uniform4fv(location_4, value);
                            break;
                        case 35674 /* FLOAT_MAT2 */:
                            webgl.uniformMatrix2fv(location_4, false, value);
                            break;
                        case 35675 /* FLOAT_MAT3 */:
                            webgl.uniformMatrix3fv(location_4, false, value);
                            break;
                        case 35676 /* FLOAT_MAT4 */:
                            webgl.uniformMatrix4fv(location_4, false, value);
                            break;
                        case 35678 /* SAMPLER_2D */:
                            if (glUniform.textureUnits && glUniform.textureUnits.length === 1) {
                                var unit = glUniform.textureUnits[0];
                                webgl.uniform1i(location_4, unit);
                                webgl.activeTexture(webgl.TEXTURE0 + unit);
                                webgl.bindTexture(webgl.TEXTURE_2D, value._texture);
                            }
                            else {
                                console.error("Error texture unit");
                            }
                            break;
                    }
                }
            };
            WebGLRenderSystem.prototype._updateAttributes = function (program, mesh, subMeshIndex, technique, forceUpdate) {
                var needUpdate = forceUpdate || this._cacheSubMeshIndex !== subMeshIndex || this._cacheMesh !== mesh;
                if (!needUpdate) {
                    return;
                }
                this._cacheSubMeshIndex = subMeshIndex;
                this._cacheMesh = mesh;
                var webgl = egret3d.WebGLCapabilities.webgl;
                var primitive = mesh.glTFMesh.primitives[subMeshIndex];
                // vbo.
                var webglAttributes = program.attributes;
                var attributes = technique.attributes;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, mesh._vbo);
                for (var _i = 0, webglAttributes_1 = webglAttributes; _i < webglAttributes_1.length; _i++) {
                    var glAttribute = webglAttributes_1[_i];
                    var attribute = attributes[glAttribute.name];
                    var location_5 = glAttribute.location;
                    var accessorIndex = primitive.attributes[attribute.semantic];
                    if (accessorIndex !== undefined) {
                        var accessor = mesh.getAccessor(accessorIndex);
                        var bufferOffset = mesh.getBufferOffset(accessor);
                        var typeCount = mesh.getAccessorTypeCount(accessor.type);
                        webgl.vertexAttribPointer(location_5, typeCount, accessor.componentType, accessor.normalized ? true : false, 0, bufferOffset); //TODO normalized应该来源于mesh，应该还没有
                        webgl.enableVertexAttribArray(location_5);
                    }
                    else {
                        webgl.disableVertexAttribArray(location_5);
                    }
                }
                // ibo.
                var ibo = mesh._ibos[subMeshIndex];
                if (ibo) {
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                }
            };
            WebGLRenderSystem.prototype._viewport = function (viewport, target) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                var w;
                var h;
                if (!target) {
                    var stageViewport = egret3d.stage.viewport;
                    w = stageViewport.w;
                    h = stageViewport.h;
                    webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
                }
                else {
                    w = target.width;
                    h = target.height;
                    target.use();
                }
                webgl.viewport(w * viewport.x, h * viewport.y, w * viewport.w, h * viewport.h);
                webgl.depthRange(0, 1);
            };
            WebGLRenderSystem.prototype.onUpdate = function () {
                var webgl = egret3d.WebGLCapabilities.webgl;
                if (!webgl) {
                    return;
                }
                egret3d.Performance.startCounter("render");
                var lightCountDirty = false;
                var isPlayerMode = paper.Application.playerMode === 0 /* Player */;
                var renderState = this._renderState;
                var cameras = this._cameraAndLightCollecter.cameras;
                var lights = this._cameraAndLightCollecter.lights;
                var editorScene = paper.Application.sceneManager.editorScene;
                this._drawCallCollecter.drawCallCount = 0;
                // Render lights.
                if (lights.length > 0) {
                    lightCountDirty = true;
                    this._cacheLightCount = 0;
                    for (var _i = 0, lights_3 = lights; _i < lights_3.length; _i++) {
                        var light = lights_3[_i];
                        this._cacheLightCount++;
                        if (!light.castShadows) {
                            continue;
                        }
                        this._renderLightShadow(light);
                    }
                }
                else if (this._cacheLightCount > 0) {
                    lightCountDirty = true;
                    this._cacheLightCount = 0;
                }
                // Render cameras.
                if (cameras.length > 0) {
                    this._egret2dOrderCount = 0;
                    for (var _a = 0, cameras_2 = cameras; _a < cameras_2.length; _a++) {
                        var camera = cameras_2[_a];
                        var scene = camera.gameObject.scene;
                        var renderEnabled = isPlayerMode ? scene !== editorScene : scene === editorScene;
                        if (renderEnabled && lightCountDirty) {
                            camera.context.updateLights(lights); // TODO 性能优化
                        }
                        if (camera.postQueues.length === 0) {
                            if (renderEnabled) {
                                this._viewport(camera.viewport, camera.renderTarget);
                                renderState.clear(camera.clearOption_Color, camera.clearOption_Depth, camera.backgroundColor);
                            }
                            this._renderCamera(camera, renderEnabled);
                            if (renderEnabled && camera.renderTarget) {
                                if (camera.renderTarget.generateMipmap()) {
                                    renderState.clearState(); // Fixed there is no texture bound to the unit 0 error.
                                }
                            }
                        }
                        else {
                            for (var _b = 0, _c = camera.postQueues; _b < _c.length; _b++) {
                                var item = _c[_b];
                                // TODO
                            }
                        }
                    }
                }
                else {
                    renderState.clear(true, true, egret3d.Color.BLACK);
                }
                egret3d.Performance.endCounter("render");
            };
            return WebGLRenderSystem;
        }(paper.BaseSystem));
        web.WebGLRenderSystem = WebGLRenderSystem;
        __reflect(WebGLRenderSystem.prototype, "egret3d.web.WebGLRenderSystem");
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var InputSystem = (function (_super) {
            __extends(InputSystem, _super);
            function InputSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._hasTouch = false;
                _this._canvas = null;
                _this._onPointerEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    var canvas = _this._canvas;
                    var downPointers = egret3d.inputCollecter.downPointers;
                    var holdPointers = egret3d.inputCollecter.holdPointers;
                    var pointer = egret3d.inputCollecter.getPointer(event.pointerId);
                    var prevEvent = pointer.event;
                    pointer.event = event;
                    // if (event.target !== canvas) {
                    //     (event as any).clientX -= canvas.clientLeft;
                    //     (event as any).clientY -= canvas.clientTop;
                    // }
                    pointer.position.set(event.clientX - (canvas.offsetLeft || 0.0), event.clientY - (canvas.offsetTop || 0.0), 0.0);
                    egret3d.stage.screenToStage(pointer.position, pointer.position);
                    switch (event.type) {
                        case "pointerover":
                            if (holdPointers.length > 0 && event.buttons === 0 /* None */) {
                                _this._pointerUp(pointer, true);
                            }
                            egret3d.inputCollecter.onPointerOver.dispatch(pointer, egret3d.inputCollecter.onPointerOver);
                            break;
                        case "pointerenter":
                            egret3d.inputCollecter.onPointerEnter.dispatch(pointer, egret3d.inputCollecter.onPointerEnter);
                            break;
                        case "pointerdown":
                            if (downPointers.indexOf(pointer) < 0 && holdPointers.indexOf(pointer) < 0) {
                                pointer.downPosition.copy(pointer.position);
                                downPointers.push(pointer);
                                egret3d.inputCollecter.onPointerDown.dispatch(pointer, egret3d.inputCollecter.onPointerDown);
                            }
                            break;
                        case "pointermove":
                            if (event.target === canvas || holdPointers.length > 0) {
                                egret3d.inputCollecter.onPointerMove.dispatch(pointer, egret3d.inputCollecter.onPointerMove);
                            }
                            else {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "pointerup":
                            if (!_this._pointerUp(pointer, false)) {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "pointercancel":
                            if (!_this._pointerUp(pointer, true)) {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "pointerout":
                            egret3d.inputCollecter.onPointerOut.dispatch(pointer, egret3d.inputCollecter.onPointerOut);
                            break;
                        case "pointerleave":
                            egret3d.inputCollecter.onPointerLeave.dispatch(pointer, egret3d.inputCollecter.onPointerLeave);
                            break;
                    }
                    // event.preventDefault();
                };
                _this._onMouseWheelEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    if (event.detail) {
                        egret3d.inputCollecter.mouseWheel = -1 * event.detail;
                    }
                    else if (event.wheelDelta) {
                        egret3d.inputCollecter.mouseWheel = event.wheelDelta / 120;
                    }
                    else {
                        egret3d.inputCollecter.mouseWheel = 0;
                    }
                    egret3d.inputCollecter.onMouseWheel.dispatch(_this);
                    event.preventDefault();
                };
                _this._onMouseEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    event.isPrimary = true;
                    event.pointerId = 1;
                    event.pressure = 0;
                    event.tangentialPressure = 0;
                    event.twist = 0;
                    event.width = 1;
                    event.height = 1;
                    event.tiltX = 0;
                    event.tiltY = 0;
                    event.pointerType = "mouse";
                    var pointerEvent = event;
                    var canvas = _this._canvas;
                    var downPointers = egret3d.inputCollecter.downPointers;
                    var holdPointers = egret3d.inputCollecter.holdPointers;
                    var pointer = egret3d.inputCollecter.getPointer(pointerEvent.pointerId);
                    var prevEvent = pointer.event;
                    pointer.event = pointerEvent;
                    // if (event.target !== canvas) {
                    //     (pointerEvent as any).clientX -= canvas.clientLeft;
                    //     (pointerEvent as any).clientY -= canvas.clientTop;
                    // }
                    pointer.position.set(event.clientX - (canvas.offsetLeft || 0.0), event.clientY - (canvas.offsetTop || 0.0), 0.0);
                    egret3d.stage.screenToStage(pointer.position, pointer.position);
                    switch (event.type) {
                        case "mouseover":
                            if (holdPointers.length > 0 && event.buttons === 0 /* None */) {
                                event.type = "pointerup";
                                _this._pointerUp(pointer, true);
                            }
                            event.type = "pointerover";
                            egret3d.inputCollecter.onPointerOver.dispatch(pointer, egret3d.inputCollecter.onPointerOver);
                            break;
                        case "mouseenter":
                            event.type = "pointerenter";
                            egret3d.inputCollecter.onPointerEnter.dispatch(pointer, egret3d.inputCollecter.onPointerEnter);
                            break;
                        case "mousedown":
                            if (downPointers.indexOf(pointer) < 0 && holdPointers.indexOf(pointer) < 0) {
                                pointer.downPosition.copy(pointer.position);
                                downPointers.push(pointer);
                                event.type = "pointerdown";
                                egret3d.inputCollecter.onPointerDown.dispatch(pointer, egret3d.inputCollecter.onPointerDown);
                            }
                            break;
                        case "mousemove":
                            if (event.target === canvas || holdPointers.length > 0) {
                                event.type = "pointermove";
                                egret3d.inputCollecter.onPointerMove.dispatch(pointer, egret3d.inputCollecter.onPointerMove);
                            }
                            else {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "mouseup":
                            event.type = "pointerup";
                            if (!_this._pointerUp(pointer, false)) {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "mousecancel":
                            event.type = "pointercancel";
                            if (!_this._pointerUp(pointer, true)) {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "mouseout":
                            event.type = "pointerout";
                            egret3d.inputCollecter.onPointerOut.dispatch(pointer, egret3d.inputCollecter.onPointerOut);
                            break;
                        case "mouseleave":
                            event.type = "pointerleave";
                            egret3d.inputCollecter.onPointerLeave.dispatch(pointer, egret3d.inputCollecter.onPointerLeave);
                            break;
                    }
                    // event.preventDefault();
                };
                _this._onTouchEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    if (!_this._hasTouch) {
                        _this._hasTouch = true;
                        _this._removeMouseEvent(); // TODO 同时支持 mouse 和 touch.
                    }
                    var touch = event.changedTouches[0];
                    event.isPrimary = true; // TODO
                    event.pointerId = touch.identifier + 2;
                    event.pressure = touch.force || 0.5;
                    event.tangentialPressure = 0;
                    event.twist = 0;
                    event.width = (touch.radiusX || 0) * 2;
                    event.height = (touch.radiusY || 0) * 2;
                    event.tiltX = 0;
                    event.tiltY = 0;
                    event.pointerType = "touch";
                    event.button = 0;
                    event.buttons = (event.type === "touchstart" || event.type === "touchmove") ? 1 : 0;
                    event.clientX = touch.clientX;
                    event.clientY = touch.clientY;
                    event.pageX = touch.pageX;
                    event.pageY = touch.pageY;
                    event.screenX = touch.screenX;
                    event.screenY = touch.screenY;
                    var pointerEvent = event;
                    var canvas = _this._canvas;
                    var downPointers = egret3d.inputCollecter.downPointers;
                    var holdPointers = egret3d.inputCollecter.holdPointers;
                    var pointer = egret3d.inputCollecter.getPointer(pointerEvent.pointerId);
                    var prevEvent = pointer.event;
                    pointer.event = pointerEvent;
                    // if (event.target !== canvas) {
                    //     (pointerEvent as any).clientX -= canvas.clientLeft;
                    //     (pointerEvent as any).clientY -= canvas.clientTop;
                    // }
                    pointer.position.set(pointerEvent.clientX - (canvas.offsetLeft || 0.0), pointerEvent.clientY - (canvas.offsetTop || 0.0), 0.0);
                    egret3d.stage.screenToStage(pointer.position, pointer.position);
                    switch (event.type) {
                        case "touchstart":
                            if (downPointers.indexOf(pointer) < 0 && holdPointers.indexOf(pointer) < 0) {
                                pointer.downPosition.copy(pointer.position);
                                downPointers.push(pointer);
                                event.type = "pointerdown";
                                egret3d.inputCollecter.onPointerDown.dispatch(pointer, egret3d.inputCollecter.onPointerDown);
                            }
                            break;
                        case "touchmove":
                            if (event.target === canvas || holdPointers.length > 0) {
                                event.type = "pointermove";
                                egret3d.inputCollecter.onPointerMove.dispatch(pointer, egret3d.inputCollecter.onPointerMove);
                                for (var i = 0, l = event.targetTouches.length; i < l; ++i) {
                                    var eachTouch = event.targetTouches[i];
                                    if (eachTouch !== touch) {
                                        var eachPointer = egret3d.inputCollecter.getPointer(eachTouch.identifier + 2);
                                        var eachPointerEvent = eachPointer.event;
                                        eachPointerEvent.pressure = eachTouch.force || 0.5;
                                        eachPointerEvent.width = (eachTouch.radiusX || 0) * 2;
                                        eachPointerEvent.height = (eachTouch.radiusY || 0) * 2;
                                        eachPointerEvent.clientX = eachTouch.clientX;
                                        eachPointerEvent.clientY = eachTouch.clientY;
                                        eachPointerEvent.pageX = eachTouch.pageX;
                                        eachPointerEvent.pageY = eachTouch.pageY;
                                        eachPointerEvent.screenX = eachTouch.screenX;
                                        eachPointerEvent.screenY = eachTouch.screenY;
                                        eachPointerEvent.type = "pointermove";
                                        // if (event.target !== canvas) {
                                        //     (eachPointerEvent as any).clientX -= canvas.clientLeft;
                                        //     (eachPointerEvent as any).clientY -= canvas.clientTop;
                                        // }
                                        eachPointer.position.set(eachPointerEvent.clientX, eachPointerEvent.clientY, 0.0);
                                        egret3d.stage.screenToStage(eachPointer.position, eachPointer.position);
                                        egret3d.inputCollecter.onPointerMove.dispatch(eachPointer, egret3d.inputCollecter.onPointerMove);
                                    }
                                }
                            }
                            else {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "touchend":
                            event.type = "pointerup";
                            if (!_this._pointerUp(pointer, false)) {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "touchcancel":
                            event.type = "pointercancel";
                            if (!_this._pointerUp(pointer, true)) {
                                pointer.event = prevEvent;
                            }
                            break;
                    }
                    // event.preventDefault();
                };
                _this._onContextMenu = function (event) {
                    if (egret3d.inputCollecter.downPointers.length > 0 ||
                        egret3d.inputCollecter.holdPointers.length > 0 ||
                        egret3d.inputCollecter.upPointers.length > 0) {
                        event.preventDefault();
                    }
                };
                _this._onKeyEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    var downKeys = egret3d.inputCollecter.downKeys;
                    var holdKeys = egret3d.inputCollecter.holdKeys;
                    var upKeys = egret3d.inputCollecter.upKeys;
                    var key = egret3d.inputCollecter.getKey(event.code);
                    key.event = event;
                    switch (event.type) {
                        case "keydown":
                            if (downKeys.indexOf(key) < 0 && holdKeys.indexOf(key) < 0) {
                                downKeys.push(key);
                                egret3d.inputCollecter.onKeyDown.dispatch(key, egret3d.inputCollecter.onKeyDown);
                            }
                            break;
                        case "keyup":
                            var index = downKeys.indexOf(key);
                            if (index >= 0) {
                                downKeys.splice(index, 1);
                            }
                            else {
                                index = holdKeys.indexOf(key);
                                if (index >= 0) {
                                    holdKeys.splice(index, 1);
                                }
                            }
                            if (index >= 0 && upKeys.indexOf(key) < 0) {
                                upKeys.push(key);
                                egret3d.inputCollecter.onKeyUp.dispatch(key, egret3d.inputCollecter.onKeyUp);
                            }
                            break;
                    }
                };
                return _this;
            }
            InputSystem.prototype._pointerUp = function (pointer, isCancel) {
                if (pointer.event.buttons !== 0 /* None */) {
                    return false;
                }
                var downPointers = egret3d.inputCollecter.downPointers;
                var holdPointers = egret3d.inputCollecter.holdPointers;
                var upPointers = egret3d.inputCollecter.upPointers;
                var index = holdPointers.indexOf(pointer);
                if (index >= 0) {
                    holdPointers.splice(index, 1);
                }
                else {
                    index = downPointers.indexOf(pointer);
                }
                if (index >= 0 && upPointers.indexOf(pointer) < 0) {
                    egret3d.inputCollecter.removePointer(pointer.event.pointerId);
                    upPointers.push(pointer);
                    if (isCancel) {
                        egret3d.inputCollecter.onPointerCancel.dispatch(pointer, egret3d.inputCollecter.onPointerCancel);
                    }
                    else {
                        egret3d.inputCollecter.onPointerUp.dispatch(pointer, egret3d.inputCollecter.onPointerUp);
                    }
                    return true;
                }
                return false;
            };
            InputSystem.prototype._removeMouseEvent = function () {
                var canvas = this._canvas;
                canvas.removeEventListener("mouseover", this._onMouseEvent);
                canvas.removeEventListener("mouseenter", this._onMouseEvent);
                canvas.removeEventListener("mousedown", this._onMouseEvent);
                window.removeEventListener("mousemove", this._onMouseEvent);
                window.removeEventListener("mouseup", this._onMouseEvent);
                canvas.removeEventListener("mouseout", this._onMouseEvent);
                canvas.removeEventListener("mouseleave", this._onMouseEvent);
            };
            InputSystem.prototype.onAwake = function (config) {
                this._canvas = config.canvas;
            };
            InputSystem.prototype.onEnable = function () {
                var canvas = this._canvas;
                // if ((window as any).PointerEvent) { // TODO 会无故触发 pointercancel （PVP 项目）
                //     Pointer events.
                //     canvas.addEventListener("pointerover", this._onPointerEvent);
                //     canvas.addEventListener("pointerenter", this._onPointerEvent);
                //     canvas.addEventListener("pointerdown", this._onPointerEvent);
                //     window.addEventListener("pointermove", this._onPointerEvent);
                //     window.addEventListener("pointerup", this._onPointerEvent);
                //     canvas.addEventListener("pointercancel", this._onPointerEvent);
                //     canvas.addEventListener("pointerout", this._onPointerEvent);
                //     canvas.addEventListener("pointerleave", this._onPointerEvent);
                // }
                // else {
                // Mouse events.
                if (!this._hasTouch) {
                    canvas.addEventListener("mousedown", this._onMouseEvent);
                    canvas.addEventListener("mouseover", this._onMouseEvent);
                    canvas.addEventListener("mouseenter", this._onMouseEvent);
                    window.addEventListener("mousemove", this._onMouseEvent);
                    window.addEventListener("mouseup", this._onMouseEvent);
                    canvas.addEventListener("mouseout", this._onMouseEvent);
                    canvas.addEventListener("mouseleave", this._onMouseEvent);
                }
                // Touch events.
                canvas.addEventListener("touchstart", this._onTouchEvent);
                canvas.addEventListener("touchmove", this._onTouchEvent);
                canvas.addEventListener("touchend", this._onTouchEvent);
                window.addEventListener("touchcancel", this._onTouchEvent);
                // }
                // Context menu event.
                window.addEventListener("contextmenu", this._onContextMenu);
                // Mouse wheel event.
                canvas.addEventListener("mousewheel", this._onMouseWheelEvent);
                // Key events.
                window.addEventListener("keydown", this._onKeyEvent);
                window.addEventListener("keyup", this._onKeyEvent);
            };
            InputSystem.prototype.onDisable = function () {
                var canvas = this._canvas;
                // Pointer events.
                canvas.removeEventListener("pointerover", this._onPointerEvent);
                canvas.removeEventListener("pointerenter", this._onPointerEvent);
                canvas.removeEventListener("pointerdown", this._onPointerEvent);
                window.removeEventListener("pointermove", this._onPointerEvent);
                window.removeEventListener("pointerup", this._onPointerEvent);
                canvas.removeEventListener("pointercancel", this._onPointerEvent);
                canvas.removeEventListener("pointerout", this._onPointerEvent);
                canvas.removeEventListener("pointerleave", this._onPointerEvent);
                // Mouse events.
                this._removeMouseEvent();
                // Touch events.
                canvas.removeEventListener("touchstart", this._onTouchEvent);
                canvas.removeEventListener("touchmove", this._onTouchEvent);
                canvas.removeEventListener("touchend", this._onTouchEvent);
                window.removeEventListener("touchcancel", this._onTouchEvent);
                // Context menu event.
                window.removeEventListener("contextmenu", this._onContextMenu);
                // Mouse wheel event.
                canvas.removeEventListener("mousewheel", this._onMouseWheelEvent);
                // Key events.
                window.removeEventListener("keydown", this._onKeyEvent);
                window.removeEventListener("keyup", this._onKeyEvent);
                egret3d.inputCollecter.clear();
            };
            InputSystem.prototype.onUpdate = function (deltaTime) {
                if (egret3d.inputCollecter.isActiveAndEnabled) {
                    egret3d.inputCollecter.update(deltaTime).clear();
                }
            };
            return InputSystem;
        }(paper.BaseSystem));
        web.InputSystem = InputSystem;
        __reflect(InputSystem.prototype, "egret3d.web.InputSystem");
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var EndSystem = (function (_super) {
            __extends(EndSystem, _super);
            function EndSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._contactCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.ContactCollecter);
                return _this;
            }
            EndSystem.prototype.onUpdate = function (deltaTime) {
                var contactCollecter = this._contactCollecter;
                if (contactCollecter.isActiveAndEnabled) {
                    this._contactCollecter.update(deltaTime);
                }
                egret3d.Performance.updateFPS();
                egret3d.Performance.endCounter("all" /* All */);
            };
            return EndSystem;
        }(paper.BaseSystem));
        web.EndSystem = EndSystem;
        __reflect(EndSystem.prototype, "egret3d.web.EndSystem");
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //最大允许合并的顶点数，超过就是下一批次
    egret3d.MAX_VERTEX_COUNT_PER_BUFFER = 50000;
    //
    var helpVec3_1 = egret3d.Vector3.create();
    var helpVec3_2 = egret3d.Vector3.create();
    var helpInverseMatrix = egret3d.Matrix4.create();
    //缓存已经校验过的对象，用于过滤
    var cacheInstances = [];
    var beforeCombineCount = 0;
    /**
     * 尝试对场景内所有静态对象合并
     */
    function autoCombine(scene) {
        combine(scene.gameObjects);
    }
    egret3d.autoCombine = autoCombine;
    /**
     * 尝试合并静态对象列表。
     * @param instances
     * @param root
     */
    function combine(instances) {
        cacheInstances.length = 0;
        beforeCombineCount = 0;
        var allCombines = {};
        //1.通过材质填充合并列表
        for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
            var obj = instances_1[_i];
            _colletCombineInstance(obj, allCombines);
        }
        console.log("合并前:" + beforeCombineCount);
        var afterCombineCount = 0;
        //2.相同材质的合并
        for (var key in allCombines) {
            var combines = allCombines[key];
            for (var _a = 0, combines_1 = combines; _a < combines_1.length; _a++) {
                var combine_1 = combines_1[_a];
                _combineInstance(combine_1);
                afterCombineCount++;
            }
        }
        console.log("合并后:" + afterCombineCount + "节省:" + (beforeCombineCount - afterCombineCount));
        cacheInstances.length = 0;
    }
    egret3d.combine = combine;
    /**
     * TODO(root暂时不支持)尝试合并静态对象列表，如果root有值，合并后可以操作root对象的transform，来实现整体移动，旋转，缩放；反之，相同材质列表的第一个对象为合并节点。
     * @param instances
     * @param root
     */
    function _colletCombineInstance(target, out, root) {
        //过滤重复的对象
        if (cacheInstances.indexOf(target.uuid) >= 0) {
            return;
        }
        cacheInstances.push(target.uuid);
        //
        for (var _i = 0, _a = target.transform.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child) {
                _colletCombineInstance(child.gameObject, out, root);
            }
        }
        //不是静态的不考虑合并
        if (!target.isStatic) {
            return;
        }
        var meshFilter = target.getComponent(egret3d.MeshFilter);
        var meshRenderer = target.getComponent(egret3d.MeshRenderer);
        //合并条件判断
        if (!meshFilter || !meshFilter.mesh || !meshRenderer || !meshRenderer.materials || meshRenderer.materials.length < 1) {
            return;
        }
        beforeCombineCount++;
        var materials = meshRenderer.materials;
        var meshData = meshFilter.mesh;
        //合并筛选的条件:光照贴图_材质0_材质1... ：0_234_532...
        var key = meshRenderer.lightmapIndex + "_";
        materials.forEach(function (element) { key = key + "_" + element.uuid; });
        if (!out[key]) {
            out[key] = [];
            out[key].push(new CombineInstance());
        }
        var combines = out[key];
        //找相同材质合成列表的最后一个，如果最后一个顶点超过允许最大数了，就新建一个，下个批次处理
        var combine = combines[combines.length - 1];
        if (combine.vertexCount + meshData.vertexCount > egret3d.MAX_VERTEX_COUNT_PER_BUFFER) {
            combine = new CombineInstance();
            out[key].push(combine);
        }
        //合并节点以传入的对象为优先，如果没有传入，那么以每种材质的第一个对象为准
        if (!combine.root) {
            combine.root = root ? root : target;
            combine.lightmapIndex = meshRenderer.lightmapIndex;
        }
        //适配最大格式
        var primitives = meshData.glTFMesh.primitives;
        for (var i = 0; i < primitives.length; i++) {
            var primitive = primitives[i];
            for (var attStr in primitives[i].attributes) {
                var attrType = attStr;
                if (!combine.meshAttribute[attrType]) {
                    combine.vertexBufferSize += meshData.getAccessorTypeCount(meshData.getAccessor(primitive.attributes[attStr]).type);
                }
                combine.meshAttribute[attrType] = attrType;
            }
            combine.indexBufferTotalSize += meshData.getBufferLength(meshData.getAccessor(primitive.indices)) / Uint16Array.BYTES_PER_ELEMENT;
        }
        //
        combine.vertexCount += meshData.vertexCount;
        combine.instances.push(target);
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     */
    function _combineInstance(combineInstance) {
        var combineMesh = _combineMesh(combineInstance);
        var combineRoot = combineInstance.root;
        //把合成好的放入root中，重新绘制
        var meshFilter = combineRoot.getComponent(egret3d.MeshFilter);
        meshFilter.mesh = combineMesh;
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     * @param root
     */
    function _combineMesh(combineInstance) {
        //
        helpInverseMatrix.inverse(combineInstance.root.transform.getWorldMatrix());
        var meshAttribute = combineInstance.meshAttribute;
        var newAttribute = [];
        var tempIndexBuffers = [];
        var tempVertexBuffers = {};
        for (var key in meshAttribute) {
            tempVertexBuffers[key] = [];
            newAttribute.push(key);
        }
        //
        var startIndex = 0;
        var endIndex = 0;
        for (var _i = 0, _a = combineInstance.instances; _i < _a.length; _i++) {
            var instance = _a[_i];
            var meshFilter = instance.getComponent(egret3d.MeshFilter);
            var meshRenderer = instance.getComponent(egret3d.MeshRenderer);
            var worldMatrix = instance.transform.getWorldMatrix();
            var mesh = meshFilter.mesh;
            var primitives = mesh.glTFMesh.primitives;
            //共享一个的buffer，vbo只处理一个submesh就可以了
            var combineOnce = true;
            for (var i = 0; i < primitives.length; i++) {
                var primitive = primitives[i];
                if (combineOnce) {
                    combineOnce = false;
                    var orginVertexCount = mesh.vertexCount;
                    var orginAttributes = primitives[i].attributes;
                    var positionBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.POSITION));
                    //vertexBuffers
                    for (var j = 0; j < positionBuffer.length; j += 3) {
                        helpVec3_1.x = positionBuffer[j + 0];
                        helpVec3_1.y = positionBuffer[j + 1];
                        helpVec3_1.z = positionBuffer[j + 2];
                        //转换成世界坐标后在转换为合并节点的本地坐标
                        worldMatrix.transformVector3(helpVec3_1, helpVec3_2);
                        helpInverseMatrix.transformVector3(helpVec3_2, helpVec3_1);
                        //
                        tempVertexBuffers["POSITION" /* POSITION */].push(helpVec3_1.x, helpVec3_1.y, helpVec3_1.z);
                    }
                    //
                    if (meshAttribute["NORMAL" /* NORMAL */]) {
                        if (orginAttributes.NORMAL) {
                            var normalBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.NORMAL));
                            var target = tempVertexBuffers["NORMAL" /* NORMAL */];
                            var count = normalBuffer.length;
                            var startIndex_1 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 3) {
                                helpVec3_1.x = normalBuffer[j + 0];
                                helpVec3_1.y = normalBuffer[j + 1];
                                helpVec3_1.z = normalBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_1 + j] = helpVec3_1.x;
                                target[startIndex_1 + j + 1] = helpVec3_1.y;
                                target[startIndex_1 + j + 2] = helpVec3_1.z;
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.NORMAL, tempVertexBuffers[gltf.MeshAttributeType.NORMAL]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["NORMAL" /* NORMAL */], orginVertexCount, [0, 0, 0]);
                        }
                    }
                    if (meshAttribute["TANGENT" /* TANGENT */]) {
                        if (orginAttributes.TANGENT) {
                            var tangentBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TANGENT));
                            var target = tempVertexBuffers["TANGENT" /* TANGENT */];
                            var count = tangentBuffer.length;
                            var startIndex_2 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 4) {
                                helpVec3_1.x = tangentBuffer[j + 0];
                                helpVec3_1.y = tangentBuffer[j + 1];
                                helpVec3_1.z = tangentBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_2 + j] = helpVec3_1.x;
                                target[startIndex_2 + j + 1] = helpVec3_1.y;
                                target[startIndex_2 + j + 2] = helpVec3_1.z;
                                target[startIndex_2 + j + 3] = tangentBuffer[j + 3];
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.TANGENT, tempVertexBuffers[gltf.MeshAttributeType.TANGENT]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TANGENT" /* TANGENT */], orginVertexCount, [0, 0, 0, 1]);
                        }
                    }
                    if (meshAttribute["COLOR_0" /* COLOR_0 */]) {
                        if (orginAttributes.COLOR_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.COLOR_0, tempVertexBuffers["COLOR_0" /* COLOR_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_0" /* COLOR_0 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_0" /* TEXCOORD_0 */]) {
                        if (orginAttributes.TEXCOORD_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_0, tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */], orginVertexCount, [0, 0]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_1" /* TEXCOORD_1 */]) {
                        if (combineInstance.lightmapIndex >= 0) {
                            // //如果有lightmap,那么将被合并的uv1的坐标转换为root下的坐标,有可能uv1没有，那用uv0来算
                            // const uvBuffer = orginAttributes.TEXCOORD_1 ?
                            //     mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TEXCOORD_1)) as Float32Array :
                            //     mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TEXCOORD_0!)) as Float32Array;
                            // //
                            // for (let j = 0; j < uvBuffer.length; j += 2) {
                            //     let u = uvBuffer[j + 0];
                            //     let v = uvBuffer[j + 1];
                            //     // u = ((u * orginLightmapScaleOffset[0] + orginLightmapScaleOffset[2]) - lightmapScaleOffset[2]) / lightmapScaleOffset[0];
                            //     // v = ((v * orginLightmapScaleOffset[1] - orginLightmapScaleOffset[1] - orginLightmapScaleOffset[3]) + lightmapScaleOffset[3] + lightmapScaleOffset[1]) / lightmapScaleOffset[1];
                            //     tempVertexBuffers[gltf.MeshAttributeType.TEXCOORD_1].push(u, v);
                            // }
                            if (orginAttributes.TEXCOORD_1 !== undefined) {
                                _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_1, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                            else {
                                _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_0, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                        }
                        else {
                            if (orginAttributes.TEXCOORD_1 !== undefined) {
                                _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_1, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                            else {
                                _fillDefaultArray(tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */], orginVertexCount, [0, 0]);
                            }
                        }
                    }
                    if (meshAttribute["JOINTS_0" /* JOINTS_0 */]) {
                        if (orginAttributes.JOINTS_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.JOINTS_0, tempVertexBuffers["JOINTS_0" /* JOINTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["JOINTS_0" /* JOINTS_0 */], orginVertexCount, [0, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["WEIGHTS_0" /* WEIGHTS_0 */]) {
                        if (orginAttributes.WEIGHTS_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.WEIGHTS_0, tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */], orginVertexCount, [1, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["COLOR_1" /* COLOR_1 */]) {
                        if (orginAttributes.COLOR_1) {
                            _copyAccessorBufferArray(mesh, orginAttributes.COLOR_1, tempVertexBuffers["COLOR_1" /* COLOR_1 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_1" /* COLOR_1 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                }
                var subIndexBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(primitive.indices));
                // //indexBuffers
                if (!tempIndexBuffers[i]) {
                    tempIndexBuffers[i] = [];
                }
                for (var j = 0; j < subIndexBuffer.length; j++) {
                    var index = subIndexBuffer[j] + startIndex;
                    tempIndexBuffers[i].push(index);
                    endIndex = index > endIndex ? index : endIndex;
                }
            }
            startIndex = endIndex + 1;
            meshFilter.mesh = null;
        }
        var combineMesh = new egret3d.Mesh(combineInstance.vertexCount, combineInstance.indexBufferTotalSize, newAttribute, undefined, 35048 /* Dynamic */);
        var newVertexBuffers = combineMesh.buffers[0];
        var newIndexBuffers = combineMesh.buffers[1];
        var iv = 0;
        for (var key in tempVertexBuffers) {
            var arr = tempVertexBuffers[key];
            for (var _b = 0, arr_1 = arr; _b < arr_1.length; _b++) {
                var v = arr_1[_b];
                newVertexBuffers[iv++] = v;
            }
        }
        var ii = 0;
        for (var key in tempIndexBuffers) {
            var arr = tempIndexBuffers[key];
            for (var _c = 0, arr_2 = arr; _c < arr_2.length; _c++) {
                var v = arr_2[_c];
                newIndexBuffers[ii++] = v;
            }
        }
        var indicesCount = 0;
        for (var i = 0; i < tempIndexBuffers.length; i++) {
            var subLen = tempIndexBuffers[i].length;
            //第一个submesh在构造函数中已经添加，需要手动添加后续的
            combineMesh.addSubMesh(indicesCount, subLen, i);
            indicesCount += subLen;
        }
        return combineMesh;
    }
    function _copyAccessorBufferArray(gltf, accessor, target) {
        var buffer = gltf.createTypeArrayFromAccessor(gltf.getAccessor(accessor));
        var count = buffer.length;
        var startIndex = target.length;
        target.length += count;
        for (var i = 0; i < count; i++) {
            target[startIndex + i] = buffer[i];
        }
    }
    function _fillDefaultArray(target, count, defaultValue) {
        var startIndex = target.length;
        var defaultValueCount = defaultValue.length;
        target.length += count * defaultValueCount;
        for (var i = 0; i < count; i++) {
            for (var j = 0; j < defaultValueCount; j++) {
                target[startIndex++] = defaultValue[j];
            }
        }
    }
    var CombineInstance = (function () {
        function CombineInstance() {
            this.vertexCount = 0;
            this.vertexBufferSize = 0;
            this.indexBufferTotalSize = 0;
            this.lightmapIndex = -1;
            this.meshAttribute = {};
            this.root = null;
            this.instances = [];
        }
        return CombineInstance;
    }());
    __reflect(CombineInstance.prototype, "CombineInstance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var PerformanceType;
    (function (PerformanceType) {
        PerformanceType["All"] = "all";
    })(PerformanceType = egret3d.PerformanceType || (egret3d.PerformanceType = {}));
    /**
     * Performance
     * 数据收集
     */
    var Performance = (function () {
        function Performance() {
        }
        Performance.getEntity = function (key) {
            return this._entities[key];
        };
        Performance.getFPS = function () {
            var entity = this.getEntity("fps");
            return (entity && entity.averageDelta) ? Math.floor(1000 / entity.averageDelta) : 0;
        };
        Performance.updateFPS = function () {
            if (!this.enable) {
                return;
            }
            this.endCounter("fps");
            this.startCounter("fps", 60);
        };
        Performance._getNow = function () {
            if (window.performance) {
                return window.performance.now();
            }
            return new Date().getTime();
        };
        Performance.startCounter = function (key, averageRange) {
            if (averageRange === void 0) { averageRange = 1; }
            if (!this.enable) {
                return;
            }
            var entity = this._entities[key];
            if (!entity) {
                entity = {
                    start: 0,
                    end: 0,
                    delta: 0,
                    _cache: [],
                    averageRange: 1,
                    averageDelta: 0
                };
                this._entities[key] = entity;
            }
            entity.start = this._getNow();
            entity.averageRange = averageRange;
        };
        Performance.endCounter = function (key) {
            if (!this.enable) {
                return;
            }
            var entity = this._entities[key];
            if (entity) {
                entity.end = this._getNow();
                entity.delta = entity.end - entity.start;
                if (entity.averageRange > 1) {
                    entity._cache.push(entity.delta);
                    var length = entity._cache.length;
                    if (length >= entity.averageRange) {
                        if (length > entity.averageRange) {
                            entity._cache.shift();
                            length--;
                        }
                        var sum = 0;
                        for (var i = 0; i < length; i++) {
                            sum += entity._cache[i];
                        }
                        entity.averageDelta = sum / length;
                    }
                }
            }
        };
        Performance._entities = {};
        Performance.enable = false;
        return Performance;
    }());
    egret3d.Performance = Performance;
    __reflect(Performance.prototype, "egret3d.Performance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Profile = (function () {
        function Profile() {
        }
        Profile._getNow = function () {
            // if (window.performance) {
            //     return window.performance.now();
            // }
            // return Date.now() * 0.001;
            return new Date().getTime();
        };
        Profile._print = function (list) {
            var totalTime = 0.0;
            for (var _a = 0, list_1 = list; _a < list_1.length; _a++) {
                var item = list_1[_a];
                totalTime += item.time;
            }
            console.log("------------------------");
            for (var _b = 0, list_2 = list; _b < list_2.length; _b++) {
                var item = list_2[_b];
                console.log(item.key + ":用时" + item.time + "平均:" + (item.time / item.count) + "最大值:" + item.maxTime + " 权重:" + (Math.round(item.time / totalTime * 100)) + "%");
            }
        };
        Profile.clear = function () {
            this.profileList.keys.length = 0;
            this.profileList.values.length = 0;
        };
        Profile.startTime = function (key, group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                this.profileList.keys.push(key);
                index = this.profileList.values.length;
                this.profileList.values.push({ key: key, count: 0, startTime: 0, time: 0, group: group, maxTime: 0 });
            }
            var item = this.profileList.values[index];
            item.count++;
            item.startTime = this._getNow();
        };
        Profile.endTime = function (key) {
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                console.log("invalid key error.", this);
            }
            else {
                var item = this.profileList.values[index];
                var d = this._getNow() - item.startTime;
                item.time += d;
                item.maxTime = item.maxTime > d ? item.maxTime : d;
            }
        };
        Profile.printAll = function () {
            if (!this.debug) {
                return;
            }
            var groups = {};
            for (var _a = 0, _b = this.profileList.values; _a < _b.length; _a++) {
                var item = _b[_a];
                if (!groups[item.group]) {
                    groups[item.group] = [];
                }
                groups[item.group].push(item);
            }
            for (var key in groups) {
                this._print(groups[key]);
            }
        };
        Profile.print = function (group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var list = [];
            for (var _a = 0, _b = this.profileList.values; _a < _b.length; _a++) {
                var item = _b[_a];
                if (item.group === group) {
                    list.push(item);
                }
            }
            this._print(list);
        };
        Profile.test = function () {
            var list0 = [];
            var map = {};
            for (var i = 0; i < 1000; i++) {
                list0.push(i);
                map[i] = i;
            }
            var old = this._getNow();
            for (var _a = 0, list0_1 = list0; _a < list0_1.length; _a++) {
                var _i = list0_1[_a];
                console.log("list:");
            }
            console.log("list of用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var _i in list0) {
                console.log("list:");
            }
            console.log("list in用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var _i in map) {
                console.log("map:");
            }
            console.log("map用时:" + (this._getNow() - old));
        };
        Profile.debug = false;
        Profile.profileList = { keys: [], values: [] };
        return Profile;
    }());
    egret3d.Profile = Profile;
    __reflect(Profile.prototype, "egret3d.Profile");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 引擎启动入口
     */
    function runEgret(options) {
        if (options === void 0) { options = { antialias: false, alpha: false }; }
        console.info("Egret version:", paper.Application.version);
        console.info("Egret start.");
        // TODO
        egret.Sound = egret.web ? egret.web.HtmlSound : egret['wxgame']['HtmlSound']; //TODO:Sound
        egret.Capabilities["renderMode" + ""] = "webgl";
        var requiredOptions = getOptions(options);
        var canvas = getMainCanvas(options);
        options.option = requiredOptions;
        options.canvas = canvas;
        options.webgl = canvas.getContext('webgl', options) || canvas.getContext("experimental-webgl", options);
        paper.Application.initialize(options);
        var systemManager = paper.Application.systemManager;
        systemManager.register(egret3d.web.BeginSystem, 0 /* Begin */, options);
        systemManager.register(egret3d.AnimationSystem, 5000 /* Animation */);
        systemManager.register(egret3d.MeshRendererSystem, 7000 /* Renderer */);
        systemManager.register(egret3d.SkinnedMeshRendererSystem, 7000 /* Renderer */);
        systemManager.register(egret3d.particle.ParticleSystem, 7000 /* Renderer */);
        systemManager.register(egret3d.Egret2DRendererSystem, 7000 /* Renderer */, options);
        systemManager.register(egret3d.CameraAndLightSystem, 8000 /* Draw */);
        systemManager.register(egret3d.web.WebGLRenderSystem, 8000 /* Draw */, options);
        systemManager.register(egret3d.web.InputSystem, 10000 /* End */, options);
        systemManager.register(egret3d.web.EndSystem, 10000 /* End */, options);
        // TODO
        systemManager._preRegisterSystems();
        console.info("Egret start complete.");
    }
    egret3d.runEgret = runEgret;
    function getMainCanvas(options) {
        if (window.canvas) {
            return window.canvas;
        }
        else if (options.canvas) {
            return options.canvas;
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            var canvas = document.createElement("canvas");
            div.appendChild(canvas);
            return canvas;
        }
    }
    function getOptions(options) {
        if (window.canvas) {
            return {
                antialias: options.antialias,
                antialiasSamples: 4,
                contentWidth: options.contentWidth || 640,
                contentHeight: options.contentHeight || 1136
            };
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            return {
                antialias: options.antialias,
                antialiasSamples: 4,
                contentWidth: parseInt(div.getAttribute("data-content-width")),
                contentHeight: parseInt(div.getAttribute("data-content-height"))
            };
        }
    }
})(egret3d || (egret3d = {}));
window.paper = paper;
window.egret3d = egret3d;
var egret3d;
(function (egret3d) {
    /**
     * 几何球体。
     */
    var Sphere = (function (_super) {
        __extends(Sphere, _super);
        /**
         * 请使用 `egret3d.Sphere.create()` 创建实例。
         * @see egret3d.Sphere.create()
         */
        function Sphere() {
            var _this = _super.call(this) || this;
            /**
             * 球体半径。
             */
            _this.radius = 0.0;
            /**
             * 球体中心点。
             */
            _this.center = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个几何球体。
         * @param center 球体中心点。
         * @param radius 球体半径。
         */
        Sphere.create = function (center, radius) {
            if (center === void 0) { center = egret3d.Vector3.ZERO; }
            if (radius === void 0) { radius = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(center, radius);
                instance._released = false;
                return instance;
            }
            return new Sphere().set(center, radius);
        };
        Sphere.prototype.serialize = function () {
            return [this.center.x, this.center.y, this.center.z, this.radius];
        };
        Sphere.prototype.deserialize = function (value) {
            this.radius = value[3];
            this.center.fromArray(value);
            return this;
        };
        Sphere.prototype.clone = function () {
            return Sphere.create(this.center, this.radius);
        };
        Sphere.prototype.copy = function (value) {
            return this.set(value.center, value.radius);
        };
        Sphere.prototype.set = function (center, radius) {
            this.radius = radius;
            this.center.copy(center);
            return this;
        };
        Sphere.prototype.applyMatrix = function (matrix) {
            this.center.applyMatrix(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        };
        /**
         * 根据点集设置球体信息。
         * @param points 点集。
         * @param center 中心点。（不设置则自动计算）
         */
        Sphere.prototype.fromPoints = function (points, center) {
            if (center) {
                this.center.copy(center);
            }
            else {
                this.center.copy(egret3d.helpAABBA.fromPoints(points).center);
            }
            var maxRadiusSqrt = 0.0;
            for (var i = 0, l = points.length; i < l; i++) {
                maxRadiusSqrt = Math.max(maxRadiusSqrt, this.center.getDistance(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSqrt);
            return this;
        };
        /**
         * 是否包含指定的点或其他球体。
         * @param value 点或球体。
         */
        Sphere.prototype.contains = function (value) {
            if (value instanceof Sphere) {
                var radiusDelta = this.radius - value.radius;
                if (radiusDelta >= 0.0) {
                    this.center.getSquaredDistance(value.center) <= (radiusDelta * radiusDelta);
                }
                return false;
            }
            return this.center.getSquaredDistance(value) <= this.radius * this.radius;
        };
        /**
         * 获取一点到该球体表面的最近距离。
         * @param value 点。
         */
        Sphere.prototype.getDistance = function (value) {
            return this.center.getDistance(value) - this.radius;
        };
        /**
         *
         * @param point
         * @param out
         */
        Sphere.prototype.clampPoint = function (point, out) {
            var squaredDistance = this.center.getSquaredDistance(point);
            if (squaredDistance > (this.radius * this.radius)) {
                out.subtract(this.center, point).normalize();
                out.multiplyScalar(this.radius).add(this.center);
            }
            else {
                out.copy(point);
            }
            return out;
        };
        Sphere.prototype.raycast = function (ray, raycastInfo) {
            var v1 = egret3d.helpVector3A.subtract(this.center, ray.origin);
            var tca = v1.dot(ray.direction);
            var d2 = v1.dot(v1) - tca * tca;
            var radius2 = this.radius * this.radius;
            if (d2 > radius2)
                return false;
            var thc = Math.sqrt(radius2 - d2);
            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;
            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;
            // test to see if both t0 and t1 are behind the ray - if so, return null
            if (t0 < 0.0 && t1 < 0.0)
                return false;
            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            // else t0 is in front of the ray, so return the first collision point scaled by t0
            if (raycastInfo) {
                var normal = raycastInfo.normal;
                var position = ray.at(raycastInfo.distance = t0 < 0.0 ? t1 : t0, raycastInfo.position);
                if (normal) {
                    normal.subtract(position, this.center).normalize();
                }
            }
            return true;
        };
        Sphere._instances = [];
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Sphere.prototype, "radius", void 0);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Sphere.prototype, "center", void 0);
        return Sphere;
    }(paper.BaseRelease));
    egret3d.Sphere = Sphere;
    __reflect(Sphere.prototype, "egret3d.Sphere", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
/// <reference path="./EventDispatcher.ts" />
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 编辑器事件
         */
        var EditorEvent = (function (_super) {
            __extends(EditorEvent, _super);
            function EditorEvent(type, data) {
                return _super.call(this, type, data) || this;
            }
            EditorEvent.CHANGE_SCENE = "changeScene";
            return EditorEvent;
        }(editor.BaseEvent));
        editor.EditorEvent = EditorEvent;
        __reflect(EditorEvent.prototype, "paper.editor.EditorEvent");
        /**
         * 编辑器
         **/
        var Editor = (function () {
            function Editor() {
            }
            /**初始化 */
            Editor.init = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.eventDispatcher = new editor.EventDispatcher();
                                //覆盖生成 uuid 的方式。
                                paper.createUUID = editor.generateUuid;
                                //初始化编辑环境
                                this.initEditEnvironment();
                                //允许重新加载
                                RES.FEATURE_FLAG.FIX_DUPLICATE_LOAD = 0;
                                //初始化资源
                                return [4 /*yield*/, RES.loadConfig("resource/default.res.json", "resource/")];
                            case 1:
                                //初始化资源
                                _a.sent();
                                //初始化编辑场景
                                this.editorSceneModel = new editor.EditorSceneModel();
                                this.editorSceneModel.init();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            Object.defineProperty(Editor, "activeEditorModel", {
                /**
                 * 当前激活的编辑模型
                 */
                get: function () {
                    return this._activeEditorModel;
                },
                enumerable: true,
                configurable: true
            });
            //设置激活模型
            Editor.setActiveModel = function (model) {
                this.activeScene(model.scene);
                this._activeEditorModel = model;
                this.editorSceneModel.editorModel = model;
                this.dispatchEvent(new EditorEvent(EditorEvent.CHANGE_SCENE));
            };
            Editor.activeScene = function (scene) {
                if (paper.Application.sceneManager.activeScene) {
                    var objs_1 = paper.Application.sceneManager.activeScene.getRootGameObjects();
                    objs_1.forEach(function (obj) {
                        obj.activeSelf = false;
                    });
                }
                paper.Application.sceneManager.activeScene = scene;
                var objs = paper.Application.sceneManager.activeScene.getRootGameObjects();
                objs.forEach(function (obj) {
                    obj.activeSelf = true;
                });
            };
            /**
             * 编辑场景
             * @param sceneUrl 场景资源URL
             */
            Editor.editScene = function (sceneUrl) {
                return __awaiter(this, void 0, void 0, function () {
                    var rawScene, scene, sceneEditorModel;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.getResAsync(sceneUrl)];
                            case 1:
                                rawScene = _a.sent();
                                if (rawScene) {
                                    if (this.activeEditorModel) {
                                        this.activeEditorModel.scene.destroy();
                                    }
                                    scene = rawScene.createInstance(true);
                                    sceneEditorModel = new editor.EditorModel();
                                    sceneEditorModel.init(scene, 'scene', sceneUrl);
                                    this.setActiveModel(sceneEditorModel);
                                    this.currentEditInfo = { url: sceneUrl, type: 'scene' };
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * 编辑预置体
             * @param prefabUrl 预置体资源URL
             */
            Editor.editPrefab = function (prefabUrl) {
                return __awaiter(this, void 0, void 0, function () {
                    var prefab, scene, prefabInstance, prefabEditorModel_1, clearPrefabInfo_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.getResAsync(prefabUrl)];
                            case 1:
                                prefab = _a.sent();
                                if (prefab) {
                                    if (this.activeEditorModel) {
                                        this.activeEditorModel.scene.destroy();
                                    }
                                    scene = paper.Scene.createEmpty('prefabEditScene', false);
                                    prefabInstance = prefab.createInstance(scene, true);
                                    prefabEditorModel_1 = new editor.EditorModel();
                                    prefabEditorModel_1.init(scene, 'prefab', prefabUrl);
                                    clearPrefabInfo_1 = function (obj) {
                                        obj.extras = {};
                                        for (var _i = 0, _a = obj.components; _i < _a.length; _i++) {
                                            var comp = _a[_i];
                                            comp.extras = {};
                                        }
                                        for (var i = 0; i < obj.transform.children.length; i++) {
                                            var child = obj.transform.children[i].gameObject;
                                            if (prefabEditorModel_1.isPrefabChild(child))
                                                clearPrefabInfo_1(child);
                                        }
                                    };
                                    clearPrefabInfo_1(prefabInstance);
                                    this.setActiveModel(prefabEditorModel_1);
                                    this.currentEditInfo = { url: prefabUrl, type: 'prefab' };
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * 刷新
             */
            Editor.refresh = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (this.activeEditorModel) {
                                    this.activeEditorModel.scene.destroy();
                                }
                                //初始化资源
                                return [4 /*yield*/, RES.loadConfig("resource/default.res.json", "resource/")];
                            case 1:
                                //初始化资源
                                _a.sent();
                                if (this.currentEditInfo) {
                                    switch (this.currentEditInfo.type) {
                                        case 'scene':
                                            this.editScene(this.currentEditInfo.url);
                                            break;
                                        case 'prefab':
                                            this.editPrefab(this.currentEditInfo.url);
                                            break;
                                    }
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * 撤销
             */
            Editor.undo = function () {
                if (this.activeEditorModel)
                    this.activeEditorModel.history.back();
            };
            /**
             * 重做
             */
            Editor.redo = function () {
                if (this.activeEditorModel)
                    this.activeEditorModel.history.forward();
            };
            Editor.deserializeHistory = function (data) {
                this.activeEditorModel.history.deserialize(data);
            };
            Editor.serializeHistory = function () {
                var historyData = this.activeEditorModel.history.serialize();
                return JSON.stringify(historyData);
            };
            Editor.addEventListener = function (type, fun, thisObj, level) {
                if (level === void 0) { level = 0; }
                this.eventDispatcher.addEventListener(type, fun, thisObj, level);
            };
            Editor.removeEventListener = function (type, fun, thisObj) {
                this.eventDispatcher.removeEventListener(type, fun, thisObj);
            };
            Editor.dispatchEvent = function (event) {
                this.eventDispatcher.dispatchEvent(event);
            };
            Editor.initEditEnvironment = function () {
                egret3d.runEgret({
                    antialias: false,
                    alpha: false,
                    playerMode: 2 /* Editor */,
                });
            };
            return Editor;
        }());
        editor.Editor = Editor;
        __reflect(Editor.prototype, "paper.editor.Editor");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 已丢失或不支持的组件数据备份。
     */
    var MissingComponent = (function (_super) {
        __extends(MissingComponent, _super);
        function MissingComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 已丢失或不支持的组件数据。
             */
            _this.missingObject = null;
            return _this;
        }
        __decorate([
            paper.serializedField
        ], MissingComponent.prototype, "missingObject", void 0);
        return MissingComponent;
    }(paper.BaseComponent));
    paper.MissingComponent = MissingComponent;
    __reflect(MissingComponent.prototype, "paper.MissingComponent");
})(paper || (paper = {}));
/// <reference path="./EventDispatcher.ts" />
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.context = new editor.EventDispatcher();
        var selectItemType;
        (function (selectItemType) {
            selectItemType[selectItemType["GAMEOBJECT"] = 0] = "GAMEOBJECT";
            selectItemType[selectItemType["ASSET"] = 1] = "ASSET";
        })(selectItemType = editor.selectItemType || (editor.selectItemType = {}));
        /**
         * 编辑模型事件
         */
        var EditorModelEvent = (function (_super) {
            __extends(EditorModelEvent, _super);
            function EditorModelEvent(type, data) {
                return _super.call(this, type, data) || this;
            }
            EditorModelEvent.ADD_GAMEOBJECTS = "addGameObject";
            EditorModelEvent.DELETE_GAMEOBJECTS = "deleteGameObject";
            EditorModelEvent.SELECT_GAMEOBJECTS = "selectGame";
            EditorModelEvent.CHANGE_DIRTY = 'change_dirty';
            EditorModelEvent.CHANGE_PROPERTY = "changeProperty";
            EditorModelEvent.CHANGE_EDIT_MODE = "changeEditMode";
            EditorModelEvent.CHANGE_EDIT_TYPE = "changeEditType";
            EditorModelEvent.ADD_COMPONENT = "addComponent";
            EditorModelEvent.REMOVE_COMPONENT = "removeComponent";
            EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY = "updateGameObjectsHierarchy";
            EditorModelEvent.SAVE_ASSET = "saveAsset";
            return EditorModelEvent;
        }(editor.BaseEvent));
        editor.EditorModelEvent = EditorModelEvent;
        __reflect(EditorModelEvent.prototype, "paper.editor.EditorModelEvent");
        var ModifyObjectType;
        (function (ModifyObjectType) {
            ModifyObjectType[ModifyObjectType["GAMEOBJECT"] = 0] = "GAMEOBJECT";
            ModifyObjectType[ModifyObjectType["BASECOMPONENT"] = 1] = "BASECOMPONENT";
        })(ModifyObjectType = editor.ModifyObjectType || (editor.ModifyObjectType = {}));
        /**
         * 编辑模型
         */
        var EditorModel = (function (_super) {
            __extends(EditorModel, _super);
            function EditorModel() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._dirty = false;
                _this._cacheIds = [];
                return _this;
            }
            Object.defineProperty(EditorModel.prototype, "history", {
                get: function () {
                    return this._history;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "scene", {
                get: function () {
                    return this._scene;
                },
                set: function (value) {
                    this._scene = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "contentType", {
                get: function () {
                    return this._contentType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "contentUrl", {
                get: function () {
                    return this._contentUrl;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "dirty", {
                get: function () {
                    return this._dirty;
                },
                set: function (v) {
                    if (this._dirty !== v) {
                        this._dirty = v;
                        this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_DIRTY));
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
             * 初始化
             * @param history
             */
            EditorModel.prototype.init = function (scene, contentType, contentUrl) {
                this._history = new editor.History();
                this._scene = scene;
                this._contentType = contentType;
                this._contentUrl = contentUrl;
            };
            EditorModel.prototype.addState = function (state) {
                if (state) {
                    state.editorModel = this;
                    this.history.add(state);
                }
            };
            EditorModel.prototype.getEditType = function (propName, target) {
                var editInfoList = editor.getEditInfo(target);
                for (var index = 0; index < editInfoList.length; index++) {
                    var element = editInfoList[index];
                    if (element.name === propName) {
                        return element.editType;
                    }
                }
                return null;
            };
            EditorModel.prototype.setTransformProperty = function (propName, propOldValue, propNewValue, target) {
                var valueEditType = this.getEditType(propName, target);
                if (valueEditType !== null) {
                    var newPropertyData = {
                        propName: propName,
                        copyValue: this.serializeProperty(propNewValue, valueEditType),
                        valueEditType: valueEditType
                    };
                    var prePropertyData = {
                        propName: propName,
                        copyValue: this.serializeProperty(propOldValue, valueEditType),
                        valueEditType: valueEditType
                    };
                    this.createModifyComponent(target.gameObject.uuid, target.uuid, [newPropertyData], [prePropertyData]);
                }
            };
            EditorModel.prototype.createModifyGameObjectPropertyState = function (gameObjectUUid, newValueList, preValueCopylist) {
                var state = editor.ModifyGameObjectPropertyState.create(gameObjectUUid, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createModifyComponent = function (gameObjectUUid, componentUUid, newValueList, preValueCopylist) {
                var state = editor.ModifyComponentPropertyState.create(gameObjectUUid, componentUUid, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createPrefabState = function (prefab, parent) {
                var state = editor.CreatePrefabState.create(prefab, parent);
                this.addState(state);
            };
            EditorModel.prototype.serializeProperty = function (value, editType) {
                switch (editType) {
                    case "UINT" /* UINT */:
                    case "INT" /* INT */:
                    case "FLOAT" /* FLOAT */:
                    case "TEXT" /* TEXT */:
                    case "CHECKBOX" /* CHECKBOX */:
                        return value;
                    case "VECTOR2" /* VECTOR2 */:
                    case "VECTOR3" /* VECTOR3 */:
                    case "VECTOR4" /* VECTOR4 */:
                    case "QUATERNION" /* QUATERNION */:
                    case "COLOR" /* COLOR */:
                    case "RECT" /* RECT */:
                        var className = egret.getQualifiedClassName(value);
                        var serializeData = value.serialize(value);
                        return { className: className, serializeData: serializeData };
                    case "SHADER" /* SHADER */:
                        return value.name;
                    case "LIST" /* LIST */:
                        return value;
                    case "MATERIAL_ARRAY" /* MATERIAL_ARRAY */:
                        var data = value.map(function (item) {
                            return { name: item.name, url: item.name };
                        });
                        return data;
                    case "MESH" /* MESH */:
                        if (!value)
                            return '';
                        var url = value.name;
                        return url;
                    case "GAMEOBJECT" /* GAMEOBJECT */:
                        if (!value) {
                            return null;
                        }
                        return value.uuid;
                    case "MATERIAL" /* MATERIAL */:
                    case "TRANSFROM" /* TRANSFROM */:
                    case "SOUND" /* SOUND */:
                    case "ARRAY" /* ARRAY */:
                        //TODO
                        console.error("not supported!");
                        break;
                    default:
                        break;
                }
            };
            EditorModel.prototype.deserializeProperty = function (serializeData, editType) {
                switch (editType) {
                    case "UINT" /* UINT */:
                    case "INT" /* INT */:
                    case "FLOAT" /* FLOAT */:
                    case "TEXT" /* TEXT */:
                    case "CHECKBOX" /* CHECKBOX */:
                        return serializeData;
                    case "VECTOR2" /* VECTOR2 */:
                    case "VECTOR3" /* VECTOR3 */:
                    case "VECTOR4" /* VECTOR4 */:
                    case "QUATERNION" /* QUATERNION */:
                    case "COLOR" /* COLOR */:
                    case "RECT" /* RECT */:
                        var clazz = egret.getDefinitionByName(serializeData.className);
                        var target = null;
                        if (clazz) {
                            target = new clazz();
                            target.deserialize(serializeData.serializeData);
                        }
                        return target;
                    case "SHADER" /* SHADER */:
                        var url = serializeData;
                        var asset = paper.Asset.find(url);
                        return asset;
                    case "LIST" /* LIST */:
                        return serializeData;
                    case "MATERIAL_ARRAY" /* MATERIAL_ARRAY */:
                        var materials = [];
                        for (var _i = 0, serializeData_1 = serializeData; _i < serializeData_1.length; _i++) {
                            var matrial = serializeData_1[_i];
                            var asset_1 = paper.Asset.find(matrial.url);
                            materials.push(asset_1);
                        }
                        return materials;
                    case "MESH" /* MESH */:
                        var meshAsset = paper.Asset.find(serializeData);
                        return meshAsset;
                    case "GAMEOBJECT" /* GAMEOBJECT */:
                        if (!serializeData) {
                            return null;
                        }
                        return this.getGameObjectByUUid(serializeData);
                    case "MATERIAL" /* MATERIAL */:
                    case "TRANSFROM" /* TRANSFROM */:
                    case "SOUND" /* SOUND */:
                    case "ARRAY" /* ARRAY */:
                        //TODO
                        console.error("not supported!");
                        return null;
                    default:
                        break;
                }
            };
            EditorModel.prototype.createGameObject = function (parentList, createType, mesh) {
                if (mesh === void 0) { mesh = null; }
                var state = editor.CreateGameObjectState.create(parentList, createType, mesh);
                this.addState(state);
            };
            EditorModel.prototype.addComponent = function (gameObjectUUid, compClzName) {
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    compClzName: compClzName
                };
                var state = editor.AddComponentState.create(gameObjectUUid, compClzName);
                this.addState(state);
            };
            EditorModel.prototype.removeComponent = function (gameObjectUUid, componentUUid) {
                var obj = this.getGameObjectByUUid(gameObjectUUid);
                if (!obj) {
                    return;
                }
                var removeComponent = this.getComponentById(obj, componentUUid);
                if (!removeComponent) {
                    return;
                }
                var serializeData = paper.serialize(removeComponent);
                var state = editor.RemoveComponentState.create(gameObjectUUid, componentUUid, serializeData);
                this.addState(state);
            };
            EditorModel.prototype.getComponentById = function (gameObject, componentId) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    if (comp.uuid === componentId) {
                        return comp;
                    }
                }
                return null;
            };
            EditorModel.prototype.getComponentByAssetId = function (gameObject, assetId) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    if (comp.extras.linkedID === assetId) {
                        return comp;
                    }
                }
                return null;
            };
            /**
             * 复制游戏对象
             * @param objs
             */
            EditorModel.prototype.copyGameObject = function (objs) {
                var clipboard = __global.runtimeModule.getClipborad();
                var content = [];
                //过滤
                this.filtTopHierarchyGameObjects(objs);
                //排序
                objs = this.sortGameObjectsForHierarchy(objs);
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    content.push({
                        type: "gameObject",
                        serializeData: paper.serialize(obj)
                    });
                }
                clipboard.writeText(JSON.stringify(content), "paper");
            };
            /**
             * 粘贴游戏对象
             * @param parent
             */
            EditorModel.prototype.pasteGameObject = function (parent) {
                var clipboard = __global.runtimeModule.getClipborad();
                var msg = clipboard.readText("paper");
                var content = JSON.parse(msg);
                if (content && content.length > 0) {
                    var objData = [];
                    for (var i = 0; i < content.length; i++) {
                        objData.push(content[i].serializeData);
                    }
                    var state = editor.PasteGameObjectsState.create(objData, parent);
                    this.addState(state);
                }
            };
            /**
             * 克隆游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.duplicateGameObjects = function (gameObjects) {
                var state = editor.DuplicateGameObjectsState.create(gameObjects, this);
                this.addState(state);
            };
            /**
             * 删除游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.deleteGameObject = function (gameObjects) {
                var _this = this;
                var deleteState = editor.DeleteGameObjectsState.create(gameObjects, this);
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (_this.isPrefabChild(obj) && !_this.isPrefabRoot(obj)) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakState = editor.BreakPrefabStructState.create(breakList);
                    var stateGroup = editor.StateGroup.create([breakState, deleteState]);
                    this.addState(stateGroup);
                }
                else {
                    this.addState(deleteState);
                }
            };
            /**
             * 解除预置体联系
             * @param gameObjects
             */
            EditorModel.prototype.breakPrefab = function (gameObjects) {
                var _this = this;
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (_this.isPrefabChild(obj) || _this.isPrefabRoot(obj)) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakState = editor.BreakPrefabStructState.create(breakList);
                    this.addState(breakState);
                }
            };
            /**
             * 更改层级
             * */
            EditorModel.prototype.updateGameObjectsHierarchy = function (gameObjects, targetGameobjcet, dir) {
                var _this = this;
                var gameObjectHierarchyState = editor.GameObjectHierarchyState.create(gameObjects, targetGameobjcet, dir, this);
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (_this.isPrefabChild(obj) &&
                        !_this.isPrefabRoot(obj) &&
                        (obj.transform.parent !== targetGameobjcet.transform.parent || dir === 'inner')) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakPrefabStructState = editor.BreakPrefabStructState.create(breakList);
                    var stateGroup = editor.StateGroup.create([breakPrefabStructState, gameObjectHierarchyState]);
                    this.addState(stateGroup);
                }
                else {
                    this.addState(gameObjectHierarchyState);
                }
            };
            /**
             * 设置对象的层级
             */
            EditorModel.prototype.setGameObjectsHierarchy = function (objects, targetObject, dir) {
                objects = objects.concat();
                //剔除所有父级
                objects.forEach(function (obj) { obj.transform.parent = null; });
                objects.reverse();
                if (dir === 'inner') {
                    var index = targetObject.transform.children.length;
                    for (var i = 0; i < objects.length; i++) {
                        var obj = objects[i];
                        obj.transform.parent = targetObject.transform;
                        var transform = targetObject.transform.children.pop();
                        targetObject.transform.children.splice(index, 0, transform);
                    }
                }
                else {
                    if (targetObject.transform.parent) {
                        var index = void 0;
                        switch (dir) {
                            case 'top':
                                index = targetObject.transform.parent.children.indexOf(targetObject.transform);
                                break;
                            case 'bottom':
                                index = targetObject.transform.parent.children.indexOf(targetObject.transform) + 1;
                                break;
                        }
                        for (var i = 0; i < objects.length; i++) {
                            var obj = objects[i];
                            obj.transform.parent = targetObject.transform.parent;
                            var transform = targetObject.transform.parent.children.pop();
                            targetObject.transform.parent.children.splice(index, 0, transform);
                        }
                    }
                    else {
                        var all = this.scene.gameObjects;
                        for (var i = 0; i < objects.length; i++) {
                            all.splice(all.indexOf(objects[i]), 1);
                        }
                        var index = void 0;
                        switch (dir) {
                            case 'top':
                                index = all.indexOf(targetObject);
                                break;
                            case 'bottom':
                                index = all.indexOf(targetObject) + 1;
                                break;
                        }
                        for (var i = 0; i < objects.length; i++) {
                            var obj = objects[i];
                            all.splice(index, 0, obj);
                        }
                    }
                }
            };
            /**
             * 筛选层级中的顶层游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.filtTopHierarchyGameObjects = function (gameObjects) {
                var findParent = false;
                var parent = null;
                for (var index = gameObjects.length - 1; index >= 0; index--) {
                    var element = gameObjects[index];
                    findParent = false;
                    parent = element.transform.parent;
                    while (parent) {
                        for (var i = 0; i < gameObjects.length; i++) {
                            var element_1 = gameObjects[i];
                            if (element_1.transform === parent) {
                                gameObjects.splice(index, 1);
                                findParent = true;
                                break;
                            }
                        }
                        if (findParent) {
                            break;
                        }
                        parent = parent.parent;
                    }
                }
            };
            EditorModel.prototype.getGameObjectByUUid = function (uuid) {
                var objects = this.scene.gameObjects;
                for (var i = 0; i < objects.length; i++) {
                    if (objects[i].uuid === uuid) {
                        return objects[i];
                    }
                }
                return null;
            };
            EditorModel.prototype.getGameObjectsByUUids = function (uuids) {
                var objects = this.scene.gameObjects;
                var obj;
                var result = [];
                var idIndex;
                var cloneIds = uuids.concat();
                for (var i = 0; i < objects.length; i++) {
                    if (cloneIds.length === 0) {
                        return result;
                    }
                    obj = objects[i];
                    idIndex = cloneIds.indexOf(obj.uuid);
                    if (idIndex !== -1) {
                        result.push(obj);
                        cloneIds.splice(idIndex, 1);
                    }
                }
                return result;
            };
            EditorModel.prototype.setTargetProperty = function (propName, target, value, editType) {
                if (editType !== "VECTOR2" /* VECTOR2 */ &&
                    editType !== "VECTOR3" /* VECTOR3 */ &&
                    editType !== "VECTOR4" /* VECTOR4 */ &&
                    editType !== "COLOR" /* COLOR */) {
                    target[propName] = value;
                    return;
                }
                if (this.propertyHasGetterSetter(propName, target)) {
                    target[propName] = value;
                }
                else {
                    switch (editType) {
                        case "VECTOR2" /* VECTOR2 */:
                            var vec2 = target[propName];
                            vec2.x = value.x;
                            vec2.y = value.y;
                            break;
                        case "VECTOR3" /* VECTOR3 */:
                            var vec3 = target[propName];
                            vec3.x = value.x;
                            vec3.y = value.y;
                            vec3.z = value.z;
                            break;
                        case "VECTOR4" /* VECTOR4 */:
                            var vec4 = target[propName];
                            vec4.x = value.x;
                            vec4.y = value.y;
                            vec4.z = value.z;
                            vec4.w = value.w;
                            break;
                        case "COLOR" /* COLOR */:
                            var color = target[propName];
                            color.r = value.r;
                            color.g = value.g;
                            color.b = value.b;
                            color.a = value.a;
                            break;
                        default:
                            break;
                    }
                }
            };
            EditorModel.prototype.propertyHasGetterSetter = function (propName, target) {
                var prototype = Object.getPrototypeOf(target);
                var descriptror;
                while (prototype) {
                    descriptror = Object.getOwnPropertyDescriptor(prototype, propName);
                    if (descriptror && descriptror.get && descriptror.set) {
                        return true;
                    }
                    prototype = Object.getPrototypeOf(prototype);
                }
                return false;
            };
            /**
             * 选择游戏对象
             *  */
            EditorModel.prototype.selectGameObject = function (objs) {
                this.currentSelected = objs;
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.SELECT_GAMEOBJECTS, objs));
            };
            /**
             * 切换编辑模式
             */
            EditorModel.prototype.changeEditMode = function (mode) {
                this.currentEditMode = mode;
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_EDIT_MODE, mode));
            };
            /**
             * 切换编辑类型
             */
            EditorModel.prototype.changeEditType = function (type) {
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_EDIT_TYPE, type));
            };
            EditorModel.prototype.isPrefabRoot = function (gameObj) {
                if (gameObj.extras.prefab) {
                    return true;
                }
                return false;
            };
            EditorModel.prototype.isPrefabChild = function (gameObj) {
                if (gameObj.extras.rootID) {
                    return true;
                }
                return false;
            };
            /**将对象按照层级进行排序
             */
            EditorModel.prototype.sortGameObjectsForHierarchy = function (gameobjects) {
                var _this = this;
                gameobjects = gameobjects.concat();
                if (gameobjects.length < 2) {
                    return gameobjects;
                }
                //生成每个对象的显示索引路径列表
                var displayPathList = [];
                gameobjects.forEach(function (obj) {
                    var result = [];
                    var currentObj = obj;
                    while (currentObj.transform.parent) {
                        result.unshift(currentObj.transform.parent.children.indexOf(currentObj.transform));
                        currentObj = currentObj.transform.parent.gameObject;
                    }
                    //追加一个根部索引
                    result.unshift(_this.scene.gameObjects.indexOf(currentObj));
                    displayPathList.push({ gameObject: obj, path: result });
                });
                function getPath(gameObject) {
                    for (var i_1 = 0; i_1 < displayPathList.length; i_1++) {
                        if (displayPathList[i_1].gameObject === gameObject) {
                            return displayPathList[i_1].path;
                        }
                    }
                }
                var length = gameobjects.length - 1;
                while (length > 0) {
                    for (var i = 0; i < length; i++) {
                        var A = getPath(gameobjects[i]);
                        var B = getPath(gameobjects[i + 1]);
                        var needChangeIndex = false;
                        var minLength = Math.min(A.length, B.length);
                        var k = 0;
                        b: for (k; k < minLength; k++) {
                            if (A[k] === B[k]) {
                                continue;
                            }
                            else if (A[k] > B[k]) {
                                needChangeIndex = true;
                                break b;
                            }
                            else if (A[k] < B[k]) {
                                needChangeIndex = false;
                                break b;
                            }
                        }
                        if (k === minLength && !needChangeIndex && A.length > B.length) {
                            needChangeIndex = true;
                        }
                        if (needChangeIndex) {
                            var tmpv = gameobjects[i];
                            gameobjects[i] = gameobjects[i + 1];
                            gameobjects[i + 1] = tmpv;
                        }
                    }
                    length--;
                }
                return gameobjects;
            };
            EditorModel.prototype.createApplyPrefabState = function (applyData, applyPrefabInstanceId, prefab) {
                var state = editor.ApplyPrefabInstanceState.create(applyData, applyPrefabInstanceId, prefab);
                this.addState(state);
            };
            EditorModel.prototype.createRevertPrefabState = function (revertData, revertPrefabInstanceId) {
                var state = editor.RevertPrefabInstanceState.create(revertData, revertPrefabInstanceId);
                this.addState(state);
            };
            EditorModel.prototype.deepClone = function (obj) {
                var _this = this;
                if (!obj || typeof obj !== 'object') {
                    return obj;
                }
                if (obj instanceof RegExp) {
                    return obj;
                }
                var result = Array.isArray(obj) ? [] : {};
                Object.keys(obj).forEach(function (key) {
                    if (obj[key] && typeof obj[key] === 'object') {
                        result[key] = _this.deepClone(obj[key]);
                    }
                    else {
                        result[key] = obj[key];
                    }
                });
                return result;
            };
            EditorModel.prototype.updateAsset = function (asset, prefabInstance) {
                if (prefabInstance === void 0) { prefabInstance = null; }
                var refs = this.findAssetRefs(this.scene, asset);
                var serializeData;
                if (asset instanceof paper.Prefab) {
                    serializeData = paper.serialize(prefabInstance);
                }
                else {
                }
                //save asset
                //destory asset,getRes
                //update refrence (paper.assets[])
                this._cacheIds.length = 0;
            };
            EditorModel.prototype.findAssetRefs = function (target, as, refs) {
                if (refs === void 0) { refs = null; }
                if (this._cacheIds.indexOf(target.uuid) >= 0) {
                    return;
                }
                this._cacheIds.push(target.uuid);
                refs = refs || [];
                for (var key in target) {
                    var source = target[key];
                    if ((typeof source) === "object") {
                        this.findFromChildren(source, as, refs, target, key);
                    }
                }
                return refs;
            };
            EditorModel.prototype.findFromChildren = function (source, as, refs, parent, key) {
                if ((typeof source) !== "object") {
                    return;
                }
                if (Array.isArray(source) || ArrayBuffer.isView(source)) {
                    for (var index = 0; index < source.length; index++) {
                        var element = source[index];
                        this.findFromChildren(element, as, refs, source, index);
                    }
                }
                if (source.constructor === Object) {
                    for (var key_1 in source) {
                        var element = source[key_1];
                        this.findFromChildren(element, as, refs, source, key_1);
                    }
                }
                if (source instanceof paper.BaseObject) {
                    if (source instanceof paper.Asset && source === as) {
                        refs.push({ p: parent, k: key });
                        return;
                    }
                    this.findAssetRefs(source, as, refs);
                }
            };
            EditorModel.prototype.getAllGameObjectsFromPrefabInstance = function (gameObj, objs) {
                if (objs === void 0) { objs = null; }
                if (gameObj) {
                    objs = objs || [];
                    if (gameObj.extras.linkedID) {
                        objs.push(gameObj);
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.getAllGameObjectsFromPrefabInstance(obj, objs);
                    }
                }
                return objs;
            };
            EditorModel.prototype.modifyMaterialPropertyValues = function (target, valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _i, valueList_1, propertyValue, propName, copyValue, uniformType, _glTFMaterial, gltfUnifromMap, uniformMap, key, value;
                    return __generator(this, function (_a) {
                        for (_i = 0, valueList_1 = valueList; _i < valueList_1.length; _i++) {
                            propertyValue = valueList_1[_i];
                            propName = propertyValue.propName, copyValue = propertyValue.copyValue, uniformType = propertyValue.uniformType;
                            if (!copyValue) {
                                continue;
                            }
                            switch (uniformType) {
                                case 35670 /* BOOL */:
                                    target.setBoolean(propName, copyValue);
                                    break;
                                case 5124 /* INT */:
                                    target.setInt(propName, copyValue);
                                case 5126 /* FLOAT */:
                                    target.setFloat(propName, copyValue);
                                    break;
                                case 35671 /* BOOL_VEC2 */:
                                case 35667 /* INT_VEC2 */:
                                case 35664 /* FLOAT_VEC2 */:
                                    target.setVector2v(propName, copyValue);
                                    break;
                                case 35672 /* BOOL_VEC3 */:
                                case 35668 /* INT_VEC3 */:
                                case 35665 /* FLOAT_VEC3 */:
                                    target.setVector3v(propName, copyValue);
                                    break;
                                case 35673 /* BOOL_VEC4 */:
                                case 35669 /* INT_VEC4 */:
                                case 35666 /* FLOAT_VEC4 */:
                                    target.setVector4v(propName, copyValue);
                                    break;
                                case 35678 /* SAMPLER_2D */:
                                    target._glTFTechnique.uniforms[propName].value = copyValue;
                                    break;
                                case 35674 /* FLOAT_MAT2 */:
                                case 35675 /* FLOAT_MAT3 */:
                                case 35676 /* FLOAT_MAT4 */:
                                    target.setMatrixv(propName, copyValue);
                                    break;
                                default:
                                    break;
                            }
                            if (propName === "renderQueue") {
                                target.config.materials[0].extensions.paper.renderQueue = copyValue;
                            }
                            this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_PROPERTY, { target: target, propName: propName, propValue: copyValue }));
                        }
                        _glTFMaterial = target.config.materials[0];
                        gltfUnifromMap = _glTFMaterial.extensions.KHR_techniques_webgl.values;
                        uniformMap = target._glTFTechnique.uniforms;
                        for (key in uniformMap) {
                            if (uniformMap[key].semantic === undefined) {
                                value = uniformMap[key].value;
                                if (Array.isArray(value)) {
                                    gltfUnifromMap[key] = value.concat();
                                }
                                else if (value instanceof egret3d.GLTexture2D) {
                                    gltfUnifromMap[key] = value.name;
                                }
                                else {
                                    gltfUnifromMap[key] = value;
                                }
                            }
                        }
                        return [2 /*return*/];
                    });
                });
            };
            return EditorModel;
        }(editor.EventDispatcher));
        editor.EditorModel = EditorModel;
        __reflect(EditorModel.prototype, "paper.editor.EditorModel");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var EditorSceneModel = (function () {
            function EditorSceneModel() {
                this.viewCache = {};
            }
            Object.defineProperty(EditorSceneModel.prototype, "editorScene", {
                get: function () {
                    return paper.Application.sceneManager.editorScene;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorSceneModel.prototype, "editorModel", {
                set: function (v) {
                    if (this.currentModel) {
                        this.viewCache[this.currentModel.contentUrl] = {
                            position: this.cameraObject.transform.getPosition().clone(),
                            rotation: this.cameraObject.transform.getRotation().clone()
                        };
                    }
                    // this.pickGameScript.clearSelected();
                    // this.geoController.clearSelected();//TODO:应在controller里新增清空状态函数
                    // this.editorCameraScript.editorModel = v;
                    // this.pickGameScript.editorModel = v;
                    // this.geoController.editorModel = v;
                    this.currentModel = v;
                    if (v && this.viewCache[v.contentUrl]) {
                        this.cameraObject.transform.setPosition(this.viewCache[v.contentUrl].position);
                        this.cameraObject.transform.setRotation(this.viewCache[v.contentUrl].rotation);
                    }
                    else {
                        this.cameraObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                        this.cameraObject.transform.lookAt(egret3d.Vector3.ZERO);
                    }
                },
                enumerable: true,
                configurable: true
            });
            EditorSceneModel.prototype.init = function () {
                this.cameraObject = egret3d.Camera.editor.gameObject;
                // this.cameraObject = GameObject.create("EditorCamera", DefaultTags.EditorOnly, Application.sceneManager.editorScene);
                var camera = this.cameraObject.getOrAddComponent(egret3d.Camera);
                camera.near = 0.1;
                camera.far = 500.0;
                camera.backgroundColor.set(0.13, 0.28, 0.51, 1.00);
                this.cameraObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                this.cameraObject.transform.lookAt(egret3d.Vector3.ZERO);
                paper.GameObject.globalGameObject.sendMessage("bootstrap");
                // this.editorCameraScript = this.cameraObject.addComponent(EditorCameraScript);
                // this.editorCameraScript.moveSpeed = 10;
                // this.editorCameraScript.rotateSpeed = 0.5;
                // this.pickGameScript = this.cameraObject.addComponent(PickGameObjectScript);
                // this.geoController = this.cameraObject.addComponent(Controller)
            };
            return EditorSceneModel;
        }());
        editor.EditorSceneModel = EditorSceneModel;
        __reflect(EditorSceneModel.prototype, "paper.editor.EditorSceneModel");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.EventType = {
            HistoryState: "HistoryState",
            HistoryAdd: "HistoryAdd",
            HistoryFree: "HistoryFree"
        };
        var History = (function () {
            function History() {
                this.dispatcher = null;
                this._locked = 0;
                this._index = -1;
                this._batchIndex = 0;
                this._states = [];
                this._batchStates = [];
                this._events = [];
            }
            History.prototype._free = function () {
                if (this._states.length > this._index + 1) {
                    this._states.length = this._index + 1; // TODO release.
                    if (this.dispatcher) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryFree, null));
                    }
                }
            };
            History.prototype._doState = function (state, isUndo) {
                if (isUndo) {
                    state.undo();
                }
                else {
                    state.redo();
                }
                var d = isUndo ? "undo" : "redo";
                if (this.dispatcher) {
                    var data = { isUndo: isUndo };
                    this._events.push(data);
                }
                return state.batchIndex > 0 && (isUndo ? this._index >= 0 : this._index < this._states.length - 1);
            };
            History.prototype.back = function () {
                if (this._index < 0 || this._batchIndex > 0) {
                    return false;
                }
                this._locked |= 1;
                while (this._doState(this._states[this._index--], true)) {
                }
                if (this.dispatcher && this._events.length > 0) {
                    for (var _i = 0, _a = this._events; _i < _a.length; _i++) {
                        var event_4 = _a[_i];
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryState, event_4));
                    }
                    this._events.length = 0;
                }
                this._locked &= 2;
                return true;
            };
            History.prototype.forward = function () {
                if (this._index >= this._states.length - 1 || this._batchIndex > 0) {
                    return false;
                }
                this._locked |= 1;
                while (this._doState(this._states[++this._index], false)) {
                }
                if (this.dispatcher && this._events.length > 0) {
                    for (var _i = 0, _a = this._events; _i < _a.length; _i++) {
                        var event_5 = _a[_i];
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryState, event_5));
                    }
                    this._events.length = 0;
                }
                this._locked &= 2;
                return true;
            };
            History.prototype.go = function (index) {
                if (this._batchIndex > 0) {
                    return false;
                }
                var result = false;
                if (this._index < index) {
                    while (this._index !== index && this.forward()) {
                        result = true;
                    }
                }
                else {
                    while (this._index !== index && this.back()) {
                        result = true;
                    }
                }
                return result;
            };
            History.prototype.add = function (state) {
                if (this._locked !== 0) {
                    return;
                }
                if (this._batchIndex > 0) {
                    state.batchIndex = this._batchIndex;
                    this._batchStates.push(state);
                }
                else {
                    this._states[this._index + 1] = state;
                    if (this.dispatcher !== null) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryAdd, event));
                    }
                    this.forward();
                    this._free();
                }
            };
            History.prototype.beginBatch = function () {
                this._batchIndex++;
            };
            History.prototype.endBatch = function () {
                if (this._batchIndex === 0) {
                    return;
                }
                this._batchIndex--;
                if (this._batchIndex === 0) {
                    var index = this._index + 1;
                    for (var _i = 0, _a = this._batchStates; _i < _a.length; _i++) {
                        var state = _a[_i];
                        this._states[index++] = state;
                    }
                    if (this.dispatcher !== null) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryAdd, event));
                    }
                    this._batchStates.length = 0;
                    this.go(this._states.length - 1);
                }
            };
            History.prototype.getState = function (index) {
                return this._states[index];
            };
            Object.defineProperty(History.prototype, "enabled", {
                get: function () {
                    return this._locked === 0;
                },
                set: function (value) {
                    if (value) {
                        this._locked &= 1;
                    }
                    else {
                        this._locked |= 2;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "count", {
                get: function () {
                    return this._states.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "index", {
                get: function () {
                    return this._index;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "batchIndex", {
                get: function () {
                    return this._batchIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "locked", {
                get: function () {
                    return this._locked;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "states", {
                get: function () {
                    return this._states;
                },
                enumerable: true,
                configurable: true
            });
            History.prototype.serialize = function () {
                var states = this.states;
                var statesData = [];
                for (var index = 0; index < states.length; index++) {
                    var element = states[index];
                    var className = egret.getQualifiedClassName(element);
                    var data = {
                        className: className,
                        batchIndex: element.batchIndex,
                        data: element.hasOwnProperty('deserialize') ? element['serialize']() : element.data,
                        autoClear: element.autoClear,
                        isDone: element.isDone,
                    };
                    statesData.push(data);
                }
                var serializeHistory = {
                    index: this.index,
                    batchIndex: this.batchIndex,
                    locked: this.locked,
                    statesData: statesData,
                };
                return serializeHistory;
            };
            History.prototype.deserialize = function (serializeHistory) {
                var states = [];
                var statesData = serializeHistory.statesData;
                for (var index = 0; index < statesData.length; index++) {
                    var element = statesData[index];
                    var clazz = egret.getDefinitionByName(element.className);
                    var state = void 0;
                    if (clazz) {
                        state = new clazz();
                        state.batchIndex = element.batchIndex;
                        state.data = element.hasOwnProperty('deserialize') ? element['deserialize'](element.data) : element.data;
                        state.autoClear = element.autoClear;
                        state.isDone = element.isDone;
                        states.push(state);
                    }
                }
                var initData = {
                    states: states,
                    index: serializeHistory.index,
                    batchIndex: serializeHistory.batchIndex,
                    locked: serializeHistory.locked,
                };
                this._index = initData ? initData.index : -1;
                this._locked = initData ? initData.locked : 0;
                this._batchIndex = initData ? initData.batchIndex : 0;
                this._states = initData ? initData.states : [];
            };
            return History;
        }());
        editor.History = History;
        __reflect(History.prototype, "paper.editor.History");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 脚本组件。
     * - 生命周期的顺序。
     * - onAwake();
     * - onReset();
     * - onEnable();
     * - onStart();
     * - onFixedUpdate();
     * - onUpdate();
     * - onLateUpdate();
     * - onDisable();
     * - onDestroy();
     */
    var Behaviour = (function (_super) {
        __extends(Behaviour, _super);
        function Behaviour() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._isReseted = false;
            /**
             * @internal
             */
            _this._isStarted = false;
            return _this;
        }
        /**
         * @internal
         */
        Behaviour.prototype._dispatchEnabledEvent = function (value) {
            _super.prototype._dispatchEnabledEvent.call(this, value);
            if (value) {
                Behaviour.onComponentEnabled.dispatch(this);
            }
            else {
                Behaviour.onComponentDisabled.dispatch(this);
            }
        };
        /**
         * @internal
         */
        Behaviour.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this, config);
            if (paper.Application.playerMode !== 2 /* Editor */ || this.constructor.executeInEditMode) {
                this.onAwake && this.onAwake(config);
            }
        };
        /**
         * @internal
         */
        Behaviour.prototype.uninitialize = function () {
            if (paper.Application.playerMode !== 2 /* Editor */ || this.constructor.executeInEditMode) {
                this.onDestroy && this.onDestroy(); // TODO onDestroy 如果不是 enabled 就不派发
            }
            _super.prototype.uninitialize.call(this);
        };
        return Behaviour;
    }(paper.BaseComponent));
    paper.Behaviour = Behaviour;
    __reflect(Behaviour.prototype, "paper.Behaviour");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 状态组
         * @author 杨宁
         */
        var StateGroup = (function (_super) {
            __extends(StateGroup, _super);
            function StateGroup() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            StateGroup.create = function (stateList) {
                var instance = new StateGroup();
                instance.stateList = stateList;
                return instance;
            };
            StateGroup.prototype.redo = function () {
                for (var i = 0; i < this.stateList.length; i++) {
                    this.stateList[i].redo();
                }
                return true;
            };
            StateGroup.prototype.undo = function () {
                for (var i = this.stateList.length - 1; i >= 0; i--) {
                    this.stateList[i].undo();
                }
                return true;
            };
            StateGroup.prototype.serialize = function () {
                var states = this.stateList;
                var statesData = [];
                for (var index = 0; index < states.length; index++) {
                    var element = states[index];
                    var className = egret.getQualifiedClassName(element);
                    var data = {
                        className: className,
                        batchIndex: element.batchIndex,
                        data: element['serialize'] ? element['serialize']() : element.data,
                        autoClear: element.autoClear,
                        isDone: element.isDone,
                    };
                    statesData.push(data);
                }
                return states;
            };
            StateGroup.prototype.deserialize = function (data) {
                this.stateList = [];
                var statesData = data;
                for (var index = 0; index < statesData.length; index++) {
                    var element = statesData[index];
                    var clazz = egret.getDefinitionByName(element.className);
                    var state = null;
                    if (clazz) {
                        state = new clazz();
                        state.batchIndex = element.batchIndex;
                        state.data = element['deserialize'] ? element['deserialize'](element.data) : element.data;
                        state.autoClear = element.autoClear;
                        state.isDone = element.isDone;
                        this.stateList.push(state);
                    }
                }
            };
            return StateGroup;
        }(editor.BaseState));
        editor.StateGroup = StateGroup;
        __reflect(StateGroup.prototype, "paper.editor.StateGroup");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ModifyGameObjectPropertyState = (function (_super) {
            __extends(ModifyGameObjectPropertyState, _super);
            function ModifyGameObjectPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyGameObjectPropertyState.create = function (gameObjectUUid, newValueList, preValueCopylist) {
                var state = new ModifyGameObjectPropertyState();
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(ModifyGameObjectPropertyState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ModifyGameObjectPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    this.modifyProperty(this.stateData.preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyGameObjectPropertyState.prototype.modifyProperty = function (valueList) {
                var _this = this;
                var uuid = this.stateData.gameObjectUUid;
                var modifyObj = this.editorModel.getGameObjectByUUid(uuid);
                if (modifyObj !== null) {
                    valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                        var propName, copyValue, valueEditType, newValue;
                        return __generator(this, function (_a) {
                            propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                            newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                            this.editorModel.setTargetProperty(propName, modifyObj, newValue, valueEditType);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
                            return [2 /*return*/];
                        });
                    }); });
                }
            };
            ModifyGameObjectPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.modifyProperty(this.stateData.newValueList);
                    return true;
                }
                return false;
            };
            return ModifyGameObjectPropertyState;
        }(editor.BaseState));
        editor.ModifyGameObjectPropertyState = ModifyGameObjectPropertyState;
        __reflect(ModifyGameObjectPropertyState.prototype, "paper.editor.ModifyGameObjectPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //修改组件属性属性
        var ModifyComponentPropertyState = (function (_super) {
            __extends(ModifyComponentPropertyState, _super);
            function ModifyComponentPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyComponentPropertyState.toString = function () {
                return "[class common.ModifyComponentPropertyState]";
            };
            ModifyComponentPropertyState.create = function (gameObjUUid, componentUUid, newValueList, preValueCopylist) {
                var state = new ModifyComponentPropertyState();
                var data = {
                    gameObjUUid: gameObjUUid,
                    componentUUid: componentUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(ModifyComponentPropertyState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ModifyComponentPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    this.modifyProperty(this.stateData.preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyComponentPropertyState.prototype.modifyProperty = function (valueList) {
                var _this = this;
                var gameObjectUUid = this.stateData.gameObjUUid;
                var componentUUid = this.stateData.componentUUid;
                var gameObj = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                var modifyObj;
                if (gameObj) {
                    modifyObj = this.editorModel.getComponentById(gameObj, componentUUid);
                    if (modifyObj) {
                        valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                            var propName, copyValue, valueEditType, newValue;
                            return __generator(this, function (_a) {
                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                                this.editorModel.setTargetProperty(propName, modifyObj, newValue, valueEditType);
                                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
                                return [2 /*return*/];
                            });
                        }); });
                    }
                }
            };
            ModifyComponentPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.modifyProperty(this.stateData.newValueList);
                    return true;
                }
                return false;
            };
            return ModifyComponentPropertyState;
        }(editor.BaseState));
        editor.ModifyComponentPropertyState = ModifyComponentPropertyState;
        __reflect(ModifyComponentPropertyState.prototype, "paper.editor.ModifyComponentPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //创建游戏对象
        var CreateGameObjectState = (function (_super) {
            __extends(CreateGameObjectState, _super);
            function CreateGameObjectState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.isFirst = true;
                return _this;
            }
            CreateGameObjectState.toString = function () {
                return "[class common.AddGameObjectState]";
            };
            CreateGameObjectState.create = function (parentList, createType, mesh) {
                var infos = parentList.map(function (obj) { return { parentUUID: obj.uuid, serializeData: null }; });
                var state = new CreateGameObjectState();
                state.infos = infos;
                state.createType = createType;
                state.mesh = mesh;
                return state;
            };
            CreateGameObjectState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = this.editorModel.getGameObjectsByUUids(this.addList);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            CreateGameObjectState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    //一条信息都没有则添加到场景根
                    if (this.infos.length === 0) {
                        this.infos.push({ parentUUID: null, serializeData: null });
                    }
                    for (var i = 0; i < this.infos.length; i++) {
                        var obj = void 0;
                        if (this.isFirst) {
                            obj = this.createGameObjectByType(this.createType);
                            this.infos[i].serializeData = paper.serialize(obj);
                        }
                        else {
                            obj = new paper.Deserializer().deserialize(this.infos[i].serializeData, true, false, this.editorModel.scene);
                        }
                        var parent_3 = this.editorModel.getGameObjectByUUid(this.infos[i].parentUUID);
                        if (parent_3)
                            obj.transform.parent = parent_3.transform;
                        this.addList.push(obj.uuid);
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    this.isFirst = false;
                    return true;
                }
                return false;
            };
            CreateGameObjectState.prototype.createGameObjectByType = function (createType) {
                var obj = new paper.GameObject();
                var meshFilter;
                obj.name = createType.toLowerCase();
                if (this.mesh) {
                    meshFilter = obj.addComponent(egret3d.MeshFilter);
                    meshFilter.mesh = this.mesh;
                    obj.addComponent(egret3d.MeshRenderer);
                }
                return obj;
            };
            return CreateGameObjectState;
        }(editor.BaseState));
        editor.CreateGameObjectState = CreateGameObjectState;
        __reflect(CreateGameObjectState.prototype, "paper.editor.CreateGameObjectState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //删除游戏对象
        var DeleteGameObjectsState = (function (_super) {
            __extends(DeleteGameObjectsState, _super);
            function DeleteGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            DeleteGameObjectsState.toString = function () {
                return "[class common.deleteGameObjectsState]";
            };
            DeleteGameObjectsState.create = function (gameObjects, editorModel) {
                gameObjects = gameObjects.concat();
                //筛选
                editorModel.filtTopHierarchyGameObjects(gameObjects);
                //排序
                gameObjects = editorModel.sortGameObjectsForHierarchy(gameObjects);
                var infos = [];
                for (var i = 0; i < gameObjects.length; i++) {
                    var obj = gameObjects[i];
                    var oldParentUUID = void 0;
                    var oldIndex = void 0;
                    var serializeData = paper.serialize(obj);
                    if (obj.transform.parent) {
                        oldParentUUID = obj.transform.parent.gameObject.uuid;
                        oldIndex = obj.transform.parent.children.indexOf(obj.transform);
                    }
                    else {
                        oldParentUUID = undefined;
                        oldIndex = editorModel.scene.gameObjects.indexOf(obj);
                    }
                    infos.push({ UUID: obj.uuid, oldParentUUID: oldParentUUID, oldIndex: oldIndex, serializeData: serializeData });
                }
                var state = new DeleteGameObjectsState();
                state.deleteInfo = infos;
                return state;
            };
            DeleteGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    for (var i = 0; i < this.deleteInfo.length; i++) {
                        var info = this.deleteInfo[i];
                        var obj = new paper.Deserializer().deserialize(info.serializeData, true, false, this.editorModel.scene);
                        var oldParentObj = this.editorModel.getGameObjectByUUid(info.oldParentUUID);
                        if (oldParentObj) {
                            var oldTargetTransform = oldParentObj.transform.children[info.oldIndex];
                            if (oldTargetTransform) {
                                this.editorModel.setGameObjectsHierarchy([obj], oldTargetTransform.gameObject, 'top');
                            }
                            else {
                                this.editorModel.setGameObjectsHierarchy([obj], oldParentObj, 'inner');
                            }
                        }
                        else {
                            obj.transform.parent = null;
                            var all = this.editorModel.scene.gameObjects;
                            var currentIndex = all.indexOf(obj);
                            all.splice(currentIndex, 1);
                            all.splice(info.oldIndex, 0, obj);
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.deleteInfo.map(function (info) { return info.UUID; }));
                    return true;
                }
                return false;
            };
            DeleteGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var ids = this.deleteInfo.map(function (info) { return info.UUID; });
                    var objs = this.editorModel.getGameObjectsByUUids(ids);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, ids);
                    return true;
                }
                return false;
            };
            DeleteGameObjectsState.prototype.serialize = function () {
                return this.deleteInfo;
            };
            DeleteGameObjectsState.prototype.deserialize = function (data) {
                this.deleteInfo = data;
            };
            return DeleteGameObjectsState;
        }(editor.BaseState));
        editor.DeleteGameObjectsState = DeleteGameObjectsState;
        __reflect(DeleteGameObjectsState.prototype, "paper.editor.DeleteGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //克隆游戏对象
        var DuplicateGameObjectsState = (function (_super) {
            __extends(DuplicateGameObjectsState, _super);
            function DuplicateGameObjectsState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.firstDo = true;
                return _this;
            }
            DuplicateGameObjectsState.toString = function () {
                return "[class common.DuplicateGameObjectsState]";
            };
            DuplicateGameObjectsState.create = function (objs, editorModel) {
                //过滤
                editorModel.filtTopHierarchyGameObjects(objs);
                //排序
                objs = editorModel.sortGameObjectsForHierarchy(objs);
                var duplicateInfo = [];
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    var UUID = obj.uuid;
                    var parentUUID = obj.transform.parent ? obj.transform.parent.gameObject.uuid : null;
                    var serializeData = paper.serialize(obj);
                    duplicateInfo.push({ UUID: UUID, parentUUID: parentUUID, serializeData: serializeData });
                }
                var state = new DuplicateGameObjectsState();
                state.duplicateInfo = duplicateInfo;
                return state;
            };
            DuplicateGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = this.editorModel.getGameObjectsByUUids(this.addList);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            DuplicateGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    for (var i = 0; i < this.duplicateInfo.length; i++) {
                        var info = this.duplicateInfo[i];
                        var obj = new paper.Deserializer().deserialize(info.serializeData, !this.firstDo, false, this.editorModel.scene);
                        var parent_4 = this.editorModel.getGameObjectByUUid(info.parentUUID);
                        if (parent_4) {
                            obj.transform.parent = parent_4.transform;
                        }
                        //清理预置体信息
                        this.clearPrefabInfo(obj);
                        this.addList.push(obj.uuid);
                        if (this.firstDo) {
                            info.serializeData = paper.serialize(obj);
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    this.firstDo = false;
                    return true;
                }
                return false;
            };
            DuplicateGameObjectsState.prototype.clearPrefabInfo = function (obj) {
                if (this.editorModel.isPrefabChild(obj)) {
                    obj.extras.linkedID = undefined;
                    obj.extras.prefab = undefined;
                    obj.extras.rootID = undefined;
                    for (var i = 0; i < obj.transform.children.length; i++) {
                        this.clearPrefabInfo(obj.transform.children[i].gameObject);
                    }
                }
            };
            DuplicateGameObjectsState.prototype.serialize = function () {
                return { duplicateInfo: this.duplicateInfo, addList: this.addList };
            };
            DuplicateGameObjectsState.prototype.deserialize = function (data) {
                this.duplicateInfo = data.duplicateInfo;
                this.addList = data.addList;
            };
            return DuplicateGameObjectsState;
        }(editor.BaseState));
        editor.DuplicateGameObjectsState = DuplicateGameObjectsState;
        __reflect(DuplicateGameObjectsState.prototype, "paper.editor.DuplicateGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //粘贴游戏对象
        var PasteGameObjectsState = (function (_super) {
            __extends(PasteGameObjectsState, _super);
            function PasteGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            PasteGameObjectsState.toString = function () {
                return "[class common.PasteGameObjectsState]";
            };
            PasteGameObjectsState.create = function (serializeData, parent) {
                var state = new PasteGameObjectsState();
                var parentUUID = parent ? parent.uuid : null;
                state.pasteInfo = { parentUUID: parentUUID, serializeData: serializeData };
                return state;
            };
            PasteGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = this.editorModel.getGameObjectsByUUids(this.addList);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            PasteGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    var parent_5 = this.editorModel.getGameObjectByUUid(this.pasteInfo.parentUUID);
                    var serializeDataList = this.cacheSerializeData ? this.cacheSerializeData : this.pasteInfo.serializeData;
                    var keepUID = this.cacheSerializeData ? true : false;
                    for (var i = 0; i < serializeDataList.length; i++) {
                        var info = serializeDataList[i];
                        var obj = new paper.Deserializer().deserialize(info, keepUID, false, this.editorModel.scene);
                        if (obj && parent_5) {
                            obj.transform.parent = parent_5.transform;
                        }
                        //清理预置体信息
                        this.clearPrefabInfo(obj);
                        this.addList.push(obj.uuid);
                        if (serializeDataList === this.pasteInfo.serializeData) {
                            if (!this.cacheSerializeData)
                                this.cacheSerializeData = [];
                            this.cacheSerializeData.push(paper.serialize(obj));
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            PasteGameObjectsState.prototype.clearPrefabInfo = function (obj) {
                if (this.editorModel.isPrefabChild(obj)) {
                    obj.extras.linkedID = undefined;
                    obj.extras.prefab = undefined;
                    obj.extras.rootID = undefined;
                    for (var i = 0; i < obj.transform.children.length; i++) {
                        this.clearPrefabInfo(obj.transform.children[i].gameObject);
                    }
                }
            };
            PasteGameObjectsState.prototype.serialize = function () {
                return { pasteInfo: this.pasteInfo, addList: this.addList };
            };
            PasteGameObjectsState.prototype.deserialize = function (data) {
                this.addList = data.addList;
                this.pasteInfo = data.pasteInfo;
            };
            return PasteGameObjectsState;
        }(editor.BaseState));
        editor.PasteGameObjectsState = PasteGameObjectsState;
        __reflect(PasteGameObjectsState.prototype, "paper.editor.PasteGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //添加组件
        var AddComponentState = (function (_super) {
            __extends(AddComponentState, _super);
            function AddComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AddComponentState.toString = function () {
                return "[class common.AddComponentState]";
            };
            AddComponentState.create = function (gameObjectUUid, compClzName) {
                var state = new AddComponentState();
                var data = { gameObjectUUid: gameObjectUUid, compClzName: compClzName };
                state.data = data;
                return state;
            };
            Object.defineProperty(AddComponentState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            AddComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var gameObjectUUid = this.stateData.gameObjectUUid;
                    var componentId = this.stateData.cacheComponentId;
                    var gameObject = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObject) {
                        var component = this.editorModel.getComponentById(gameObject, componentId);
                        if (component) {
                            gameObject.removeComponent(component);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                        }
                    }
                    return true;
                }
                return false;
            };
            AddComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUid = this.stateData.gameObjectUUid;
                    var compClzName = this.stateData.compClzName;
                    var gameObject = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObject) {
                        if (this.stateData.serializeData) {
                            new paper.Deserializer().deserialize(this.data.serializeData, true, false, gameObject);
                        }
                        else {
                            var compClz = egret.getDefinitionByName(compClzName);
                            var addComponent = gameObject.addComponent(compClz);
                            this.stateData.serializeData = paper.serialize(addComponent);
                            this.stateData.cacheComponentId = addComponent.uuid;
                        }
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                    }
                    return true;
                }
                return false;
            };
            return AddComponentState;
        }(editor.BaseState));
        editor.AddComponentState = AddComponentState;
        __reflect(AddComponentState.prototype, "paper.editor.AddComponentState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //移除组件
        var RemoveComponentState = (function (_super) {
            __extends(RemoveComponentState, _super);
            function RemoveComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RemoveComponentState.toString = function () {
                return "[class common.RemoveComponentState]";
            };
            RemoveComponentState.create = function (gameObjectUUid, componentUUid, cacheSerializeData) {
                var state = new RemoveComponentState();
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    componentUUid: componentUUid,
                    cacheSerializeData: cacheSerializeData
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(RemoveComponentState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            RemoveComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var gameObject = this.editorModel.getGameObjectByUUid(this.stateData.gameObjectUUid);
                    if (gameObject) {
                        new paper.Deserializer().deserialize(this.stateData.cacheSerializeData, true, false, gameObject);
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                    }
                    return true;
                }
                return false;
            };
            RemoveComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUid = this.stateData.gameObjectUUid;
                    var componentUUid = this.stateData.componentUUid;
                    var obj = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (obj) {
                        var component = this.editorModel.getComponentById(obj, componentUUid);
                        if (component) {
                            obj.removeComponent(component);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                        }
                    }
                    return true;
                }
                return false;
            };
            return RemoveComponentState;
        }(editor.BaseState));
        editor.RemoveComponentState = RemoveComponentState;
        __reflect(RemoveComponentState.prototype, "paper.editor.RemoveComponentState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 游戏对象层级
         * @author 杨宁
         */
        var GameObjectHierarchyState = (function (_super) {
            __extends(GameObjectHierarchyState, _super);
            function GameObjectHierarchyState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.gameObjectsInfo = [];
                return _this;
            }
            GameObjectHierarchyState.create = function (gameObjects, targetGameObj, dir, editorModel) {
                //筛选
                gameObjects = gameObjects.concat();
                editorModel.filtTopHierarchyGameObjects(gameObjects);
                //必须进行层级排序
                var objs = editorModel.sortGameObjectsForHierarchy(gameObjects);
                //整理对象信息
                var objInfos = [];
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    var oldTargetUUID = void 0;
                    var oldDir = void 0;
                    if (obj.transform.parent) {
                        var index = obj.transform.parent.children.indexOf(obj.transform);
                        if (++index < obj.transform.parent.children.length) {
                            oldTargetUUID = obj.transform.parent.children[index].gameObject.uuid;
                            oldDir = 'top';
                        }
                        else {
                            oldTargetUUID = obj.transform.parent.gameObject.uuid;
                            oldDir = 'inner';
                        }
                    }
                    else {
                        var all = editorModel.scene.gameObjects;
                        var index = all.indexOf(obj);
                        if (++index < all.length) {
                            oldTargetUUID = all[index].uuid;
                            oldDir = 'top';
                        }
                        else {
                            oldTargetUUID = 'scene'; //特殊标记，用来标记最外层最后一个
                            oldDir = 'inner';
                        }
                    }
                    objInfos.push({ UUID: obj.uuid, oldTargetUUID: oldTargetUUID, oldDir: oldDir });
                }
                var instance = new GameObjectHierarchyState();
                instance.gameObjectsInfo = objInfos;
                instance.targetDir = dir;
                instance.targetObject = targetGameObj.uuid;
                return instance;
            };
            GameObjectHierarchyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var tmpList = this.gameObjectsInfo.concat();
                    tmpList.reverse();
                    for (var index = 0; index < tmpList.length; index++) {
                        var info = tmpList[index];
                        var obj = this.editorModel.getGameObjectByUUid(info.UUID);
                        var oldTarget = this.editorModel.getGameObjectByUUid(info.oldTargetUUID);
                        var oldDir = info.oldDir;
                        if (info.oldTargetUUID === 'scene') {
                            var all = this.editorModel.scene.gameObjects;
                            oldTarget = all[all.length - 1];
                            oldDir = 'bottom';
                        }
                        this.editorModel.setGameObjectsHierarchy([obj], oldTarget, oldDir);
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                    return true;
                }
                return false;
            };
            GameObjectHierarchyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUids = this.gameObjectsInfo.map(function (v) { return v.UUID; });
                    var gameObjs = this.editorModel.getGameObjectsByUUids(gameObjectUUids);
                    var targetGameObj = this.editorModel.getGameObjectByUUid(this.targetObject);
                    gameObjs = this.editorModel.sortGameObjectsForHierarchy(gameObjs);
                    this.editorModel.setGameObjectsHierarchy(gameObjs, targetGameObj, this.targetDir);
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                    return true;
                }
                return false;
            };
            return GameObjectHierarchyState;
        }(editor.BaseState));
        editor.GameObjectHierarchyState = GameObjectHierarchyState;
        __reflect(GameObjectHierarchyState.prototype, "paper.editor.GameObjectHierarchyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var CreatePrefabState = (function (_super) {
            __extends(CreatePrefabState, _super);
            function CreatePrefabState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            CreatePrefabState.toString = function () {
                return "[class common.CreatePrefabState]";
            };
            CreatePrefabState.create = function (prefab, parent) {
                var state = new CreatePrefabState();
                var parentUUID = parent ? parent.uuid : undefined;
                var data = {
                    prefab: prefab,
                    parentUUID: parentUUID
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(CreatePrefabState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            CreatePrefabState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var deleteUUid = this.stateData.cachePrefabUUid;
                    if (deleteUUid) {
                        var gameObj = this.editorModel.getGameObjectByUUid(deleteUUid);
                        if (gameObj) {
                            gameObj.destroy();
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, [deleteUUid]);
                        }
                    }
                    return true;
                }
                return false;
            };
            CreatePrefabState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var prefab = this.stateData.prefab;
                    if (prefab) {
                        var instance = this.stateData.prefab.createInstance(this.editorModel.scene);
                        this.stateData.cachePrefabUUid = instance.uuid;
                        var parent_6 = this.editorModel.getGameObjectByUUid(this.stateData.parentUUID);
                        if (parent_6) {
                            instance.transform.parent = parent_6.transform;
                        }
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS);
                    }
                    return true;
                }
                return false;
            };
            return CreatePrefabState;
        }(editor.BaseState));
        editor.CreatePrefabState = CreatePrefabState;
        __reflect(CreatePrefabState.prototype, "paper.editor.CreatePrefabState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 预置体结构状态
         * @author 杨宁
         */
        var BreakPrefabStructState = (function (_super) {
            __extends(BreakPrefabStructState, _super);
            function BreakPrefabStructState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.prefabInfos = [];
                return _this;
            }
            BreakPrefabStructState.create = function (prefabInstanceList) {
                var _this = this;
                var instance = new BreakPrefabStructState();
                instance.prefabInfos = [];
                prefabInstanceList.forEach(function (obj) {
                    for (var _i = 0, _a = instance.prefabInfos; _i < _a.length; _i++) {
                        var info = _a[_i];
                        if (info.uuid === obj.uuid)
                            return;
                    }
                    instance.prefabInfos = instance.prefabInfos.concat(_this.makePrefabInfo(obj));
                });
                return instance;
            };
            BreakPrefabStructState.makePrefabInfo = function (gameOjbect) {
                var isPrefabRoot = function (gameObj) {
                    if (gameObj.extras.prefab) {
                        return true;
                    }
                    return false;
                };
                var isPrefabChild = function (gameObj) {
                    if (gameObj.extras.rootID) {
                        return true;
                    }
                    return false;
                };
                var makeInfo = function (target, result) {
                    if (result === void 0) { result = []; }
                    result.push({ uuid: target.uuid, linkid: target.extras.linkedID, rootid: target.extras.rootID, prefab: target.extras.prefab.name });
                    target.transform.children.forEach(function (transform) {
                        var obj = transform.gameObject;
                        if (isPrefabChild(obj) && !isPrefabRoot(obj)) {
                            makeInfo(obj, result);
                        }
                    });
                };
                var target = gameOjbect;
                var infos = [];
                while (target) {
                    if (isPrefabRoot(target)) {
                        makeInfo(target, infos);
                        break;
                    }
                    if (target.transform.parent)
                        target = target.transform.parent.gameObject;
                    else
                        break;
                }
                return infos;
            };
            BreakPrefabStructState.prototype.redo = function () {
                var _this = this;
                var ids = this.prefabInfos.map(function (prefabInfos) { return prefabInfos.uuid; });
                var objs = this.editorModel.getGameObjectsByUUids(ids);
                objs.forEach(function (obj) {
                    obj.extras.linkedID = undefined;
                    obj.extras.prefab = undefined;
                    obj.extras.rootID = undefined;
                    _this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: obj, propName: 'prefab', propValue: null });
                });
                return true;
            };
            BreakPrefabStructState.prototype.undo = function () {
                var all = this.editorModel.scene.gameObjects;
                for (var i = 0; i < all.length; i++) {
                    var obj = all[i];
                    b: for (var k = 0; k < this.prefabInfos.length; k++) {
                        var info = this.prefabInfos[k];
                        if (obj.uuid === info.uuid) {
                            obj.extras.linkedID = info.linkid;
                            obj.extras.prefab = paper.Asset.find(info.prefab);
                            obj.extras.rootID = info.rootid;
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: obj, propName: 'prefab', propValue: obj.extras.prefab });
                            break b;
                        }
                    }
                }
                return true;
            };
            BreakPrefabStructState.prototype.serialize = function () {
                return this.prefabInfos;
            };
            BreakPrefabStructState.prototype.deserialize = function (data) {
                this.prefabInfos = data;
            };
            return BreakPrefabStructState;
        }(editor.BaseState));
        editor.BreakPrefabStructState = BreakPrefabStructState;
        __reflect(BreakPrefabStructState.prototype, "paper.editor.BreakPrefabStructState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ApplyPrefabInstanceState = (function (_super) {
            __extends(ApplyPrefabInstanceState, _super);
            function ApplyPrefabInstanceState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.firstRedo = true;
                return _this;
            }
            ApplyPrefabInstanceState.toString = function () {
                return "[class common.ApplyPrefabInstanceState]";
            };
            ApplyPrefabInstanceState.create = function (applyData, applyPrefabRootId, prefab) {
                var state = new ApplyPrefabInstanceState();
                var cachePrefabSerializedData = editor.Editor.activeEditorModel.deepClone(prefab._raw);
                var data = {
                    applyPrefabRootId: applyPrefabRootId,
                    prefab: prefab,
                    applyData: applyData,
                    cachePrefabSerializedData: cachePrefabSerializedData
                };
                data.cacheGameObjetsIds = [];
                data.cacheComponentsIds = {};
                state.data = data;
                return state;
            };
            Object.defineProperty(ApplyPrefabInstanceState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ApplyPrefabInstanceState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var applyGameObject = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.applyPrefabRootId);
                    var objects = this.editorModel.scene.gameObjects;
                    for (var index = objects.length - 1; index >= 0; index--) {
                        if (this.stateData.cacheGameObjetsIds.length === 0 && Object.keys(this.stateData.cacheComponentsIds).length === 0) {
                            break;
                        }
                        var gameObj = objects[index];
                        var gIndex = this.stateData.cacheGameObjetsIds.indexOf(gameObj.uuid);
                        if (gIndex >= 0) {
                            gameObj.destroy();
                            this.stateData.cacheGameObjetsIds.splice(gIndex, 1);
                        }
                        else if (this.stateData.cacheComponentsIds[gameObj.uuid] && this.stateData.cacheComponentsIds[gameObj.uuid].length > 0) {
                            var comIds = this.stateData.cacheComponentsIds[gameObj.uuid];
                            for (var comIndex = gameObj.components.length - 1; comIndex >= 0; comIndex--) {
                                var com = gameObj.components[comIndex];
                                var cIndex = comIds.indexOf(com.uuid);
                                if (cIndex >= 0) {
                                    gameObj.removeComponent(com);
                                    comIds.splice(cIndex, 1);
                                    if (comIds.length === 0) {
                                        delete this.stateData.cacheComponentsIds[gameObj.uuid];
                                    }
                                }
                            }
                        }
                    }
                    var tempPrefabObject = this.stateData.prefab.createInstance(paper.Application.sceneManager.globalScene, true);
                    for (var linkedId in this.stateData.applyData) {
                        var applyData = this.stateData.applyData[linkedId];
                        if (applyData.addGameObjects && applyData.addGameObjects.length > 0) {
                            for (var index = 0; index < applyData.addGameObjects.length; index++) {
                                var obj = applyData.addGameObjects[index];
                                var originalObj = this.getGameObjectByUUid(applyGameObject, obj.id);
                                if (originalObj) {
                                    this.clearLinkedId(originalObj);
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                        }
                        if (applyData.addComponents && applyData.addComponents.length > 0) {
                            for (var index = 0; index < applyData.addComponents.length; index++) {
                                var element = applyData.addComponents[index];
                                var id = element.id, gameObjId = element.gameObjId;
                                var originalObj = this.getGameObjectByUUid(applyGameObject, gameObjId);
                                if (originalObj) {
                                    var originalComponent = editor.Editor.activeEditorModel.getComponentById(originalObj, id);
                                    if (originalComponent) {
                                        originalComponent.extras = {};
                                    }
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                        }
                        if (applyData.modifyGameObjectPropertyList && applyData.modifyGameObjectPropertyList.length > 0) {
                            for (var _i = 0, _a = applyData.modifyGameObjectPropertyList; _i < _a.length; _i++) {
                                var obj = _a[_i];
                                this.modifyPrefabGameObjectPropertyValues(linkedId, tempPrefabObject, obj.preValueCopylist);
                            }
                        }
                        if (applyData.modifyComponentPropertyList && applyData.modifyComponentPropertyList.length > 0) {
                            for (var _b = 0, _c = applyData.modifyComponentPropertyList; _b < _c.length; _b++) {
                                var obj = _c[_b];
                                this.modifyPrefabComponentPropertyValues(linkedId, obj.componentId, tempPrefabObject, obj.preValueCopylist);
                            }
                        }
                    }
                    //reset prefab serrializedata,save prefab
                    // (this.stateData.prefab as any)._raw = this.stateData.cachePrefabSerializedData;
                    var prefabJson = this.stateData.cachePrefabSerializedData;
                    this.stateData.prefab._raw = prefabJson;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.SAVE_ASSET, { name: this.stateData.prefab.name, raw: prefabJson });
                    tempPrefabObject.destroy();
                    tempPrefabObject = null;
                    return true;
                }
                return false;
            };
            ApplyPrefabInstanceState.prototype.getAllUUidFromGameObject = function (gameObj, uuids) {
                if (uuids === void 0) { uuids = null; }
                if (gameObj) {
                    uuids = uuids || [];
                    uuids.push(gameObj.uuid);
                    for (var _i = 0, _a = gameObj.components; _i < _a.length; _i++) {
                        var com = _a[_i];
                        uuids.push(com.uuid);
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.getAllUUidFromGameObject(obj, uuids);
                    }
                }
                return uuids;
            };
            ApplyPrefabInstanceState.prototype.setLinkedId = function (gameObj, ids) {
                if (gameObj) {
                    var linkedId = ids.shift();
                    if (linkedId === undefined) {
                        console.error("linkedId error");
                    }
                    gameObj.extras.linkedID = linkedId;
                    for (var _i = 0, _a = gameObj.components; _i < _a.length; _i++) {
                        var com = _a[_i];
                        linkedId = ids.shift();
                        if (linkedId === undefined) {
                            console.error("linkedId error");
                        }
                        com.extras.linkedID = linkedId;
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        if (obj.hideFlags === 3 /* HideAndDontSave */) {
                            continue;
                        }
                        this.setLinkedId(obj, ids);
                    }
                }
            };
            ApplyPrefabInstanceState.prototype.clearLinkedId = function (gameObj) {
                if (gameObj) {
                    gameObj.extras = {};
                    for (var index = 0; index < gameObj.components.length; index++) {
                        var element = gameObj.components[index];
                        element.extras = {};
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.clearLinkedId(obj);
                    }
                }
            };
            ApplyPrefabInstanceState.prototype.dispathPropertyEvent = function (modifyObj, propName, newValue) {
                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
            };
            ApplyPrefabInstanceState.prototype.modifyPrefabGameObjectPropertyValues = function (linkedId, tempObj, valueList) {
                var _this = this;
                var prefabObj = this.getGameObjectByLinkedId(tempObj, linkedId);
                var objects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                valueList.forEach(function (propertyValue) {
                    var propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                    var newValue = _this.editorModel.deserializeProperty(copyValue, valueEditType);
                    objects.forEach(function (object) {
                        if (paper.equal(object[propName], prefabObj[propName])) {
                            _this.editorModel.setTargetProperty(propName, object, newValue, valueEditType);
                            _this.dispathPropertyEvent(object, propName, newValue);
                        }
                    });
                    _this.editorModel.setTargetProperty(propName, prefabObj, newValue, valueEditType);
                });
                this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
            };
            ApplyPrefabInstanceState.prototype.modifyPrefabComponentPropertyValues = function (linkedId, componentUUid, tempObj, valueList) {
                var _this = this;
                var prefabObj = this.getGameObjectByLinkedId(tempObj, linkedId);
                var objects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                var _loop_1 = function (k) {
                    var prefabComp = prefabObj.components[k];
                    if (prefabComp.uuid === componentUUid) {
                        valueList.forEach(function (propertyValue) {
                            var propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                            var newValue = _this.editorModel.deserializeProperty(copyValue, valueEditType);
                            objects.forEach(function (object) {
                                var objectComp = _this.editorModel.getComponentByAssetId(object, prefabComp.extras.linkedID);
                                if (objectComp !== null) {
                                    if (paper.equal(objectComp[propName], prefabComp[propName])) {
                                        _this.editorModel.setTargetProperty(propName, objectComp, newValue, valueEditType);
                                        _this.dispathPropertyEvent(objectComp, propName, newValue);
                                    }
                                }
                            });
                            _this.editorModel.setTargetProperty(propName, prefabComp, newValue, valueEditType);
                        });
                    }
                };
                for (var k = 0; k < prefabObj.components.length; k++) {
                    _loop_1(k);
                }
            };
            ApplyPrefabInstanceState.prototype.setGameObjectPrefabRootId = function (gameObj, rootID) {
                if (gameObj.extras.prefab === undefined) {
                    gameObj.extras.rootID = rootID;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.setGameObjectPrefabRootId(obj, rootID);
                }
            };
            ApplyPrefabInstanceState.prototype.getGameObjectsByLinkedId = function (linkedId, filterApplyRootId) {
                var objects = this.editorModel.scene.gameObjects;
                var result = [];
                for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
                    var obj = objects_1[_i];
                    if ((obj.extras && obj.extras.linkedID && obj.extras.linkedID === linkedId) && (obj.extras.prefab || (obj.extras.rootID && obj.extras.rootID !== filterApplyRootId)) && obj.uuid !== filterApplyRootId) {
                        result.push(obj);
                    }
                }
                return result;
            };
            ApplyPrefabInstanceState.prototype.getGameObjectByLinkedId = function (gameObj, linkedID) {
                if (!gameObj) {
                    return null;
                }
                var result;
                if (gameObj.extras.linkedID === linkedID) {
                    result = gameObj;
                    return gameObj;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    result = this.getGameObjectByLinkedId(obj, linkedID);
                    if (result) {
                        break;
                    }
                }
                return result;
            };
            ApplyPrefabInstanceState.prototype.getGameObjectByUUid = function (gameObj, uuid) {
                if (!gameObj) {
                    return null;
                }
                var result;
                if (gameObj.uuid === uuid) {
                    result = gameObj;
                    return gameObj;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    result = this.getGameObjectByUUid(obj, uuid);
                    if (result) {
                        break;
                    }
                }
                return result;
            };
            ApplyPrefabInstanceState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var tempPrefabObject = this.stateData.prefab.createInstance(paper.Application.sceneManager.globalScene, true);
                    var tempGameObjects = editor.Editor.activeEditorModel.getAllGameObjectsFromPrefabInstance(tempPrefabObject);
                    var applyGameObject = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.applyPrefabRootId);
                    for (var _i = 0, _a = tempGameObjects; _i < _a.length; _i++) {
                        var gameObj = _a[_i];
                        if (!(this.stateData.applyData[gameObj.extras.linkedID])) {
                            continue;
                        }
                        var applyData = this.stateData.applyData[gameObj.extras.linkedID];
                        if (applyData.addGameObjects && applyData.addGameObjects.length > 0) {
                            for (var index = 0; index < applyData.addGameObjects.length; index++) {
                                var obj = applyData.addGameObjects[index];
                                var ids = [];
                                var newObj = void 0;
                                if (this.firstRedo) {
                                    newObj = new paper.Deserializer().deserialize(obj.serializeData, false, false, paper.Application.sceneManager.globalScene);
                                    newObj.parent = gameObj;
                                    ids = this.getAllUUidFromGameObject(newObj);
                                    obj.cacheSerializeData = Object.create(null);
                                    obj.cacheSerializeData[gameObj.uuid] = [];
                                    obj.cacheSerializeData[gameObj.uuid][index] = paper.serialize(newObj);
                                }
                                else {
                                    var cacheData = obj.cacheSerializeData[gameObj.uuid][index];
                                    newObj = new paper.Deserializer().deserialize(cacheData, true, false, paper.Application.sceneManager.globalScene);
                                    newObj.parent = gameObj;
                                    ids = this.getAllUUidFromGameObject(newObj);
                                }
                                var linkedId = gameObj.extras.linkedID;
                                var instanceGameObjects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                                for (var _b = 0, instanceGameObjects_1 = instanceGameObjects; _b < instanceGameObjects_1.length; _b++) {
                                    var instanceGameObject = instanceGameObjects_1[_b];
                                    var addObj = void 0;
                                    if (this.firstRedo) {
                                        addObj = new paper.Deserializer().deserialize(obj.serializeData, false, false, this.editorModel.scene);
                                        addObj.parent = instanceGameObject;
                                        var rootId = instanceGameObject.extras.prefab ? instanceGameObject.uuid : instanceGameObject.extras.rootID;
                                        this.setGameObjectPrefabRootId(addObj, rootId);
                                        this.setLinkedId(addObj, ids.concat());
                                        obj.cacheSerializeData[instanceGameObject.uuid] = [];
                                        obj.cacheSerializeData[instanceGameObject.uuid][index] = this.clearExtrasFromSerilizeData(paper.serialize(addObj));
                                    }
                                    else {
                                        var cacheData = obj.cacheSerializeData[instanceGameObject.uuid][index];
                                        addObj = new paper.Deserializer().deserialize(cacheData, true, false, this.editorModel.scene);
                                        addObj.parent = instanceGameObject;
                                        var rootId = instanceGameObject.extras.prefab ? instanceGameObject.uuid : instanceGameObject.extras.rootID;
                                        this.setGameObjectPrefabRootId(addObj, rootId);
                                        this.setLinkedId(addObj, ids.concat());
                                    }
                                    if (addObj) {
                                        this.stateData.cacheGameObjetsIds.push(addObj.uuid);
                                    }
                                }
                                var originalGameObj = this.getGameObjectByUUid(applyGameObject, obj.id);
                                if (originalGameObj) {
                                    this.setGameObjectPrefabRootId(originalGameObj, this.stateData.applyPrefabRootId);
                                    this.setLinkedId(originalGameObj, ids.concat());
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS);
                        }
                        if (applyData.addComponents && applyData.addComponents.length > 0) {
                            for (var _c = 0, _d = applyData.addComponents; _c < _d.length; _c++) {
                                var obj = _d[_c];
                                var newComponent = void 0;
                                if (this.firstRedo) {
                                    newComponent = new paper.Deserializer().deserialize(obj.serializeData, false, false, gameObj);
                                    obj.cacheSerializeData = Object.create(null);
                                    obj.cacheSerializeData[gameObj.uuid] = paper.serialize(newComponent);
                                }
                                else {
                                    var cacheData = obj.cacheSerializeData[gameObj.uuid];
                                    newComponent = new paper.Deserializer().deserialize(cacheData, true, false, gameObj);
                                }
                                var linkedId = gameObj.extras.linkedID;
                                var instanceGameObjects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                                for (var _e = 0, instanceGameObjects_2 = instanceGameObjects; _e < instanceGameObjects_2.length; _e++) {
                                    var instanceGameObject = instanceGameObjects_2[_e];
                                    var addComponent = void 0;
                                    if (this.firstRedo) {
                                        addComponent = new paper.Deserializer().deserialize(obj.serializeData, false, false, instanceGameObject);
                                        addComponent.extras.linkedID = newComponent.uuid;
                                        obj.cacheSerializeData[instanceGameObject.uuid] = this.clearExtrasFromSerilizeData(paper.serialize(addComponent));
                                    }
                                    else {
                                        var cacheData = obj.cacheSerializeData[instanceGameObject.uuid];
                                        addComponent = new paper.Deserializer().deserialize(cacheData, true, false, instanceGameObject);
                                        addComponent.extras.linkedID = newComponent.uuid;
                                    }
                                    this.stateData.cacheComponentsIds[instanceGameObject.uuid] = this.stateData.cacheComponentsIds[instanceGameObject.uuid] || [];
                                    if (addComponent) {
                                        this.stateData.cacheComponentsIds[instanceGameObject.uuid].push(addComponent.uuid);
                                    }
                                }
                                var originalGameObj = this.getGameObjectByUUid(applyGameObject, obj.gameObjId);
                                if (originalGameObj) {
                                    var originalComponent = editor.Editor.activeEditorModel.getComponentById(originalGameObj, obj.id);
                                    originalComponent.extras.linkedID = newComponent.uuid;
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                        }
                        if (applyData.modifyGameObjectPropertyList && applyData.modifyGameObjectPropertyList.length > 0) {
                            for (var _f = 0, _g = applyData.modifyGameObjectPropertyList; _f < _g.length; _f++) {
                                var obj = _g[_f];
                                this.modifyPrefabGameObjectPropertyValues(gameObj.extras.linkedID, tempPrefabObject, obj.newValueList);
                            }
                        }
                        if (applyData.modifyComponentPropertyList && applyData.modifyComponentPropertyList.length > 0) {
                            for (var _h = 0, _j = applyData.modifyComponentPropertyList; _h < _j.length; _h++) {
                                var obj = _j[_h];
                                this.modifyPrefabComponentPropertyValues(gameObj.extras.linkedID, obj.componentId, tempPrefabObject, obj.newValueList);
                            }
                        }
                    }
                    this.clearGameObjectExtrasInfo(tempPrefabObject);
                    // (this.stateData.prefab as any)._raw = this.clearExtrasFromSerilizeData(paper.serialize(tempPrefabObject));
                    var prefabJson = this.clearExtrasFromSerilizeData(paper.serialize(tempPrefabObject));
                    this.stateData.prefab._raw = prefabJson;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.SAVE_ASSET, { name: this.stateData.prefab.name, raw: prefabJson });
                    tempPrefabObject.destroy();
                    this.firstRedo = false;
                    return true;
                }
                return false;
            };
            ApplyPrefabInstanceState.prototype.clearGameObjectExtrasInfo = function (gameObj) {
                if (gameObj) {
                    delete gameObj.extras;
                    for (var _i = 0, _a = gameObj.components; _i < _a.length; _i++) {
                        var comp = _a[_i];
                        delete comp.extras;
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.clearGameObjectExtrasInfo(obj);
                    }
                }
            };
            ApplyPrefabInstanceState.prototype.clearExtrasFromSerilizeData = function (data) {
                var objects = data.objects;
                var components = data.components;
                for (var _i = 0, objects_2 = objects; _i < objects_2.length; _i++) {
                    var obj = objects_2[_i];
                    delete obj["extras"];
                }
                for (var _a = 0, components_6 = components; _a < components_6.length; _a++) {
                    var comp = components_6[_a];
                    delete comp["extras"];
                }
                return data;
            };
            return ApplyPrefabInstanceState;
        }(editor.BaseState));
        editor.ApplyPrefabInstanceState = ApplyPrefabInstanceState;
        __reflect(ApplyPrefabInstanceState.prototype, "paper.editor.ApplyPrefabInstanceState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var RevertPrefabInstanceState = (function (_super) {
            __extends(RevertPrefabInstanceState, _super);
            function RevertPrefabInstanceState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RevertPrefabInstanceState.toString = function () {
                return "[class common.RevertPrefabInstanceState]";
            };
            RevertPrefabInstanceState.create = function (revertData, revertPrefabRootId) {
                var state = new RevertPrefabInstanceState();
                var data = { revertData: revertData, revertPrefabRootId: revertPrefabRootId };
                state.data = data;
                return state;
            };
            Object.defineProperty(RevertPrefabInstanceState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            RevertPrefabInstanceState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var revertRoot = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.revertPrefabRootId);
                    var gameObjects = editor.Editor.activeEditorModel.getAllGameObjectsFromPrefabInstance(revertRoot);
                    var removeGameObjIds = [];
                    for (var _i = 0, gameObjects_3 = gameObjects; _i < gameObjects_3.length; _i++) {
                        var gameObj = gameObjects_3[_i];
                        if (!(this.stateData.revertData[gameObj.extras.linkedID])) {
                            continue;
                        }
                        var revertData = this.stateData.revertData[gameObj.extras.linkedID];
                        if (revertData.revertGameObjects && revertData.revertGameObjects.length > 0) {
                            for (var _a = 0, _b = revertData.revertGameObjects; _a < _b.length; _a++) {
                                var obj = _b[_a];
                                var serializeData = obj.serializeData;
                                var newObj = new paper.Deserializer().deserialize(serializeData, true, false, this.editorModel.scene);
                                newObj.parent = gameObj;
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS);
                        }
                        if (revertData.revertComponents && revertData.revertComponents.length > 0) {
                            for (var _c = 0, _d = revertData.revertComponents; _c < _d.length; _c++) {
                                var com = _d[_c];
                                var serializeData = com.serializeData;
                                new paper.Deserializer().deserialize(serializeData, true, false, gameObj);
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                        }
                        if (revertData.modifyGameObjectPropertyList && revertData.modifyGameObjectPropertyList.length > 0) {
                            for (var _e = 0, _f = revertData.modifyGameObjectPropertyList; _e < _f.length; _e++) {
                                var obj = _f[_e];
                                var preValueCopylist = obj.newValueList;
                                this.modifyPrefabGameObjectPropertyValues(gameObj, preValueCopylist);
                            }
                        }
                        if (revertData.modifyComponentPropertyList && revertData.modifyComponentPropertyList.length > 0) {
                            for (var _g = 0, _h = revertData.modifyComponentPropertyList; _g < _h.length; _g++) {
                                var obj = _h[_g];
                                var componentId = obj.componentId, preValueCopylist = obj.preValueCopylist;
                                this.modifyPrefabComponentPropertyValues(gameObj, componentId, preValueCopylist);
                            }
                        }
                    }
                    return true;
                }
                return false;
            };
            RevertPrefabInstanceState.prototype.dispathPropertyEvent = function (modifyObj, propName, newValue) {
                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
            };
            RevertPrefabInstanceState.prototype.modifyPrefabGameObjectPropertyValues = function (gameObj, valueList) {
                var _this = this;
                valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                    var propName, copyValue, valueEditType, newValue;
                    return __generator(this, function (_a) {
                        propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                        newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                        this.editorModel.setTargetProperty(propName, gameObj, newValue, valueEditType);
                        this.dispathPropertyEvent(gameObj, propName, newValue);
                        return [2 /*return*/];
                    });
                }); });
            };
            RevertPrefabInstanceState.prototype.modifyPrefabComponentPropertyValues = function (gameObj, componentUUid, valueList) {
                var _this = this;
                var _loop_2 = function (k) {
                    var prefabComp = gameObj.components[k];
                    if (prefabComp.uuid === componentUUid) {
                        valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                            var propName, copyValue, valueEditType, newValue;
                            return __generator(this, function (_a) {
                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                                this.editorModel.setTargetProperty(propName, prefabComp, newValue, valueEditType);
                                this.dispathPropertyEvent(prefabComp, propName, newValue);
                                return [2 /*return*/];
                            });
                        }); });
                    }
                };
                for (var k = 0; k < gameObj.components.length; k++) {
                    _loop_2(k);
                }
            };
            RevertPrefabInstanceState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var revertRoot = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.revertPrefabRootId);
                    var gameObjects = editor.Editor.activeEditorModel.getAllGameObjectsFromPrefabInstance(revertRoot);
                    var removeGameObjIds_1 = [];
                    var _loop_3 = function (gameObj) {
                        if (!(this_1.stateData.revertData[gameObj.extras.linkedID])) {
                            return "continue";
                        }
                        var revertData = this_1.stateData.revertData[gameObj.extras.linkedID];
                        if (revertData.revertGameObjects && revertData.revertGameObjects.length > 0) {
                            revertData.revertGameObjects.forEach(function (element) {
                                removeGameObjIds_1.push(element.id);
                            });
                        }
                        if (revertData.revertComponents && revertData.revertComponents.length > 0) {
                            var revertComponentIds_1 = [];
                            revertData.revertComponents.forEach(function (element) {
                                revertComponentIds_1.push(element.id);
                            });
                            var components = gameObj.components;
                            for (var index = components.length - 1; index >= 0; index--) {
                                var element = components[index];
                                if (revertComponentIds_1.indexOf(element.uuid) >= 0) {
                                    gameObj.removeComponent(element.constructor);
                                }
                            }
                            this_1.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                        }
                        if (revertData.modifyGameObjectPropertyList && revertData.modifyGameObjectPropertyList.length > 0) {
                            for (var _i = 0, _a = revertData.modifyGameObjectPropertyList; _i < _a.length; _i++) {
                                var obj = _a[_i];
                                var newValueList = obj.newValueList;
                                this_1.modifyPrefabGameObjectPropertyValues(gameObj, newValueList);
                            }
                        }
                        if (revertData.modifyComponentPropertyList && revertData.modifyComponentPropertyList.length > 0) {
                            for (var _b = 0, _c = revertData.modifyComponentPropertyList; _b < _c.length; _b++) {
                                var obj = _c[_b];
                                var componentId = obj.componentId, newValueList = obj.newValueList;
                                this_1.modifyPrefabComponentPropertyValues(gameObj, componentId, newValueList);
                            }
                        }
                    };
                    var this_1 = this;
                    for (var _i = 0, gameObjects_4 = gameObjects; _i < gameObjects_4.length; _i++) {
                        var gameObj = gameObjects_4[_i];
                        _loop_3(gameObj);
                    }
                    var gameObjs = editor.Editor.activeEditorModel.getGameObjectsByUUids(removeGameObjIds_1);
                    gameObjs.forEach(function (element) { return element.destroy(); });
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, removeGameObjIds_1);
                    return true;
                }
                return false;
            };
            return RevertPrefabInstanceState;
        }(editor.BaseState));
        editor.RevertPrefabInstanceState = RevertPrefabInstanceState;
        __reflect(RevertPrefabInstanceState.prototype, "paper.editor.RevertPrefabInstanceState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ValueUUID = (function () {
            function ValueUUID(_value) {
                this._value = _value;
                // empty
            }
            ValueUUID.prototype.asHex = function () {
                return this._value;
            };
            return ValueUUID;
        }());
        __reflect(ValueUUID.prototype, "ValueUUID", ["paper.editor.UUID"]);
        var V4UUID = (function (_super) {
            __extends(V4UUID, _super);
            function V4UUID() {
                return _super.call(this, [
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    '4',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._oneOf(V4UUID._timeHighBits),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                ].join('')) || this;
            }
            V4UUID._oneOf = function (array) {
                return array[Math.floor(array.length * Math.random())];
            };
            V4UUID._randomHex = function () {
                return V4UUID._oneOf(V4UUID._chars);
            };
            V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
            V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
            return V4UUID;
        }(ValueUUID));
        __reflect(V4UUID.prototype, "V4UUID");
        function v4() {
            return new V4UUID();
        }
        editor.v4 = v4;
        var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        function isUUID(value) {
            return _UUIDPattern.test(value);
        }
        editor.isUUID = isUUID;
        /**
         * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
         * @param value A uuid string.
         */
        function parse(value) {
            if (!isUUID(value)) {
                throw new Error('invalid uuid');
            }
            return new ValueUUID(value);
        }
        editor.parse = parse;
        function generateUuid() {
            return v4().asHex();
        }
        editor.generateUuid = generateUuid;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 雾。
     */
    var Shadow = (function () {
        /**
         * 禁止实例化。
         */
        function Shadow() {
        }
        /**
         * @internal
         */
        Shadow.create = function () {
            return new Shadow();
        };
        Shadow.prototype.serialize = function () {
            return [];
        };
        Shadow.prototype.deserialize = function (data) {
        };
        return Shadow;
    }());
    egret3d.Shadow = Shadow;
    __reflect(Shadow.prototype, "egret3d.Shadow", ["paper.ISerializable"]);
})(egret3d || (egret3d = {}));

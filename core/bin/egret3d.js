/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function (global) {

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active: true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params: null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute: function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params ? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach: function () {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound: function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce: function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener: function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal: function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy: function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString: function () {
            return '[SignalBinding isOnce:' + this._isOnce + ', isBound:' + this.isBound() + ', active:' + this.active + ']';
        }

    };


    /*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error('listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName));
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function () {
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION: '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize: false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate: true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active: true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener: function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if (this.memorize && this._prevParams) {
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding: function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener: function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has: function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add: function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce: function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove: function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll: function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners: function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt: function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch: function (params) {
            if (!this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (!n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget: function () {
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose: function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString: function () {
            return '[Signal active:' + this.active + ' numListeners:' + this.getNumListeners() + ']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;
    global['signals'] = signals
}(window));
"use strict";
var __reflect = (this && this.__reflect) || function (p, c, t) {
    p.__class__ = c, t ? t.push(c) : t = [c], p.__types__ = p.__types__ ? t.concat(p.__types__) : t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __extends = this && this.__extends || function __extends(t, e) { 
 function r() { 
 this.constructor = t;
}
for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
r.prototype = e.prototype, t.prototype = new r();
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var paper;
(function (paper) {
    /**
     *
     */
    var HideFlags;
    (function (HideFlags) {
        /**
         *
         */
        HideFlags[HideFlags["None"] = 0] = "None";
        /**
         *
         */
        HideFlags[HideFlags["NotEditable"] = 1] = "NotEditable";
        /**
         *
         */
        HideFlags[HideFlags["Hide"] = 2] = "Hide";
        /**
         *
         */
        HideFlags[HideFlags["HideAndDontSave"] = 3] = "HideAndDontSave";
    })(HideFlags = paper.HideFlags || (paper.HideFlags = {}));
    /**
     *
     */
    var DefaultNames;
    (function (DefaultNames) {
        DefaultNames["NoName"] = "NoName";
        DefaultNames["Default"] = "Default";
        DefaultNames["Global"] = "Global";
        DefaultNames["MainCamera"] = "Main Camera";
        DefaultNames["EditorCamera"] = "Editor Camera";
        DefaultNames["EditorOnly"] = "Editor Only";
        DefaultNames["MissingPrefab"] = "Missing Prefab";
    })(DefaultNames = paper.DefaultNames || (paper.DefaultNames = {}));
    /**
     * 默认标识和自定义标识。
     */
    var DefaultTags;
    (function (DefaultTags) {
        DefaultTags["Untagged"] = "Untagged";
        DefaultTags["Respawn"] = "Respawn";
        DefaultTags["Finish"] = "Finish";
        DefaultTags["EditorOnly"] = "EditorOnly";
        DefaultTags["MainCamera"] = "MainCamera";
        DefaultTags["Player"] = "Player";
        DefaultTags["GameController"] = "GameController";
        DefaultTags["Global"] = "Global";
    })(DefaultTags = paper.DefaultTags || (paper.DefaultTags = {}));
    /**
     * 内置层级和自定义层级。
     */
    var Layer;
    (function (Layer) {
        Layer[Layer["Nothing"] = 0] = "Nothing";
        Layer[Layer["Everything"] = 4294967295] = "Everything";
        Layer[Layer["BuiltinLayer0"] = 1] = "BuiltinLayer0";
        Layer[Layer["BuiltinLayer1"] = 2] = "BuiltinLayer1";
        Layer[Layer["BuiltinLayer2"] = 4] = "BuiltinLayer2";
        Layer[Layer["BuiltinLayer3"] = 8] = "BuiltinLayer3";
        Layer[Layer["BuiltinLayer4"] = 16] = "BuiltinLayer4";
        Layer[Layer["BuiltinLayer5"] = 32] = "BuiltinLayer5";
        Layer[Layer["BuiltinLayer6"] = 64] = "BuiltinLayer6";
        Layer[Layer["BuiltinLayer7"] = 128] = "BuiltinLayer7";
        Layer[Layer["UserLayer8"] = 256] = "UserLayer8";
        Layer[Layer["UserLayer9"] = 512] = "UserLayer9";
        Layer[Layer["UserLayer10"] = 1024] = "UserLayer10";
        Layer[Layer["UserLayer11"] = 2048] = "UserLayer11";
        Layer[Layer["UserLayer12"] = 4096] = "UserLayer12";
        Layer[Layer["UserLayer13"] = 8192] = "UserLayer13";
        Layer[Layer["UserLayer14"] = 16384] = "UserLayer14";
        Layer[Layer["UserLayer15"] = 32768] = "UserLayer15";
        Layer[Layer["UserLayer16"] = 65536] = "UserLayer16";
        Layer[Layer["UserLayer17"] = 131072] = "UserLayer17";
        Layer[Layer["UserLayer18"] = 262144] = "UserLayer18";
        Layer[Layer["UserLayer19"] = 524288] = "UserLayer19";
        Layer[Layer["UserLayer20"] = 1048576] = "UserLayer20";
        Layer[Layer["UserLayer21"] = 2097152] = "UserLayer21";
        Layer[Layer["UserLayer22"] = 4194304] = "UserLayer22";
        Layer[Layer["UserLayer23"] = 8388608] = "UserLayer23";
        Layer[Layer["UserLayer24"] = 16777216] = "UserLayer24";
        Layer[Layer["UserLayer25"] = 33554432] = "UserLayer25";
        Layer[Layer["UserLayer26"] = 67108864] = "UserLayer26";
        Layer[Layer["UserLayer27"] = 134217728] = "UserLayer27";
        Layer[Layer["UserLayer28"] = 268435456] = "UserLayer28";
        Layer[Layer["UserLayer29"] = 536870912] = "UserLayer29";
        Layer[Layer["UserLayer30"] = 1073741824] = "UserLayer30";
        Layer[Layer["UserLayer31"] = 2147483648] = "UserLayer31";
        Layer[Layer["Default"] = 1] = "Default";
        Layer[Layer["TransparentFX"] = 2] = "TransparentFX";
        Layer[Layer["IgnoreRayCast"] = 4] = "IgnoreRayCast";
        Layer[Layer["Water"] = 16] = "Water";
        Layer[Layer["UI"] = 32] = "UI";
    })(Layer = paper.Layer || (paper.Layer = {}));
    /**
     * 系统排序。
     */
    var SystemOrder;
    (function (SystemOrder) {
        SystemOrder[SystemOrder["Begin"] = 0] = "Begin";
        SystemOrder[SystemOrder["Enable"] = 1000] = "Enable";
        SystemOrder[SystemOrder["Start"] = 2000] = "Start";
        SystemOrder[SystemOrder["FixedUpdate"] = 3000] = "FixedUpdate";
        SystemOrder[SystemOrder["Update"] = 4000] = "Update";
        SystemOrder[SystemOrder["Animation"] = 5000] = "Animation";
        SystemOrder[SystemOrder["LateUpdate"] = 6000] = "LateUpdate";
        SystemOrder[SystemOrder["BeforeRenderer"] = 7000] = "BeforeRenderer";
        SystemOrder[SystemOrder["Renderer"] = 8000] = "Renderer";
        SystemOrder[SystemOrder["Disable"] = 9000] = "Disable";
        SystemOrder[SystemOrder["End"] = 10000] = "End";
    })(SystemOrder = paper.SystemOrder || (paper.SystemOrder = {}));
    /**
     * 渲染排序。
     */
    var RenderQueue;
    (function (RenderQueue) {
        RenderQueue[RenderQueue["Background"] = 1000] = "Background";
        RenderQueue[RenderQueue["Geometry"] = 2000] = "Geometry";
        RenderQueue[RenderQueue["AlphaTest"] = 2450] = "AlphaTest";
        RenderQueue[RenderQueue["Transparent"] = 3000] = "Transparent";
        RenderQueue[RenderQueue["Overlay"] = 4000] = "Overlay";
    })(RenderQueue = paper.RenderQueue || (paper.RenderQueue = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    function registerClass(baseClass) {
        baseClass.__onRegister();
    }
    paper.registerClass = registerClass;
    function serializedField(classPrototypeOrOldKey, key) {
        if (key) {
            var baseClass = classPrototypeOrOldKey.constructor;
            registerClass(baseClass);
            baseClass.__serializeKeys[key] = null;
        }
        else {
            return function (classPrototype, key) {
                var baseClass = classPrototype.constructor;
                registerClass(baseClass);
                baseClass.__serializeKeys[key] = classPrototypeOrOldKey;
            };
        }
    }
    paper.serializedField = serializedField;
    /**
     * 通过装饰器标记反序列化时需要忽略的属性。
     * @param classPrototype 类原型。
     * @param key 键值。
     */
    function deserializedIgnore(classPrototype, key) {
        var baseClass = classPrototype.constructor;
        registerClass(baseClass);
        var keys = baseClass.__deserializeIgnore;
        if (keys.indexOf(key) < 0) {
            keys.push(key);
        }
    }
    paper.deserializedIgnore = deserializedIgnore;
    /**
     * 通过装饰器标记组件是否允许在同一实体上添加多个实例。
     * @param componentClass 组件类。
     */
    function allowMultiple(componentClass) {
        registerClass(componentClass);
        if (!componentClass.__isSingleton) {
            componentClass.allowMultiple = true;
        }
        else {
            console.warn("Singleton component cannot allow multiple.");
        }
    }
    paper.allowMultiple = allowMultiple;
    /**
     * 通过装饰器标记组件依赖的其他组件。
     * @param requireComponentClass 依赖的组件类。
     */
    function requireComponent(requireComponentClass) {
        return function (componentClass) {
            var requireComponents = componentClass.requireComponents;
            if (requireComponents.indexOf(requireComponentClass) < 0) {
                requireComponents.push(requireComponentClass);
            }
        };
    }
    paper.requireComponent = requireComponent;
    // executionOrder: number; TODO
    // /**
    //  * 通过装饰器标记脚本组件的生命周期优先级。（默认：0）
    //  */
    // export function executionOrder(order: number = 0) {
    //     return function (componentClass: ComponentClass<Behaviour>) {
    //         registerClass(componentClass);
    //         componentClass.executionOrder = order;
    //     }
    // }
    /**
     * 通过装饰器标记脚本组件是否在编辑模式也拥有生命周期。
     * @param componentClass 组件类。
     */
    function executeInEditMode(componentClass) {
        registerClass(componentClass);
        componentClass.executeInEditMode = true;
    }
    paper.executeInEditMode = executeInEditMode;
    /**
     * 通过装饰器标记 API 已被废弃。
     * @param version 废弃的版本。
     */
    function deprecated(version) {
        return function (target, key, descriptor) {
            var method = descriptor.value;
            descriptor.value = function () {
                var arg = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    arg[_i] = arguments[_i];
                }
                // TODO 装饰动态、静态、getter setter 等。
                console.warn(target.name + "." + key + "\u5728" + version + "\u7248\u672C\u4E2D\u5DF2\u88AB\u5E9F\u5F03");
                return method.apply(descriptor, arg);
            };
        };
    }
    paper.deprecated = deprecated;
})(paper || (paper = {}));
var paper;
(function (paper) {
    var _hashCount = 1;
    /**
     * 生成 uuid 的方式。
     * @private
     */
    paper.createUUID = function () {
        return (_hashCount++).toString();
    };
    /**
     * 可以被 paper.DisposeCollecter 收集，并在此帧末尾释放的基础对象。
     */
    var BaseRelease = (function () {
        function BaseRelease() {
        }
        /**
         * 更新该对象，使得该对象的 `onUpdate()` 被执行。
         */
        BaseRelease.prototype.update = function () {
            if (this.onUpdate) {
                this.onUpdate.call(this.onUpdateTarget || this, this);
            }
            return this;
        };
        /**
         * 在此帧末尾释放该对象。
         * - 释放该对象后，必须清除所有对该对象的显示引用。（该问题必须引起足够的重视）
         * - 不能在静态解释阶段执行。
         */
        BaseRelease.prototype.release = function () {
            if (this._released) {
                if (true) {
                    console.warn("The object has been released.");
                }
                return this;
            }
            paper.disposeCollecter.releases.push(this);
            this._released = true;
            return this;
        };
        return BaseRelease;
    }());
    paper.BaseRelease = BaseRelease;
    __reflect(BaseRelease.prototype, "paper.BaseRelease");
    /**
     * 基础对象。
     */
    var BaseObject = (function () {
        function BaseObject() {
            this.uuid = paper.createUUID();
        }
        /**
         * @internal
         */
        BaseObject.__onRegister = function () {
            if (this.__owner && this.__owner === this) {
                return false;
            }
            this.__deserializeIgnore = [];
            this.__serializeKeys = {};
            this.__owner = this;
            return true;
        };
        __decorate([
            paper.serializedField
        ], BaseObject.prototype, "uuid", void 0);
        return BaseObject;
    }());
    paper.BaseObject = BaseObject;
    __reflect(BaseObject.prototype, "paper.BaseObject", ["paper.IUUID"]);
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 属性信息。
         */
        var PropertyInfo = (function () {
            function PropertyInfo(name, editType, option) {
                this.name = name;
                this.editType = editType;
                this.option = option;
            }
            return PropertyInfo;
        }());
        editor.PropertyInfo = PropertyInfo;
        __reflect(PropertyInfo.prototype, "paper.editor.PropertyInfo");
        /**
         * 编辑类型。
         */
        var EditType;
        (function (EditType) {
            /**
             * 选中框。
             */
            EditType["CHECKBOX"] = "CHECKBOX";
            /**
             * 正整数。
             */
            EditType["UINT"] = "UINT";
            /**
             * 整数。
             */
            EditType["INT"] = "INT";
            /**
             * 浮点数。
             */
            EditType["FLOAT"] = "FLOAT";
            /**
             * 文本。
             */
            EditType["TEXT"] = "TEXT";
            /**
             * 下拉列表。
             */
            EditType["LIST"] = "LIST";
            /**
             * 数组。
             */
            EditType["ARRAY"] = "ARRAY";
            /**
             * 尺寸。
             */
            EditType["SIZE"] = "SIZE";
            /**
             * 矩形。
             */
            EditType["RECT"] = "RECT";
            /**
             * 二维向量。
             */
            EditType["VECTOR2"] = "VECTOR2";
            /**
             * 三维向量。
             */
            EditType["VECTOR3"] = "VECTOR3";
            /**
             * 四维向量。
             */
            EditType["VECTOR4"] = "VECTOR4";
            /**
             * 四元数。
             */
            EditType["QUATERNION"] = "QUATERNION";
            /**
             * 颜色选择器。
             */
            EditType["COLOR"] = "COLOR";
            /**
             * 着色器。
             */
            EditType["SHADER"] = "SHADER";
            /**
             * 材质。
             */
            EditType["MATERIAL"] = "MATERIAL";
            /**
             * 材质数组。
             */
            EditType["MATERIAL_ARRAY"] = "MATERIAL_ARRAY";
            /**
             * 贴图。
             */
            EditType["TEXTUREDESC"] = "TEXTUREDESC";
            /**
             * 网格。
             */
            EditType["MESH"] = "MESH";
            /**
             * 实体。
             */
            EditType["GAMEOBJECT"] = "GAMEOBJECT";
            /**
             * 组件。
             */
            EditType["COMPONENT"] = "COMPONENT";
            /**声音 */
            EditType["SOUND"] = "SOUND";
            /**
             * 按钮。
             */
            EditType["BUTTON"] = "BUTTON";
            /**
             * 3x3 矩阵。
             */
            EditType["MAT3"] = "MAT3";
            /**
             * 内嵌的。
             */
            EditType["NESTED"] = "NESTED";
            /**变换 TODO remove*/
            EditType["TRANSFROM"] = "TRANSFROM";
        })(EditType = editor.EditType || (editor.EditType = {}));
        /**
         * 自定义装饰器。
         */
        function custom() {
            return function (target) {
                target['__custom__'] = true;
            };
        }
        editor.custom = custom;
        /**
         * 属性装饰器。
         * @param editType 编辑类型。
         * @param option 配置。
         */
        function property(editType, option) {
            return function (target, property) {
                if (!target.hasOwnProperty('__props__')) {
                    target['__props__'] = [];
                }
                if (editType !== undefined) {
                    target['__props__'].push(new PropertyInfo(property, editType, option));
                }
                else {
                    //TODO:自动分析编辑类型
                }
            };
        }
        editor.property = property;
        /**
         * 从枚举中生成装饰器列表项。
         */
        function getItemsFromEnum(enumObject) {
            var items = [];
            for (var k in enumObject) {
                if (!isNaN(Number(k))) {
                    continue;
                }
                items.push({ label: k, value: enumObject[k] });
            }
            return items;
        }
        editor.getItemsFromEnum = getItemsFromEnum;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 基础资源。
     * - 全部资源的基类。
     */
    var Asset = (function (_super) {
        __extends(Asset, _super);
        /**
         * TODO
         * remove
         * @param name
         */
        function Asset(name) {
            if (name === void 0) { name = ""; }
            var _this = _super.call(this) || this;
            /**
             * 资源名称。
             * @readonly
             */
            _this.name = "";
            _this._referenceCount = -1;
            _this.name = name;
            return _this;
        }
        /**
         * 将一个资源注册为全局可访问资源。
         * - 引用计数加 1 。
         */
        Asset.register = function (asset) {
            var assetName = asset.name;
            if (!assetName) {
                console.warn("Unable to register an unnamed asset.");
                return false;
            }
            var assets = this._assets;
            if (assetName in assets) {
                var existingAsset = assets[assetName];
                if (existingAsset === asset) {
                    return false;
                }
                console.warn("Replaces an existing asset.", assetName);
                existingAsset.release();
            }
            assets[assetName] = asset;
            asset.retain();
            return true;
        };
        /**
         * 通过资源名获取一个已注册的指定资源。
         */
        Asset.find = function (name) {
            var assets = this._assets;
            if (name in assets) {
                return assets[name];
            }
            return RES.getRes(name);
        };
        /**
         * 该资源内部初始化。
         * - 重写此方法时，必须调用 `super.initialize();`。
         */
        Asset.prototype.initialize = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._referenceCount = 0;
        };
        /**
         * 该资源的引用计数加一。
         */
        Asset.prototype.retain = function () {
            if (this._referenceCount === 0) {
            }
            this._referenceCount++;
            return this;
        };
        /**
         * 该资源的引用计数减一。
         */
        Asset.prototype.release = function () {
            if (this._referenceCount > 0) {
                this._referenceCount--;
                if (this._referenceCount === 0) {
                }
            }
            return this;
        };
        /**
         * 释放该资源。
         * - 重写此方法时，必须调用 `super.dispose();`。
         * @returns 释放是否成功。（已经释放过的资源，无法再次释放）
         */
        Asset.prototype.dispose = function () {
            if (this._referenceCount < 0) {
                return false;
            }
            //
            var assets = Asset._assets;
            if (this.name in assets) {
                delete assets[this.name];
            }
            //
            this._referenceCount = -1;
            return true;
        };
        Object.defineProperty(Asset.prototype, "isDisposed", {
            /**
             *
             */
            get: function () {
                return this._referenceCount === -1;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * TODO RES 需要有注册的功能，并拥有查询所有指定类型资源的功能。
         * Asset 类型需要引擎枚举，paper 空间还是引擎空间。
         * 空间结构
         * 引擎、res、ecs、2d、3d，其他
         * @internal
         */
        Asset._assets = {};
        return Asset;
    }(paper.BaseObject));
    paper.Asset = Asset;
    __reflect(Asset.prototype, "paper.Asset");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var _createEnabled = null;
    /**
     * 基础组件。
     * - 所有组件的基类。
     * - 在纯粹的实体组件系统中，组件通常应只包含数据，不应有业务逻辑、行为和生命周期。
     */
    var BaseComponent = (function (_super) {
        __extends(BaseComponent, _super);
        /**
         * 禁止实例化组件。
         * @protected
         */
        function BaseComponent() {
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.hideFlags = 0 /* None */;
            /**
             * 该组件的实体。
             */
            _this.gameObject = null;
            /**
             * 仅保存在编辑器环境的额外数据，项目发布该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            _this._enabled = true;
            if (!_createEnabled) {
                throw new Error("Component instantiation through constructor is not allowed.");
            }
            _this.gameObject = _createEnabled;
            _createEnabled = null;
            return _this;
        }
        /**
         * @internal
         */
        BaseComponent.__onRegister = function () {
            if (!paper.BaseObject.__onRegister.call(this)) {
                return false;
            }
            if ((this.__isSingleton ? this._allSingletonComponents : this._allComponents).indexOf(this) >= 0) {
                console.warn("Register component class again.", egret.getQualifiedClassName(this));
                return false;
            }
            if (this.requireComponents) {
                this.requireComponents = this.requireComponents.concat();
            }
            else {
                this.requireComponents = [];
            }
            this.onComponentEnabled = new signals.Signal();
            this.onComponentDisabled = new signals.Signal();
            if (this.__isSingleton) {
                this.__index = this._allSingletonComponents.length + 300; // This means that a maximum of 300 non-singleton components can be added.
                this._allSingletonComponents.push(this);
            }
            else {
                this.__index = this._allComponents.length;
                this._allComponents.push(this);
            }
            return true;
        };
        /**
         * @internal
         */
        BaseComponent.create = function (componentClass, gameObject) {
            _createEnabled = gameObject;
            return new componentClass();
        };
        /**
         * @private
         */
        BaseComponent.prototype._dispatchEnabledEvent = function (value) {
            var componentClass = this.constructor;
            if (value) {
                componentClass.onComponentEnabled.dispatch(this);
            }
            else {
                componentClass.onComponentDisabled.dispatch(this);
            }
        };
        /**
         * 添加组件后，组件内部初始化时执行。
         * - 重写此方法时，必须调用 `super.initialize()`。
         * @param config 实体添加该组件时可以传递的初始化数据。（注意：如果添加该组件时，实体未处于激活状态，则该属性无效）
         */
        BaseComponent.prototype.initialize = function (config) {
        };
        /**
         * 移除组件后，组件内部卸载时执行。
         * - 重写此方法时，必须调用 `super.uninitialize()`。
         */
        BaseComponent.prototype.uninitialize = function () {
        };
        Object.defineProperty(BaseComponent.prototype, "isDestroyed", {
            /**
             * 该组件是否已被销毁。
             */
            get: function () {
                return !this.gameObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "enabled", {
            /**
             * 该组件自身的激活状态。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled === value) {
                    return;
                }
                // if (!value && this.constructor === egret3d.Transform) { TODO
                //     console.warn("Cannot disable transform compnent.");
                //     return;
                // }
                var prevEnabled = this.isActiveAndEnabled;
                this._enabled = value;
                var currentEnabled = this.isActiveAndEnabled;
                if (currentEnabled !== prevEnabled) {
                    this._dispatchEnabledEvent(currentEnabled);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "isActiveAndEnabled", {
            /**
             * 该组件在场景的激活状态。
             */
            get: function () {
                // return this._enabled && this.gameObject.activeInHierarchy;
                return this._enabled && (this.gameObject._activeDirty ? this.gameObject.activeInHierarchy : this.gameObject._activeInHierarchy);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "transform", {
            /**
             * 该组件所属实体的变换组件。
             */
            get: function () {
                return this.gameObject.transform;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该组件的实例是否在编辑模式拥有生命周期。
         * @internal
         */
        BaseComponent.executeInEditMode = false;
        /**
         * 是否允许在同一实体上添加多个该组件的实例。
         * @internal
         */
        BaseComponent.allowMultiple = false;
        /**
         * 该组件实例依赖的其他前置组件。
         * @internal
         */
        BaseComponent.requireComponents = null;
        /**
         * 当该组件被激活时派发事件。
         * @internal
         */
        BaseComponent.onComponentEnabled = null;
        /**
         * 当该组件被禁用时派发事件。
         * @internal
         */
        BaseComponent.onComponentDisabled = null;
        // TODO 基类标记，以阻止注册基类。
        /**
         * 该组件实例是否为单例组件。
         * @internal
         */
        BaseComponent.__isSingleton = false;
        /**
         * @internal
         */
        BaseComponent.__isBehaviour = false;
        /**
         * 该组件实例索引。
         * @internal
         */
        BaseComponent.__index = -1;
        /**
         * 所有已注册的组件类。
         */
        BaseComponent._allComponents = [];
        /**
         * 所有已注册的单例组件类。
         */
        BaseComponent._allSingletonComponents = [];
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "hideFlags", void 0);
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "_enabled", void 0);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseComponent.prototype, "enabled", null);
        return BaseComponent;
    }(paper.BaseObject));
    paper.BaseComponent = BaseComponent;
    __reflect(BaseComponent.prototype, "paper.BaseComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 二维向量。
     */
    var Vector2 = (function (_super) {
        __extends(Vector2, _super);
        /**
         * 请使用 `egret3d.Vector2.create()` 创建实例。
         * @see egret3d.Vector2.create()
         * @deprecated
         * @private
         */
        function Vector2(x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            return _this;
        }
        /**
         * 创建一个二维向量。
         * @param x X 轴分量。
         * @param y Y 轴分量。
         */
        Vector2.create = function (x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y);
                instance._released = false;
                return instance;
            }
            return new Vector2().set(x, y);
        };
        Vector2.prototype.serialize = function () {
            return [this.x, this.y];
        };
        Vector2.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector2.prototype.copy = function (value) {
            return this.set(value.x, value.y);
        };
        Vector2.prototype.clone = function () {
            return Vector2.create(this.x, this.y);
        };
        Vector2.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        Vector2.prototype.clear = function () {
            this.x = 0.0;
            this.y = 0.0;
            return this;
        };
        Vector2.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            return this;
        };
        Vector2.prototype.normalize = function (input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y;
            var l = Math.sqrt(x * x + y * y);
            if (l > 2.220446049250313e-16 /* EPSILON */) {
                l = 1.0 / l;
                this.x = x * l;
                this.y = y * l;
            }
            else {
                this.x = 1.0;
                this.y = 0.0;
            }
            return this;
        };
        Vector2.prototype.add = function (vectorA, vectorB) {
            if (!vectorB) {
                vectorB = vectorA;
                vectorA = this;
            }
            this.x = vectorA.x + vectorB.x;
            this.y = vectorA.y + vectorB.y;
            return this;
        };
        Vector2.prototype.subtract = function (vectorA, vectorB) {
            if (!vectorB) {
                vectorB = vectorA;
                vectorA = this;
            }
            this.x = vectorA.x - vectorB.x;
            this.y = vectorA.y - vectorB.y;
            return this;
        };
        Vector2.prototype.addScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = input.x + scalar;
            this.y = input.y + scalar;
            return this;
        };
        Vector2.prototype.multiplyScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = scalar * input.x;
            this.y = scalar * input.y;
            return this;
        };
        Vector2.prototype.min = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.min(valueA.x, valueB.x);
            this.y = Math.min(valueA.y, valueB.y);
            return this;
        };
        Vector2.prototype.max = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.max(valueA.x, valueB.x);
            this.y = Math.max(valueA.y, valueB.y);
            return this;
        };
        Vector2.prototype.clamp = function (min, max, input) {
            if (!input) {
                input = this;
            }
            if (true && (min.x > max.x || min.y > max.y)) {
                console.warn("Invalid arguments.");
            }
            // assumes min < max, componentwise
            this.x = Math.max(min.x, Math.min(max.x, input.x));
            this.y = Math.max(min.y, Math.min(max.y, input.y));
            return this;
        };
        Object.defineProperty(Vector2.prototype, "length", {
            /**
             * 该向量的长度。
             * - 该值是实时计算的。
             */
            get: function () {
                return Math.sqrt(this.sqrtLength);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2.prototype, "sqrtLength", {
            /**
             * 该向量的长度的平方。
             * - 该值是实时计算的。
             */
            get: function () {
                return this.x * this.x + this.y * this.y;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Vector2.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            return out;
        };
        /**
         * @deprecated
         */
        Vector2.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            return out;
        };
        /**
         * @deprecated
         */
        Vector2.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            return out;
        };
        /**
         * @deprecated
         */
        Vector2.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        };
        /**
         * @deprecated
         */
        Vector2.scale = function (v, scaler) {
            v.x = v.x * scaler;
            v.y = v.y * scaler;
            return v;
        };
        /**
         * @deprecated
         */
        Vector2.getLength = function (v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        };
        /**
         * @deprecated
         */
        Vector2.getDistance = function (v1, v2) {
            this.subtract(v1, v2, _helpVector2A);
            return this.getLength(_helpVector2A);
        };
        /**
         * @deprecated
         */
        Vector2.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            return true;
        };
        /**
         * @deprecated
         */
        Vector2.lerp = function (v1, v2, value, out) {
            out.x = v1.x * (1 - value) + v2.x * value;
            out.y = v1.y * (1 - value) + v2.y * value;
            return out;
        };
        Vector2.ZERO = new Vector2(0.0, 0.0);
        Vector2.ONE = new Vector2(1.0, 1.0);
        Vector2.MINUS_ONE = new Vector2(-1.0, -1.0);
        Vector2._instances = [];
        return Vector2;
    }(paper.BaseRelease));
    egret3d.Vector2 = Vector2;
    __reflect(Vector2.prototype, "egret3d.Vector2", ["egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
    var _helpVector2A = new Vector2();
    /**
     * @internal
     */
    egret3d.helpVector2A = Vector2.create();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 欧拉旋转顺序。
     */
    var EulerOrder;
    (function (EulerOrder) {
        EulerOrder[EulerOrder["XYZ"] = 0] = "XYZ";
        EulerOrder[EulerOrder["XZY"] = 1] = "XZY";
        EulerOrder[EulerOrder["YXZ"] = 2] = "YXZ";
        EulerOrder[EulerOrder["YZX"] = 3] = "YZX";
        EulerOrder[EulerOrder["ZXY"] = 4] = "ZXY";
        EulerOrder[EulerOrder["ZYX"] = 5] = "ZYX";
    })(EulerOrder = egret3d.EulerOrder || (egret3d.EulerOrder = {}));
    /**
     * 三维向量。
     */
    var Vector3 = (function (_super) {
        __extends(Vector3, _super);
        /**
         * 请使用 `egret3d.Vector3.create()` 创建实例。
         * @see egret3d.Vector3.create()
         * @deprecated
         * @private
         */
        function Vector3(x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.z = z;
            return _this;
        }
        /**
         * 创建一个三维向量。
         * @param x X 轴分量。
         * @param y Y 轴分量。
         * @param z Z 轴分量。
         */
        Vector3.create = function (x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z);
                instance._released = false;
                return instance;
            }
            return new Vector3().set(x, y, z);
        };
        Vector3.prototype.serialize = function () {
            return [this.x, this.y, this.z];
        };
        Vector3.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector3.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.z);
        };
        Vector3.prototype.clone = function () {
            return Vector3.create(this.x, this.y, this.z);
        };
        Vector3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        Vector3.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        };
        Vector3.prototype.fromMatrixPosition = function (matrix) {
            var array = matrix.rawData;
            this.x = array[12];
            this.y = array[13];
            this.z = array[14];
            return this.fromArray(matrix.rawData, 12);
        };
        Vector3.prototype.fromMatrixColumn = function (matrix, index) {
            return this.fromArray(matrix.rawData, index * 4);
        };
        Vector3.prototype.clear = function () {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            return this;
        };
        /**
         * 判断该向量是否和一个向量相等。
         * @param value 一个向量。
         * @param threshold 阈值。
         */
        Vector3.prototype.equal = function (value, threshold) {
            if (threshold === void 0) { threshold = 2.220446049250313e-16 /* EPSILON */; }
            if (Math.abs(this.x - value.x) <= threshold &&
                Math.abs(this.y - value.y) <= threshold &&
                Math.abs(this.z - value.z) <= threshold) {
                return true;
            }
            return false;
        };
        Vector3.prototype.normalize = function (input, defaultVector) {
            if (defaultVector === void 0) { defaultVector = Vector3.FORWARD; }
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var l = Math.sqrt(x * x + y * y + z * z);
            if (l > 2.220446049250313e-16 /* EPSILON */) {
                l = 1.0 / l;
                this.x = x * l;
                this.y = y * l;
                this.z = z * l;
            }
            else {
                this.copy(defaultVector);
            }
            return this;
        };
        Vector3.prototype.negate = function (input) {
            if (!input) {
                input = this;
            }
            this.x = -input.x;
            this.y = -input.y;
            this.z = -input.z;
            return this;
        };
        Vector3.prototype.fromSphericalCoords = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                p3 = p1.z;
                p2 = p1.y;
                p1 = p1.x;
            }
            var sinPhiRadius = Math.sin(p2) * p1;
            this.x = sinPhiRadius * Math.sin(p3);
            this.y = Math.cos(p2) * p1;
            this.z = sinPhiRadius * Math.cos(p3);
            return this;
        };
        Vector3.prototype.applyMatrix3 = function (matrix, input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var rawData = matrix.rawData;
            this.x = rawData[0] * x + rawData[3] * y + rawData[6] * z;
            this.y = rawData[1] * x + rawData[4] * y + rawData[7] * z;
            this.z = rawData[2] * x + rawData[5] * y + rawData[8] * z;
            return this;
        };
        Vector3.prototype.applyMatrix = function (matrix, input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var rawData = matrix.rawData;
            var w = rawData[3] * x + rawData[7] * y + rawData[11] * z + rawData[15];
            if (w < -2.220446049250313e-16 /* EPSILON */ || 2.220446049250313e-16 /* EPSILON */ < w) {
                w = 1.0 / w;
                this.x = (rawData[0] * x + rawData[4] * y + rawData[8] * z + rawData[12]) * w;
                this.y = (rawData[1] * x + rawData[5] * y + rawData[9] * z + rawData[13]) * w;
                this.z = (rawData[2] * x + rawData[6] * y + rawData[10] * z + rawData[14]) * w;
            }
            else {
                this.x = 0.0;
                this.y = 0.0;
                this.z = 0.0;
                if (true) {
                    console.warn("Dividing by zero.");
                }
            }
            return this;
        };
        Vector3.prototype.applyDirection = function (matrix, input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var rawData = matrix.rawData;
            this.x = rawData[0] * x + rawData[4] * y + rawData[8] * z;
            this.y = rawData[1] * x + rawData[5] * y + rawData[9] * z;
            this.z = rawData[2] * x + rawData[6] * y + rawData[10] * z;
            return this.normalize();
        };
        Vector3.prototype.applyQuaternion = function (quaternion, input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var qx = quaternion.x, qy = quaternion.y, qz = quaternion.z, qw = quaternion.w;
            // calculate quat * vector
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            // calculate result * inverse quat
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        };
        Vector3.prototype.addScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = input.x + scalar;
            this.y = input.y + scalar;
            this.z = input.z + scalar;
            return this;
        };
        Vector3.prototype.multiplyScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = scalar * input.x;
            this.y = scalar * input.y;
            this.z = scalar * input.z;
            return this;
        };
        Vector3.prototype.add = function (vectorA, vectorB) {
            if (!vectorB) {
                vectorB = vectorA;
                vectorA = this;
            }
            this.x = vectorA.x + vectorB.x;
            this.y = vectorA.y + vectorB.y;
            this.z = vectorA.z + vectorB.z;
            return this;
        };
        Vector3.prototype.subtract = function (vectorA, vectorB) {
            if (!vectorB) {
                vectorB = vectorA;
                vectorA = this;
            }
            this.x = vectorA.x - vectorB.x;
            this.y = vectorA.y - vectorB.y;
            this.z = vectorA.z - vectorB.z;
            return this;
        };
        Vector3.prototype.multiply = function (vectorA, vectorB) {
            if (!vectorB) {
                vectorB = vectorA;
                vectorA = this;
            }
            this.x = vectorA.x * vectorB.x;
            this.y = vectorA.y * vectorB.y;
            this.z = vectorA.z * vectorB.z;
            return this;
        };
        Vector3.prototype.divide = function (vectorA, vectorB) {
            if (!vectorB) {
                vectorB = vectorA;
                vectorA = this;
            }
            if (true && (vectorB.x === 0.0 || vectorB.y === 0.0 || vectorB.z === 0)) {
                console.warn("Dividing by zero.");
            }
            this.x = vectorA.x / vectorB.x;
            this.y = vectorA.y / vectorB.y;
            this.z = vectorA.z / vectorB.z;
            return this;
        };
        /**
         * 将该向量与一个向量相点乘。
         * - v · vector
         * @param vector 一个向量。
         */
        Vector3.prototype.dot = function (vector) {
            return this.x * vector.x + this.y * vector.y + this.z * vector.z;
        };
        Vector3.prototype.cross = function (vectorA, vectorB) {
            if (!vectorB) {
                vectorB = vectorA;
                vectorA = this;
            }
            var x = vectorA.x;
            var y = vectorA.y;
            var z = vectorA.z;
            var xB = vectorB.x;
            var yB = vectorB.y;
            var zB = vectorB.z;
            this.x = y * zB - z * yB;
            this.y = z * xB - x * zB;
            this.z = x * yB - y * xB;
            return this;
        };
        Vector3.prototype.lerp = function (p1, p2, p3) {
            if (typeof p1 === "number") {
                if (!p3) {
                    p3 = p1;
                    p1 = this;
                }
                else {
                    var temp = p1;
                    p1 = p2;
                    p2 = p3;
                    p3 = temp;
                }
            }
            else if (typeof p2 === "number") {
                p3 = p2;
                p2 = p1;
                p1 = this;
            }
            this.x = p1.x + (p2.x - p1.x) * p3;
            this.y = p1.y + (p2.y - p1.y) * p3;
            this.z = p1.z + (p2.z - p1.z) * p3;
            return this;
        };
        Vector3.prototype.min = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.min(valueA.x, valueB.x);
            this.y = Math.min(valueA.y, valueB.y);
            this.z = Math.min(valueA.z, valueB.z);
            return this;
        };
        Vector3.prototype.max = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.max(valueA.x, valueB.x);
            this.y = Math.max(valueA.y, valueB.y);
            this.z = Math.max(valueA.z, valueB.z);
            return this;
        };
        Vector3.prototype.clamp = function (min, max, input) {
            if (!input) {
                input = this;
            }
            if (true && (min.x > max.x || min.y > max.y || min.z > max.z)) {
                console.warn("Invalid arguments.");
            }
            // assumes min < max, componentwise
            this.x = Math.max(min.x, Math.min(max.x, input.x));
            this.y = Math.max(min.y, Math.min(max.y, input.y));
            this.z = Math.max(min.z, Math.min(max.z, input.z));
            return this;
        };
        Vector3.prototype.reflect = function (normal, input) {
            if (!input) {
                input = this;
            }
            return this.subtract(input, _helpVector3.multiplyScalar(2.0 * input.dot(normal), normal));
        };
        /**
         * 获取该向量和一个向量的夹角。（弧度制）
         * - 假设向量长度均不为零。
         */
        Vector3.prototype.getAngle = function (vector) {
            var v = this.squaredLength * vector.squaredLength;
            if (true && v === 0.0) {
                console.warn("Dividing by zero.");
            }
            var theta = this.dot(vector) / Math.sqrt(v);
            // clamp, to handle numerical problems
            return Math.acos(Math.max(-1.0, Math.min(1.0, theta)));
        };
        /**
         * 获取两点的最近距离的平方。
         * @param point 一个点。
         */
        Vector3.prototype.getSquaredDistance = function (point) {
            return _helpVector3.subtract(point, this).squaredLength;
        };
        /**
         * 获取两点的最近距离。
         * @param point 一个点。
         */
        Vector3.prototype.getDistance = function (point) {
            return _helpVector3.subtract(point, this).length;
        };
        /**
         * 将该向量转换为数组。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Vector3.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            array[0 + offset] = this.x;
            array[1 + offset] = this.y;
            array[2 + offset] = this.z;
            return array;
        };
        Object.defineProperty(Vector3.prototype, "length", {
            /**
             * 该向量的长度。
             * - 该值是实时计算的。
             */
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3.prototype, "squaredLength", {
            /**
             * 该向量的长度的平方。
             * - 该值是实时计算的。
             */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Vector3.set = function (x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.normalize = function (v) {
            return v.normalize();
        };
        /**
         * @deprecated
         */
        Vector3.copy = function (v, out) {
            out.x = v.x;
            out.y = v.y;
            out.z = v.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            out.z = v1.z + v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            out.z = v1.z * v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.scale = function (v, scale) {
            v.x = v.x * scale;
            v.y = v.y * scale;
            v.z = v.z * scale;
            return v;
        };
        /**
         * @deprecated
         */
        Vector3.cross = function (lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        };
        /**
         * @deprecated
         */
        Vector3.lerp = function (v1, v2, v, out) {
            out.x = v1.x * (1 - v) + v2.x * v;
            out.y = v1.y * (1 - v) + v2.y * v;
            out.z = v1.z * (1 - v) + v2.z * v;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            if (Math.abs(v1.z - v2.z) > threshold) {
                return false;
            }
            return true;
        };
        /**
         * @deprecated
         */
        Vector3.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            out.z = v1.z - v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.getSqrLength = function (v) {
            return v.x * v.x + v.y * v.y + v.z * v.z;
        };
        /**
         * @deprecated
         */
        Vector3.getLength = function (v) {
            return Math.sqrt(this.getSqrLength(v));
        };
        /**
         * @deprecated
         */
        Vector3.getDistance = function (a, b) {
            return this.getLength(this.subtract(a, b, _helpVector3));
        };
        /**
         * 零向量。
         * - 请注意不要修改该值。
         */
        Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
        /**
         * 三方向均为一的向量。
         * - 请注意不要修改该值。
         */
        Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
        /**
         * 三方向均为负一的向量。
         * - 请注意不要修改该值。
         */
        Vector3.MINUS_ONE = new Vector3(-1.0, -1.0, -1.0);
        /**
         * 上向量。
         * - 请注意不要修改该值。
         */
        Vector3.UP = new Vector3(0.0, 1.0, 0.0);
        /**
         * 下向量。
         * - 请注意不要修改该值。
         */
        Vector3.DOWN = new Vector3(0.0, -1.0, 0.0);
        /**
         * 左向量。
         * - 请注意不要修改该值。
         */
        Vector3.LEFT = new Vector3(-1.0, 0.0, 0.0);
        /**
         * 右向量。
         * - 请注意不要修改该值。
         */
        Vector3.RIGHT = new Vector3(1.0, 0.0, 0.0);
        /**
         * 前向量。
         * - 请注意不要修改该值。
         */
        Vector3.FORWARD = new Vector3(0.0, 0.0, 1.0);
        /**
         * 后向量。
         * - 请注意不要修改该值。
         */
        Vector3.BACK = new Vector3(0.0, 0.0, -1.0);
        Vector3._instances = [];
        return Vector3;
    }(paper.BaseRelease));
    egret3d.Vector3 = Vector3;
    __reflect(Vector3.prototype, "egret3d.Vector3", ["egret3d.IVector3", "egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
    var _helpVector3 = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3A = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3B = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3C = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3D = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3E = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3F = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3G = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3H = Vector3.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础单例组件。
     * - 全部单例组件的基类。
     */
    var SingletonComponent = (function (_super) {
        __extends(SingletonComponent, _super);
        function SingletonComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @internal
         */
        SingletonComponent.__isSingleton = true;
        return SingletonComponent;
    }(paper.BaseComponent));
    paper.SingletonComponent = SingletonComponent;
    __reflect(SingletonComponent.prototype, "paper.SingletonComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var AnimationBlendType;
    (function (AnimationBlendType) {
        AnimationBlendType[AnimationBlendType["E1D"] = 0] = "E1D";
    })(AnimationBlendType = egret3d.AnimationBlendType || (egret3d.AnimationBlendType = {}));
})(egret3d || (egret3d = {}));
// For keep const enum.
var gltf;
(function (gltf) {
    /**
     * 绘制缓存掩码。
     */
    var BufferMask;
    (function (BufferMask) {
        BufferMask[BufferMask["None"] = 0] = "None";
        BufferMask[BufferMask["Depth"] = 256] = "Depth";
        BufferMask[BufferMask["Stencil"] = 1024] = "Stencil";
        BufferMask[BufferMask["Color"] = 16384] = "Color";
        BufferMask[BufferMask["DepthAndStencil"] = 1280] = "DepthAndStencil";
        BufferMask[BufferMask["DepthAndColor"] = 16640] = "DepthAndColor";
        BufferMask[BufferMask["StencilAndColor"] = 17408] = "StencilAndColor";
        BufferMask[BufferMask["All"] = 17664] = "All";
    })(BufferMask = gltf.BufferMask || (gltf.BufferMask = {}));
    var BlendMode;
    (function (BlendMode) {
        BlendMode[BlendMode["None"] = 0] = "None";
        BlendMode[BlendMode["Blend"] = 1] = "Blend";
        BlendMode[BlendMode["Blend_PreMultiply"] = 2] = "Blend_PreMultiply";
        BlendMode[BlendMode["Additive"] = 3] = "Additive";
        BlendMode[BlendMode["Additive_PreMultiply"] = 4] = "Additive_PreMultiply";
        BlendMode[BlendMode["Subtractive"] = 5] = "Subtractive";
        BlendMode[BlendMode["Subtractive_PreMultiply"] = 6] = "Subtractive_PreMultiply";
        BlendMode[BlendMode["Multiply"] = 7] = "Multiply";
        BlendMode[BlendMode["Multiply_PreMultiply"] = 8] = "Multiply_PreMultiply";
        /**
         * @deprecated
         */
        BlendMode[BlendMode["Add"] = 3] = "Add";
        /**
         * @deprecated
         */
        BlendMode[BlendMode["Add_PreMultiply"] = 4] = "Add_PreMultiply";
    })(BlendMode = gltf.BlendMode || (gltf.BlendMode = {}));
    var BlendEquation;
    (function (BlendEquation) {
        BlendEquation[BlendEquation["Add"] = 32774] = "Add";
        BlendEquation[BlendEquation["Subtract"] = 32778] = "Subtract";
        BlendEquation[BlendEquation["ReverseSubtract"] = 32779] = "ReverseSubtract";
    })(BlendEquation = gltf.BlendEquation || (gltf.BlendEquation = {}));
    var BlendFactor;
    (function (BlendFactor) {
        BlendFactor[BlendFactor["ZERO"] = 0] = "ZERO";
        BlendFactor[BlendFactor["ONE"] = 1] = "ONE";
        BlendFactor[BlendFactor["SRC_COLOR"] = 768] = "SRC_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
        BlendFactor[BlendFactor["DST_COLOR"] = 774] = "DST_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
        BlendFactor[BlendFactor["SRC_ALPHA"] = 770] = "SRC_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
        BlendFactor[BlendFactor["DST_ALPHA"] = 772] = "DST_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
        BlendFactor[BlendFactor["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
        BlendFactor[BlendFactor["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
        BlendFactor[BlendFactor["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    })(BlendFactor = gltf.BlendFactor || (gltf.BlendFactor = {}));
    var CullFace;
    (function (CullFace) {
        CullFace[CullFace["Front"] = 1028] = "Front";
        CullFace[CullFace["Back"] = 1029] = "Back";
        CullFace[CullFace["FrontAndBack"] = 1032] = "FrontAndBack";
    })(CullFace = gltf.CullFace || (gltf.CullFace = {}));
    var FrontFace;
    (function (FrontFace) {
        FrontFace[FrontFace["CW"] = 2304] = "CW";
        FrontFace[FrontFace["CCW"] = 2305] = "CCW";
    })(FrontFace = gltf.FrontFace || (gltf.FrontFace = {}));
})(gltf || (gltf = {}));
var egret3d;
(function (egret3d) {
    /**
     * glTF 资源。
     */
    var GLTFAsset = (function (_super) {
        __extends(GLTFAsset, _super);
        /**
         * 请使用 `T.create()` 创建实例。
         */
        function GLTFAsset(name, config) {
            var _this = _super.call(this, name) || this;
            /**
             * Buffer 列表。
             */
            _this.buffers = [];
            /**
             * 配置。
             */
            _this.config = null;
            _this.config = config;
            return _this;
        }
        /**
         *
         */
        GLTFAsset.getComponentTypeCount = function (type) {
            switch (type) {
                case 5120 /* Byte */:
                case 5121 /* UnsignedByte */:
                    return 1;
                case 5122 /* Short */:
                case 5123 /* UnsignedShort */:
                    return 2;
                case 5124 /* Int */:
                case 5125 /* UnsignedInt */:
                    return 4;
                case 5126 /* Float */:
                    return 4;
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.getAccessorTypeCount = function (type) {
            switch (type) {
                case "SCALAR" /* SCALAR */:
                    return 1;
                case "VEC2" /* VEC2 */:
                    return 2;
                case "VEC3" /* VEC3 */:
                    return 3;
                case "VEC4" /* VEC4 */:
                case "MAT2" /* MAT2 */:
                    return 4;
                case "MAT3" /* MAT3 */:
                    return 9;
                case "MAT4" /* MAT4 */:
                    return 16;
                default:
                    throw new Error();
            }
        };
        /**
         * @private
         */
        GLTFAsset.createConfig = function () {
            var config = {
                version: "4",
                asset: {
                    version: "2.0"
                },
                extensions: {},
                extensionsRequired: ["paper"],
                extensionsUsed: ["paper"],
            };
            return config;
        };
        /**
         * @private
         */
        GLTFAsset.parseFromBinary = function (array) {
            var index = 0;
            var result = { buffers: [] };
            if (array[index++] !== 0x46546C67 ||
                array[index++] !== 2) {
                console.assert(false, "Nonsupport glTF data.");
                return;
            }
            if (array[index++] !== array.byteLength) {
                console.assert(false, "Error glTF data.");
                return;
            }
            var chunkLength = 0;
            var chunkType = 0;
            while (index < array.length) {
                chunkLength = array[index++];
                chunkType = array[index++];
                if (chunkLength % 4) {
                    console.assert(false, "Error glTF data.");
                }
                if (chunkType === 0x4E4F534A) {
                    var jsonArray = new Uint8Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint8Array.BYTES_PER_ELEMENT);
                    var jsonString = egret3d.io.BinReader.utf8ArrayToString(jsonArray);
                    result.config = JSON.parse(jsonString);
                }
                else if (chunkType === 0x004E4942) {
                    var buffer = new Uint32Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint32Array.BYTES_PER_ELEMENT);
                    result.buffers.push(buffer);
                }
                else {
                    console.assert(false, "Nonsupport glTF data.");
                    return;
                }
                index += chunkLength / 4;
            }
            return result;
        };
        GLTFAsset.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this.buffers.length = 0;
            this.config = null;
            return true;
        };
        /**
         *
         */
        GLTFAsset.prototype.updateAccessorTypeCount = function () {
            var accessors = this.config.accessors;
            if (accessors) {
                for (var _i = 0, accessors_1 = accessors; _i < accessors_1.length; _i++) {
                    var accessor = accessors_1[_i];
                    accessor.typeCount = GLTFAsset.getAccessorTypeCount(accessor.type);
                }
            }
            return this;
        };
        /**
         * 根据指定 BufferView 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromBufferView = function (bufferView, componentType) {
            var buffer = this.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0);
            // assert.config.buffers[bufferView.buffer];
            switch (componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int8Array.BYTES_PER_ELEMENT);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint8Array.BYTES_PER_ELEMENT);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int16Array.BYTES_PER_ELEMENT);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int32Array.BYTES_PER_ELEMENT);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint32Array.BYTES_PER_ELEMENT);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Float32Array.BYTES_PER_ELEMENT);
                default:
                    throw new Error();
            }
        };
        /**
         * 根据指定 Accessor 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromAccessor = function (accessor, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var typeCount = accessor.typeCount;
            var bufferCount = typeCount * Math.min(accessor.count - offset, count || accessor.count);
            var bufferView = this.getBufferView(accessor);
            var buffer = this.buffers[bufferView.buffer];
            // assert.config.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
            if (offset > 0) {
                bufferOffset += offset * typeCount * GLTFAsset.getComponentTypeCount(accessor.componentType);
            }
            switch (accessor.componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferCount);
                default:
                    throw new Error();
            }
        };
        /**
         * 通过 Accessor 获取指定 BufferLength。
         */
        GLTFAsset.prototype.getBufferLength = function (accessor) {
            return accessor.typeCount * GLTFAsset.getComponentTypeCount(accessor.componentType) * accessor.count;
        };
        /**
         * 通过 Accessor 获取指定 BufferOffset。
         */
        GLTFAsset.prototype.getBufferOffset = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // const buffer = this.buffers[bufferView.buffer];
            return (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
        };
        /**
         * 通过 Accessor 获取指定 Buffer。
         */
        GLTFAsset.prototype.getBuffer = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // this.config.buffers[bufferView.buffer];
            return this.buffers[bufferView.buffer];
        };
        /**
         * 通过 Accessor 获取指定 BufferView。
         */
        GLTFAsset.prototype.getBufferView = function (accessor) {
            return this.config.bufferViews[accessor.bufferView || 0];
        };
        /**
         * 通过 Accessor 索引，获取指定 Accessor。
         */
        GLTFAsset.prototype.getAccessor = function (index) {
            return this.config.accessors[index];
        };
        /**
         * 获取节点。
         */
        GLTFAsset.prototype.getNode = function (index) {
            return this.config.nodes[index];
        };
        return GLTFAsset;
    }(paper.Asset));
    egret3d.GLTFAsset = GLTFAsset;
    __reflect(GLTFAsset.prototype, "egret3d.GLTFAsset");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _array = [
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
    ];
    /**
     * 4x4 矩阵。
     */
    var Matrix4 = (function (_super) {
        __extends(Matrix4, _super);
        /**
         * 请使用 `egret3d.Matrix4.create()` 创建实例。
         * @see egret3d.Matrix4.create()
         * @deprecated
         */
        function Matrix4(rawData, offsetOrByteOffset) {
            if (offsetOrByteOffset === void 0) { offsetOrByteOffset = 0; }
            var _this = _super.call(this) || this;
            /**
             * 矩阵原始数据。
             * @readonly
             */
            _this.rawData = null;
            if (rawData && rawData instanceof ArrayBuffer) {
                _this.fromBuffer(rawData, offsetOrByteOffset);
            }
            else {
                _this.rawData = new Float32Array(16);
                _this.fromArray(rawData || _array);
            }
            return _this;
        }
        /**
         * 创建一个矩阵。
         * @param rawData
         * @param offsetOrByteOffset
         */
        Matrix4.create = function (rawData, offsetOrByteOffset) {
            if (offsetOrByteOffset === void 0) { offsetOrByteOffset = 0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                if (rawData) {
                    if (rawData instanceof ArrayBuffer) {
                        instance.fromBuffer(rawData, offsetOrByteOffset);
                    }
                    else {
                        instance.fromArray(rawData, offsetOrByteOffset);
                    }
                }
                else {
                    instance.identity();
                }
                return instance;
            }
            return new Matrix4(rawData, offsetOrByteOffset);
        };
        Matrix4.prototype.serialize = function () {
            return this.rawData;
        };
        Matrix4.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Matrix4.prototype.copy = function (value) {
            return this.fromArray(value.rawData);
        };
        Matrix4.prototype.clone = function () {
            return Matrix4.create(this.rawData);
        };
        Matrix4.prototype.set = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var rawData = this.rawData;
            rawData[0] = n11;
            rawData[4] = n12;
            rawData[8] = n13;
            rawData[12] = n14;
            rawData[1] = n21;
            rawData[5] = n22;
            rawData[9] = n23;
            rawData[13] = n24;
            rawData[2] = n31;
            rawData[6] = n32;
            rawData[10] = n33;
            rawData[14] = n34;
            rawData[3] = n41;
            rawData[7] = n42;
            rawData[11] = n43;
            rawData[15] = n44;
            return this;
        };
        /**
         * 将该矩阵转换为恒等矩阵。
         */
        Matrix4.prototype.identity = function () {
            this.rawData[0] = 1.0;
            this.rawData[1] = 0.0;
            this.rawData[2] = 0.0;
            this.rawData[3] = 0.0;
            this.rawData[4] = 0.0;
            this.rawData[5] = 1.0;
            this.rawData[6] = 0.0;
            this.rawData[7] = 0.0;
            this.rawData[8] = 0.0;
            this.rawData[9] = 0.0;
            this.rawData[10] = 1.0;
            this.rawData[11] = 0.0;
            this.rawData[12] = 0.0;
            this.rawData[13] = 0.0;
            this.rawData[14] = 0.0;
            this.rawData[15] = 1.0;
            return this;
        };
        Matrix4.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            for (var i = 0; i < 16; ++i) {
                this.rawData[i] = array[i + offset];
            }
            return this;
        };
        Matrix4.prototype.fromBuffer = function (buffer, byteOffset) {
            if (byteOffset === void 0) { byteOffset = 0; }
            this.rawData = new Float32Array(buffer, byteOffset, 16);
            return this;
        };
        /**
         * 通过平移向量设置该矩阵。
         * @param translate 平移向量。
         * @param rotationAndScaleStays 是否保留该矩阵的旋转和数据。
         */
        Matrix4.prototype.fromTranslate = function (translate, rotationAndScaleStays) {
            if (rotationAndScaleStays === void 0) { rotationAndScaleStays = false; }
            if (!rotationAndScaleStays) {
                this.identity();
            }
            this.rawData[12] = translate.x;
            this.rawData[13] = translate.y;
            this.rawData[14] = translate.z;
            return this;
        };
        /**
         * 通过四元数旋转设置该矩阵。
         * @param rotation 四元数旋转。
         * @param translateStays 是否保留该矩阵的平移数据。
         */
        Matrix4.prototype.fromRotation = function (rotation, translateStays) {
            if (translateStays === void 0) { translateStays = false; }
            return this.compose(translateStays ? _helpVector3A.fromArray(this.rawData, 12) : egret3d.Vector3.ZERO, rotation, egret3d.Vector3.ONE);
        };
        /**
         * 通过欧拉旋转设置该矩阵。
         * @param euler 欧拉旋转。
         * @param order 欧拉旋转顺序。
         * @param translateStays 是否保留该矩阵的平移数据。
         */
        Matrix4.prototype.fromEuler = function (euler, order, translateStays) {
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            if (order === void 0) { order = 2 /* YXZ */; }
            if (translateStays === void 0) { translateStays = false; }
            var cos = Math.cos;
            var sin = Math.sin;
            var x = euler.x, y = euler.y, z = euler.z;
            var a = cos(x), b = sin(x);
            var c = cos(y), d = sin(y);
            var e = cos(z), f = sin(z);
            var rawData = this.rawData;
            switch (order) {
                case 0 /* XYZ */: {
                    var ae = a * e, af = a * f, be = b * e, bf = b * f;
                    rawData[0] = c * e;
                    rawData[4] = -c * f;
                    rawData[8] = d;
                    rawData[1] = af + be * d;
                    rawData[5] = ae - bf * d;
                    rawData[9] = -b * c;
                    rawData[2] = bf - ae * d;
                    rawData[6] = be + af * d;
                    rawData[10] = a * c;
                    break;
                }
                case 1 /* XZY */: {
                    var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                    rawData[0] = c * e;
                    rawData[4] = -f;
                    rawData[8] = d * e;
                    rawData[1] = ac * f + bd;
                    rawData[5] = a * e;
                    rawData[9] = ad * f - bc;
                    rawData[2] = bc * f - ad;
                    rawData[6] = b * e;
                    rawData[10] = bd * f + ac;
                    break;
                }
                case 2 /* YXZ */: {
                    var ce = c * e, cf = c * f, de = d * e, df = d * f;
                    rawData[0] = ce + df * b;
                    rawData[4] = de * b - cf;
                    rawData[8] = a * d;
                    rawData[1] = a * f;
                    rawData[5] = a * e;
                    rawData[9] = -b;
                    rawData[2] = cf * b - de;
                    rawData[6] = df + ce * b;
                    rawData[10] = a * c;
                    break;
                }
                case 3 /* YZX */: {
                    var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                    rawData[0] = c * e;
                    rawData[4] = bd - ac * f;
                    rawData[8] = bc * f + ad;
                    rawData[1] = f;
                    rawData[5] = a * e;
                    rawData[9] = -b * e;
                    rawData[2] = -d * e;
                    rawData[6] = ad * f + bc;
                    rawData[10] = ac - bd * f;
                    break;
                }
                case 4 /* ZXY */: {
                    var ce = c * e, cf = c * f, de = d * e, df = d * f;
                    rawData[0] = ce - df * b;
                    rawData[4] = -a * f;
                    rawData[8] = de + cf * b;
                    rawData[1] = cf + de * b;
                    rawData[5] = a * e;
                    rawData[9] = df - ce * b;
                    rawData[2] = -a * d;
                    rawData[6] = b;
                    rawData[10] = a * c;
                    break;
                }
                case 5 /* ZYX */: {
                    var ae = a * e, af = a * f, be = b * e, bf = b * f;
                    rawData[0] = c * e;
                    rawData[4] = be * d - af;
                    rawData[8] = ae * d + bf;
                    rawData[1] = c * f;
                    rawData[5] = bf * d + ae;
                    rawData[9] = af * d - be;
                    rawData[2] = -d;
                    rawData[6] = b * c;
                    rawData[10] = a * c;
                    break;
                }
            }
            // bottom row
            rawData[3] = 0.0;
            rawData[7] = 0.0;
            rawData[11] = 0.0;
            if (!translateStays) {
                // last column
                rawData[12] = 0.0;
                rawData[13] = 0.0;
                rawData[14] = 0.0;
                rawData[15] = 1.0;
            }
            return this;
        };
        /**
         * 通过缩放向量设置该矩阵。
         * @param scale 缩放向量。
         * @param translateStays 是否保留该矩阵的平移数据。
         */
        Matrix4.prototype.fromScale = function (scale, translateStays) {
            if (translateStays === void 0) { translateStays = false; }
            if (translateStays) {
                _helpVector3A.fromArray(this.rawData, 12);
            }
            this.identity();
            this.rawData[0] = scale.x;
            this.rawData[5] = scale.y;
            this.rawData[10] = scale.z;
            if (translateStays) {
                this.rawData[12] = _helpVector3A.x;
                this.rawData[13] = _helpVector3A.y;
                this.rawData[14] = _helpVector3A.z;
            }
            return this;
        };
        /**
         * 通过绕 X 轴的旋转角度设置该矩阵。
         * @param angle 旋转角。（弧度制）
         */
        Matrix4.prototype.fromRotationX = function (angle) {
            var c = Math.cos(angle), s = Math.sin(angle);
            return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        };
        /**
         * 通过绕 Y 轴的旋转角度设置该矩阵。
         * @param theta 旋转角。（弧度制）
         */
        Matrix4.prototype.fromRotationY = function (theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        };
        /**
         * 通过绕 Z 轴的旋转角度设置该矩阵。
         * @param theta 旋转角。（弧度制）
         */
        Matrix4.prototype.fromRotationZ = function (theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        };
        /**
         * 通过旋转轴设置该矩阵。
         * - 假设旋转轴已被归一化。
         * @param axis 旋转轴。
         * @param angle 旋转角。（弧度制）
         */
        Matrix4.prototype.fromAxis = function (axis, angle) {
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var t = 1.0 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
            return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0.0, tx * y + s * z, ty * y + c, ty * z - s * x, 0.0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0.0, 0.0, 0.0, 0.0, 1.0);
        };
        Matrix4.prototype.fromProjection = function (fov, near, far, size, opvalue, asp, matchFactor) {
            var orthographicMatrix = _helpMatrix;
            matchFactor = 1.0 - matchFactor;
            if (opvalue > 0.0) {
                var tan = Math.tan(fov * 0.5);
                var topX = near * tan;
                var heightX = 2.0 * topX;
                var widthX = asp * heightX;
                var leftX = -0.5 * widthX;
                var leftY = -near * tan;
                var widthY = 2.0 * -leftY;
                var heightY = widthY / asp;
                var topY = 0.5 * heightY;
                var top_1 = topX + (topY - topX) * matchFactor;
                var left = leftX + (leftY - leftX) * matchFactor;
                var width = widthX + (widthY - widthX) * matchFactor;
                var height = heightX + (heightY - heightX) * matchFactor;
                Matrix4._perspectiveProjectMatrix(left, left + width, top_1, top_1 - height, near, far, this);
            }
            if (opvalue < 1.0) {
                var widthX = size * asp;
                var heightX = size;
                var widthY = size;
                var heightY = size / asp;
                var width = widthX + (widthY - widthX) * matchFactor;
                var height = heightX + (heightY - heightX) * matchFactor;
                Matrix4.orthographicProjectLH(width, height, near, far, orthographicMatrix);
            }
            if (opvalue === 0.0) {
                this.copy(orthographicMatrix);
            }
            else if (opvalue === 1.0) {
                // this;
            }
            else {
                this.lerp(orthographicMatrix, this, opvalue);
            }
            return this;
        };
        /**
         * 通过 X、Y、Z 轴设置该矩阵。
         * @param axisX X 轴。
         * @param axisY Y 轴。
         * @param axisZ Z 轴。
         */
        Matrix4.prototype.fromAxises = function (axisX, axisY, axisZ) {
            return this.set(axisX.x, axisY.x, axisZ.x, 0.0, axisX.y, axisY.y, axisZ.y, 0.0, axisX.z, axisY.z, axisZ.z, 0.0, 0.0, 0.0, 0.0, 1.0);
        };
        /**
         * 通过平移向量、四元数旋转、缩放向量设置该矩阵。
         * @param translation 平移向量。
         * @param rotation 四元数旋转。
         * @param scale 缩放向量。
         */
        Matrix4.prototype.compose = function (translation, rotation, scale) {
            var rX = rotation.x, rY = rotation.y, rZ = rotation.z, rW = rotation.w;
            var sX = scale.x, sY = scale.y, sZ = scale.z;
            var x2 = rX + rX, y2 = rY + rY, z2 = rZ + rZ;
            var xx = rX * x2, xy = rX * y2, xz = rX * z2;
            var yy = rY * y2, yz = rY * z2, zz = rZ * z2;
            var wx = rW * x2, wy = rW * y2, wz = rW * z2;
            var rawData = this.rawData;
            rawData[0] = (1.0 - (yy + zz)) * sX;
            rawData[1] = (xy + wz) * sX;
            rawData[2] = (xz - wy) * sX;
            rawData[4] = (xy - wz) * sY;
            rawData[5] = (1.0 - (xx + zz)) * sY;
            rawData[6] = (yz + wx) * sY;
            rawData[8] = (xz + wy) * sZ;
            rawData[9] = (yz - wx) * sZ;
            rawData[10] = (1.0 - (xx + yy)) * sZ;
            rawData[12] = translation.x;
            rawData[13] = translation.y;
            rawData[14] = translation.z;
            rawData[3] = rawData[7] = rawData[11] = 0.0, rawData[15] = 1.0;
            return this;
        };
        /**
         * 将该矩阵分解为平移向量、四元数旋转、缩放向量。
         * @param translation 平移向量。
         * @param rotation 四元数旋转。
         * @param scale 缩放向量。
         */
        Matrix4.prototype.decompose = function (translation, rotation, scale) {
            if (translation === void 0) { translation = null; }
            if (rotation === void 0) { rotation = null; }
            if (scale === void 0) { scale = null; }
            var rawData = this.rawData;
            if (translation) {
                translation.x = rawData[12];
                translation.y = rawData[13];
                translation.z = rawData[14];
            }
            if (rotation || scale) {
                var helpVector3A_1 = _helpVector3A;
                var sx = helpVector3A_1.set(rawData[0], rawData[1], rawData[2]).length;
                var sy = helpVector3A_1.set(rawData[4], rawData[5], rawData[6]).length;
                var sz = helpVector3A_1.set(rawData[8], rawData[9], rawData[10]).length;
                // if determine is negative, we need to invert one scale
                var det = this.determinant;
                if (det < 0.0)
                    sx = -sx;
                if (rotation) {
                    // scale the rotation part
                    var helpMatrix = _helpMatrix;
                    helpMatrix.copy(this);
                    var invSX = 1.0 / sx;
                    var invSY = 1.0 / sy;
                    var invSZ = 1.0 / sz;
                    helpMatrix.rawData[0] *= invSX;
                    helpMatrix.rawData[1] *= invSX;
                    helpMatrix.rawData[2] *= invSX;
                    helpMatrix.rawData[4] *= invSY;
                    helpMatrix.rawData[5] *= invSY;
                    helpMatrix.rawData[6] *= invSY;
                    helpMatrix.rawData[8] *= invSZ;
                    helpMatrix.rawData[9] *= invSZ;
                    helpMatrix.rawData[10] *= invSZ;
                    rotation.fromMatrix(helpMatrix);
                }
                if (scale) {
                    scale.x = sx;
                    scale.y = sy;
                    scale.z = sz;
                }
            }
            return this;
        };
        Matrix4.prototype.extractRotation = function (input) {
            if (!input) {
                input = this;
            }
            var rawData = this.rawData;
            var inputRawData = input.rawData;
            var helpVector = _helpVector3A;
            var scaleX = 1.0 / helpVector.fromMatrixColumn(input, 0).length;
            var scaleY = 1.0 / helpVector.fromMatrixColumn(input, 1).length;
            var scaleZ = 1.0 / helpVector.fromMatrixColumn(input, 2).length;
            rawData[0] = inputRawData[0] * scaleX;
            rawData[1] = inputRawData[1] * scaleX;
            rawData[2] = inputRawData[2] * scaleX;
            rawData[3] = 0.0;
            rawData[4] = inputRawData[4] * scaleY;
            rawData[5] = inputRawData[5] * scaleY;
            rawData[6] = inputRawData[6] * scaleY;
            rawData[7] = 0.0;
            rawData[8] = inputRawData[8] * scaleZ;
            rawData[9] = inputRawData[9] * scaleZ;
            rawData[10] = inputRawData[10] * scaleZ;
            rawData[11] = 0.0;
            rawData[12] = 0.0;
            rawData[13] = 0.0;
            rawData[14] = 0.0;
            rawData[15] = 1.0;
            return this;
        };
        Matrix4.prototype.transpose = function (input) {
            if (!input) {
                input = this;
            }
            var inputRawData = input.rawData;
            var rawData = this.rawData;
            var temp = 0.0;
            temp = inputRawData[1];
            rawData[1] = inputRawData[4];
            rawData[4] = temp;
            temp = inputRawData[2];
            rawData[2] = inputRawData[8];
            rawData[8] = temp;
            temp = inputRawData[6];
            rawData[6] = inputRawData[9];
            rawData[9] = temp;
            temp = inputRawData[3];
            rawData[3] = inputRawData[12];
            rawData[12] = temp;
            temp = inputRawData[7];
            rawData[7] = inputRawData[13];
            rawData[13] = temp;
            temp = inputRawData[11];
            rawData[11] = inputRawData[14];
            rawData[14] = temp;
            return this;
        };
        Matrix4.prototype.inverse = function (input) {
            if (!input) {
                input = this;
            }
            var valueRawData = input.rawData;
            var rawData = this.rawData;
            var n11 = valueRawData[0], n21 = valueRawData[1], n31 = valueRawData[2], n41 = valueRawData[3], n12 = valueRawData[4], n22 = valueRawData[5], n32 = valueRawData[6], n42 = valueRawData[7], n13 = valueRawData[8], n23 = valueRawData[9], n33 = valueRawData[10], n43 = valueRawData[11], n14 = valueRawData[12], n24 = valueRawData[13], n34 = valueRawData[14], n44 = valueRawData[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0.0) {
                console.warn("Cannot invert matrix, determinant is 0.");
                return this.identity();
            }
            var detInv = 1.0 / det;
            rawData[0] = t11 * detInv;
            rawData[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            rawData[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            rawData[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            rawData[4] = t12 * detInv;
            rawData[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            rawData[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            rawData[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            rawData[8] = t13 * detInv;
            rawData[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            rawData[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            rawData[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            rawData[12] = t14 * detInv;
            rawData[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            rawData[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            rawData[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        };
        Matrix4.prototype.multiplyScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            var sourceRawData = input.rawData;
            var rawData = this.rawData;
            rawData[0] = sourceRawData[0] * scalar;
            rawData[1] = sourceRawData[1] * scalar;
            rawData[2] = sourceRawData[2] * scalar;
            rawData[3] = sourceRawData[3] * scalar;
            rawData[4] = sourceRawData[4] * scalar;
            rawData[5] = sourceRawData[5] * scalar;
            rawData[6] = sourceRawData[6] * scalar;
            rawData[7] = sourceRawData[7] * scalar;
            rawData[8] = sourceRawData[8] * scalar;
            rawData[9] = sourceRawData[9] * scalar;
            rawData[10] = sourceRawData[10] * scalar;
            rawData[11] = sourceRawData[11] * scalar;
            rawData[12] = sourceRawData[12] * scalar;
            rawData[13] = sourceRawData[13] * scalar;
            rawData[14] = sourceRawData[14] * scalar;
            rawData[15] = sourceRawData[15] * scalar;
            return this;
        };
        Matrix4.prototype.multiply = function (matrixA, matrixB) {
            if (!matrixB) {
                matrixB = matrixA;
                matrixA = this;
            }
            var rawDataA = matrixA.rawData;
            var rawDataB = matrixB.rawData;
            var rawData = this.rawData;
            var a11 = rawDataA[0], a12 = rawDataA[4], a13 = rawDataA[8], a14 = rawDataA[12];
            var a21 = rawDataA[1], a22 = rawDataA[5], a23 = rawDataA[9], a24 = rawDataA[13];
            var a31 = rawDataA[2], a32 = rawDataA[6], a33 = rawDataA[10], a34 = rawDataA[14];
            var a41 = rawDataA[3], a42 = rawDataA[7], a43 = rawDataA[11], a44 = rawDataA[15];
            var b11 = rawDataB[0], b12 = rawDataB[4], b13 = rawDataB[8], b14 = rawDataB[12];
            var b21 = rawDataB[1], b22 = rawDataB[5], b23 = rawDataB[9], b24 = rawDataB[13];
            var b31 = rawDataB[2], b32 = rawDataB[6], b33 = rawDataB[10], b34 = rawDataB[14];
            var b41 = rawDataB[3], b42 = rawDataB[7], b43 = rawDataB[11], b44 = rawDataB[15];
            rawData[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            rawData[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            rawData[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            rawData[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            rawData[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            rawData[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            rawData[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            rawData[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            rawData[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            rawData[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            rawData[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            rawData[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            rawData[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            rawData[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            rawData[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            rawData[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        };
        /**
         * 将一个矩阵与该矩阵相乘的结果写入该矩阵。
         * - v = matrix * v
         * @param matrix 一个矩阵。
         */
        Matrix4.prototype.premultiply = function (matrix) {
            return this.multiply(matrix, this);
        };
        Matrix4.prototype.lerp = function (p1, p2, p3) {
            if (typeof p2 === "number") {
                p3 = p2;
                p2 = p1;
                p1 = this;
            }
            if (p3 === 0.0) {
                for (var i = 0; i < 16; i++) {
                    this.rawData[i] = p1.rawData[i];
                }
                return this;
            }
            else if (p3 === 1.0) {
                for (var i = 0; i < 16; i++) {
                    this.rawData[i] = p2.rawData[i];
                }
                return this;
            }
            for (var i = 0; i < 16; i++) {
                var fV = p1.rawData[i];
                this.rawData[i] = fV + (p2.rawData[i] - fV) * p3;
            }
            return this;
        };
        /**
         * 设置该矩阵，使其 Z 轴正方向与起始点到目标点的方向相一致。
         * - 矩阵的缩放值将被覆盖。
         * @param from 起始点。
         * @param to 目标点。
         * @param up
         */
        Matrix4.prototype.lookAt = function (from, to, up) {
            this.lookRotation(_helpVector3C.subtract(to, from), up);
            return this;
        };
        /**
         * 设置该矩阵，使其 Z 轴正方向与目标方向相一致。
         * - 矩阵的缩放值将被覆盖。
         * @param vector 目标方向。
         * @param up
         */
        Matrix4.prototype.lookRotation = function (vector, up) {
            var z = _helpVector3C.normalize(vector);
            var x = _helpVector3A.cross(up, z).normalize(_helpVector3A, egret3d.Vector3.RIGHT);
            var y = _helpVector3B.cross(z, x);
            var rawData = this.rawData;
            rawData[0] = x.x;
            rawData[4] = y.x;
            rawData[8] = z.x;
            rawData[1] = x.y;
            rawData[5] = y.y;
            rawData[9] = z.y;
            rawData[2] = x.z;
            rawData[6] = y.z;
            rawData[10] = z.z;
            return this;
        };
        /**
         * 将该旋转矩阵转换为数组。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Matrix4.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            for (var i = 0; i < 16; ++i) {
                array[i + offset] = this.rawData[i];
            }
            return array;
        };
        /**
         * 将该旋转矩阵转换为欧拉旋转。
         * @param euler 欧拉旋转。（弧度制）
         * @param order 欧拉旋转顺序。
         */
        Matrix4.prototype.toEuler = function (euler, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            if (!euler) {
                euler = egret3d.Vector3.create();
            }
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var rawData = this.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            switch (order) {
                case 0 /* XYZ */: {
                    euler.y = Math.asin(egret3d.math.clamp(m13, -1.0, 1.0));
                    if (Math.abs(m13) < 0.999999) {
                        euler.x = Math.atan2(-m23, m33);
                        euler.z = Math.atan2(-m12, m11);
                    }
                    else {
                        euler.x = Math.atan2(m32, m22);
                        euler.z = 0.0;
                    }
                    break;
                }
                case 1 /* XZY */: {
                    euler.z = Math.asin(-egret3d.math.clamp(m12, -1.0, 1.0));
                    if (Math.abs(m12) < 0.999999) {
                        euler.x = Math.atan2(m32, m22);
                        euler.y = Math.atan2(m13, m11);
                    }
                    else {
                        euler.x = Math.atan2(-m23, m33);
                        euler.y = 0.0;
                    }
                    break;
                }
                case 2 /* YXZ */: {
                    euler.x = Math.asin(-egret3d.math.clamp(m23, -1.0, 1.0));
                    if (Math.abs(m23) < 0.999999) {
                        euler.y = Math.atan2(m13, m33);
                        euler.z = Math.atan2(m21, m22);
                    }
                    else {
                        euler.y = Math.atan2(-m31, m11);
                        euler.z = 0.0;
                    }
                    break;
                }
                case 3 /* YZX */: {
                    euler.z = Math.asin(egret3d.math.clamp(m21, -1.0, 1.0));
                    if (Math.abs(m21) < 0.999999) {
                        euler.x = Math.atan2(-m23, m22);
                        euler.y = Math.atan2(-m31, m11);
                    }
                    else {
                        euler.x = 0.0;
                        euler.y = Math.atan2(m13, m33);
                    }
                    break;
                }
                case 4 /* ZXY */: {
                    euler.x = Math.asin(egret3d.math.clamp(m32, -1.0, 1.0));
                    if (Math.abs(m32) < 0.999999) {
                        euler.y = Math.atan2(-m31, m33);
                        euler.z = Math.atan2(-m12, m22);
                    }
                    else {
                        euler.y = 0.0;
                        euler.z = Math.atan2(m21, m11);
                    }
                    break;
                }
                case 5 /* ZYX */: {
                    euler.y = Math.asin(-egret3d.math.clamp(m31, -1.0, 1.0));
                    if (Math.abs(m31) < 0.999999) {
                        euler.x = Math.atan2(m32, m33);
                        euler.z = Math.atan2(m21, m11);
                    }
                    else {
                        euler.x = 0.0;
                        euler.z = Math.atan2(-m12, m22);
                    }
                    break;
                }
            }
            return euler;
        };
        Object.defineProperty(Matrix4.prototype, "determinant", {
            /**
             * 获取该矩阵的行列式。
             * - 该值是实时计算的。
             */
            get: function () {
                var rawData = this.rawData;
                var n11 = rawData[0], n12 = rawData[4], n13 = rawData[8], n14 = rawData[12];
                var n21 = rawData[1], n22 = rawData[5], n23 = rawData[9], n24 = rawData[13];
                var n31 = rawData[2], n32 = rawData[6], n33 = rawData[10], n34 = rawData[14];
                var n41 = rawData[3], n42 = rawData[7], n43 = rawData[11], n44 = rawData[15];
                //TODO: make this more efficient
                //( based on https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js )
                return (n41 * (+n14 * n23 * n32
                    - n13 * n24 * n32
                    - n14 * n22 * n33
                    + n12 * n24 * n33
                    + n13 * n22 * n34
                    - n12 * n23 * n34) +
                    n42 * (+n11 * n23 * n34
                        - n11 * n24 * n33
                        + n14 * n21 * n33
                        - n13 * n21 * n34
                        + n13 * n24 * n31
                        - n14 * n23 * n31) +
                    n43 * (+n11 * n24 * n32
                        - n11 * n22 * n34
                        - n14 * n21 * n32
                        + n12 * n21 * n34
                        + n14 * n22 * n31
                        - n12 * n24 * n31) +
                    n44 * (-n13 * n22 * n31
                        - n11 * n23 * n32
                        + n11 * n22 * n33
                        + n13 * n21 * n32
                        - n12 * n21 * n33
                        + n12 * n23 * n31));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4.prototype, "maxScaleOnAxis", {
            /**
             * 获取该矩阵的最大缩放值。
             * - 该值是实时计算的。
             */
            get: function () {
                var rawData = this.rawData;
                var scaleXSq = rawData[0] * rawData[0] + rawData[1] * rawData[1] + rawData[2] * rawData[2];
                var scaleYSq = rawData[4] * rawData[4] + rawData[5] * rawData[5] + rawData[6] * rawData[6];
                var scaleZSq = rawData[8] * rawData[8] + rawData[9] * rawData[9] + rawData[10] * rawData[10];
                return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Matrix4.prototype.transformVector3 = function (value, out) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]) + this.rawData[12];
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]) + this.rawData[13];
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]) + this.rawData[14];
            var w = (value.x * this.rawData[3]) + (value.y * this.rawData[7]) + (value.z * this.rawData[11]) + this.rawData[15];
            if (!out) {
                out = value;
            }
            out.x = x / w;
            out.y = y / w;
            out.z = z / w;
            return out;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.transformNormal = function (value, out) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]);
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]);
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]);
            if (!out) {
                out = value;
            }
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        Matrix4._perspectiveProjectMatrix = function (left, right, top, bottom, near, far, out) {
            var iDeltaZ = 1.0 / (near - far);
            var doubleNear = 2.0 * near;
            out.rawData[0] = doubleNear / (right - left);
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = doubleNear / (top - bottom);
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = (far + near) * -iDeltaZ;
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = doubleNear * far * iDeltaZ;
            return out;
        };
        Matrix4.orthographicProjectLH = function (width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 2.0 / (zfar - znear);
            var nid = (znear + zfar) / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
            return out;
        };
        /**
         * 一个静态的恒等矩阵。
         * - 请注意不要修改该值。
         */
        Matrix4.IDENTITY = new Matrix4();
        Matrix4._instances = [];
        return Matrix4;
    }(paper.BaseRelease));
    egret3d.Matrix4 = Matrix4;
    __reflect(Matrix4.prototype, "egret3d.Matrix4", ["paper.ICCS", "paper.ISerializable"]);
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixA = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixB = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixC = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixD = Matrix4.create();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 三角形。
     */
    var Triangle = (function (_super) {
        __extends(Triangle, _super);
        /**
         * 请使用 `egret3d.Triangle.create()` 创建实例。
         * @see egret3d.Triangle.create()
         */
        function Triangle() {
            var _this = _super.call(this) || this;
            /**
             * 点 A。
             */
            _this.a = egret3d.Vector3.create();
            /**
             * 点 B。
             */
            _this.b = egret3d.Vector3.create();
            /**
             * 点 C。
             */
            _this.c = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个三角形实例。
         * -   a
         * -  /·\
         * - b - c
         * @param a 点 A。
         * @param b 点 B。
         * @param c 点 C。
         */
        Triangle.create = function (a, b, c) {
            if (a === void 0) { a = egret3d.Vector3.ZERO; }
            if (b === void 0) { b = egret3d.Vector3.ZERO; }
            if (c === void 0) { c = egret3d.Vector3.ZERO; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(a, b, c);
                instance._released = false;
                return instance;
            }
            return new Triangle().set(a, b, c);
        };
        /**
         * 通过三个点确定一个三角形，获取该三角形的法线。
         * -   a
         * -  /·\
         * - b - c
         * @param a 点 A。
         * @param b 点 B。
         * @param c 点 C。
         * @param out 法线结果。
         */
        Triangle.getNormal = function (a, b, c, out) {
            out.subtract(c, a);
            out.cross(egret3d.helpVector3A.subtract(b, a));
            var squaredLength = out.squaredLength;
            if (squaredLength > 0.0) {
                return out.multiplyScalar(1.0 / Math.sqrt(squaredLength));
            }
            return out.set(0.0, 0.0, 1.0);
        };
        Triangle.prototype.serialize = function () {
            return [
                this.a.x, this.a.y, this.a.z,
                this.b.x, this.b.y, this.b.z,
                this.c.x, this.c.y, this.c.z,
            ];
        };
        Triangle.prototype.deserialize = function (element) {
            return this.fromArray(element);
        };
        Triangle.prototype.copy = function (value) {
            return this.set(value.a, value.b, value.c);
        };
        Triangle.prototype.clone = function () {
            return Triangle.create(this.a, this.b, this.c);
        };
        Triangle.prototype.set = function (a, b, c) {
            if (a === void 0) { a = egret3d.Vector3.ZERO; }
            if (b === void 0) { b = egret3d.Vector3.ZERO; }
            if (c === void 0) { c = egret3d.Vector3.ZERO; }
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        };
        Triangle.prototype.fromArray = function (array, offsetA, offsetB, offsetC) {
            if (offsetA === undefined) {
                offsetA = 0;
            }
            this.a.fromArray(array, offsetA);
            this.b.fromArray(array, offsetB !== undefined ? offsetB : offsetA + 3);
            this.c.fromArray(array, offsetC !== undefined ? offsetC : offsetA + 6);
        };
        /**
         * 获取该三角形的中心点。
         * @param out 输出。
         */
        Triangle.prototype.getCenter = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.add(this.a, this.b).add(this.c).multiplyScalar(1.0 / 3.0);
        };
        /**
         * 获取该三角形的法线。
         * @param out 输出。
         */
        Triangle.prototype.getNormal = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return Triangle.getNormal(this.a, this.b, this.c, out);
        };
        /**
         *
         * @param u
         * @param v
         * @param out
         */
        Triangle.prototype.getPointAt = function (u, v, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            out.x = egret3d.math.lerp(this.a.x, this.c.x, u) + egret3d.math.lerp(0.0, this.b.x - this.a.x, v);
            out.y = egret3d.math.lerp(this.a.y, this.b.y, v) + egret3d.math.lerp(0.0, this.c.y - this.a.y, u);
            out.z = egret3d.math.lerp(this.a.z, this.c.z, u) + egret3d.math.lerp(0.0, this.b.z - this.a.z, v);
            return out;
        };
        /**
         * 获取一个点到该三角形的最近点。
         * @param point 一个点。
         * @param out 最近点。
         */
        Triangle.prototype.getClosestPointToPoint = function (point, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            var vab = egret3d.helpVector3A;
            var vac = egret3d.helpVector3B;
            var vbc = egret3d.helpVector3C;
            var vap = egret3d.helpVector3D;
            var vbp = egret3d.helpVector3E;
            var vcp = egret3d.helpVector3F;
            var a = this.a, b = this.b, c = this.c;
            var v, w;
            // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
            // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
            // under the accompanying license; see chapter 5.1.5 for detailed explanation.
            // basically, we're distinguishing which of the voronoi regions of the triangle
            // the point lies in with the minimum amount of redundant computation.
            vab.subtract(b, a);
            vac.subtract(c, a);
            vap.subtract(point, a);
            var d1 = vab.dot(vap);
            var d2 = vac.dot(vap);
            if (d1 <= 0 && d2 <= 0) {
                // vertex region of A; barycentric coords (1, 0, 0)
                return out.copy(a);
            }
            vbp.subtract(point, b);
            var d3 = vab.dot(vbp);
            var d4 = vac.dot(vbp);
            if (d3 >= 0 && d4 <= d3) {
                // vertex region of B; barycentric coords (0, 1, 0)
                return out.copy(b);
            }
            var vc = d1 * d4 - d3 * d2;
            if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                v = d1 / (d1 - d3);
                // edge region of AB; barycentric coords (1-v, v, 0)
                return out.multiplyScalar(v, vab).add(a);
            }
            vcp.subtract(point, c);
            var d5 = vab.dot(vcp);
            var d6 = vac.dot(vcp);
            if (d6 >= 0 && d5 <= d6) {
                // vertex region of C; barycentric coords (0, 0, 1)
                return out.copy(c);
            }
            var vb = d5 * d2 - d1 * d6;
            if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                w = d2 / (d2 - d6);
                // edge region of AC; barycentric coords (1-w, 0, w)
                return out.multiplyScalar(w, vac).add(a);
            }
            var va = d3 * d6 - d5 * d4;
            if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                vbc.subtract(c, b);
                w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                // edge region of BC; barycentric coords (0, 1-w, w)
                return out.multiplyScalar(w, vbc).add(b); // edge region of BC
            }
            // face region
            var denom = 1.0 / (va + vb + vc);
            // u = va * denom
            v = vb * denom;
            w = vc * denom;
            return out.add(a, vac.multiplyScalar(w).add(vab.multiplyScalar(v)));
        };
        Triangle.prototype.raycast = function (ray, raycastInfo) {
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
            var edge1 = egret3d.helpVector3A;
            var edge2 = egret3d.helpVector3B;
            var diff = egret3d.helpVector3C;
            var normal = egret3d.helpVector3D;
            var rayDirection = ray.direction;
            var rayOrigin = ray.origin;
            var pA = this.a;
            var pB = this.b;
            var pC = this.c;
            edge1.subtract(pC, pA);
            edge2.subtract(pB, pA);
            normal.cross(edge1, edge2);
            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = rayDirection.dot(normal);
            var sign = 1.0;
            if (DdN > 0.0) {
                if (!raycastInfo || raycastInfo.backfaceCulling)
                    return false;
            }
            else if (DdN < 0.0) {
                sign = -1.0;
                DdN = -DdN;
            }
            else {
                return false;
            }
            diff.subtract(rayOrigin, pA);
            var DdQxE2 = sign * rayDirection.dot(edge2.cross(diff, edge2));
            // b1 < 0, no intersection
            if (DdQxE2 < 0.0) {
                return false;
            }
            var DdE1xQ = sign * rayDirection.dot(edge1.cross(diff));
            // b2 < 0, no intersection
            if (DdE1xQ < 0.0) {
                return false;
            }
            // b1+b2 > 1, no intersection
            if (DdQxE2 + DdE1xQ > DdN) {
                return false;
            }
            // Line intersects triangle, check if ray does.
            var QdN = -sign * diff.dot(normal);
            // t < 0, no intersection
            if (QdN < 0.0) {
                return false;
            }
            if (raycastInfo) {
                DdN = 1.0 / DdN;
                raycastInfo.coord.x = DdQxE2 * DdN;
                raycastInfo.coord.y = DdE1xQ * DdN;
                ray.getPointAt(raycastInfo.distance = QdN * DdN, raycastInfo.position);
                if (raycastInfo.normal) {
                    raycastInfo.normal.copy(normal);
                }
            }
            return true;
        };
        Object.defineProperty(Triangle.prototype, "area", {
            /**
             * 获取该三角形的面积。
             * - 该值是实时计算的。
             */
            get: function () {
                egret3d.helpVector3A.subtract(this.c, this.a);
                egret3d.helpVector3B.subtract(this.b, this.a);
                return egret3d.helpVector3A.cross(egret3d.helpVector3B).length * 0.5;
            },
            enumerable: true,
            configurable: true
        });
        Triangle._instances = [];
        return Triangle;
    }(paper.BaseRelease));
    egret3d.Triangle = Triangle;
    __reflect(Triangle.prototype, "egret3d.Triangle", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础渲染组件。
     */
    var BaseRenderer = (function (_super) {
        __extends(BaseRenderer, _super);
        function BaseRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 该组件是否开启视锥剔除。
             */
            _this.frustumCulled = true;
            /**
             * @internal
             */
            _this._localBoundingBoxDirty = true;
            _this._boundingSphereDirty = true;
            _this._receiveShadows = false;
            _this._castShadows = false;
            _this._boundingSphere = egret3d.Sphere.create();
            _this._localBoundingBox = egret3d.Box.create();
            _this._materials = [egret3d.DefaultMaterials.MESH_BASIC.retain()];
            return _this;
        }
        BaseRenderer.prototype._recalculateSphere = function () {
            var localBoundingBox = this.localBoundingBox; // Update localBoundingBox.
            var worldMatrix = this.gameObject.transform.localToWorldMatrix;
            this._boundingSphere.set(localBoundingBox.center, localBoundingBox.boundingSphereRadius);
            this._boundingSphere.center.applyMatrix(worldMatrix);
            this._boundingSphere.radius *= worldMatrix.maxScaleOnAxis;
        };
        BaseRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.gameObject.transform.registerObserver(this);
        };
        BaseRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            for (var _i = 0, _a = this._materials; _i < _a.length; _i++) {
                var material = _a[_i];
                if (material) {
                    material.release();
                }
            }
            this._materials.length = 0;
        };
        BaseRenderer.prototype.onTransformChange = function () {
            this._boundingSphereDirty = true;
        };
        Object.defineProperty(BaseRenderer.prototype, "receiveShadows", {
            /**
             * 该组件是否接收投影。
             */
            get: function () {
                return this._receiveShadows;
            },
            set: function (value) {
                if (value === this._receiveShadows) {
                    return;
                }
                this._receiveShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "castShadows", {
            /**
             * 该组件是否产生投影。
             */
            get: function () {
                return this._castShadows;
            },
            set: function (value) {
                if (value === this._castShadows) {
                    return;
                }
                this._castShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "localBoundingBox", {
            /**
             * 该组件的本地包围盒。
             */
            get: function () {
                if (this._localBoundingBoxDirty) {
                    this.recalculateLocalBox();
                    this._localBoundingBoxDirty = false;
                }
                return this._localBoundingBox;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "boundingSphere", {
            /**
             * 基于该组件本地包围盒生成的世界包围球，用于摄像机视锥剔除。
             */
            get: function () {
                if (this._boundingSphereDirty) {
                    this._recalculateSphere();
                    this._boundingSphereDirty = false;
                }
                return this._boundingSphere;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "materials", {
            /**
             * 该组件的材质列表。
             */
            get: function () {
                return this._materials;
            },
            set: function (value) {
                var materials = this._materials;
                for (var _i = 0, materials_1 = materials; _i < materials_1.length; _i++) {
                    var material = materials_1[_i];
                    if (material) {
                        material.release();
                    }
                }
                if (value !== materials) {
                    materials.length = 0;
                    for (var _a = 0, value_1 = value; _a < value_1.length; _a++) {
                        var material = value_1[_a];
                        materials.push(material);
                    }
                }
                for (var _b = 0, materials_2 = materials; _b < materials_2.length; _b++) {
                    var material = materials_2[_b];
                    if (material) {
                        material.retain();
                    }
                }
                BaseRenderer.onMaterialsChanged.dispatch(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "material", {
            /**
             * 该组件材质列表中的第一个材质。
             */
            get: function () {
                var materials = this._materials;
                return materials.length > 0 ? materials[0] : null;
            },
            set: function (value) {
                var dirty = false;
                var materials = this._materials;
                var existingMaterial = null;
                if (materials.length > 0) {
                    existingMaterial = materials[0];
                    if (existingMaterial !== value) {
                        dirty = true;
                    }
                }
                else if (value) {
                    dirty = true;
                }
                if (dirty) {
                    if (existingMaterial) {
                        existingMaterial.release();
                    }
                    if (value) {
                        value.retain();
                    }
                    materials[0] = value;
                    BaseRenderer.onMaterialsChanged.dispatch(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "aabb", {
            /**
             * @deprecated
             */
            get: function () {
                return this.localBoundingBox;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当渲染组件的材质列表改变时派发事件。
         */
        BaseRenderer.onMaterialsChanged = new signals.Signal();
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseRenderer.prototype, "frustumCulled", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_receiveShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_castShadows", void 0);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseRenderer.prototype, "receiveShadows", null);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseRenderer.prototype, "castShadows", null);
        __decorate([
            paper.editor.property("MATERIAL_ARRAY" /* MATERIAL_ARRAY */),
            paper.serializedField("_materials")
        ], BaseRenderer.prototype, "materials", null);
        return BaseRenderer;
    }(paper.BaseComponent));
    paper.BaseRenderer = BaseRenderer;
    __reflect(BaseRenderer.prototype, "paper.BaseRenderer", ["egret3d.IRaycast", "egret3d.ITransformObserver"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 射线检测信息。
     */
    var RaycastInfo = (function (_super) {
        __extends(RaycastInfo, _super);
        function RaycastInfo() {
            var _this = _super.call(this) || this;
            _this.backfaceCulling = true;
            _this.subMeshIndex = -1;
            _this.triangleIndex = -1;
            /**
             * 交点到射线起始点的距离。
             * - 如果未相交则为 -1.0。
             */
            _this.distance = -1.0;
            /**
             * 相交的点。
             */
            _this.position = egret3d.Vector3.create();
            /**
             * 相交的 UV 坐标。
             */
            _this.coord = egret3d.Vector2.create();
            /**
             * 相交的法线。
             * - 提供法线向量将计算法线。
             */
            _this.normal = null;
            _this.textureCoordA = null;
            _this.textureCoordB = null;
            /**
             * 相交的变换组件。（如果有的话）
             */
            _this.transform = null;
            /**
             * 相交的碰撞组件。（如果有的话）
             */
            _this.collider = null;
            /**
             * 相交的刚体组件。（如果有的话）
             */
            _this.rigidbody = null;
            return _this;
        }
        /**
         * 创建一个射线检测信息实例。
         */
        RaycastInfo.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new RaycastInfo();
        };
        RaycastInfo.prototype.onClear = function () {
            this.clear();
        };
        RaycastInfo.prototype.copy = function (value) {
            this.subMeshIndex = value.subMeshIndex;
            this.triangleIndex = value.triangleIndex;
            this.distance = value.distance;
            this.position.copy(value.position);
            this.coord.copy(value.coord);
            if (this.normal && value.normal) {
                this.normal.copy(value.normal);
            }
            // this.textureCoordA = null;
            // this.textureCoordB = null;
            this.transform = value.transform;
            this.collider = value.collider;
            this.rigidbody = value.rigidbody;
            return this;
        };
        RaycastInfo.prototype.clear = function () {
            this.subMeshIndex = -1;
            this.triangleIndex = -1;
            this.distance = -1.0;
            this.position.set(0.0, 0.0, 0.0);
            this.coord.set(0.0, 0.0);
            this.normal = null;
            this.textureCoordA = null;
            this.textureCoordB = null;
            this.transform = null;
            this.collider = null;
            this.rigidbody = null;
            return this;
        };
        RaycastInfo._instances = [];
        return RaycastInfo;
    }(paper.BaseRelease));
    egret3d.RaycastInfo = RaycastInfo;
    __reflect(RaycastInfo.prototype, "egret3d.RaycastInfo");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 基础纹理资源。
     * - 纹理资源的基类。
     */
    var BaseTexture = (function (_super) {
        __extends(BaseTexture, _super);
        function BaseTexture() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._gltfTexture = null;
            _this._image = null;
            _this._sampler = null;
            return _this;
        }
        BaseTexture._createConfig = function (createTextureParameters) {
            var config = this.createConfig();
            config.images = [{}];
            config.samplers = [{
                    magFilter: 9728 /* Nearest */, minFilter: 9728 /* Nearest */,
                    wrapS: 10497 /* Repeat */, wrapT: 10497 /* Repeat */,
                }];
            config.textures = [{ sampler: 0, source: 0, extensions: { paper: {} } }];
            //
            var gltfTexture = config.textures[0];
            var image = config.images[gltfTexture.source];
            var sampler = config.samplers[gltfTexture.sampler];
            var extension = gltfTexture.extensions.paper;
            //
            var _a = createTextureParameters, source = _a.source, _b = _a.width, width = _b === void 0 ? 0 : _b, _c = _a.height, height = _c === void 0 ? 0 : _c, _d = _a.mipmap, mipmap = _d === void 0 ? false : _d, _e = _a.premultiplyAlpha, premultiplyAlpha = _e === void 0 ? 0 : _e, _f = _a.flipY, flipY = _f === void 0 ? 0 : _f, _g = _a.anisotropy, anisotropy = _g === void 0 ? 1 : _g, _h = _a.format, format = _h === void 0 ? 6408 /* RGBA */ : _h, _j = _a.type, type = _j === void 0 ? 5121 /* UNSIGNED_BYTE */ : _j, _k = _a.wrapS, wrapS = _k === void 0 ? 10497 /* Repeat */ : _k, _l = _a.wrapT, wrapT = _l === void 0 ? 10497 /* Repeat */ : _l, _m = _a.magFilter, magFilter = _m === void 0 ? 9728 /* Nearest */ : _m, _o = _a.minFilter, minFilter = _o === void 0 ? 9728 /* Nearest */ : _o, _p = _a.unpackAlignment, unpackAlignment = _p === void 0 ? 4 /* Four */ : _p, 
            //
            _q = _a.depthBuffer, 
            //
            depthBuffer = _q === void 0 ? false : _q, _r = _a.stencilBuffer, stencilBuffer = _r === void 0 ? false : _r;
            //
            sampler.wrapS = wrapS;
            sampler.wrapT = wrapT;
            sampler.magFilter = magFilter;
            sampler.minFilter = minFilter;
            extension.width = width;
            extension.height = height;
            extension.anisotropy = anisotropy;
            extension.mipmap = mipmap;
            extension.premultiplyAlpha = premultiplyAlpha;
            extension.flipY = flipY;
            extension.depthBuffer = depthBuffer;
            extension.stencilBuffer = stencilBuffer;
            extension.format = format;
            extension.type = type;
            extension.unpackAlignment = unpackAlignment;
            //
            if (ArrayBuffer.isView(source)) {
                image.uri = source;
            }
            else if (source) {
                image.uri = source;
                extension.width = source.width;
                extension.height = source.height;
            }
            return config;
        };
        /**
         * @internal
         */
        BaseTexture.prototype.setupTexture = function (index) { };
        BaseTexture.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            var gltfTexture = this._gltfTexture = this.config.textures[0];
            this._image = this.config.images[gltfTexture.source];
            this._sampler = this.config.samplers[gltfTexture.sampler];
        };
        /**
         *
         */
        BaseTexture.prototype.setLiner = function (linear) {
            var sampler = this._sampler;
            if (this._gltfTexture.extensions.paper.mipmap) {
                sampler.magFilter = linear ? 9729 /* Linear */ : 9728 /* Nearest */;
                sampler.minFilter = linear ? 9987 /* LinearMipMapLinear */ : 9984 /* MearestMipmapNearest */;
            }
            else {
                sampler.magFilter = linear ? 9729 /* Linear */ : 9728 /* Nearest */;
                sampler.minFilter = linear ? 9729 /* Linear */ : 9728 /* Nearest */;
            }
            return this;
        };
        /**
         *
         */
        BaseTexture.prototype.setRepeat = function (repeat) {
            var sampler = this._sampler;
            sampler.wrapS = sampler.wrapT = repeat ? 10497 /* Repeat */ : 33071 /* ClampToEdge */;
            return this;
        };
        Object.defineProperty(BaseTexture.prototype, "width", {
            /**
             *
             */
            get: function () {
                return this._gltfTexture.extensions.paper.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTexture.prototype, "height", {
            /**
             *
             */
            get: function () {
                return this._gltfTexture.extensions.paper.height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTexture.prototype, "format", {
            /**
             *
             */
            get: function () {
                return this._gltfTexture.extensions.paper.format;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTexture.prototype, "sampler", {
            /**
             *
             */
            get: function () {
                return this._sampler;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTexture.prototype, "gltfTexture", {
            /**
             *
             */
            get: function () {
                return this._gltfTexture;
            },
            enumerable: true,
            configurable: true
        });
        return BaseTexture;
    }(egret3d.GLTFAsset));
    egret3d.BaseTexture = BaseTexture;
    __reflect(BaseTexture.prototype, "egret3d.BaseTexture");
    /**
     * 纹理资源。
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Texture.create = function (parametersOrName, config) {
            var name;
            var texture;
            if (typeof parametersOrName === "string") {
                name = parametersOrName;
            }
            else {
                config = this._createConfig(parametersOrName);
                name = parametersOrName.name || "";
            }
            // Retargeting.
            texture = new egret3d.Texture(name, config);
            texture.initialize();
            return texture;
        };
        /**
         *
         */
        Texture.createColorTexture = function (name, r, g, b) {
            var texture = Texture.create({
                name: name, source: new Uint8Array([r, g, b, 255]), width: 1, height: 1,
                // mipmap: true,
                wrapS: 33071 /* ClampToEdge */, wrapT: 33071 /* ClampToEdge */,
                magFilter: 9729 /* Linear */, minFilter: 9987 /* LinearMipMapLinear */
            });
            return texture;
        };
        /**
         * @internal
         */
        Texture.createGridTexture = function (name) {
            var width = 128;
            var height = 128;
            var source = new Uint8Array(width * height * 4);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var seek = (y * width + x) * 4;
                    var bool = ((x - width * 0.5) * (y - height * 0.5)) > 0;
                    source[seek] = source[seek + 1] = source[seek + 2] = bool ? 0 : 255;
                    source[seek + 3] = 255;
                }
            }
            var texture = Texture.create({
                name: name, source: source, width: width, height: height,
                mipmap: true,
                wrapS: 10497 /* Repeat */, wrapT: 10497 /* Repeat */,
                magFilter: 9729 /* Linear */, minFilter: 9987 /* LinearMipMapLinear */
            });
            return texture;
        };
        return Texture;
    }(BaseTexture));
    egret3d.Texture = Texture;
    __reflect(Texture.prototype, "egret3d.Texture");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var ToneMapping;
    (function (ToneMapping) {
        ToneMapping[ToneMapping["None"] = 0] = "None";
        ToneMapping[ToneMapping["LinearToneMapping"] = 1] = "LinearToneMapping";
        ToneMapping[ToneMapping["ReinhardToneMapping"] = 2] = "ReinhardToneMapping";
        ToneMapping[ToneMapping["Uncharted2ToneMapping"] = 3] = "Uncharted2ToneMapping";
        ToneMapping[ToneMapping["CineonToneMapping"] = 4] = "CineonToneMapping";
    })(ToneMapping = egret3d.ToneMapping || (egret3d.ToneMapping = {}));
    /**
     * 内置提供的全局Attribute
     * @private
     */
    egret3d.globalAttributeSemantic = {
        "corner": "_CORNER" /* _CORNER */,
        "position": "POSITION" /* POSITION */,
        "normal": "NORMAL" /* NORMAL */,
        "uv": "TEXCOORD_0" /* TEXCOORD_0 */,
        "uv2": "TEXCOORD_1" /* TEXCOORD_1 */,
        "color": "COLOR_0" /* COLOR_0 */,
        // "morphTarget0": gltf.AttributeSemanticType.MORPHTARGET_0,
        // "morphTarget1": gltf.AttributeSemanticType.MORPHTARGET_1,
        // "morphTarget2": gltf.AttributeSemanticType.MORPHTARGET_2,
        // "morphTarget3": gltf.AttributeSemanticType.MORPHTARGET_3,
        // "morphTarget4": gltf.AttributeSemanticType.MORPHTARGET_4,
        // "morphTarget5": gltf.AttributeSemanticType.MORPHTARGET_5,
        // "morphTarget6": gltf.AttributeSemanticType.MORPHTARGET_6,
        // "morphTarget7": gltf.AttributeSemanticType.MORPHTARGET_7,
        // "morphNormal0": gltf.AttributeSemanticType.MORPHNORMAL_0,
        // "morphNormal1": gltf.AttributeSemanticType.MORPHNORMAL_1,
        // "morphNormal2": gltf.AttributeSemanticType.MORPHNORMAL_2,
        // "morphNormal3": gltf.AttributeSemanticType.MORPHNORMAL_3,
        "skinIndex": "JOINTS_0" /* JOINTS_0 */,
        "skinWeight": "WEIGHTS_0" /* WEIGHTS_0 */,
        "startPosition": "_START_POSITION" /* _START_POSITION */,
        "startVelocity": "_START_VELOCITY" /* _START_VELOCITY */,
        "startColor": "_START_COLOR" /* _START_COLOR */,
        "startSize": "_START_SIZE" /* _START_SIZE */,
        "startRotation": "_START_ROTATION" /* _START_ROTATION */,
        "time": "_TIME" /* _TIME */,
        "random0": "_RANDOM0" /* _RANDOM0 */,
        "random1": "_RANDOM1" /* _RANDOM1 */,
        "startWorldPosition": "_WORLD_POSITION" /* _WORLD_POSITION */,
        "startWorldRotation": "_WORLD_ROTATION" /* _WORLD_ROTATION */,
        "lineDistance": "_INSTANCE_DISTANCE" /* _INSTANCE_DISTANCE */,
        "instanceStart": "_INSTANCE_START" /* _INSTANCE_START */,
        "instanceEnd": "_INSTANCE_END" /* _INSTANCE_END */,
        "instanceColorStart": "_INSTANCE_COLOR_START" /* _INSTANCE_COLOR_START */,
        "instanceColorEnd": "_INSTANCE_COLOR_END" /* _INSTANCE_COLOR_END */,
        "instanceDistanceStart": "_INSTANCE_DISTANCE_START" /* _INSTANCE_DISTANCE_START */,
        "instanceDistanceEnd": "_INSTANCE_DISTANCE_END" /* _INSTANCE_DISTANCE_END */,
    };
    /**
     * 内置提供的全局Uniform
     * @private
     */
    egret3d.globalUniformSemantic = {
        "modelMatrix": "MODEL" /* MODEL */,
        "modelViewMatrix": "MODELVIEW" /* MODELVIEW */,
        "projectionMatrix": "PROJECTION" /* PROJECTION */,
        "viewMatrix": "VIEW" /* VIEW */,
        "normalMatrix": "MODELVIEWINVERSE" /* MODELVIEWINVERSE */,
        "modelViewProjectionMatrix": "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */,
        "viewProjectionMatrix": "_VIEWPROJECTION" /* _VIEWPROJECTION */,
        "cameraPosition": "_CAMERA_POS" /* _CAMERA_POS */,
        "cameraForward": "_CAMERA_FORWARD" /* _CAMERA_FORWARD */,
        "cameraUp": "_CAMERA_UP" /* _CAMERA_UP */,
        "ambientLightColor": "_AMBIENTLIGHTCOLOR" /* _AMBIENTLIGHTCOLOR */,
        "directionalLights[0]": "_DIRECTLIGHTS" /* _DIRECTLIGHTS */,
        "pointLights[0]": "_POINTLIGHTS" /* _POINTLIGHTS */,
        "spotLights[0]": "_SPOTLIGHTS" /* _SPOTLIGHTS */,
        "boneMatrices[0]": "JOINTMATRIX" /* JOINTMATRIX */,
        "directionalShadowMatrix[0]": "_DIRECTIONSHADOWMAT" /* _DIRECTIONSHADOWMAT */,
        "spotShadowMatrix[0]": "_SPOTSHADOWMAT" /* _SPOTSHADOWMAT */,
        "pointShadowMatrix[0]": "_POINTSHADOWMAT" /* _POINTSHADOWMAT */,
        "directionalShadowMap[0]": "_DIRECTIONSHADOWMAP" /* _DIRECTIONSHADOWMAP */,
        "spotShadowMap[0]": "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */,
        "pointShadowMap[0]": "_POINTSHADOWMAP" /* _POINTSHADOWMAP */,
        "lightMap": "_LIGHTMAPTEX" /* _LIGHTMAPTEX */,
        "lightMapIntensity": "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */,
        "lightMapScaleOffset": "_LIGHTMAP_SCALE_OFFSET" /* _LIGHTMAP_SCALE_OFFSET */,
        "referencePosition": "_REFERENCEPOSITION" /* _REFERENCEPOSITION */,
        "nearDistance": "_NEARDICTANCE" /* _NEARDICTANCE */,
        "farDistance": "_FARDISTANCE" /* _FARDISTANCE */,
        "fogColor": "_FOG_COLOR" /* _FOG_COLOR */,
        "fogDensity": "_FOG_DENSITY" /* _FOG_DENSITY */,
        "fogNear": "_FOG_NEAR" /* _FOG_NEAR */,
        "fogFar": "_FOG_FAR" /* _FOG_FAR */,
        "toneMappingExposure": "_TONE_MAPPING_EXPOSURE" /* _TONE_MAPPING_EXPOSURE */,
        "toneMappingWhitePoint": "_TONE_MAPPING_WHITE_POINT" /* _TONE_MAPPING_WHITE_POINT */,
    };
    var _patternA = /#include +<([\w\d.]+)>/g;
    var _patternB = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    function _loopReplace(match, start, end, snippet) {
        var unroll = "";
        for (var i = parseInt(start); i < parseInt(end); i++) {
            unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
        }
        return unroll;
    }
    function _replace(match, include) {
        var flag = true;
        var chunk = "";
        if (include in egret3d.ShaderChunk) {
            chunk = egret3d.ShaderChunk[include];
        }
        else if (include in egret3d.renderState.defaultCustomShaderChunks) {
            flag = false;
            chunk = (egret3d.renderState.customShaderChunks && include in egret3d.renderState.customShaderChunks) ? egret3d.renderState.customShaderChunks[include] : "";
        }
        if (chunk) {
            return chunk.replace(_patternA, _replace);
        }
        if (flag) {
            console.error("Can not resolve #include <" + include + ">");
        }
        return "";
    }
    function _filterEmptyLine(string) {
        return string !== "";
    }
    /**
     *
     */
    var RenderState = (function (_super) {
        __extends(RenderState, _super);
        function RenderState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.maxBoneCount = 24;
            _this.toneMapping = ToneMapping.None;
            _this.toneMappingExposure = 1.0;
            _this.toneMappingWhitePoint = 1.0;
            _this.commonExtensions = "";
            _this.commonDefines = "";
            _this.clearColor = egret3d.Color.create();
            _this.viewPort = egret3d.Rectangle.create();
            _this.defaultCustomShaderChunks = {
                custom_vertex: "",
                custom_begin_vertex: "",
                custom_end_vertex: "",
                custom_fragment: "",
                custom_begin_fragment: "",
                custom_end_fragment: "",
            };
            _this.customShaderChunks = null;
            _this.renderTarget = null;
            _this.render = null;
            _this.draw = null;
            return _this;
        }
        RenderState.prototype._parseIncludes = function (string) {
            return string.replace(_patternA, _replace);
        };
        RenderState.prototype._unrollLoops = function (string) {
            return string.replace(_patternB, _loopReplace);
        };
        RenderState.prototype._prefixVertex = function (customDefines) {
            var prefixContext = [
                this.commonDefines,
                customDefines,
                egret3d.ShaderChunk.common_vert_def,
                '\n'
            ].filter(_filterEmptyLine).join('\n');
            return prefixContext;
        };
        RenderState.prototype._prefixFragment = function (customDefines) {
            var toneMappingNone = this.toneMapping === ToneMapping.None;
            var prefixContext = [
                this.commonExtensions,
                this.commonDefines,
                customDefines,
                egret3d.ShaderChunk.common_frag_def,
                toneMappingNone ? '' : '#define TONE_MAPPING',
                toneMappingNone ? '' : egret3d.ShaderChunk.tonemapping_pars_fragment,
                toneMappingNone ? '' : this._getToneMappingFunction(this.toneMapping),
                '\n'
            ].filter(_filterEmptyLine).join('\n');
            return prefixContext;
        };
        RenderState.prototype._getToneMappingFunction = function (toneMapping) {
            var toneMappingName = "";
            switch (toneMapping) {
                case ToneMapping.LinearToneMapping:
                    toneMappingName = 'Linear';
                    break;
                case ToneMapping.ReinhardToneMapping:
                    toneMappingName = 'Reinhard';
                    break;
                case ToneMapping.Uncharted2ToneMapping:
                    toneMappingName = 'Uncharted2';
                    break;
                case ToneMapping.CineonToneMapping:
                    toneMappingName = 'OptimizedCineon';
                    break;
                default:
                    throw new Error('unsupported toneMapping: ' + toneMapping);
            }
            return 'vec3 toneMapping( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
        };
        RenderState.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this, config);
            egret3d.renderState = this;
        };
        RenderState.prototype.updateViewport = function (viewport, target) { };
        RenderState.prototype.clearBuffer = function (bufferBit, clearColor) { };
        RenderState.prototype.copyFramebufferToTexture = function (screenPostion, target, level) {
            if (level === void 0) { level = 0; }
        };
        return RenderState;
    }(paper.SingletonComponent));
    egret3d.RenderState = RenderState;
    __reflect(RenderState.prototype, "egret3d.RenderState");
    /**
     *
     */
    egret3d.renderState = null;
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础预制体资源。
     * - 预制体资源和场景资源的基类。
     */
    var BasePrefabAsset = (function (_super) {
        __extends(BasePrefabAsset, _super);
        function BasePrefabAsset(config, name) {
            var _this = _super.call(this, name) || this;
            /**
             *
             */
            _this.config = null;
            _this.config = config;
            return _this;
        }
        BasePrefabAsset.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this.config = null;
            return true;
        };
        return BasePrefabAsset;
    }(paper.Asset));
    paper.BasePrefabAsset = BasePrefabAsset;
    __reflect(BasePrefabAsset.prototype, "paper.BasePrefabAsset");
    /**
     * 预制体资源。
     */
    var Prefab = (function (_super) {
        __extends(Prefab, _super);
        function Prefab() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Prefab.create = function (name, xOrScene, y, z, scene) {
            var prefab = paper.Asset.find(name);
            if (prefab && prefab instanceof Prefab) {
                if (xOrScene !== undefined && xOrScene !== null) {
                    if (xOrScene instanceof paper.Scene) {
                        var gameObject = prefab.createInstance(xOrScene);
                        if (gameObject) {
                            gameObject.transform.setLocalPosition(0.0, 0.0, 0.0);
                        }
                        return gameObject;
                    }
                    else {
                        var gameObject = prefab.createInstance(scene || null);
                        if (gameObject) {
                            gameObject.transform.setLocalPosition(xOrScene, y, z);
                        }
                        return gameObject;
                    }
                }
                else {
                    var gameObject = prefab.createInstance();
                    if (gameObject) {
                        gameObject.transform.setLocalPosition(0.0, 0.0, 0.0);
                    }
                    return gameObject;
                }
            }
            else {
                console.warn("The prefab don't exists.", name);
            }
            return null;
        };
        /**
         * @deprecated
         */
        Prefab.prototype.createInstance = function (scene, keepUUID) {
            if (!this.config) {
                return null;
            }
            var isEditor = paper.Application.playerMode === 2 /* Editor */;
            var deserializer = new paper.Deserializer();
            var gameObject = deserializer.deserialize(this.config, keepUUID, isEditor, scene);
            if (gameObject && isEditor) {
                if (!gameObject.extras.prefab) {
                    gameObject.extras.prefab = this;
                }
            }
            return gameObject;
        };
        return Prefab;
    }(BasePrefabAsset));
    paper.Prefab = Prefab;
    __reflect(Prefab.prototype, "paper.Prefab");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Vector4 = (function (_super) {
        __extends(Vector4, _super);
        /**
         * 请使用 `egret3d.Vector4.create(); egret3d.Quaternion.create()` 创建实例。
         * @see egret3d.Quaternion.create()
         * @see egret3d.Vector4.create()
         * @deprecated
         */
        function Vector4(x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.z = z;
            _this.w = w;
            return _this;
        }
        /**
         *
         */
        Vector4.create = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z, w);
                instance._released = false;
                return instance;
            }
            return new Vector4().set(x, y, z, w);
        };
        Vector4.prototype.serialize = function () {
            return [this.x, this.y, this.z, this.w];
        };
        Vector4.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector4.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.z, value.w);
        };
        Vector4.prototype.clone = function () {
            return Vector4.create(this.x, this.y, this.z, this.w);
        };
        Vector4.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Vector4.prototype.clear = function () {
            this.x = 0.0;
            this.y = 0.0;
            this.z = 0.0;
            this.w = 1.0;
            return this;
        };
        Vector4.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = value[offset];
            this.y = value[offset + 1];
            this.z = value[offset + 2];
            this.w = value[offset + 3];
            return this;
        };
        /**
         * 判断该向量是否和一个向量相等。
         * @param value 一个向量。
         * @param threshold 阈值。
         */
        Vector4.prototype.equal = function (value, threshold) {
            if (threshold === void 0) { threshold = 0.000001; }
            if (Math.abs(this.x - value.x) <= threshold &&
                Math.abs(this.y - value.y) <= threshold &&
                Math.abs(this.z - value.z) <= threshold &&
                Math.abs(this.w - value.w) <= threshold) {
                return true;
            }
            return false;
        };
        Vector4.prototype.normalize = function (input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z, w = input.w;
            var l = Math.sqrt(x * x + y * y + z * z + w * w);
            if (l > 2.220446049250313e-16 /* EPSILON */) {
                l = 1.0 / l;
                this.x = x * l;
                this.y = y * l;
                this.z = z * l;
                this.w = w * l;
            }
            else {
                this.clear();
            }
            return this;
        };
        Vector4.prototype.inverse = function (input) {
            if (!input) {
                input = this;
            }
            this.x = input.x * -1;
            this.y = input.y * -1;
            this.z = input.z * -1;
            this.w = input.w;
            return this;
        };
        /**
         * 向量与标量相乘运算。
         * - `v.multiplyScalar(scalar)` 将该向量与标量相乘，相当于 v *= scalar。
         * - `v.multiplyScalar(scalar, input)` 将输入向量与标量相乘的结果写入该向量，相当于 v = input * scalar。
         * @param scalar 标量。
         * @param input 输入向量。
         */
        Vector4.prototype.multiplyScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = scalar * input.x;
            this.y = scalar * input.y;
            this.z = scalar * input.z;
            this.w = scalar * input.w;
            return this;
        };
        /**
         * 将该向量与一个向量相点乘。
         * - v · vector
         * @param vector 一个向量。
         */
        Vector4.prototype.dot = function (vector) {
            return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
        };
        Vector4.prototype.lerp = function (p1, p2, p3) {
            if (typeof p1 === "number") {
                if (!p3) {
                    p3 = p1;
                    p1 = this;
                }
                else {
                    var temp = p1;
                    p1 = p2;
                    p2 = p3;
                    p3 = temp;
                }
            }
            else if (typeof p2 === "number") {
                p3 = p2;
                p2 = p1;
                p1 = this;
            }
            this.x = p1.x + (p2.x - p1.x) * p3;
            this.y = p1.y + (p2.y - p1.y) * p3;
            this.z = p1.z + (p2.z - p1.z) * p3;
            this.w = p1.w + (p2.w - p1.w) * p3;
            return this;
        };
        /**
         * 将该向量转换为数组。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Vector4.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            array[0 + offset] = this.x;
            array[1 + offset] = this.y;
            array[2 + offset] = this.z;
            array[3 + offset] = this.w;
            return array;
        };
        Object.defineProperty(Vector4.prototype, "length", {
            /**
             * 该向量的长度。
             * - 该值是实时计算的。
             */
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector4.prototype, "squaredLength", {
            /**
             * 该向量的长度的平方。
             * - 该值是实时计算的。
             */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            },
            enumerable: true,
            configurable: true
        });
        Vector4._instances = [];
        return Vector4;
    }(paper.BaseRelease));
    egret3d.Vector4 = Vector4;
    __reflect(Vector4.prototype, "egret3d.Vector4", ["egret3d.IVector4", "egret3d.IVector3", "egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 程序系统管理器。
     */
    var SystemManager = (function () {
        function SystemManager() {
            this._preSystems = [];
            this._systems = [];
        }
        /**
         * 程序系统管理器单例。
         */
        SystemManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SystemManager();
            }
            return this._instance;
        };
        SystemManager.prototype._getSystemInsertIndex = function (order) {
            var index = -1;
            var systemCount = this._systems.length;
            if (systemCount > 0) {
                if (order < this._systems[0].order) {
                    return 0;
                }
                else if (order >= this._systems[systemCount - 1].order) {
                    return systemCount;
                }
            }
            for (var i = 0; i < systemCount - 1; ++i) {
                if (this._systems[i].order <= order && order < this._systems[i + 1].order) {
                    index = i + 1;
                    break;
                }
            }
            return index < 0 ? this._systems.length : index;
        };
        SystemManager.prototype._checkRegister = function (systemClass) {
            var system = this.getSystem(systemClass);
            if (system) {
                console.warn("The system has been registered.", egret.getQualifiedClassName(systemClass));
                return system;
            }
            return system;
        };
        /**
         * TODO
         * @internal
         */
        SystemManager.prototype._preRegisterSystems = function () {
            this._preSystems.sort(function (a, b) { return a.order - b.order; });
            for (var _i = 0, _a = this._preSystems; _i < _a.length; _i++) {
                var pair = _a[_i];
                this.register(pair.systemClass, pair.order);
            }
            this._preSystems.length = 0;
        };
        /**
         * @internal
         */
        SystemManager.prototype.update = function () {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.enabled && !system._started) {
                    system._started = true;
                    system.onStart && system.onStart();
                }
            }
            for (var _b = 0, _c = this._systems; _b < _c.length; _b++) {
                var system = _c[_b];
                if (system) {
                    system.update();
                }
            }
            for (var _d = 0, _e = this._systems; _d < _e.length; _d++) {
                var system = _e[_d];
                if (system) {
                    system.lateUpdate();
                }
            }
        };
        /**
         * 在程序启动之前预注册一个指定的系统。
         */
        SystemManager.prototype.preRegister = function (systemClass, order) {
            if (order === void 0) { order = 4000 /* Update */; }
            if (this._systems.length > 0) {
                this.register(systemClass, order);
                return this;
            }
            this._preSystems.unshift({ systemClass: systemClass, order: order });
            return this;
        };
        /**
         * 为程序注册一个指定的系统。
         */
        SystemManager.prototype.register = function (systemClass, order, config) {
            if (order === void 0) { order = 4000 /* Update */; }
            var system = this._checkRegister(systemClass);
            if (system) {
                return system;
            }
            system = paper.BaseSystem.create(systemClass, order);
            this._systems.splice(this._getSystemInsertIndex(order), 0, system);
            system.initialize(config);
            return system;
        };
        /**
         * 从程序已注册的全部系统中获取一个指定的系统。
         */
        SystemManager.prototype.getSystem = function (systemClass) {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.constructor === systemClass) {
                    return system;
                }
            }
            return null;
        };
        /**
         * 从程序已注册的全部系统中获取一个指定的系统，如果尚未注册，则注册该系统。
         */
        SystemManager.prototype.getOrRegisterSystem = function (systemClass, order) {
            if (order === void 0) { order = 4000 /* Update */; }
            var system = this.getSystem(systemClass);
            if (!system) {
                system = this.register(systemClass, order);
            }
            return system;
        };
        Object.defineProperty(SystemManager.prototype, "systems", {
            /**
             * 程序已注册的全部系统。
             */
            get: function () {
                return this._systems;
            },
            enumerable: true,
            configurable: true
        });
        SystemManager._instance = null;
        return SystemManager;
    }());
    paper.SystemManager = SystemManager;
    __reflect(SystemManager.prototype, "paper.SystemManager");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _points = [
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
    ];
    /**
     * 几何立方体。
     */
    var Box = (function (_super) {
        __extends(Box, _super);
        /**
         * 请使用 `egret3d.AABB.create()` 创建实例。
         * @see egret3d.AABB.create()
         */
        function Box() {
            var _this = _super.call(this) || this;
            _this._dirtyRadius = true;
            _this._dirtyCenter = true;
            _this._dirtySize = true;
            _this._boundingSphereRadius = 0.0;
            _this._minimum = egret3d.Vector3.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            _this._maximum = egret3d.Vector3.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            _this._center = egret3d.Vector3.create();
            _this._size = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个几何立方体。
         * @param minimum 最小点。
         * @param maximum 最大点。
         */
        Box.create = function (minimum, maximum) {
            if (minimum === void 0) { minimum = null; }
            if (maximum === void 0) { maximum = null; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(minimum, maximum);
                instance._released = false;
                return instance;
            }
            return new Box().set(minimum, maximum);
        };
        Box.prototype.serialize = function () {
            return [this._minimum.x, this._minimum.y, this._minimum.z, this._maximum.x, this._maximum.y, this._maximum.z];
        };
        Box.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Box.prototype.clone = function () {
            return Box.create(this.minimum, this.maximum);
        };
        Box.prototype.copy = function (value) {
            return this.set(value.minimum, value.maximum);
        };
        Box.prototype.clear = function () {
            this._minimum.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            this._maximum.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        Box.prototype.set = function (minimum, maximum) {
            if (minimum === void 0) { minimum = null; }
            if (maximum === void 0) { maximum = null; }
            if (minimum && minimum !== this._minimum) {
                this._minimum.copy(minimum);
            }
            if (maximum && maximum !== this._maximum) {
                this._maximum.copy(maximum);
            }
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        Box.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this._minimum.fromArray(value, offset);
            this._maximum.fromArray(value, offset + 3);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        /**
         * 设置该立方体，使得全部点都在立方体内。
         * @param points 全部点。
         */
        Box.prototype.fromPoints = function (points) {
            this.clear();
            for (var _i = 0, _a = points; _i < _a.length; _i++) {
                var point = _a[_i];
                this.add(point);
            }
            return this;
        };
        Box.prototype.applyMatrix = function (matrix, input) {
            if (!input) {
                input = this;
            }
            // transform of empty box is an empty box.
            if (input.isEmpty) {
                if (input !== this) {
                    this.copy(input);
                }
                return this;
            }
            var min = input.minimum;
            var max = input.maximum;
            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            _points[0].set(min.x, min.y, min.z).applyMatrix(matrix); // 000
            _points[1].set(min.x, min.y, max.z).applyMatrix(matrix); // 001
            _points[2].set(min.x, max.y, min.z).applyMatrix(matrix); // 010
            _points[3].set(min.x, max.y, max.z).applyMatrix(matrix); // 011
            _points[4].set(max.x, min.y, min.z).applyMatrix(matrix); // 100
            _points[5].set(max.x, min.y, max.z).applyMatrix(matrix); // 101
            _points[6].set(max.x, max.y, min.z).applyMatrix(matrix); // 110
            _points[7].set(max.x, max.y, max.z).applyMatrix(matrix); // 111
            this.fromPoints(_points);
            return this;
        };
        Box.prototype.add = function (pointOrBox, input) {
            if (!input) {
                input = this;
            }
            var min = input.minimum;
            var max = input.maximum;
            if (pointOrBox instanceof Box) {
                this._minimum.min(pointOrBox._minimum, min);
                this._maximum.max(pointOrBox._maximum, max);
            }
            else {
                this._minimum.min(pointOrBox, min);
                this._maximum.max(pointOrBox, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        Box.prototype.expand = function (scalarOrVector, input) {
            if (!input) {
                input = this;
            }
            var min = input.minimum;
            var max = input.maximum;
            if (typeof scalarOrVector === "number") {
                this._minimum.addScalar(-scalarOrVector, min);
                this._maximum.addScalar(scalarOrVector, max);
            }
            else {
                this._minimum.subtract(scalarOrVector, min);
                this._maximum.add(scalarOrVector, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        Box.prototype.translate = function (scalarOrVector, input) {
            if (!input) {
                input = this;
            }
            var min = input.minimum;
            var max = input.maximum;
            if (typeof scalarOrVector === "number") {
                this._minimum.addScalar(scalarOrVector, min);
                this._maximum.addScalar(scalarOrVector, max);
            }
            else {
                this._minimum.add(scalarOrVector, min);
                this._maximum.add(scalarOrVector, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        /**
         * 获取一个点到该立方体的最近点。（如果该点在立方体内部，则最近点就是该点）
         * @param point 一个点。
         * @param out 最近点。
         */
        Box.prototype.getClosestPointToPoint = function (point, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.clamp(this._minimum, this._maximum, point);
        };
        /**
         * 获取一个点到该立方体的最近距离。
         * @param point 一个点。
         */
        Box.prototype.getDistance = function (point) {
            return egret3d.helpVector3A.clamp(this._minimum, this._maximum, point).subtract(point).length;
        };
        /**
         * 该立方体是否包含指定的点或立方体。
         */
        Box.prototype.contains = function (pointOrBox) {
            var min = this._minimum;
            var max = this._maximum;
            if (pointOrBox instanceof Box) {
                var vMin = pointOrBox.minimum;
                var vMax = pointOrBox.maximum;
                return min.x <= vMin.x && vMax.x <= max.x &&
                    min.y <= vMin.y && vMax.y <= max.y &&
                    min.z <= vMin.z && vMax.z <= max.z;
            }
            return (pointOrBox.x > min.x) && (pointOrBox.x < max.x) &&
                (pointOrBox.y > min.y) && (pointOrBox.y < max.y) &&
                (pointOrBox.z > min.z) && (pointOrBox.z < max.z);
        };
        Box.prototype.raycast = function (ray, raycastInfo) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var hitDirection = 0;
            var origin = ray.origin;
            var direction = ray.direction;
            var minimum = this.minimum;
            var maximum = this.maximum;
            var invdirx = 1.0 / direction.x, invdiry = 1.0 / direction.y, invdirz = 1.0 / direction.z;
            if (invdirx >= 0.0) {
                tmin = (minimum.x - origin.x) * invdirx;
                tmax = (maximum.x - origin.x) * invdirx;
            }
            else {
                tmin = (maximum.x - origin.x) * invdirx;
                tmax = (minimum.x - origin.x) * invdirx;
            }
            if (invdiry >= 0.0) {
                tymin = (minimum.y - origin.y) * invdiry;
                tymax = (maximum.y - origin.y) * invdiry;
            }
            else {
                tymin = (maximum.y - origin.y) * invdiry;
                tymax = (minimum.y - origin.y) * invdiry;
            }
            if ((tmin > tymax) || (tymin > tmax))
                return false;
            // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN
            if (tymin > tmin || tmin !== tmin) {
                tmin = tymin;
                hitDirection = 1;
            }
            if (tymax < tmax || tmax !== tmax)
                tmax = tymax;
            if (invdirz >= 0.0) {
                tzmin = (minimum.z - origin.z) * invdirz;
                tzmax = (maximum.z - origin.z) * invdirz;
            }
            else {
                tzmin = (maximum.z - origin.z) * invdirz;
                tzmax = (minimum.z - origin.z) * invdirz;
            }
            if ((tmin > tzmax) || (tzmin > tmax))
                return false;
            if (tzmin > tmin || tmin !== tmin) {
                tmin = tzmin;
                hitDirection = 2;
            }
            if (tzmax < tmax || tmax !== tmax)
                tmax = tzmax;
            // return point closest to the ray (positive side)
            if (tmax < 0.0)
                return false;
            if (raycastInfo) {
                var normal = raycastInfo.normal;
                ray.getPointAt(raycastInfo.distance = tmin >= 0.0 ? tmin : tmax, raycastInfo.position);
                if (normal) {
                    switch (hitDirection) {
                        case 0:
                            normal.set(invdirx > 0.0 ? -1.0 : 1.0, 0.0, 0.0);
                            break;
                        case 1:
                            normal.set(0.0, invdiry > 0.0 ? -1.0 : 1.0, 0.0);
                            break;
                        case 2:
                            normal.set(0.0, 0.0, invdirz > 0.0 ? -1.0 : 1.0);
                            break;
                    }
                }
            }
            return true;
        };
        Object.defineProperty(Box.prototype, "isEmpty", {
            /**
             * 该立方体是否为空。
             */
            get: function () {
                // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                return (this._maximum.x < this._minimum.x) || (this._maximum.y < this._minimum.y) || (this._maximum.z < this._minimum.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "boundingSphereRadius", {
            /**
             * 该立方体的包围球半径。
             */
            get: function () {
                if (this._dirtyRadius) {
                    egret3d.helpVector3A.subtract(this._maximum, this._minimum).multiplyScalar(0.5);
                    this._boundingSphereRadius = egret3d.helpVector3A.length;
                    this._dirtyRadius = false;
                }
                return this._boundingSphereRadius;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "minimum", {
            /**
             * 该立方体的最小点。
             */
            get: function () {
                return this._minimum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "maximum", {
            /**
             * 该立方体的最大点。
             */
            get: function () {
                return this._maximum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "size", {
            /**
             * 该立方体的尺寸。
             */
            get: function () {
                if (this._dirtySize) {
                    this._size.subtract(this._maximum, this._minimum);
                    this._dirtySize = false;
                }
                return this._size;
            },
            set: function (value) {
                var center = this.center;
                var size = this._size.copy(value);
                var halfSize = egret3d.helpVector3A.copy(size).multiplyScalar(0.5);
                this._minimum.copy(center).subtract(halfSize);
                this._maximum.copy(center).add(halfSize);
                this._dirtyRadius = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "center", {
            /**
             * 该立方体的中心点。
             */
            get: function () {
                if (this._dirtyCenter) {
                    this._center.add(this._maximum, this._minimum).multiplyScalar(0.5);
                    this._dirtyCenter = false;
                }
                return this._center;
            },
            set: function (value) {
                var size = this.size;
                var center = this._center.copy(value);
                var halfSize = egret3d.helpVector3A.copy(size).multiplyScalar(0.5);
                this._minimum.copy(center).subtract(halfSize);
                this._maximum.copy(center).add(halfSize);
            },
            enumerable: true,
            configurable: true
        });
        Box.ONE = new Box().set(egret3d.Vector3.MINUS_ONE.clone().multiplyScalar(0.5), egret3d.Vector3.ONE.clone().multiplyScalar(0.5));
        Box._instances = [];
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */, { minimum: 0.0 })
        ], Box.prototype, "size", null);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Box.prototype, "center", null);
        return Box;
    }(paper.BaseRelease));
    egret3d.Box = Box;
    __reflect(Box.prototype, "egret3d.Box", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
    /**
     * @internal
     */
    egret3d.helpAABBA = Box.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var _createEnabled = false;
    /**
     * 基础系统。
     * - 全部系统的基类。
     */
    var BaseSystem = (function () {
        /**
         * 禁止实例化系统。
         * @protected
         */
        function BaseSystem(order) {
            if (order === void 0) { order = -1; }
            /**
             * 该系统是否被激活。
             */
            this.enabled = true;
            /**
             * 该系统的执行顺序。
             */
            this.order = -1;
            /**
             * 该系统在调试模式时每帧消耗的时间，仅用于性能统计。（以毫秒为单位）
             */
            this.deltaTime = 0;
            /**
             * 全局时钟信息组件实例。
             */
            this.clock = paper.GameObject.globalGameObject.getOrAddComponent(paper.Clock);
            /**
             *
             */
            this.interests = [];
            /**
             * 该系统关心的实体组。
             */
            this.groups = [];
            /**
             * @private
             */
            this._started = false;
            this._enabled = false;
            if (!_createEnabled) {
                throw new Error("Create an instance of a system is not allowed.");
            }
            _createEnabled = false;
            this.order = order;
        }
        /**
         * 创建一个指定系统。
         * @internal
         */
        BaseSystem.create = function (systemClass, order) {
            _createEnabled = true;
            return new systemClass(order);
        };
        /**
         * 系统内部初始化。
         * @private
         */
        BaseSystem.prototype.initialize = function (config) {
            this.interests = this.interests || this["_interests"]; // TODO
            if (this.interests.length > 0) {
                var interests = void 0;
                if (Array.isArray(this.interests[0])) {
                    interests = this.interests;
                }
                else {
                    interests = [this.interests];
                }
                var groups = this.groups;
                for (var _i = 0, interests_1 = interests; _i < interests_1.length; _i++) {
                    var interest = interests_1[_i];
                    for (var _a = 0, interest_1 = interest; _a < interest_1.length; _a++) {
                        var config_1 = interest_1[_a];
                        if (config_1.listeners) {
                            for (var _b = 0, _c = config_1.listeners; _b < _c.length; _b++) {
                                var listenerConfig = _c[_b];
                                listenerConfig.type.add(listenerConfig.listener, this);
                            }
                        }
                    }
                    groups.push(paper.GameObjectGroup.create(interest));
                }
            }
            this.onAwake && this.onAwake(config);
        };
        /**
         * 系统内部卸载。
         * @private
         */
        BaseSystem.prototype.uninitialize = function () {
            this.onDestroy && this.onDestroy();
            if (this.interests.length > 0) {
                var interests = void 0;
                if (Array.isArray(this.interests[0])) {
                    interests = this.interests;
                }
                else {
                    interests = [this.interests];
                }
                for (var _i = 0, interests_2 = interests; _i < interests_2.length; _i++) {
                    var interest = interests_2[_i];
                    for (var _a = 0, interest_2 = interest; _a < interest_2.length; _a++) {
                        var config = interest_2[_a];
                        if (config.listeners) {
                            for (var _b = 0, _c = config.listeners; _b < _c.length; _b++) {
                                var listenerConfig = _c[_b];
                                listenerConfig.type.remove(listenerConfig.listener);
                            }
                        }
                    }
                }
            }
        };
        /**
         * 系统内部更新。
         * @private
         */
        BaseSystem.prototype.update = function () {
            var enabled = this.enabled;
            if (this._enabled !== enabled) {
                if (enabled) {
                    this.onEnable && this.onEnable();
                    if (true) {
                        console.info(egret.getQualifiedClassName(this), "enabled.");
                    }
                }
            }
            if (enabled && this._started) {
                var startTime = 0;
                var clock_1 = this.clock;
                if (true) {
                    this.deltaTime = 0;
                    startTime = clock_1.now;
                }
                for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {
                    var group = _a[_i];
                    if (this.onAddGameObject) {
                        for (var _b = 0, _c = group._addedGameObjects; _b < _c.length; _b++) {
                            var gameObject = _c[_b];
                            if (gameObject) {
                                this.onAddGameObject(gameObject, group);
                            }
                        }
                    }
                    if (this.onAddComponent) {
                        for (var _d = 0, _e = group._addedComponents; _d < _e.length; _d++) {
                            var component = _e[_d];
                            if (component) {
                                this.onAddComponent(component, group);
                            }
                        }
                    }
                }
                this.onUpdate && this.onUpdate(clock_1.deltaTime);
                if (true) {
                    this.deltaTime += clock_1.now - startTime;
                }
            }
            if (this._enabled !== enabled) {
                this._enabled = enabled;
                if (!enabled) {
                    this.onDisable && this.onDisable();
                    if (true) {
                        console.info(egret.getQualifiedClassName(this), "disabled.");
                    }
                }
            }
        };
        /**
         * 系统内部更新。
         * @private
         */
        BaseSystem.prototype.lateUpdate = function () {
            if (this.enabled && this._started) {
                var startTime = 0;
                var clock_2 = this.clock;
                if (true) {
                    startTime = clock_2.now;
                }
                this.onLateUpdate && this.onLateUpdate(clock_2.deltaTime);
                if (true) {
                    this.deltaTime += clock_2.now - startTime;
                }
            }
        };
        return BaseSystem;
    }());
    paper.BaseSystem = BaseSystem;
    __reflect(BaseSystem.prototype, "paper.BaseSystem");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 3×3 矩阵。
     */
    var Matrix3 = (function (_super) {
        __extends(Matrix3, _super);
        /**
         * 请使用 `egret3d.Matrix3.create()` 创建实例。
         * @see egret3d.Matrix3.create()
         */
        function Matrix3() {
            var _this = _super.call(this) || this;
            /**
             * 矩阵原始数据。
             * @readonly
             */
            _this.rawData = null;
            // if (rawData) {
            //     this.rawData = rawData;
            // }
            // else {
            // TODO
            _this.rawData = new Float32Array([
                1.0, 0.0, 0.0,
                0.0, 1.0, 0.0,
                0.0, 0.0, 1.0,
            ]);
            return _this;
            // }
        }
        /**
         * 创建一个矩阵。
         * @param rawData
         * @param offsetOrByteOffset
         */
        Matrix3.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop().identity();
                instance._released = false;
                return instance;
            }
            return new Matrix3();
        };
        Matrix3.prototype.serialize = function () {
            return this.rawData;
        };
        Matrix3.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Matrix3.prototype.copy = function (value) {
            this.fromArray(value.rawData);
            return this;
        };
        Matrix3.prototype.clone = function () {
            var value = new Matrix3();
            value.copy(this);
            return value;
        };
        Matrix3.prototype.set = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var rawData = this.rawData;
            rawData[0] = n11;
            rawData[1] = n21;
            rawData[2] = n31;
            rawData[3] = n12;
            rawData[4] = n22;
            rawData[5] = n32;
            rawData[6] = n13;
            rawData[7] = n23;
            rawData[8] = n33;
            return this;
        };
        Matrix3.prototype.identity = function () {
            var rawData = this.rawData;
            rawData[0] = 1.0;
            rawData[1] = 0.0;
            rawData[2] = 0.0;
            rawData[3] = 0.0;
            rawData[4] = 1.0;
            rawData[5] = 0.0;
            rawData[6] = 0.0;
            rawData[7] = 0.0;
            rawData[8] = 1.0;
            return this;
        };
        Matrix3.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            for (var i = 0; i < 9; ++i) {
                this.rawData[i] = value[i + offset];
            }
            return this;
        };
        Matrix3.prototype.fromBuffer = function (value, byteOffset) {
            if (byteOffset === void 0) { byteOffset = 0; }
            this.rawData = new Float32Array(value, byteOffset, 9);
            return this;
        };
        Matrix3.prototype.fromScale = function (vector) {
            var rawData = this.rawData;
            rawData[0] = vector.x;
            rawData[1] = 0.0;
            rawData[2] = 0.0;
            rawData[3] = 0.0;
            rawData[4] = vector.y;
            rawData[5] = 0.0;
            rawData[6] = 0.0;
            rawData[7] = 0.0;
            rawData[8] = vector.z;
            return this;
        };
        /**
         * 通过 UV 变换设置该矩阵。
         * @param tx 水平偏移。
         * @param ty 垂直偏移。
         * @param sx 水平重复。
         * @param sy 垂直重复。
         * @param rotation 旋转。（弧度制）
         * @param cx 水平中心。
         * @param cy 垂直中心。
         */
        Matrix3.prototype.fromUVTransform = function (tx, ty, sx, sy, rotation, cx, cy) {
            var c = Math.cos(rotation);
            var s = Math.sin(rotation);
            return this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0.0, 0.0, 1.0);
        };
        Matrix3.prototype.fromMatrix4 = function (value) {
            var rawData = value.rawData;
            this.set(rawData[0], rawData[4], rawData[8], rawData[1], rawData[5], rawData[9], rawData[2], rawData[6], rawData[10]);
            return this;
        };
        Matrix3.prototype.inverse = function (input) {
            if (!input) {
                input = this;
            }
            var me = input.rawData, te = this.rawData, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) {
                // TODO
                // var msg = "can't invert matrix, determinant is 0";
                // console.warn(msg);
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        };
        Matrix3.prototype.getNormalMatrix = function (matrix4) {
            return this.fromMatrix4(matrix4).inverse().transpose();
        };
        Matrix3.prototype.transpose = function () {
            var temp = 0.0;
            var rawData = this.rawData;
            temp = rawData[1];
            rawData[1] = rawData[3];
            rawData[3] = temp;
            temp = rawData[2];
            rawData[2] = rawData[6];
            rawData[6] = temp;
            temp = rawData[5];
            rawData[5] = rawData[7];
            rawData[7] = temp;
            return this;
        };
        Matrix3.prototype.multiply = function (matrixA, matrixB) {
            if (!matrixB) {
                matrixB = matrixA;
                matrixA = this;
            }
            var rawDataA = matrixA.rawData;
            var rawDataB = matrixB.rawData;
            var rawData = this.rawData;
            var a11 = rawDataA[0], a12 = rawDataA[3], a13 = rawDataA[6];
            var a21 = rawDataA[1], a22 = rawDataA[4], a23 = rawDataA[7];
            var a31 = rawDataA[2], a32 = rawDataA[5], a33 = rawDataA[8];
            var b11 = rawDataB[0], b12 = rawDataB[3], b13 = rawDataB[6];
            var b21 = rawDataB[1], b22 = rawDataB[4], b23 = rawDataB[7];
            var b31 = rawDataB[2], b32 = rawDataB[5], b33 = rawDataB[8];
            rawData[0] = a11 * b11 + a12 * b21 + a13 * b31;
            rawData[3] = a11 * b12 + a12 * b22 + a13 * b32;
            rawData[6] = a11 * b13 + a12 * b23 + a13 * b33;
            rawData[1] = a21 * b11 + a22 * b21 + a23 * b31;
            rawData[4] = a21 * b12 + a22 * b22 + a23 * b32;
            rawData[7] = a21 * b13 + a22 * b23 + a23 * b33;
            rawData[2] = a31 * b11 + a32 * b21 + a33 * b31;
            rawData[5] = a31 * b12 + a32 * b22 + a33 * b32;
            rawData[8] = a31 * b13 + a32 * b23 + a33 * b33;
            return this;
        };
        /**
         * 将一个矩阵与该矩阵相乘的结果写入该矩阵。
         * - v = matrix * v
         * @param matrix 一个矩阵。
         */
        Matrix3.prototype.premultiply = function (matrix) {
            return this.multiply(matrix, this);
        };
        /**
         * 将该旋转矩阵转换为数组。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Matrix3.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            for (var i = 0; i < 9; ++i) {
                array[i + offset] = this.rawData[i];
            }
            return array;
        };
        Object.defineProperty(Matrix3.prototype, "determinant", {
            get: function () {
                var rawData = this.rawData;
                var a = rawData[0], b = rawData[1], c = rawData[2], d = rawData[3], e = rawData[4], f = rawData[5], g = rawData[6], h = rawData[7], i = rawData[8];
                return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
            },
            enumerable: true,
            configurable: true
        });
        Matrix3.IDENTITY = new Matrix3();
        Matrix3._instances = [];
        return Matrix3;
    }(paper.BaseRelease));
    egret3d.Matrix3 = Matrix3;
    __reflect(Matrix3.prototype, "egret3d.Matrix3", ["paper.ICCS", "paper.ISerializable"]);
    /**
     * @deprecated
     */
    egret3d.helpMatrix3A = Matrix3.create();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var math;
    (function (math) {
        /**
         *
         */
        function euclideanModulo(n, m) {
            return ((n % m) + m) % m;
        }
        math.euclideanModulo = euclideanModulo;
        /**
         *
         */
        function clamp(v, min, max) {
            if (min === void 0) { min = 0.0; }
            if (max === void 0) { max = 1.0; }
            if (v < min) {
                return min;
            }
            else if (v > max) {
                return max;
            }
            else {
                return v;
            }
        }
        math.clamp = clamp;
        /**
         *
         */
        function lerp(from, to, t) {
            return from + (to - from) * t;
        }
        math.lerp = lerp;
        function frustumIntersectsSphere(frustum, sphere) {
            var planes = frustum.planes;
            var center = sphere.center;
            var negRadius = -sphere.radius;
            for (var _i = 0, planes_1 = planes; _i < planes_1.length; _i++) {
                var plane = planes_1[_i];
                var distance = plane.getDistance(center);
                if (distance < negRadius) {
                    return false;
                }
            }
            return true;
        }
        math.frustumIntersectsSphere = frustumIntersectsSphere;
        function isPowerOfTwo(value) {
            return (value & (value - 1)) === 0 && value !== 0;
        }
        math.isPowerOfTwo = isPowerOfTwo;
    })(math = egret3d.math || (egret3d.math = {}));
    /**
     * 内联的数字常数枚举。
     */
    var Const;
    (function (Const) {
        /**
         * 弧度制到角度制相乘的系数。
         */
        Const[Const["RAD_DEG"] = 57.29577951308232] = "RAD_DEG";
        /**
         * 角度制到弧度制相乘的系数。
         */
        Const[Const["DEG_RAD"] = 0.017453292519943295] = "DEG_RAD";
        /**
         * 大于零的最小正值。
         * - https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
         */
        Const[Const["EPSILON"] = 2.220446049250313e-16] = "EPSILON";
    })(Const = egret3d.Const || (egret3d.Const = {}));
    function sign(value) {
        if (value === 0 || value !== value) {
            return value;
        }
        return value > 0 ? 1 : -1;
    }
    egret3d.sign = sign;
    // export function triangleIntersectsPlane() {
    // }
    function satForAxes(axes) {
        var v0 = egret3d.helpVector3A;
        var v1 = egret3d.helpVector3B;
        var v2 = egret3d.helpVector3C;
        var extents = egret3d.helpVector3H;
        var testAxis = egret3d.helpVector3A;
        for (var i = 0, l = axes.length - 3; i <= l; i += 3) {
            testAxis.fromArray(axes, i);
            // project the aabb onto the seperating axis
            var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
            // project all 3 vertices of the triangle onto the seperating axis
            var p0 = v0.dot(testAxis);
            var p1 = v1.dot(testAxis);
            var p2 = v2.dot(testAxis);
            // actual test, basically see if either of the most extreme of the triangle points intersects r
            if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                // points of the projected triangle are outside the projected half-length of the aabb
                // the axis is seperating and we can exit
                return false;
            }
        }
        return true;
    }
    function triangleIntersectsAABB(triangle, aabb) {
        if (aabb.isEmpty) {
            return false;
        }
        var v0 = egret3d.helpVector3A;
        var v1 = egret3d.helpVector3B;
        var v2 = egret3d.helpVector3C;
        // triangle edge vectors
        var f0 = egret3d.helpVector3D;
        var f1 = egret3d.helpVector3E;
        var f2 = egret3d.helpVector3F;
        var center = egret3d.helpVector3G;
        var extents = egret3d.helpVector3H;
        // compute box center and extents
        extents.subtract(aabb.maximum, aabb.center);
        // translate triangle to aabb origin
        v0.subtract(triangle.a, center);
        v1.subtract(triangle.b, center);
        v2.subtract(triangle.c, center);
        // compute edge vectors for triangle
        f0.subtract(v1, v0);
        f1.subtract(v2, v1);
        f2.subtract(v0, v2);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        var axes = [
            0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y,
            f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x,
            -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0
        ];
        if (!satForAxes(axes)) {
            return false;
        }
        // test 3 face normals from the aabb
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes)) {
            return false;
        }
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        egret3d.helpVector3A.cross(f0, f1);
        axes = [egret3d.helpVector3A.x, egret3d.helpVector3A.y, egret3d.helpVector3A.z];
        return satForAxes(axes);
    }
    egret3d.triangleIntersectsAABB = triangleIntersectsAABB;
    function planeIntersectsAABB(plane, aabb) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        var vMin;
        var vMax;
        var min = aabb.minimum;
        var max = aabb.maximum;
        if (plane.normal.x > 0.0) {
            vMin = plane.normal.x * min.x;
            vMax = plane.normal.x * max.x;
        }
        else {
            vMin = plane.normal.x * max.x;
            vMax = plane.normal.x * min.x;
        }
        if (plane.normal.y > 0.0) {
            vMin += plane.normal.y * min.y;
            vMax += plane.normal.y * max.y;
        }
        else {
            vMin += plane.normal.y * max.y;
            vMax += plane.normal.y * min.y;
        }
        if (plane.normal.z > 0.0) {
            vMin += plane.normal.z * min.z;
            vMax += plane.normal.z * max.z;
        }
        else {
            vMin += plane.normal.z * max.z;
            vMax += plane.normal.z * min.z;
        }
        return vMin <= plane.constant && vMax >= plane.constant;
    }
    egret3d.planeIntersectsAABB = planeIntersectsAABB;
    function planeIntersectsSphere(plane, sphere) {
        return Math.abs(plane.getDistance(sphere.center)) <= sphere.radius;
    }
    egret3d.planeIntersectsSphere = planeIntersectsSphere;
    function aabbIntersectsSphere(aabb, sphere) {
        // Find the point on the AABB closest to the sphere center.
        egret3d.helpVector3A.copy(sphere.center).clamp(aabb.minimum, aabb.maximum);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return egret3d.helpVector3A.getSquaredDistance(sphere.center) <= (sphere.radius * sphere.radius);
    }
    egret3d.aabbIntersectsSphere = aabbIntersectsSphere;
    function aabbIntersectsAABB(valueA, valueB) {
        var minA = valueA.minimum;
        var maxA = valueA.maximum;
        var minB = valueB.minimum;
        var maxB = valueB.maximum;
        // using 6 splitting planes to rule out intersections.
        return maxA.x < minB.x || minA.x > maxB.x ||
            maxA.y < minB.y || minA.y > maxB.y ||
            maxA.z < minB.z || minA.z > maxB.z ? false : true;
    }
    egret3d.aabbIntersectsAABB = aabbIntersectsAABB;
    function sphereIntersectsSphere(valueA, valueB) {
        var radiusSum = valueA.radius + valueB.radius;
        return valueA.center.getSquaredDistance(valueB.center) <= (radiusSum * radiusSum);
    }
    egret3d.sphereIntersectsSphere = sphereIntersectsSphere;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 灯光组件。
     */
    var BaseLight = (function (_super) {
        __extends(BaseLight, _super);
        function BaseLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * TODO
             */
            _this.cullingMask = 4294967295 /* Everything */;
            /**
             * 该灯光的强度。
             */
            _this.intensity = 1.0;
            /**
             * 该灯光的颜色。
             */
            _this.color = egret3d.Color.create(1.0, 1.0, 1.0, 1.0);
            /**
             * 该灯光是否投射阴影。
             */
            _this.castShadows = false;
            /**
             *
             */
            _this.shadow = egret3d.LightShadow.create();
            return _this;
            // protected _updateShadowMatrix(camera: Camera) {
            //     // matrix * 0.5 + 0.5, after identity, range is 0 ~ 1 instead of -1 ~ 1
            //     const matrix = this.shadowMatrix;
            //     matrix.set(
            //         0.5, 0.0, 0.0, 0.5,
            //         0.0, 0.5, 0.0, 0.5,
            //         0.0, 0.0, 0.5, 0.5,
            //         0.0, 0.0, 0.0, 1.0
            //     );
            //     const context = camera.context;
            //     context.updateCameraTransform(camera, this.gameObject.transform.localToWorldMatrix);
            //     context.updateLightDepth(this);
            //     helpMatrixA.fromProjection(
            //         camera.fov, this.shadowCameraNear, this.shadowCameraFar,
            //         this.shadowSize, camera.opvalue,
            //         camera.aspect, stage.matchFactor
            //     );
            //     matrix.multiply(helpMatrixA).multiply(this.gameObject.transform.worldToLocalMatrix);
            // }
            // public updateShadow(camera: Camera) {
            // }
            // /**
            //  * @internal
            //  */
            // public updateFace(camera: Camera, faceIndex: number) {
            // }
        }
        __decorate([
            paper.serializedField
        ], BaseLight.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "intensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("COLOR" /* COLOR */)
        ], BaseLight.prototype, "color", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseLight.prototype, "castShadows", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("NESTED" /* NESTED */)
        ], BaseLight.prototype, "shadow", void 0);
        return BaseLight;
    }(paper.BaseComponent));
    egret3d.BaseLight = BaseLight;
    __reflect(BaseLight.prototype, "egret3d.BaseLight");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 场景资源。
     */
    var RawScene = (function (_super) {
        __extends(RawScene, _super);
        function RawScene() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @deprecated
         */
        RawScene.prototype.createInstance = function (keepUUID) {
            if (keepUUID === void 0) { keepUUID = false; }
            if (!this.config) {
                return null;
            }
            var isEditor = paper.Application.playerMode === 2 /* Editor */;
            var deserializer = new paper.Deserializer();
            var scene = deserializer.deserialize(this.config, keepUUID);
            if (scene && isEditor) {
            }
            return scene;
        };
        Object.defineProperty(RawScene.prototype, "name", {
            get: function () {
                return this.config.objects[0].name;
            },
            enumerable: true,
            configurable: true
        });
        return RawScene;
    }(paper.BasePrefabAsset));
    paper.RawScene = RawScene;
    __reflect(RawScene.prototype, "paper.RawScene");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格渲染组件。
     * - 用于渲染网格筛选组件提供的网格资源。
     */
    var MeshRenderer = (function (_super) {
        __extends(MeshRenderer, _super);
        function MeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._lightmapIndex = -1;
            /**
             * 如果该属性合并到 UV2 中，会破坏网格共享，共享的网格无法拥有不同的 lightmap UV。
             */
            _this._lightmapScaleOffset = egret3d.Vector4.create();
            return _this;
        }
        MeshRenderer.prototype.recalculateLocalBox = function () {
            this._localBoundingBox.clear();
            var filter = this.gameObject.getComponent(egret3d.MeshFilter);
            if (filter && filter.mesh) {
                var vertices = filter.mesh.getVertices();
                var position = egret3d.helpVector3A;
                for (var i = 0, l = vertices.length; i < l; i += 3) {
                    position.set(vertices[i], vertices[i + 1], vertices[i + 2]);
                    this._localBoundingBox.add(position);
                }
            }
        };
        /**
         * 实时获取网格资源的指定三角形顶点位置。
         */
        MeshRenderer.prototype.getTriangle = function (triangleIndex, out) {
            if (!out) {
                out = egret3d.Triangle.create();
            }
            var meshFilter = this.gameObject.getComponent(egret3d.MeshFilter);
            if (!meshFilter) {
                return out;
            }
            var mesh = meshFilter.mesh;
            if (!mesh) {
                return out;
            }
            var localToWorldMatrix = this.gameObject.transform.localToWorldMatrix;
            mesh.getTriangle(triangleIndex, out);
            out.a.applyMatrix(localToWorldMatrix);
            out.b.applyMatrix(localToWorldMatrix);
            out.c.applyMatrix(localToWorldMatrix);
            return out;
        };
        MeshRenderer.prototype.raycast = function (p1, p2, p3) {
            var meshFilter = this.gameObject.getComponent(egret3d.MeshFilter);
            if (!meshFilter || !meshFilter.enabled || !meshFilter.mesh) {
                return false;
            }
            var raycastMesh = false;
            var raycastInfo = undefined;
            var transform = this.gameObject.transform;
            var worldToLocalMatrix = transform.worldToLocalMatrix;
            var localRay = egret3d.helpRay.applyMatrix(worldToLocalMatrix, p1);
            var localBoundingBox = this.localBoundingBox;
            if (p2) {
                if (p2 === true) {
                    raycastMesh = true;
                }
                else {
                    raycastMesh = p3 || false;
                    raycastInfo = p2;
                }
            }
            if (raycastMesh ? localBoundingBox.raycast(localRay) && meshFilter.mesh.raycast(localRay, raycastInfo) : localBoundingBox.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    var localToWorldMatrix = transform.localToWorldMatrix;
                    raycastInfo.distance = p1.origin.getDistance(raycastInfo.position.applyMatrix(localToWorldMatrix));
                    raycastInfo.transform = transform;
                    var normal = raycastInfo.normal;
                    if (normal) {
                        // normal.applyDirection(localToWorldMatrix);
                        normal.applyMatrix3(egret3d.helpMatrix3A.fromMatrix4(worldToLocalMatrix).transpose()).normalize();
                    }
                }
                return true;
            }
            return false;
        };
        Object.defineProperty(MeshRenderer.prototype, "lightmapIndex", {
            /**
             * 该组件的光照图索引。
             */
            get: function () {
                return this._lightmapIndex;
            },
            set: function (value) {
                if (value === this._lightmapIndex) {
                    return;
                }
                this._lightmapIndex = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshRenderer.prototype, "lightmapScaleOffset", {
            get: function () {
                return this._lightmapScaleOffset;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], MeshRenderer.prototype, "_lightmapIndex", void 0);
        __decorate([
            paper.serializedField
        ], MeshRenderer.prototype, "_lightmapScaleOffset", void 0);
        __decorate([
            paper.editor.property("INT" /* INT */, { minimum: -1 })
        ], MeshRenderer.prototype, "lightmapIndex", null);
        return MeshRenderer;
    }(paper.BaseRenderer));
    egret3d.MeshRenderer = MeshRenderer;
    __reflect(MeshRenderer.prototype, "egret3d.MeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 四元数。
     */
    var Quaternion = (function (_super) {
        __extends(Quaternion, _super);
        function Quaternion() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * 创建一个四元数。
         */
        Quaternion.create = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z, w);
                instance._released = false;
                return instance;
            }
            return new Quaternion().set(x, y, z, w);
        };
        Quaternion.prototype.clone = function () {
            return Quaternion.create(this.x, this.y, this.z, this.w);
        };
        /**
         * 通过旋转矩阵设置该四元数。
         * - 旋转矩阵不应包含缩放值。
         * @param rotateMatrix 旋转矩阵。
         */
        Quaternion.prototype.fromMatrix = function (rotateMatrix) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var rawData = rotateMatrix.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            var trace = m11 + m22 + m33;
            var s = 0.0;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                this.w = 0.25 / s;
                this.x = (m32 - m23) * s;
                this.y = (m13 - m31) * s;
                this.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this.w = (m32 - m23) / s;
                this.x = 0.25 * s;
                this.y = (m12 + m21) / s;
                this.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this.w = (m13 - m31) / s;
                this.x = (m12 + m21) / s;
                this.y = 0.25 * s;
                this.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this.w = (m21 - m12) / s;
                this.x = (m13 + m31) / s;
                this.y = (m23 + m32) / s;
                this.z = 0.25 * s;
            }
            return this;
        };
        /**
         * 通过欧拉旋转设置该四元数。
         * @param euler 欧拉旋转。（弧度制）
         * @param order 欧拉旋转顺序。
         */
        Quaternion.prototype.fromEuler = function (euler, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            var x = euler.x, y = euler.y, z = euler.z;
            // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
            var cos = Math.cos;
            var sin = Math.sin;
            var c1 = cos(x * 0.5);
            var c2 = cos(y * 0.5);
            var c3 = cos(z * 0.5);
            var s1 = sin(x * 0.5);
            var s2 = sin(y * 0.5);
            var s3 = sin(z * 0.5);
            switch (order) {
                case 0 /* XYZ */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 1 /* XZY */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 2 /* YXZ */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 3 /* YZX */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 4 /* ZXY */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 5 /* ZYX */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
            }
            return this;
        };
        /**
         * 通过旋转轴设置该四元数。
         * - 假设旋转轴已被归一化。
         * @param axis 旋转轴。
         * @param angle 旋转角。（弧度制）
         */
        Quaternion.prototype.fromAxis = function (axis, angle) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
            var halfAngle = angle * 0.5, s = Math.sin(halfAngle);
            this.x = axis.x * s;
            this.y = axis.y * s;
            this.z = axis.z * s;
            this.w = Math.cos(halfAngle);
            return this;
        };
        /**
         * 通过自起始方向到目标方向的旋转值设置该四元数。
         * - 假设方向向量已被归一化。
         * @param from 起始方向。
         * @param to 目标方向。
         */
        Quaternion.prototype.fromVectors = function (from, to) {
            var r = from.dot(to) + 1.0;
            var v1 = egret3d.helpVector3A;
            if (r < 2.220446049250313e-16 /* EPSILON */) {
                r = 0.0;
                if (Math.abs(from.x) > Math.abs(from.z)) {
                    v1.set(-from.y, from.x, 0.0);
                }
                else {
                    v1.set(0.0, -from.z, from.y);
                }
            }
            else {
                v1.cross(from, to);
            }
            this.x = v1.x;
            this.y = v1.y;
            this.z = v1.z;
            this.w = r;
            return this.normalize();
        };
        /**
         * 将该四元数转换为恒等四元数。
         */
        Quaternion.prototype.identity = function () {
            this.x = this.y = this.z = 0.0;
            this.w = 1.0;
            return this;
        };
        Quaternion.prototype.multiply = function (quaternionA, quaternionB) {
            if (!quaternionB) {
                quaternionB = quaternionA;
                quaternionA = this;
            }
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var ax = quaternionA.x, ay = quaternionA.y, az = quaternionA.z, aw = quaternionA.w;
            var bx = quaternionB.x, by = quaternionB.y, bz = quaternionB.z, bw = quaternionB.w;
            this.x = ax * bw + aw * bx + ay * bz - az * by;
            this.y = ay * bw + aw * by + az * bx - ax * bz;
            this.z = az * bw + aw * bz + ax * by - ay * bx;
            this.w = aw * bw - ax * bx - ay * by - az * bz;
            return this;
        };
        /**
         * 将一个四元数与该四元数相乘的结果写入该四元数。
         * - v = quaternion * v
         * @param quaternion 一个四元数。
         */
        Quaternion.prototype.premultiply = function (quaternion) {
            return this.multiply(quaternion, this);
        };
        Quaternion.prototype.lerp = function (p1, p2, p3) {
            if (typeof p1 === "number") {
                if (!p3) {
                    p3 = p1;
                    p1 = this;
                }
                else {
                    var temp = p1;
                    p1 = p2;
                    p2 = p3;
                    p3 = temp;
                }
            }
            else if (typeof p2 === "number") {
                p3 = p2;
                p2 = p1;
                p1 = this;
            }
            var fX = p1.x, fY = p1.y, fZ = p1.z, fW = p1.w;
            var tX = p2.x, tY = p2.y, tZ = p2.z, tW = p2.w;
            if (fX * tX + fY * tY + fZ * tZ + fW * tW < 0.0) {
                this.x = fX + (-tX - fX) * p3;
                this.y = fY + (-tY - fY) * p3;
                this.z = fZ + (-tZ - fZ) * p3;
                this.w = fW + (-tW - fW) * p3;
            }
            else {
                this.x = fX + (tX - fX) * p3;
                this.y = fY + (tY - fY) * p3;
                this.z = fZ + (tZ - fZ) * p3;
                this.w = fW + (tW - fW) * p3;
            }
            return this.normalize();
        };
        Quaternion.prototype.slerp = function (p1, p2, p3) {
            if (typeof p1 === "number") {
                if (!p3) {
                    p3 = p1;
                    p1 = this;
                }
                else {
                    var temp = p1;
                    p1 = p2;
                    p2 = p3;
                    p3 = temp;
                }
            }
            else if (typeof p2 === "number") {
                p3 = p2;
                p2 = p1;
                p1 = this;
            }
            if (p1 === 0.0)
                return this.copy(p2);
            if (p1 === 1.0)
                return this.copy(p3);
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var fX = p1.x, fY = p1.y, fZ = p1.z, fW = p1.w;
            var tX = p2.x, tY = p2.y, tZ = p2.z, tW = p2.w;
            var cosHalfTheta = fW * tW + fX * tX + fY * tY + fZ * tZ;
            if (cosHalfTheta < 0.0) {
                this.w = -tW;
                this.x = -tX;
                this.y = -tY;
                this.z = -tZ;
                cosHalfTheta = -cosHalfTheta;
            }
            else {
                this.w = tW;
                this.x = tX;
                this.y = tY;
                this.z = tZ;
            }
            if (cosHalfTheta >= 1.0) {
                this.w = fW;
                this.x = fX;
                this.y = fY;
                this.z = fZ;
                return this;
            }
            var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
            if (sqrSinHalfTheta < 2.220446049250313e-16 /* EPSILON */) {
                return this.lerp(p1, this);
            }
            var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1.0 - p3) * halfTheta) / sinHalfTheta, ratioB = Math.sin(p3 * halfTheta) / sinHalfTheta;
            this.w = fW * ratioA + this.w * ratioB;
            this.x = fX * ratioA + this.x * ratioB;
            this.y = fY * ratioA + this.y * ratioB;
            this.z = fZ * ratioA + this.z * ratioB;
            return this;
        };
        /**
         * 设置该四元数，使其与起始点到目标点的方向相一致。
         * @param from 起始点。
         * @param to 目标点。
         * @param up
         */
        Quaternion.prototype.lookAt = function (from, to, up) {
            return this.fromMatrix(egret3d.helpMatrixA.lookAt(from, to, up));
        };
        /**
         * 设置该四元数，使其与目标方向相一致。
         * @param vector 目标方向。
         * @param up
         */
        Quaternion.prototype.lookRotation = function (vector, up) {
            return this.fromMatrix(egret3d.helpMatrixA.lookRotation(vector, up));
        };
        /**
         * 获取该四元数和一个四元数的夹角。（弧度制）
         */
        Quaternion.prototype.getAngle = function (value) {
            return 2.0 * Math.acos(Math.abs(egret3d.math.clamp(this.dot(value), -1.0, 1.0)));
        };
        /**
         * 将该四元数转换为欧拉旋转。（弧度制）
         * @param out 欧拉旋转。
         * @param order 欧拉旋转顺序。
         */
        Quaternion.prototype.toEuler = function (out, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return _helpMatrix.fromRotation(this).toEuler(out, order);
        };
        /**
         * 恒等四元数。
         */
        Quaternion.IDENTITY = new Quaternion();
        Quaternion._instances = [];
        return Quaternion;
    }(egret3d.Vector4));
    egret3d.Quaternion = Quaternion;
    __reflect(Quaternion.prototype, "egret3d.Quaternion");
    var _helpMatrix = egret3d.Matrix4.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 程序场景管理器。
     */
    var SceneManager = (function () {
        function SceneManager() {
            this._scenes = [];
            this._globalScene = null;
            this._editorScene = null;
        }
        /**
         * 场景管理器单例。
         */
        SceneManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SceneManager();
            }
            return this._instance;
        };
        /**
         * @internal
         */
        SceneManager.prototype.addScene = function (scene, isActive) {
            if (this._scenes.indexOf(scene) >= 0) {
                console.warn("Add the scene again.", scene.name);
            }
            if (isActive) {
                this._scenes.unshift(scene);
            }
            else {
                this._scenes.push(scene);
            }
        };
        /**
         * @internal
         */
        SceneManager.prototype.removeScene = function (scene) {
            if (scene === this._globalScene ||
                scene === this._editorScene) {
                console.warn("Cannot dispose global scene.");
                return false;
            }
            var index = this._scenes.indexOf(scene);
            if (index < 0) {
                console.warn("Remove scene error.", scene.name);
                return false;
            }
            this._scenes.splice(index, 1);
            return true;
        };
        /**
         * 卸载程序中的全部场景。
         * - 不包含全局场景。
         */
        SceneManager.prototype.unloadAllScene = function (excludes) {
            var i = this._scenes.length;
            while (i--) {
                var scene = this._scenes[i];
                if (excludes && excludes.indexOf(scene) >= 0) {
                    continue;
                }
                scene.destroy();
            }
        };
        /**
         * 从程序已创建的全部场景中获取指定名称的场景。
         */
        SceneManager.prototype.getScene = function (name) {
            for (var _i = 0, _a = this._scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                if (scene.name === name) {
                    return scene;
                }
            }
            return null;
        };
        Object.defineProperty(SceneManager.prototype, "scenes", {
            /**
             * 程序已创建的全部动态场景。
             */
            get: function () {
                return this._scenes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalScene", {
            /**
             * 全局静态的场景。
             * - 全局场景无法被销毁。
             */
            get: function () {
                if (!this._globalScene) {
                    this._globalScene = paper.Scene.createEmpty("Global" /* Global */, false);
                    this._scenes.pop(); // Remove global scene from scenes.
                }
                return this._globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "editorScene", {
            /**
             * 全局静态编辑器的场景。
             */
            get: function () {
                if (!this._editorScene) {
                    this._editorScene = paper.Scene.createEmpty("Editor Only" /* EditorOnly */, false);
                    this._scenes.pop(); // Remove editor scene from scenes.
                }
                return this._editorScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "activeScene", {
            /**
             * 当前激活的场景。
             */
            get: function () {
                if (this._scenes.length === 0) {
                    paper.Scene.createEmpty();
                }
                return this._scenes[0];
            },
            set: function (value) {
                if (this._scenes.length <= 1 ||
                    this._scenes[0] === value ||
                    this._globalScene === value //|| // Cannot active global scene.
                ) {
                    return;
                }
                var index = this._scenes.indexOf(value);
                if (index < 0) {
                    console.warn("Active scene error.", value.name);
                }
                this._scenes.splice(index, 1);
                this._scenes.unshift(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        SceneManager.prototype.createScene = function (name, isActive) {
            if (isActive === void 0) { isActive = true; }
            return paper.Scene.createEmpty(name, isActive);
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.loadScene = function (resourceName, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            return paper.Scene.create(resourceName, combineStaticObjects);
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.unloadScene = function (scene) {
            scene.destroy();
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.getActiveScene = function () {
            return this.activeScene;
        };
        SceneManager._instance = null;
        return SceneManager;
    }());
    paper.SceneManager = SceneManager;
    __reflect(SceneManager.prototype, "paper.SceneManager");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 颜色。
     */
    var Color = (function (_super) {
        __extends(Color, _super);
        /**
         * 请使用 `egret3d.Color.create()` 创建实例。
         * @see egret3d.Color.create()
         */
        function Color() {
            var _this = _super.call(this) || this;
            _this.r = 1.0;
            _this.g = 1.0;
            _this.b = 1.0;
            _this.a = 1.0;
            return _this;
        }
        /**
         * 创建一个新的颜色对象实例
         * @param r 红色通道
         * @param g 绿色通道
         * @param b 蓝色通道
         * @param a 透明通道
         */
        Color.create = function (r, g, b, a) {
            if (r === void 0) { r = 1.0; }
            if (g === void 0) { g = 1.0; }
            if (b === void 0) { b = 1.0; }
            if (a === void 0) { a = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(r, g, b, a);
                instance._released = false;
                return instance;
            }
            return new Color().set(r, g, b, a);
        };
        Color.prototype.serialize = function () {
            return [this.r, this.g, this.b, this.a];
        };
        Color.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Color.prototype.clone = function () {
            return Color.create(this.r, this.g, this.b, this.a);
        };
        Color.prototype.copy = function (value) {
            return this.set(value.r, value.g, value.b, value.a);
        };
        Color.prototype.set = function (r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            if (a !== undefined) {
                this.a = a;
            }
            return this;
        };
        Color.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.r = value[0 + offset];
            this.g = value[1 + offset];
            this.b = value[2 + offset];
            this.a = value[3 + offset];
            return this;
        };
        Color.prototype.fromHex = function (hex) {
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        };
        // public fromHSL(h: number, s: number, l: number): this {
        //     // h,s,l ranges are in 0.0 - 1.0
        //     h = _Math.euclideanModulo(h, 1);
        //     s = floatClamp(s, 0, 1);
        //     l = floatClamp(l, 0, 1);
        //     if (s === 0) {
        //         this.r = this.g = this.b = l;
        //     } else {
        //         var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
        //         var q = (2 * l) - p;
        //         this.r = hue2rgb(q, p, h + 1 / 3);
        //         this.g = hue2rgb(q, p, h);
        //         this.b = hue2rgb(q, p, h - 1 / 3);
        //     }
        //     return this;
        // }
        Color.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
            }
            valueA = this;
            this.r = valueA.r * valueB.r;
            this.g = valueA.g * valueB.g;
            this.b = valueA.b * valueB.b;
            this.a = valueA.a * valueB.a;
            return this;
        };
        Color.prototype.scale = function (value, source) {
            if (!source) {
                source = this;
            }
            this.r = source.r * value;
            this.g = source.g * value;
            this.b = source.b * value;
            this.a = source.a * value;
            return this;
        };
        Color.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.r = t * (valueB.r - valueA.r) + valueA.r;
            this.g = t * (valueB.g - valueA.g) + valueA.g;
            this.b = t * (valueB.b - valueA.b) + valueA.b;
            this.a = t * (valueB.a - valueA.a) + valueA.a;
            return this;
        };
        /**
         * 所有颜色通道均为零的颜色。
         * - 请注意不要修改该值。
         */
        Color.ZERO = new Color().set(0.0, 0.0, 0.0, 0.0);
        /**
         * 黑色。
         * - 请注意不要修改该值。
         */
        Color.BLACK = new Color().set(0.0, 0.0, 0.0, 1.0);
        /**
         * 灰色。
         * - 请注意不要修改该值。
         */
        Color.GRAY = new Color().set(0.5, 0.5, 0.5, 1.0);
        /**
         * 白色。
         * - 请注意不要修改该值。
         */
        Color.WHITE = new Color().set(1.0, 1.0, 1.0, 1.0);
        /**
         * 红色。
         * - 请注意不要修改该值。
         */
        Color.RED = new Color().set(1.0, 0.0, 0.0, 1.0);
        /**
         * 绿色。
         * - 请注意不要修改该值。
         */
        Color.GREEN = new Color().set(0.0, 1.0, 0.0, 1.0);
        /**
         * 蓝色。
         * - 请注意不要修改该值。
         */
        Color.BLUE = new Color().set(0.0, 0.0, 1.0, 1.0);
        /**
         * 黄色。
         * - 请注意不要修改该值。
         */
        Color.YELLOW = new Color().set(1.0, 1.0, 0.0, 1.0);
        /**
         * 靛蓝色。
         * - 请注意不要修改该值。
         */
        Color.INDIGO = new Color().set(0.0, 1.0, 1.0, 1.0);
        /**
         * 紫色。
         * - 请注意不要修改该值。
         */
        Color.PURPLE = new Color().set(1.0, 0.0, 1.0, 1.0);
        Color._instances = [];
        return Color;
    }(paper.BaseRelease));
    egret3d.Color = Color;
    __reflect(Color.prototype, "egret3d.Color", ["egret3d.IColor", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 渲染贴图。
     */
    var RenderTexture = (function (_super) {
        __extends(RenderTexture, _super);
        function RenderTexture() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._mipmap = false;
            return _this;
        }
        RenderTexture.create = function (parametersOrName, config) {
            var name;
            var renderTexture;
            if (typeof parametersOrName === "string") {
                name = parametersOrName;
            }
            else {
                config = this._createConfig(parametersOrName);
                name = parametersOrName.name || "";
            }
            // Retargeting.
            renderTexture = new egret3d.RenderTexture(name, config);
            renderTexture.initialize();
            return renderTexture;
        };
        RenderTexture.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            var extension = this._gltfTexture.extensions.paper;
            this._mipmap = extension.mipmap;
        };
        RenderTexture.prototype.activateRenderTexture = function (index) { };
        RenderTexture.prototype.generateMipmap = function () { return false; };
        return RenderTexture;
    }(egret3d.BaseTexture));
    egret3d.RenderTexture = RenderTexture;
    __reflect(RenderTexture.prototype, "egret3d.RenderTexture");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpTriangleA = egret3d.Triangle.create();
    var _helpTriangleB = egret3d.Triangle.create();
    var _helpRaycastInfo = egret3d.RaycastInfo.create();
    var _attributeNames = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    /**
     * 网格资源。
     */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        function Mesh() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._drawMode = 35044 /* Static */;
            _this._vertexCount = 0;
            _this._attributeNames = [];
            _this._attributeTypes = {};
            _this._glTFMesh = null;
            _this._inverseBindMatrices = null;
            _this._boneIndices = null;
            return _this;
        }
        Mesh.create = function (vertexCountOrName, indexCountOrConfig, attributeNamesOrBuffers, attributeTypes) {
            var name;
            var config;
            var buffers;
            var mesh;
            var indexCount = 0;
            //
            if (typeof vertexCountOrName === "number") {
                indexCount = indexCountOrConfig;
                //
                name = "";
                config = this._createConfig(vertexCountOrName, indexCount, attributeNamesOrBuffers || _attributeNames, attributeTypes || null);
                buffers = [new Uint32Array(config.bufferViews[0].byteLength / Uint32Array.BYTES_PER_ELEMENT)];
            }
            else {
                name = vertexCountOrName;
                config = indexCountOrConfig;
                buffers = attributeNamesOrBuffers;
            }
            // Retargeting.
            mesh = new egret3d.Mesh(name, config);
            mesh.initialize(buffers, attributeTypes || null);
            //
            if (indexCount > 0) {
                mesh.addSubMesh(indexCount, 0);
            }
            return mesh;
        };
        Mesh._createConfig = function (vertexCount, indexCount, attributeNames, attributeTypes) {
            var config = this.createConfig();
            config.buffers = [{ byteLength: 0 }];
            config.bufferViews = [{ buffer: 0, byteOffset: 0, byteLength: 0, target: 34962 /* ArrayBuffer */ }]; // VBO
            config.accessors = [];
            config.meshes = [{
                    primitives: [{ attributes: {} }],
                    extensions: { paper: {} },
                }];
            //
            var buffer = config.buffers[0];
            var vertexBufferView = config.bufferViews[0];
            var accessors = config.accessors;
            var attributes = config.meshes[0].primitives[0].attributes;
            //
            for (var _i = 0, attributeNames_1 = attributeNames; _i < attributeNames_1.length; _i++) {
                var attributeName = attributeNames_1[_i];
                var attributeType = this._getMeshAttributeType(attributeName, attributeTypes);
                var byteOffset = vertexBufferView.byteLength;
                vertexBufferView.byteLength += vertexCount * egret3d.GLTFAsset.getAccessorTypeCount(attributeType) * Float32Array.BYTES_PER_ELEMENT;
                attributes[attributeName] = accessors.length;
                accessors.push({
                    bufferView: 0,
                    byteOffset: byteOffset,
                    count: vertexCount,
                    normalized: attributeName === "NORMAL" /* NORMAL */ || attributeName === "TANGENT" /* TANGENT */,
                    componentType: 5126 /* Float */,
                    type: attributeType,
                });
            }
            buffer.byteLength = vertexBufferView.byteLength;
            //
            if (indexCount === 0) {
                config.meshes[0].primitives[0].material = 0;
            }
            return config;
        };
        Mesh._getMeshAttributeType = function (attributeName, customAttributeTypes) {
            if (customAttributeTypes && attributeName in customAttributeTypes) {
                return customAttributeTypes[attributeName];
            }
            switch (attributeName) {
                case "POSITION" /* POSITION */:
                case "NORMAL" /* NORMAL */:
                    return "VEC3" /* VEC3 */;
                case "TEXCOORD_0" /* TEXCOORD_0 */:
                case "TEXCOORD_1" /* TEXCOORD_1 */:
                    return "VEC2" /* VEC2 */;
                case "TANGENT" /* TANGENT */:
                case "COLOR_0" /* COLOR_0 */:
                case "COLOR_1" /* COLOR_1 */:
                case "JOINTS_0" /* JOINTS_0 */:
                case "WEIGHTS_0" /* WEIGHTS_0 */:
                    return "VEC4" /* VEC4 */;
                default:
                    throw new Error();
            }
        };
        Mesh.prototype.initialize = function (buffers, attributeTypes) {
            _super.prototype.initialize.call(this);
            var glTFMesh = this._glTFMesh = this.config.meshes[0];
            this._vertexCount = this.getAccessor(glTFMesh.primitives[0].attributes.POSITION || 0).count;
            for (var k in glTFMesh.primitives[0].attributes) {
                this._attributeNames.push(k);
            }
            if (attributeTypes) {
                for (var k in attributeTypes) {
                    this._attributeTypes[k] = attributeTypes[k];
                }
            }
            for (var _i = 0, buffers_1 = buffers; _i < buffers_1.length; _i++) {
                var buffer = buffers_1[_i];
                this.buffers.push(buffer);
            }
            this.updateAccessorTypeCount();
        };
        Mesh.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            for (var k in this._attributeTypes) {
                delete this._attributeTypes[k];
            }
            this._drawMode = 35044 /* Static */;
            this._attributeNames.length = 0;
            // this._customAttributeTypes;
            this._glTFMesh = null;
            this._inverseBindMatrices = null;
            this._boneIndices = null;
            return true;
        };
        /**
         * 克隆该网格。
         */
        Mesh.prototype.clone = function () {
            // TODO
            var value = Mesh.create(this.vertexCount, 0, this._attributeNames, this._attributeTypes);
            value._drawMode = this._drawMode;
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                if (primitive.indices !== undefined) {
                    var accessor = this.getAccessor(primitive.indices);
                    value.addSubMesh(accessor.count, primitive.material, primitive.mode);
                }
            }
            var index = 0;
            for (var _b = 0, _c = this.config.bufferViews; _b < _c.length; _b++) {
                var bufferViewA = _c[_b];
                var bufferViewB = value.config.bufferViews[index++];
                var a = this.createTypeArrayFromBufferView(bufferViewA, 5125 /* UnsignedInt */);
                var b = value.createTypeArrayFromBufferView(bufferViewB, 5125 /* UnsignedInt */);
                for (var i = 0, l = a.length; i < l; ++i) {
                    b[i] = a[i];
                }
            }
            return value;
        };
        /**
         * TODO applyMatrix
         */
        /**
         *
         */
        Mesh.prototype.getTriangle = function (triangleIndex, out, vertices) {
            if (!out) {
                out = egret3d.Triangle.create();
            }
            var indices = this.getIndices();
            vertices = vertices || this.getVertices();
            if (indices) {
                var vertexOffset = triangleIndex * 3;
                out.fromArray(vertices, indices[vertexOffset + 0] * 3, indices[vertexOffset + 1] * 3, indices[vertexOffset + 2] * 3);
            }
            else {
                out.fromArray(vertices, triangleIndex * 9);
            }
            return out;
        };
        /**
         *
         */
        Mesh.prototype.raycast = function (ray, raycastInfo, vertices) {
            var subMeshIndex = 0;
            var helpTriangleA = _helpTriangleA;
            var helpTriangleB = _helpTriangleB;
            var helpRaycastInfo = _helpRaycastInfo;
            vertices = vertices || this.getVertices();
            var hit = false;
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var indices = primitive.indices !== undefined ? this.getIndices(subMeshIndex) : null;
                switch (primitive.mode) {
                    case 0 /* Points */:
                        break;
                    case 1 /* Lines */:
                        break;
                    case 2 /* LineLoop */:
                        break;
                    case 3 /* LineStrip */:
                        break;
                    case 6 /* TrianglesFan */:
                        break;
                    case 5 /* TrianglesStrip */:
                        break;
                    case 4 /* Triangles */:
                    default:
                        if (indices) {
                            for (var i = 0, l = indices.length; i < l; i += 3) {
                                helpTriangleA.fromArray(vertices, indices[i] * 3, indices[i + 1] * 3, indices[i + 2] * 3);
                                if (raycastInfo) {
                                    helpRaycastInfo.backfaceCulling = raycastInfo.backfaceCulling;
                                    if (helpTriangleA.raycast(ray, helpRaycastInfo) &&
                                        (!hit || raycastInfo.distance > helpRaycastInfo.distance)) {
                                        raycastInfo.subMeshIndex = subMeshIndex;
                                        raycastInfo.triangleIndex = i / 3;
                                        raycastInfo.distance = helpRaycastInfo.distance;
                                        raycastInfo.position.copy(helpRaycastInfo.position);
                                        raycastInfo.coord.copy(helpRaycastInfo.coord);
                                        // raycastInfo.textureCoordB.copy(helpRaycastInfo.textureCoordB); TODO
                                        hit = true;
                                        if (raycastInfo.normal) {
                                            helpTriangleB.copy(helpTriangleA);
                                        }
                                    }
                                }
                                else if (helpTriangleA.raycast(ray)) {
                                    return true;
                                }
                            }
                        }
                        else {
                            for (var i = 0, l = vertices.length; i < l; i += 9) {
                                helpTriangleA.fromArray(vertices, i);
                                if (raycastInfo) {
                                    helpRaycastInfo.backfaceCulling = raycastInfo.backfaceCulling;
                                    if (helpTriangleA.raycast(ray, helpRaycastInfo)) {
                                        if (!hit || raycastInfo.distance > helpRaycastInfo.distance) {
                                            raycastInfo.subMeshIndex = subMeshIndex;
                                            raycastInfo.triangleIndex = i / 9;
                                            raycastInfo.distance = helpRaycastInfo.distance;
                                            raycastInfo.position.copy(helpRaycastInfo.position);
                                            raycastInfo.coord.copy(helpRaycastInfo.coord);
                                            // raycastInfo.textureCoordB.copy(helpRaycastInfo.textureCoordB); TODO
                                            hit = true;
                                            if (raycastInfo.normal) {
                                                helpTriangleB.copy(helpTriangleA);
                                            }
                                        }
                                    }
                                }
                                else if (helpTriangleA.raycast(ray)) {
                                    return true;
                                }
                            }
                        }
                        break;
                }
                subMeshIndex++;
            }
            if (hit && raycastInfo.normal) {
                var normal = raycastInfo.normal;
                // const normals = this.getNormals();
                // if (normals) {
                //     // TODO 三顶点的法线插值。
                //     const indices = this.getIndices();
                //     if (indices) {
                //         normal.fromArray(normals, indices[raycastInfo!.triangleIndex * 3] * 3);
                //     }
                //     else {
                //         normal.fromArray(normals, raycastInfo!.triangleIndex * 9);
                //     }
                // }
                // else {
                helpTriangleB.getNormal(normal);
                // }
            }
            return hit;
        };
        /**
         *
         */
        Mesh.prototype.addSubMesh = function (indexCount, materialIndex, randerMode) {
            if (materialIndex === void 0) { materialIndex = 0; }
            var accessors = this.config.accessors;
            var primitives = this.config.meshes[0].primitives;
            var subMeshIndex = this.buffers.length === primitives.length + 1 ? primitives.length : 0;
            var indexBufferView = this.config.bufferViews[subMeshIndex + 1] = {
                buffer: subMeshIndex + 1,
                byteOffset: 0,
                byteLength: indexCount * Uint16Array.BYTES_PER_ELEMENT,
                target: 34963 /* ElementArrayBuffer */,
            };
            var primitive = primitives[subMeshIndex] = primitives[subMeshIndex] || {
                attributes: primitives[0].attributes,
            };
            primitive.indices = accessors.length;
            primitive.material = materialIndex;
            primitive.mode = randerMode;
            accessors.push({
                bufferView: subMeshIndex + 1, byteOffset: 0,
                count: indexCount,
                typeCount: 1,
                componentType: 5123 /* UnsignedShort */, type: "SCALAR" /* SCALAR */,
            });
            this.buffers[subMeshIndex + 1] = new Uint16Array(indexBufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
            this.config.buffers[subMeshIndex + 1] = { byteLength: indexBufferView.byteLength };
            return primitives.length - 1;
        };
        /**
         * 获取该网格顶点的位置属性数据。
         * - x0, y0, z0, x1, y1, z1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        Mesh.prototype.getVertices = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("POSITION" /* POSITION */, offset, count);
        };
        /**
         * 获取该网格顶点的 UV 属性数据。
         * - u0, v0, u1, v1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        Mesh.prototype.getUVs = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */, offset, count);
        };
        /**
         * 获取该网格顶点的颜色属性数据。
         * - r0, g0, b0, a0, r1, g1, b1, a1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        Mesh.prototype.getColors = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("COLOR_0" /* COLOR_0 */, offset, count);
        };
        /**
         * 获取该网格顶点的法线属性数据。
         * - x0, y0, z0, x1, y1, z1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        Mesh.prototype.getNormals = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("NORMAL" /* NORMAL */, offset, count);
        };
        /**
         * 获取该网格顶点的切线属性数据。
         * - x0, y0, z0, w0,  x1, y1, z1, w1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        Mesh.prototype.getTangents = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("TANGENT" /* TANGENT */, offset, count);
        };
        /**
         * 获取该网格顶点的指定属性数据。
         * @param attributeType 属性名。
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点总数。（默认全部顶点）
         */
        Mesh.prototype.getAttributes = function (attributeType, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var accessorIndex = this._glTFMesh.primitives[0].attributes[attributeType];
            if (accessorIndex === undefined) {
                return null;
            }
            return this.createTypeArrayFromAccessor(this.getAccessor(accessorIndex), offset, count);
        };
        /**
         * 设置该网格指定的顶点属性数据。
         * @param attributeType 属性名。
         * @param value 属性数据。
         * @param offset 顶点偏移。（默认从第一个点开始）
         */
        Mesh.prototype.setAttributes = function (attributeType, value, offset) {
            if (offset === void 0) { offset = 0; }
            var target = this.getAttributes(attributeType, offset);
            if (target) {
                for (var i = 0, l = Math.min(value.length, target.length); i < l; i++) {
                    target[i] = value[i];
                }
            }
            return target;
        };
        /**
         * 获取该网格的顶点索引数据。
         * @param subMeshIndex 子网格索引。（默认第一个子网格）
         */
        Mesh.prototype.getIndices = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessorIndex = this._glTFMesh.primitives[subMeshIndex].indices;
                if (accessorIndex === undefined) {
                    return null;
                }
                return this.createTypeArrayFromAccessor(this.getAccessor(accessorIndex));
            }
            console.warn("Error arguments.");
            return null;
        };
        /**
         * 设置该网格的顶点索引数据。
         * @param value 顶点索引数据。
         * @param subMeshIndex 子网格索引。（默认第一个子网格）
         * @param offset 索引偏移。（默认不偏移）
         */
        Mesh.prototype.setIndices = function (value, subMeshIndex, offset) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (offset === void 0) { offset = 0; }
            var target = this.getIndices(subMeshIndex);
            if (target) {
                for (var i = 0, l = Math.min(value.length, target.length); i < l; i++) {
                    target[i] = value[offset + i];
                }
            }
            return target;
        };
        /**
         * 当修改该网格的顶点属性后，调用此方法来更新顶点属性的缓冲区。
         * @param uploadAttributes
         * @param offset 顶点偏移。（默认不偏移）
         * @param count 顶点总数。（默认全部顶点）
         */
        Mesh.prototype.uploadVertexBuffer = function (uploadAttributes, offset, count) { };
        /**
         * 当修改该网格的顶点索引后，调用此方法来更新顶点索引的缓冲区。
         * @param subMeshIndex 子网格索引。（默认第一个子网格）
         */
        Mesh.prototype.uploadSubIndexBuffer = function (subMeshIndex) { };
        Object.defineProperty(Mesh.prototype, "drawMode", {
            /**
             * 该网格的渲染模式。
             */
            get: function () {
                return this._drawMode;
            },
            set: function (value) {
                this._drawMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "subMeshCount", {
            /**
             * 该网格的子网格总数。
             */
            get: function () {
                return this._glTFMesh.primitives.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "vertexCount", {
            /**
             * 该网格的顶点总数。
             */
            get: function () {
                return this._vertexCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "attributeNames", {
            /**
             * 该网格的全部顶点属性名称。
             */
            get: function () {
                return this._attributeNames;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "boneIndices", {
            /**
             * @internal
             */
            get: function () {
                var config = this.config;
                if (!this._boneIndices && config.skins) {
                    var nodeIndices = this._boneIndices = {};
                    for (var _i = 0, _a = config.skins[0].joints; _i < _a.length; _i++) {
                        var joint = _a[_i];
                        var node = config.nodes[joint];
                        nodeIndices[node.name] = joint;
                    }
                }
                return this._boneIndices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "inverseBindMatrices", {
            /**
             * @internal
             */
            get: function () {
                var config = this.config;
                if (!this._inverseBindMatrices && config.skins) {
                    // Mast be skinned mesh if has skin.
                    // Skinned mesh mast has inverseBindMatrices.
                    this._inverseBindMatrices = this.createTypeArrayFromAccessor(this.getAccessor(config.skins[0].inverseBindMatrices));
                }
                return this._inverseBindMatrices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "glTFMesh", {
            /**
             * 获取该网格的 glTF 网格数据。
             */
            get: function () {
                return this._glTFMesh;
            },
            enumerable: true,
            configurable: true
        });
        return Mesh;
    }(egret3d.GLTFAsset));
    egret3d.Mesh = Mesh;
    __reflect(Mesh.prototype, "egret3d.Mesh", ["egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        function _extractAttributes(webgl, program, technique) {
            var webglProgram = program.program;
            var attributes = program.attributes;
            var totalAttributes = webgl.getProgramParameter(webglProgram, webgl.ACTIVE_ATTRIBUTES);
            for (var i = 0; i < totalAttributes; i++) {
                var attribData = webgl.getActiveAttrib(webglProgram, i);
                var location_1 = webgl.getAttribLocation(webglProgram, attribData.name);
                var semantic = "";
                if (!technique.attributes[attribData.name]) {
                    semantic = egret3d.globalAttributeSemantic[attribData.name];
                    if (!semantic) {
                        console.error("未知Uniform定义：" + attribData.name);
                    }
                }
                else {
                    semantic = technique.attributes[attribData.name].semantic;
                }
                attributes.push({ name: attribData.name, type: attribData.type, size: attribData.size, location: location_1, semantic: semantic });
            }
        }
        function _extractUniforms(webgl, program, technique) {
            var webglProgram = program.program;
            var contextUniforms = program.contextUniforms;
            var uniforms = program.uniforms;
            var totalUniforms = webgl.getProgramParameter(webglProgram, webgl.ACTIVE_UNIFORMS);
            for (var i = 0; i < totalUniforms; i++) {
                var uniformData = webgl.getActiveUniform(webglProgram, i);
                var location_2 = webgl.getUniformLocation(webglProgram, uniformData.name);
                var techniqueUniform = technique.uniforms[uniformData.name];
                var semantic = "";
                if (!techniqueUniform) {
                    semantic = egret3d.globalUniformSemantic[uniformData.name];
                    if (!semantic) {
                        //不在自定义中，也不在全局Uniform中
                        console.error("未知Uniform定义：" + uniformData.name);
                    }
                }
                else {
                    semantic = techniqueUniform.semantic;
                }
                if (semantic) {
                    contextUniforms.push({ name: uniformData.name, type: uniformData.type, size: uniformData.size, semantic: semantic, location: location_2 });
                }
                else {
                    uniforms.push({ name: uniformData.name, type: uniformData.type, size: uniformData.size, location: location_2 });
                }
            }
        }
        function _extractTextureUnits(program) {
            var activeUniforms = program.contextUniforms.concat(program.uniforms);
            var samplerArrayKeys = [];
            var samplerKeys = [];
            //排序
            for (var _i = 0, activeUniforms_1 = activeUniforms; _i < activeUniforms_1.length; _i++) {
                var uniform = activeUniforms_1[_i];
                var key = uniform.name;
                if (uniform.type === 35678 /* SAMPLER_2D */ || uniform.type === 35680 /* SAMPLER_CUBE */) {
                    if (key.indexOf("[") > -1) {
                        samplerArrayKeys.push(key);
                    }
                    else {
                        samplerKeys.push(key);
                    }
                }
            }
            var textureUint = 0;
            var allKeys = samplerKeys.concat(samplerArrayKeys);
            for (var _a = 0, activeUniforms_2 = activeUniforms; _a < activeUniforms_2.length; _a++) {
                var uniform = activeUniforms_2[_a];
                if (allKeys.indexOf(uniform.name) < 0) {
                    continue;
                }
                if (!uniform.textureUnits) {
                    uniform.textureUnits = [];
                }
                uniform.textureUnits.length = uniform.size;
                for (var i = 0; i < uniform.size; i++) {
                    uniform.textureUnits[i] = textureUint++;
                }
            }
        }
        var _browserPrefixes = [
            "",
            "MOZ_",
            "OP_",
            "WEBKIT_",
        ];
        function _getExtension(gl, name) {
            for (var _i = 0, _browserPrefixes_1 = _browserPrefixes; _i < _browserPrefixes_1.length; _i++) {
                var prefixedName = _browserPrefixes_1[_i];
                var extension = gl.getExtension(prefixedName + name);
                if (extension) {
                    return extension;
                }
            }
            return null;
        }
        function _getMaxShaderPrecision(gl, precision) {
            if (precision === "highp") {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
                    gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                    return "highp";
                }
                precision = "mediump";
            }
            if (precision === "mediump") {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
                    gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                    return "mediump";
                }
            }
            return "lowp";
        }
        /**
         * @internal
         */
        var WebGLRenderState = (function (_super) {
            __extends(WebGLRenderState, _super);
            function WebGLRenderState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._stateEnables = [3042 /* Blend */, 2884 /* CullFace */, 2929 /* DepthTest */]; // TODO
                _this._programs = {};
                _this._vsShaders = {};
                _this._fsShaders = {};
                _this._cacheStateEnable = {};
                _this._cacheProgram = null;
                _this._cacheState = null;
                return _this;
            }
            WebGLRenderState.prototype._getWebGLShader = function (type, webgl, gltfShader, defines) {
                var shader = webgl.createShader(type);
                var shaderContent = this._parseIncludes(gltfShader.uri);
                shaderContent = this._unrollLoops(shaderContent);
                webgl.shaderSource(shader, defines + shaderContent);
                webgl.compileShader(shader);
                var parameter = webgl.getShaderParameter(shader, webgl.COMPILE_STATUS);
                if (!parameter) {
                    console.error("Shader compile:" + gltfShader.name + " error! ->" + webgl.getShaderInfoLog(shader) + "\n" + ". did you want see the code?");
                    // if (confirm("Shader compile:" + gltfShader.name + " error! ->" + webgl.getShaderInfoLog(shader) + "\n" + ". did you want see the code?")) {
                    //     alert(gltfShader.uri);
                    // }
                    webgl.deleteShader(shader);
                    return null;
                }
                return shader;
            };
            WebGLRenderState.prototype._getWebGLProgram = function (vs, fs, customDefines) {
                var webgl = WebGLRenderState.webgl;
                var program = webgl.createProgram();
                if (program) {
                    var key = vs.name + customDefines;
                    var vertexShader = this._vsShaders[key];
                    if (!vertexShader) {
                        var prefixVertex = this._prefixVertex(customDefines);
                        vertexShader = this._getWebGLShader(webgl.VERTEX_SHADER, webgl, vs, prefixVertex);
                        if (vertexShader) {
                            this._vsShaders[key] = vertexShader;
                        }
                        else {
                            this._vsShaders[key] = true;
                        }
                    }
                    key = fs.name + customDefines;
                    var fragmentShader = this._fsShaders[key];
                    if (!fragmentShader) {
                        var prefixFragment = this._prefixFragment(customDefines);
                        fragmentShader = this._getWebGLShader(webgl.FRAGMENT_SHADER, webgl, fs, prefixFragment);
                        if (fragmentShader) {
                            this._fsShaders[key] = fragmentShader;
                        }
                        else {
                            this._vsShaders[key] = true;
                        }
                    }
                    if (vertexShader && fragmentShader &&
                        vertexShader !== true && fragmentShader !== true) {
                        webgl.attachShader(program, vertexShader);
                        webgl.attachShader(program, fragmentShader);
                        webgl.linkProgram(program);
                        var parameter = webgl.getProgramParameter(program, webgl.LINK_STATUS);
                        if (parameter) {
                            return program;
                        }
                        else {
                            console.error("program compile: " + vs.name + "_" + fs.name + " error! ->" + webgl.getProgramInfoLog(program));
                            // alert("program compile: " + vs.name + "_" + fs.name + " error! ->" + webgl.getProgramInfoLog(program));
                            webgl.deleteProgram(program);
                        }
                    }
                }
                return null;
            };
            WebGLRenderState.prototype._getCommonExtensions = function () {
                var extensions = "";
                if (this.oesStandardDerivatives) {
                    extensions += "#extension GL_OES_standard_derivatives : enable \n";
                }
                return extensions;
            };
            WebGLRenderState.prototype._getCommonDefines = function () {
                var defines = "";
                defines += "precision " + this.maxPrecision + " float; \n";
                defines += "precision " + this.maxPrecision + " int; \n";
                return defines;
            };
            WebGLRenderState.prototype.initialize = function (config) {
                _super.prototype.initialize.call(this);
                WebGLRenderState.canvas = config.canvas;
                WebGLRenderState.webgl = config.webgl;
                var webgl = WebGLRenderState.webgl;
                if (!webgl) {
                    return;
                }
                var webglVersions = /^WebGL\ ([0-9])/.exec(webgl.getParameter(webgl.VERSION));
                this.version = webglVersions ? parseFloat(webglVersions[1]) : 1.0;
                //
                this.textureFloat = !!_getExtension(webgl, "OES_texture_float");
                this.anisotropyExt = _getExtension(webgl, "EXT_texture_filter_anisotropic");
                this.shaderTextureLOD = _getExtension(webgl, "EXT_shader_texture_lod");
                // use dfdx and dfdy must enable OES_standard_derivatives
                this.oesStandardDerivatives = !!_getExtension(webgl, "OES_standard_derivatives");
                //
                this.maxPrecision = _getMaxShaderPrecision(webgl, "highp");
                this.maxTextures = webgl.getParameter(webgl.MAX_TEXTURE_IMAGE_UNITS);
                this.maxVertexTextures = webgl.getParameter(webgl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                this.maxTextureSize = webgl.getParameter(webgl.MAX_TEXTURE_SIZE);
                this.maxCubemapSize = webgl.getParameter(webgl.MAX_CUBE_MAP_TEXTURE_SIZE);
                this.maxRenderBufferize = webgl.getParameter(webgl.MAX_RENDERBUFFER_SIZE);
                this.maxVertexUniformVectors = webgl.getParameter(webgl.MAX_VERTEX_UNIFORM_VECTORS);
                this.maxBoneCount = Math.floor((this.maxVertexUniformVectors - 20) / 4); // TODO
                this.maxAnisotropy = (this.anisotropyExt !== null) ? webgl.getParameter(this.anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
                this.commonExtensions = this._getCommonExtensions();
                this.commonDefines = this._getCommonDefines();
                console.info("WebGL version:", this.version);
                console.info("Maximum shader precision:", this.maxPrecision);
                console.info("Maximum texture count:", this.maxTextures);
                console.info("Maximum vertex texture count:", this.maxVertexTextures);
                console.info("Maximum texture size:", this.maxTextureSize);
                console.info("Maximum cube map texture size:", this.maxCubemapSize);
                console.info("Maximum render buffer size:", this.maxRenderBufferize);
                console.info("Maximum vertex uniform vectors:", this.maxVertexUniformVectors);
                console.info("Maximum GPU skinned bone count:", this.maxBoneCount);
            };
            WebGLRenderState.prototype.updateViewport = function (viewport, target) {
                var webgl = WebGLRenderState.webgl;
                var w;
                var h;
                this.viewPort.copy(viewport);
                this.renderTarget = target;
                if (target) {
                    w = target.width;
                    h = target.height;
                    // target.use();
                    target.activateRenderTexture();
                }
                else {
                    var stageViewport = egret3d.stage.viewport;
                    w = stageViewport.w;
                    h = stageViewport.h;
                    webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
                }
                webgl.viewport(w * viewport.x, h * (1.0 - viewport.y - viewport.h), w * viewport.w, h * viewport.h);
                webgl.depthRange(0.0, 1.0); // TODO
            };
            WebGLRenderState.prototype.clearBuffer = function (bufferBit, clearColor) {
                var webgl = WebGLRenderState.webgl;
                if (bufferBit & 256 /* Depth */) {
                    webgl.depthMask(true);
                    webgl.clearDepth(1.0);
                }
                if (bufferBit & 1024 /* Stencil */) {
                    webgl.clearStencil(1.0);
                }
                if ((bufferBit & 16384 /* Color */) !== 0 && clearColor) {
                    webgl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
                }
                webgl.clear(bufferBit);
            };
            WebGLRenderState.prototype.copyFramebufferToTexture = function (screenPostion, target, level) {
                if (level === void 0) { level = 0; }
                var webgl = WebGLRenderState.webgl;
                if (target.dirty) {
                    target.setupTexture(0);
                }
                else {
                    webgl.activeTexture(webgl.TEXTURE0);
                    webgl.bindTexture(webgl.TEXTURE_2D, target.webglTexture);
                }
                webgl.copyTexImage2D(webgl.TEXTURE_2D, level, target.format, screenPostion.x, screenPostion.y, target.width, target.height, 0); //TODO
            };
            WebGLRenderState.prototype.updateState = function (state) {
                if (this._cacheState === state) {
                    return;
                }
                this._cacheState = state;
                var webgl = WebGLRenderState.webgl;
                var stateEnables = this._stateEnables;
                var cacheStateEnable = this._cacheStateEnable;
                for (var _i = 0, stateEnables_1 = stateEnables; _i < stateEnables_1.length; _i++) {
                    var e = stateEnables_1[_i];
                    var b = state ? state.enable && state.enable.indexOf(e) >= 0 : false;
                    if (cacheStateEnable[e] !== b) {
                        cacheStateEnable[e] = b;
                        b ? webgl.enable(e) : webgl.disable(e);
                    }
                }
                // Functions.
                if (state) {
                    var functions = state.functions;
                    if (functions) {
                        for (var fun in functions) {
                            webgl[fun].apply(webgl, functions[fun]);
                        }
                    }
                }
            };
            WebGLRenderState.prototype.clearState = function () {
                for (var key in this._cacheStateEnable) {
                    delete this._cacheStateEnable[key];
                }
                this._cacheProgram = null;
                this._cacheState = null;
            };
            WebGLRenderState.prototype.useProgram = function (program) {
                if (this._cacheProgram !== program) {
                    this._cacheProgram = program;
                    WebGLRenderState.webgl.useProgram(program.program);
                    return true;
                }
                return false;
            };
            WebGLRenderState.prototype.getProgram = function (material, technique, contextDefine) {
                var shader = material._shader;
                var extensions = shader.config.extensions.KHR_techniques_webgl;
                var vertexShader = extensions.shaders[0]; // TODO 顺序依赖
                var fragmentShader = extensions.shaders[1]; // TODO 顺序依赖
                this.customShaderChunks = shader.customs; //
                var defines = contextDefine + material.shaderDefine;
                var name = vertexShader.name + "_" + fragmentShader.name + "_" + defines; // TODO材质标脏可以优化
                var webgl = WebGLRenderState.webgl;
                var programBinder = null;
                if (name in this._programs) {
                    programBinder = this._programs[name];
                }
                else {
                    var program = this._getWebGLProgram(vertexShader, fragmentShader, defines);
                    if (program) {
                        this._programs[name] = programBinder = new web.WebGLProgramBinder(program);
                        _extractAttributes(webgl, programBinder, technique);
                        _extractUniforms(webgl, programBinder, technique);
                        _extractTextureUnits(programBinder);
                    }
                }
                if (programBinder && technique.program !== programBinder.id) {
                    technique.program = programBinder.id;
                }
                return programBinder;
            };
            /**
             * @deprecated
             */
            WebGLRenderState.canvas = null;
            /**
             * @deprecated
             */
            WebGLRenderState.webgl = null;
            return WebGLRenderState;
        }(egret3d.RenderState));
        web.WebGLRenderState = WebGLRenderState;
        __reflect(WebGLRenderState.prototype, "egret3d.web.WebGLRenderState");
        // Retarget.
        egret3d.RenderState = WebGLRenderState;
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 已丢失或不支持的组件数据备份。
     */
    var MissingComponent = (function (_super) {
        __extends(MissingComponent, _super);
        function MissingComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 已丢失或不支持的组件数据。
             */
            _this.missingObject = null;
            return _this;
        }
        Object.defineProperty(MissingComponent.prototype, "missingClass", {
            /**
             * 丢失的组件类名
             */
            get: function () {
                if (this.missingObject) {
                    return this.missingObject.class;
                }
                return "";
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("TEXT" /* TEXT */, { readonly: true })
        ], MissingComponent.prototype, "missingClass", null);
        __decorate([
            paper.serializedField
        ], MissingComponent.prototype, "missingObject", void 0);
        return MissingComponent;
    }(paper.BaseComponent));
    paper.MissingComponent = MissingComponent;
    __reflect(MissingComponent.prototype, "paper.MissingComponent");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 脚本组件。
     * - 为了开发的便捷，允许使用脚本组件实现组件生命周期。
     * - 生命周期的顺序如下：
     * - onAwake();
     * - onReset();
     * - onEnable();
     * - onStart();
     * - onFixedUpdate();
     * - onUpdate();
     * - onLateUpdate();
     * - onDisable();
     * - onDestroy();
     */
    var Behaviour = (function (_super) {
        __extends(Behaviour, _super);
        function Behaviour() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this._isReseted = false;
            /**
             * @private
             */
            _this._isAwaked = false;
            /**
             * @private
             */
            _this._isStarted = false;
            return _this;
        }
        /**
         * @private
         */
        Behaviour.prototype._dispatchEnabledEvent = function (value) {
            _super.prototype._dispatchEnabledEvent.call(this, value);
            if (value) {
                Behaviour.onComponentEnabled.dispatch(this);
            }
            else {
                Behaviour.onComponentDisabled.dispatch(this);
            }
        };
        /**
         * @internal
         */
        Behaviour.__isBehaviour = true;
        return Behaviour;
    }(paper.BaseComponent));
    paper.Behaviour = Behaviour;
    __reflect(Behaviour.prototype, "paper.Behaviour");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 全局时钟信息组件。
     */
    var Clock = (function (_super) {
        __extends(Clock, _super);
        function Clock() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.maxFixedSubSteps = 3;
            _this.fixedDeltaTime = 1.0 / 50.0; // TODO same as fps.
            _this.timeScale = 1.0;
            _this._frameCount = 0;
            _this._beginTime = 0.0;
            _this._lastTime = 0.0;
            _this._delayTime = 0.0;
            _this._unscaledTime = 0.0;
            _this._unscaledDeltaTime = 0.0;
            _this._fixedTime = 0.0;
            return _this;
        }
        Clock.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            paper.Time = paper.clock = this;
            this._beginTime = this.now * 0.001;
        };
        /**
         * @internal
         */
        Clock.prototype.update = function (time) {
            if (this._unscaledTime !== 0.0) {
                this._lastTime = this._unscaledTime;
                if (this._fixedTime < this.fixedDeltaTime) {
                }
                else if (this._fixedTime < this.fixedDeltaTime * this.maxFixedSubSteps) {
                    this._fixedTime %= this.fixedDeltaTime;
                }
                else {
                    this._fixedTime -= this.fixedDeltaTime * this.maxFixedSubSteps;
                }
            }
            var now = time || this.now * 0.001;
            this._frameCount += 1;
            this._unscaledTime = now - this._beginTime;
            this._unscaledDeltaTime = this._unscaledTime - this._lastTime;
            this._fixedTime += this._unscaledDeltaTime;
        };
        Object.defineProperty(Clock.prototype, "frameCount", {
            get: function () {
                return this._frameCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "now", {
            /**
             * 系统时间。（以毫秒为单位）
             */
            get: function () {
                if (Date.now) {
                    return Date.now();
                }
                return new Date().getTime();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "time", {
            /**
             * 从程序开始运行时的累计时间。（以秒为单位）
             */
            get: function () {
                return this._unscaledTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "fixedTime", {
            /**
             *
             */
            get: function () {
                return this._fixedTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "deltaTime", {
            /**
             * 上一帧到此帧流逝的时间。（以秒为单位）
             */
            get: function () {
                return this._unscaledDeltaTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledTime", {
            /**
             *
             */
            get: function () {
                return this._unscaledTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledDeltaTime", {
            /**
             *
             */
            get: function () {
                return this._unscaledDeltaTime;
            },
            enumerable: true,
            configurable: true
        });
        return Clock;
    }(paper.SingletonComponent));
    paper.Clock = Clock;
    __reflect(Clock.prototype, "paper.Clock");
    /**
     * 全局时钟信息组件实例。
     */
    paper.clock = null;
    /**
     * @deprecated
     * @see paper.clock
     */
    paper.Time = null;
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * TODO
     * @internal
     */
    paper._parentChangedGameObjects = [];
    /**
     * 全局销毁信息收集组件。
     */
    var DisposeCollecter = (function (_super) {
        __extends(DisposeCollecter, _super);
        function DisposeCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 缓存此帧销毁的全部场景。
             */
            _this.scenes = [];
            /**
             * 缓存此帧销毁的全部实体。
             */
            _this.gameObjects = [];
            /**
             * 缓存此帧更改过父级的实体。
             */
            _this.parentChangedGameObjects = paper._parentChangedGameObjects;
            /**
             * 缓存此帧销毁的全部组件。
             */
            _this.components = [];
            /**
             * 缓存此帧结束时释放的对象。
             */
            _this.releases = [];
            return _this;
        }
        DisposeCollecter.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            paper.disposeCollecter = this;
        };
        /**
         * @internal
         */
        DisposeCollecter.prototype.clear = function () {
            this.scenes.length = 0;
            this.gameObjects.length = 0;
            this.parentChangedGameObjects.length = 0;
            this.components.length = 0;
            this.releases.length = 0;
        };
        return DisposeCollecter;
    }(paper.SingletonComponent));
    paper.DisposeCollecter = DisposeCollecter;
    __reflect(DisposeCollecter.prototype, "paper.DisposeCollecter");
    /**
     * @internal
     */
    paper.disposeCollecter = null;
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 关心组件的类型。
     */
    var InterestType;
    (function (InterestType) {
        /**
         * @deprecated
         */
        InterestType[InterestType["Extends"] = 1] = "Extends";
        /**
         *
         */
        InterestType[InterestType["Exculde"] = 2] = "Exculde";
        /**
         *
         */
        InterestType[InterestType["Unessential"] = 4] = "Unessential";
    })(InterestType = paper.InterestType || (paper.InterestType = {}));
    /**
     * 实体组。
     * - 收集符合指定特征的实体。
     */
    var GameObjectGroup = (function () {
        function GameObjectGroup(interestConfig) {
            /**
             * TODO
             * @internal
             */
            this.locked = false;
            this._isRemoved = false;
            this._isBehaviour = false;
            // TODO add systems
            this._bufferedGameObjects = [];
            /**
             * @internal
             */
            this._addedGameObjects = [];
            this._gameObjects = []; // TODO
            this._bufferedComponents = [];
            /**
             * @internal
             */
            this._addedComponents = [];
            this._behaviourComponents = []; // TODO
            this._interestConfig = null;
            this._isBehaviour = interestConfig.length === 1 && interestConfig[0].type !== undefined && interestConfig[0].type !== 0;
            this._interestConfig = interestConfig;
            for (var _i = 0, _a = this._interestConfig; _i < _a.length; _i++) {
                var config = _a[_i];
                var isUnessential = (config.type !== undefined) && (config.type & 4 /* Unessential */) !== 0;
                if (Array.isArray(config.componentClass)) {
                    for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                        var componentClass = _c[_b];
                        this._addListener(componentClass, isUnessential);
                    }
                }
                else {
                    this._addListener(config.componentClass, isUnessential);
                }
            }
            for (var _d = 0, _e = paper.Application.sceneManager.scenes; _d < _e.length; _d++) {
                var scene = _e[_d];
                for (var _f = 0, _g = scene.gameObjects; _f < _g.length; _f++) {
                    var gameObject = _g[_f];
                    this._addGameObject(gameObject);
                }
            }
        }
        /**
         * @internal
         */
        GameObjectGroup.create = function (interestConfig) {
            interestConfig = Array.isArray(interestConfig) ? interestConfig : [interestConfig];
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group_1 = _a[_i];
                if (group_1._interestConfig.length !== interestConfig.length) {
                    continue;
                }
                var isSame = true;
                for (var i = 0, l = interestConfig.length; i < l; ++i) {
                    var configA = interestConfig[i];
                    var configB = group_1._interestConfig[i];
                    if (configA.type !== configB.type) {
                        isSame = false;
                        break;
                    }
                    if (Array.isArray(configA.componentClass) && Array.isArray(configB.componentClass)) {
                        if (configA.componentClass.length !== configB.componentClass.length) {
                            isSame = false;
                            break;
                        }
                    }
                    else if (configA.componentClass !== configB.componentClass) {
                        isSame = false;
                        break;
                    }
                }
                if (isSame) {
                    return group_1;
                }
            }
            var group = new GameObjectGroup(interestConfig);
            this._groups.push(group);
            return group;
        };
        /**
         * @internal
         */
        GameObjectGroup.update = function () {
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group = _a[_i];
                group._update();
            }
        };
        GameObjectGroup.prototype._addListener = function (componentClass, isUnessential) {
            paper.registerClass(componentClass);
            componentClass.onComponentDisabled.add(this._onRemoveUnessentialComponent, this);
            if (!isUnessential) {
                componentClass.onComponentEnabled.add(this._onAddComponent, this);
                componentClass.onComponentDisabled.add(this._onRemoveComponent, this);
            }
            componentClass.onComponentEnabled.add(this._onAddUnessentialComponent, this);
        };
        GameObjectGroup.prototype._onAddComponent = function (component) {
            this._addGameObject(component.gameObject);
        };
        GameObjectGroup.prototype._onAddUnessentialComponent = function (component) {
            var gameObject = component.gameObject;
            if (!component.isActiveAndEnabled) {
                return;
            }
            if (!this._isBehaviour) {
                if (this._bufferedGameObjects.indexOf(gameObject) < 0 && this._gameObjects.indexOf(gameObject) < 0) {
                    return;
                }
            }
            if (this._bufferedComponents.indexOf(component) >= 0 || this._behaviourComponents.indexOf(component) >= 0) {
                return;
            }
            this._bufferedComponents.push(component);
        };
        GameObjectGroup.prototype._onRemoveUnessentialComponent = function (component) {
            var gameObject = component.gameObject;
            var index = this._bufferedComponents.indexOf(component);
            if (index >= 0) {
                this._bufferedComponents.splice(index, 1);
                return;
            }
            if (this._isBehaviour) {
                index = this._behaviourComponents.indexOf(component);
                if (index < 0) {
                    return;
                }
                this._isRemoved = true;
                this._behaviourComponents[index] = null;
                index = this._addedComponents.indexOf(component);
                if (index >= 0) {
                    this._addedComponents[index] = null;
                }
            }
            else {
                if (this._gameObjects.indexOf(gameObject) < 0) {
                    return;
                }
                index = this._addedComponents.indexOf(component);
                if (index >= 0) {
                    this._addedComponents[index] = null;
                }
            }
            for (var _i = 0, _a = paper.Application.systemManager.systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (!system.onRemoveComponent || system.groups.indexOf(this) < 0) {
                    continue;
                }
                system.onRemoveComponent(component, this);
            }
        };
        GameObjectGroup.prototype._onRemoveComponent = function (component) {
            this._removeGameObject(component.gameObject);
        };
        GameObjectGroup.prototype._addGameObject = function (gameObject) {
            if (!gameObject.activeInHierarchy) {
                return;
            }
            if (this._bufferedGameObjects.indexOf(gameObject) >= 0 ||
                this._gameObjects.indexOf(gameObject) >= 0) {
                return;
            }
            for (var _i = 0, _a = this._interestConfig; _i < _a.length; _i++) {
                var config = _a[_i];
                if (config.type && (config.type & 4 /* Unessential */)) {
                    continue;
                }
                var isExtends = config.type && (config.type & 1 /* Extends */) !== 0;
                var isExculde = config.type && (config.type & 2 /* Exculde */) !== 0;
                var insterestComponent = null;
                if (Array.isArray(config.componentClass)) {
                    for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                        var componentClass = _c[_b];
                        insterestComponent = gameObject.getComponent(componentClass, isExtends);
                        if (insterestComponent && insterestComponent.isActiveAndEnabled) {
                            break;
                        }
                        insterestComponent = null;
                    }
                }
                else {
                    insterestComponent = gameObject.getComponent(config.componentClass, isExtends);
                    if (insterestComponent && !insterestComponent.isActiveAndEnabled) {
                        insterestComponent = null;
                    }
                }
                if (isExculde ? insterestComponent : !insterestComponent) {
                    return;
                }
            }
            this._bufferedGameObjects.push(gameObject);
        };
        GameObjectGroup.prototype._removeGameObject = function (gameObject) {
            var index = this._bufferedGameObjects.indexOf(gameObject);
            if (index >= 0) {
                this._bufferedGameObjects.splice(index, 1);
            }
            else {
                index = this._gameObjects.indexOf(gameObject);
                if (index >= 0) {
                    if (this.locked) {
                        this.locked = false;
                        this._gameObjects = this._gameObjects.concat();
                    }
                    this._gameObjects.splice(index, 1);
                    index = this._addedGameObjects.indexOf(gameObject);
                    if (index >= 0) {
                        this._addedGameObjects[index] = null;
                    }
                    for (var _i = 0, _a = paper.Application.systemManager.systems; _i < _a.length; _i++) {
                        var system = _a[_i];
                        if (!system.onRemoveGameObject || system.groups.indexOf(this) < 0) {
                            continue;
                        }
                        system.onRemoveGameObject(gameObject, this);
                    }
                }
            }
        };
        GameObjectGroup.prototype._update = function () {
            this.locked = false;
            if (this._addedGameObjects.length > 0) {
                this._addedGameObjects.length = 0;
            }
            if (this._addedComponents.length > 0) {
                this._addedComponents.length = 0;
            }
            if (this._isRemoved) {
                var index = 0;
                var removeCount = 0;
                this._isRemoved = false;
                for (var _i = 0, _a = this._behaviourComponents; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (component) {
                        if (removeCount > 0) {
                            this._behaviourComponents[index - removeCount] = component;
                            this._behaviourComponents[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
                if (removeCount > 0) {
                    this._behaviourComponents.length -= removeCount;
                }
            }
            if (this._bufferedGameObjects.length > 0) {
                for (var _b = 0, _c = this._bufferedGameObjects; _b < _c.length; _b++) {
                    var gameObject = _c[_b];
                    if (!gameObject) {
                        continue;
                    }
                    this._addedGameObjects.push(gameObject);
                    this._gameObjects.push(gameObject);
                }
                this._bufferedGameObjects.length = 0;
            }
            if (this._bufferedComponents.length > 0) {
                for (var _d = 0, _e = this._bufferedComponents; _d < _e.length; _d++) {
                    var component = _e[_d];
                    if (!component) {
                        continue;
                    }
                    this._addedComponents.push(component);
                    if (component.constructor.__isBehaviour) {
                        if (component.gameObject.getComponent(egret3d.Camera)) {
                            this._behaviourComponents.unshift(component);
                        }
                        else {
                            this._behaviourComponents.push(component);
                        }
                    }
                }
                this._bufferedComponents.length = 0;
            }
        };
        /**
         * 该组是否已收集指定的实体。
         */
        GameObjectGroup.prototype.hasGameObject = function (gameObject) {
            return this._gameObjects.indexOf(gameObject) >= 0;
        };
        Object.defineProperty(GameObjectGroup.prototype, "gameObjects", {
            /**
             * 该组已收集的全部实体。
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObjectGroup.prototype, "components", {
            /**
             * 该组已收集的全部组件。
             */
            get: function () {
                return this._behaviourComponents;
            },
            enumerable: true,
            configurable: true
        });
        GameObjectGroup._groups = [];
        return GameObjectGroup;
    }());
    paper.GameObjectGroup = GameObjectGroup;
    __reflect(GameObjectGroup.prototype, "paper.GameObjectGroup");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 几何平面。
     */
    var Plane = (function (_super) {
        __extends(Plane, _super);
        /**
         * 请使用 `egret3d.Plane.create()` 创建实例。
         * @see egret3d.Plane.create()
         */
        function Plane() {
            var _this = _super.call(this) || this;
            /**
             * 二维平面到原点的距离。
             */
            _this.constant = 0.0;
            /**
             * 平面的法线。
             */
            _this.normal = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个几何平面。
         * @param normal 法线。
         * @param constant 二维平面离原点的距离。
         */
        Plane.create = function (normal, constant) {
            if (normal === void 0) { normal = egret3d.Vector3.ZERO; }
            if (constant === void 0) { constant = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(normal, constant);
                instance._released = false;
                return instance;
            }
            return new Plane().set(normal, constant);
        };
        Plane.prototype.serialize = function () {
            return this.toArray();
        };
        Plane.prototype.deserialize = function (value) {
            this.normal.fromArray(value);
            this.constant = value[3];
            return this;
        };
        Plane.prototype.clone = function () {
            return Plane.create(this.normal, this.constant);
        };
        Plane.prototype.copy = function (value) {
            return this.set(value.normal, value.constant);
        };
        Plane.prototype.set = function (normal, constant) {
            this.constant = constant;
            this.normal.copy(normal);
            return this;
        };
        Plane.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.normal.fromArray(array, offset);
            this.constant = array[offset + 3];
            return this;
        };
        Plane.prototype.fromPoint = function (point, normal) {
            if (normal === void 0) { normal = egret3d.Vector3.UP; }
            this.constant = -normal.dot(point);
            this.normal.copy(normal);
            return this;
        };
        Plane.prototype.fromPoints = function (valueA, valueB, valueC) {
            var normal = egret3d.helpVector3A.subtract(valueC, valueB).cross(egret3d.helpVector3B.subtract(valueA, valueB)).normalize();
            this.fromPoint(valueA, normal);
            return this;
        };
        Plane.prototype.normalize = function (input) {
            if (!input) {
                input = this;
            }
            var inverseNormalLength = 1.0 / input.normal.length;
            this.constant = input.constant * inverseNormalLength;
            this.normal.multiplyScalar(inverseNormalLength, input.normal);
            return this;
        };
        Plane.prototype.negate = function (input) {
            if (!input) {
                input = this;
            }
            this.constant = -input.constant;
            this.normal.negate(input.normal);
            return this;
        };
        Plane.prototype.applyMatrix = function (matrix, normalMatrix) {
            if (!normalMatrix) {
                normalMatrix = egret3d.helpMatrix3A.getNormalMatrix(matrix);
            }
            var referencePoint = this.getCoplanarPoint(egret3d.helpVector3A).applyMatrix(matrix);
            var normal = this.normal.applyMatrix3(normalMatrix).normalize();
            this.constant = -referencePoint.dot(normal);
            return this;
        };
        Plane.prototype.getDistance = function (point) {
            return this.normal.dot(point) + this.constant;
        };
        Plane.prototype.getProjectionPoint = function (point, output) {
            if (!output) {
                output = egret3d.Vector3.create();
            }
            return output.multiplyScalar(-this.getDistance(point), this.normal).add(point);
        };
        Plane.prototype.getCoplanarPoint = function (output) {
            if (!output) {
                output = egret3d.Vector3.create();
            }
            return output.copy(this.normal).multiplyScalar(-this.constant);
        };
        Plane.prototype.raycast = function (ray, raycastInfo) {
            var t = ray.getDistanceToPlane(this);
            if (t > 0.0) {
                if (raycastInfo) {
                    var normal = raycastInfo.normal;
                    raycastInfo.distance = t;
                    ray.getPointAt(t, raycastInfo.position);
                    if (normal) {
                        // TODO
                        normal.copy(this.normal);
                    }
                }
                return true;
            }
            return false;
        };
        Plane.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            this.normal.toArray(array, offset);
            array[offset + 3] = this.constant;
            return array;
        };
        Plane._instances = [];
        return Plane;
    }(paper.BaseRelease));
    egret3d.Plane = Plane;
    __reflect(Plane.prototype, "egret3d.Plane", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
    /**
     * @internal
     */
    var helpPlane = Plane.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var EnableSystem = (function (_super) {
        __extends(EnableSystem, _super);
        function EnableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        EnableSystem.prototype.onAddComponent = function (component) {
            if (!component) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */) {
                if (!component.constructor.executeInEditMode) {
                    return;
                }
                if (!component._isReseted) {
                    component._isReseted = true;
                    component.onReset && component.onReset();
                }
            }
            component.onEnable && component.onEnable();
        };
        return EnableSystem;
    }(paper.BaseSystem));
    paper.EnableSystem = EnableSystem;
    __reflect(EnableSystem.prototype, "paper.EnableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var StartSystem = (function (_super) {
        __extends(StartSystem, _super);
        function StartSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        StartSystem.prototype.onAddComponent = function (component) {
            if (!component || component._isStarted) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */ &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component._isStarted = true;
            component.onStart && component.onStart();
        };
        return StartSystem;
    }(paper.BaseSystem));
    paper.StartSystem = StartSystem;
    __reflect(StartSystem.prototype, "paper.StartSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 固定更新系统。
     * TODO
     */
    var FixedUpdateSystem = (function (_super) {
        __extends(FixedUpdateSystem, _super);
        function FixedUpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        FixedUpdateSystem.prototype.onUpdate = function () {
            var clock = this.clock;
            var currentTimes = 0;
            var fixedTime = clock.fixedTime;
            var totalTimes = Math.min(Math.floor(fixedTime / clock.fixedDeltaTime), clock.maxFixedSubSteps);
            var components = this.groups[0].components;
            while (fixedTime >= clock.fixedDeltaTime && currentTimes++ < clock.maxFixedSubSteps) {
                for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
                    var component = components_1[_i];
                    if (component && component._isStarted) {
                        component.onFixedUpdate && component.onFixedUpdate(currentTimes, totalTimes);
                    }
                }
                fixedTime -= clock.fixedDeltaTime;
            }
        };
        return FixedUpdateSystem;
    }(paper.BaseSystem));
    paper.FixedUpdateSystem = FixedUpdateSystem;
    __reflect(FixedUpdateSystem.prototype, "paper.FixedUpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 更新系统。
     */
    var UpdateSystem = (function (_super) {
        __extends(UpdateSystem, _super);
        function UpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        UpdateSystem.prototype.onUpdate = function (deltaTime) {
            var components = this.groups[0].components;
            for (var _i = 0, components_2 = components; _i < components_2.length; _i++) {
                var component = components_2[_i];
                if (component && component._isStarted) {
                    component.onUpdate && component.onUpdate(deltaTime);
                }
            }
        };
        return UpdateSystem;
    }(paper.BaseSystem));
    paper.UpdateSystem = UpdateSystem;
    __reflect(UpdateSystem.prototype, "paper.UpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * Late 更新系统。
     */
    var LateUpdateSystem = (function (_super) {
        __extends(LateUpdateSystem, _super);
        function LateUpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            _this._laterCalls = [];
            return _this;
        }
        LateUpdateSystem.prototype.onUpdate = function (deltaTime) {
            // Update behaviours.
            var components = this.groups[0].components;
            for (var _i = 0, components_3 = components; _i < components_3.length; _i++) {
                var component = components_3[_i];
                if (component && component._isStarted) {
                    component.onLateUpdate && component.onLateUpdate(deltaTime);
                }
            }
            //
            egret.ticker.update(); // TODO 帧频
            //
            var laterCalls = this._laterCalls;
            if (laterCalls.length > 0) {
                for (var _a = 0, laterCalls_1 = laterCalls; _a < laterCalls_1.length; _a++) {
                    var callback = laterCalls_1[_a];
                    callback();
                }
                laterCalls.length = 0;
            }
        };
        /**
         * 在 `paper.Behaviour.onLateUpdate()` 生命周期之后回调指定方法。
         * @param callback 需要回调的方法。
         */
        LateUpdateSystem.prototype.callLater = function (callback) {
            this._laterCalls.push(callback);
        };
        return LateUpdateSystem;
    }(paper.BaseSystem));
    paper.LateUpdateSystem = LateUpdateSystem;
    __reflect(LateUpdateSystem.prototype, "paper.LateUpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var DisableSystem = (function (_super) {
        __extends(DisableSystem, _super);
        function DisableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            _this._disposeCollecter = paper.GameObject.globalGameObject.getOrAddComponent(paper.DisposeCollecter);
            return _this;
        }
        DisableSystem.prototype.onRemoveComponent = function (component) {
            if (!component) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */ &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component.onDisable && component.onDisable();
        };
        DisableSystem.prototype.onUpdate = function () {
            var disposeCollecter = this._disposeCollecter;
            for (var _i = 0, _a = disposeCollecter.scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                scene.uninitialize();
            }
            for (var _b = 0, _c = disposeCollecter.gameObjects; _b < _c.length; _b++) {
                var gameObject = _c[_b];
                gameObject.uninitialize();
            }
            for (var _d = 0, _e = disposeCollecter.components; _d < _e.length; _d++) {
                var component = _e[_d];
                component.uninitialize();
            }
            for (var _f = 0, _g = disposeCollecter.releases; _f < _g.length; _f++) {
                var instance = _g[_f];
                var instances = instance.constructor._instances; // TODO
                instance.onClear && instance.onClear();
                instances.push(instance);
            }
            disposeCollecter.clear();
        };
        return DisableSystem;
    }(paper.BaseSystem));
    paper.DisableSystem = DisableSystem;
    __reflect(DisableSystem.prototype, "paper.DisableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    paper.serializeClassMap = {
        0: "paper.Scene",
        1: "paper.GameObject",
        2: "egret3d.AniPlayer",
        3: "egret3d.BoxCollider",
        4: "egret3d.Camera",
        5: "egret3d.MeshFilter",
        6: "egret3d.MeshRenderer",
        7: "egret3d.particle.ParticleComponent",
        8: "egret3d.particle.ParticleRenderer",
        9: "egret3d.SkinnedMeshRenderer",
        10: "egret3d.SphereCollider",
        11: "egret3d.Transform",
        12: "egret3d.Shader",
        15: "egret3d.AnimationClip",
        16: "egret3d.TPoseInfo",
        17: "egret3d.PoseBoneMatrix",
        18: "egret3d.Texture",
        19: "egret3d.Texture",
        20: "egret3d.Vector2",
        21: "egret3d.Vector3",
        22: "egret3d.Vector4",
        23: "egret3d.Quaternion",
        24: "egret3d.Color",
        25: "egret3d.Gradient",
        26: "egret3d.Curve",
        27: "egret3d.Keyframe",
        28: "egret3d.Rect",
        29: "egret3d.MainModule",
        30: "egret3d.EmissionModule",
        31: "egret3d.ShapeModule",
        32: "egret3d.VelocityOverLifetimeModule",
        33: "egret3d.RotationOverLifetimeModule",
        34: "egret3d.ColorOverLifetimeModule",
        35: "egret3d.SizeOverLifetimeModule",
        36: "egret3d.MinMaxCurve",
        37: "egret3d.MinMaxGradient",
        38: "egret3d.alphaKey",
        39: "egret3d.colorKey",
        40: "egret3d.Animation",
        41: "egret3d.GLTFAsset",
        //
        13: "paper.Compatible",
        14: "paper.Compatible",
    };
    /**
     * @internal
     */
    var Compatible = (function () {
        function Compatible() {
        }
        Compatible.prototype.serialize = function () {
            throw new Error("Never");
        };
        Compatible.prototype.deserialize = function (element, data) {
            if (!data) {
                throw new Error("Never");
            }
            return data.getAssetOrComponent(element._glTFAsset);
        };
        return Compatible;
    }());
    paper.Compatible = Compatible;
    __reflect(Compatible.prototype, "paper.Compatible", ["paper.ISerializable"]);
})(paper || (paper = {}));
var paper;
(function (paper) {
    var KEY_UUID = "uuid";
    var KEY_ASSET = "asset";
    var KEY_CLASS = "class";
    var KEY_DESERIALIZE = "deserialize";
    var KEY_COMPONENTS = "components";
    var KEY_EXTRAS = "extras";
    var KEY_CHILDREN = "children";
    // const KEY_MISSINGOBJECT: keyof MissingComponent = 'missingObject';
    function _getDeserializedKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        var serializeKeys = serializedClass.__serializeKeys;
        if (serializeKeys) {
            keys = keys || {};
            for (var key in serializeKeys) {
                var retargetKey = serializeKeys[key];
                if (retargetKey) {
                    keys[retargetKey] = key;
                }
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getDeserializedKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    function _getDeserializedIgnoreKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        if (serializedClass.__deserializeIgnore) {
            keys = keys || [];
            for (var _i = 0, _a = serializedClass.__deserializeIgnore; _i < _a.length; _i++) {
                var key = _a[_i];
                keys.push(key);
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getDeserializedIgnoreKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    /**
     *
     */
    var Deserializer = (function () {
        function Deserializer() {
            /**
             *
             */
            this.assets = [];
            /**
             *
             */
            this.objects = {};
            /**
             *
             */
            this.components = {};
            this.root = null;
            this._deserializers = {};
            this._prefabRootMap = {};
            this._rootTarget = null;
        }
        Deserializer.prototype._deserializeObject = function (source, target) {
            var deserializedKeys = _getDeserializedKeys(target.constructor);
            var deserializedIgnoreKeys = _getDeserializedIgnoreKeys(target.constructor);
            for (var k in source) {
                if (k === KEY_CLASS) {
                    continue;
                }
                if (k === KEY_EXTRAS) {
                    continue;
                }
                if (!this._keepUUID && k === KEY_UUID) {
                    continue;
                }
                // if (k === KEY_MISSINGOBJECT) { // 丢失的对象数据直接赋值。 TODO
                //     (target as any)[k] = source[k];
                //     continue;
                // }
                var retargetKey = (deserializedKeys && k in deserializedKeys) ? deserializedKeys[k] : k; // 重定向反序列化 key。
                if (deserializedIgnoreKeys && deserializedIgnoreKeys.indexOf(retargetKey) >= 0) {
                    continue;
                }
                var retarget = this._deserializeChild(source[k], target[retargetKey]);
                if (retarget === undefined) {
                    continue;
                }
                target[retargetKey] = retarget;
            }
            return target;
        };
        Deserializer.prototype._deserializeComponent = function (componentSource, source, target) {
            var className = paper.serializeClassMap[componentSource.class] || componentSource.class; // 废弃 serializeClassMap。
            var clazz = egret.getDefinitionByName(className);
            var componentTarget = undefined;
            if (clazz) {
                var hasLink = KEY_EXTRAS in componentSource && componentSource[KEY_EXTRAS].linkedID;
                if (clazz === egret3d.Transform) {
                    componentTarget = this.components[componentSource.uuid];
                    if (KEY_CHILDREN in componentSource) {
                        for (var _i = 0, _a = componentSource[KEY_CHILDREN]; _i < _a.length; _i++) {
                            var childUUID = _a[_i];
                            var child = this.components[childUUID.uuid];
                            if (child && child._parent !== componentTarget) {
                                child._parent = componentTarget;
                                componentTarget._children.push(child);
                            }
                        }
                    }
                }
                else {
                    if (hasLink) {
                        var componentExtras = componentSource[KEY_EXTRAS];
                        var extras = source[KEY_EXTRAS];
                        var linkedID = componentExtras.linkedID;
                        var prefabDeserializer = this._deserializers[extras.prefab ? source.uuid : extras.rootID];
                        componentTarget = prefabDeserializer.components[linkedID];
                    }
                    else {
                        // const enabled = componentSource._enabled === undefined ? true : componentSource._enabled; // TODO
                        componentTarget = (target || this._rootTarget).addComponent(clazz);
                    }
                    // if (clazz === Behaviour) { TODO
                    //     (componentTarget as Behaviour)._isReseted = true;
                    // }
                }
                if (!hasLink && this._makeLink && componentTarget) {
                    componentTarget.extras.linkedID = componentSource.uuid;
                }
            }
            else {
                componentTarget = target.addComponent(paper.MissingComponent);
                componentTarget.missingObject = componentSource;
                if (true) {
                    console.warn("Class " + className + " is not defined.");
                }
            }
            this.components[componentSource.uuid] = componentTarget;
            return componentTarget;
        };
        Deserializer.prototype._deserializeChild = function (source, target) {
            if (source === null || source === undefined) {
                return source;
            }
            switch (typeof source) {
                case "function":
                    return undefined;
                case "object": {
                    if (target) {
                        if (ArrayBuffer.isView(target)) {
                            for (var i = 0, l = Math.min(source.length, target.length); i < l; ++i) {
                                target[i] = source[i];
                            }
                            return target;
                        }
                        else if (Array.isArray(target) && target.length === 0) {
                            for (var i = 0, l = source.length; i < l; ++i) {
                                target[i] = this._deserializeChild(source[i]);
                            }
                            return target;
                        }
                        else if (target[KEY_DESERIALIZE]) {
                            return target.deserialize(source, this);
                        }
                        else {
                            // console.info("Deserialize can be optimized."); TODO
                        }
                    }
                    if (Array.isArray(source)) {
                        target = [];
                        for (var i = 0, l = source.length; i < l; ++i) {
                            target[i] = this._deserializeChild(source[i]);
                        }
                        return target;
                    }
                    var classCodeOrName = source[KEY_CLASS];
                    if (KEY_ASSET in source) {
                        var assetIndex = source.asset;
                        if (assetIndex >= 0) {
                            return paper.Asset.find(this.assets[assetIndex]);
                        }
                        return null;
                    }
                    else if (KEY_UUID in source) {
                        var uuid = source.uuid;
                        if (uuid in this.objects) {
                            return this.objects[uuid];
                        }
                        else if (uuid in this.components) {
                            return this.components[uuid];
                        }
                        else if (classCodeOrName) {
                            var scene = this._rootTarget instanceof paper.GameObject ? this._rootTarget.scene : this._rootTarget;
                            if ((paper.serializeClassMap[classCodeOrName] || classCodeOrName) === egret.getQualifiedClassName(paper.GameObject)) {
                                for (var _i = 0, _a = scene.gameObjects; _i < _a.length; _i++) {
                                    var gameObject = _a[_i];
                                    if (gameObject.uuid === uuid) {
                                        return gameObject;
                                    }
                                }
                            }
                            else {
                                for (var _b = 0, _c = scene.gameObjects; _b < _c.length; _b++) {
                                    var gameObject = _c[_b];
                                    for (var _d = 0, _e = gameObject.components; _d < _e.length; _d++) {
                                        var component = _e[_d];
                                        if (component && component.uuid === uuid) {
                                            return component;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if (classCodeOrName) {
                        var clazz = egret.getDefinitionByName(paper.serializeClassMap[classCodeOrName] || classCodeOrName);
                        if (clazz) {
                            target = new clazz();
                            return target.deserialize(source, this);
                        }
                    }
                    else {
                        target = {};
                        for (var k in source) {
                            target[k] = this._deserializeChild(source[k]);
                        }
                        return target;
                    }
                    console.warn("Deserialize error.", source);
                    return undefined;
                }
                default:
                    return source;
            }
        };
        Deserializer.prototype.getAssetOrComponent = function (source) {
            if (KEY_ASSET in source) {
                var assetIndex = source.asset;
                if (assetIndex >= 0) {
                    return paper.Asset.find(this.assets[assetIndex]);
                }
                return null;
            }
            var uuid = source.uuid;
            return this.components[uuid] || this.objects[uuid];
        };
        /**
         * @private
         */
        Deserializer.prototype.deserialize = function (data, keepUUID, makeLink, rootTarget) {
            if (keepUUID === void 0) { keepUUID = false; }
            if (makeLink === void 0) { makeLink = false; }
            if (rootTarget === void 0) { rootTarget = null; }
            if (data.assets) {
                for (var _i = 0, _a = data.assets; _i < _a.length; _i++) {
                    var assetName = _a[_i];
                    this.assets.push(assetName);
                }
            }
            this._keepUUID = keepUUID;
            this._makeLink = makeLink;
            this._rootTarget = rootTarget;
            var sceneClassName = egret.getQualifiedClassName(paper.Scene);
            var transformClassName = egret.getQualifiedClassName(egret3d.Transform);
            var components = {};
            var root = null;
            if (data.components) {
                for (var _b = 0, _c = data.components; _b < _c.length; _b++) {
                    var componentSource = _c[_b];
                    components[componentSource.uuid] = componentSource;
                }
            }
            if (data.objects) {
                for (var _d = 0, _e = data.objects; _d < _e.length; _d++) {
                    var source = _e[_d];
                    var className = paper.serializeClassMap[source.class] || source.class;
                    var target = undefined;
                    if (className === sceneClassName) {
                        target = paper.Scene.createEmpty(source.name);
                        this._rootTarget = target;
                    }
                    else {
                        if (!this._rootTarget) {
                            this._rootTarget = paper.Application.sceneManager.activeScene; // TODO
                        }
                        var hasLink = KEY_EXTRAS in source && source[KEY_EXTRAS].linkedID;
                        if (hasLink) {
                            var extras = source[KEY_EXTRAS];
                            var linkedID = extras.linkedID;
                            var prefab = extras.prefab;
                            if (prefab) {
                                var assetIndex = prefab.asset;
                                if (assetIndex >= 0) {
                                    var assetName = this.assets[assetIndex];
                                    target = paper.Prefab.create(assetName, this._rootTarget);
                                    if (target) {
                                        this._deserializers[source.uuid] = Deserializer._lastDeserializer;
                                        this._prefabRootMap[source.uuid] = { rootUUID: target.uuid, root: target };
                                    }
                                    else {
                                        target = paper.GameObject.create("Missing Prefab" /* MissingPrefab */, "Untagged" /* Untagged */, this._rootTarget);
                                    }
                                }
                            }
                            else {
                                var prefabDeserializer = this._deserializers[extras.rootID];
                                target = prefabDeserializer.objects[linkedID];
                            }
                        }
                        else {
                            target = paper.GameObject.create("NoName" /* NoName */, "Untagged" /* Untagged */, this._rootTarget);
                            if (this._makeLink) {
                                target.extras.linkedID = source.uuid;
                                if (root) {
                                    target.extras.rootID = root.uuid;
                                }
                            }
                        }
                        if (target && KEY_COMPONENTS in source) {
                            for (var _f = 0, _g = source[KEY_COMPONENTS]; _f < _g.length; _f++) {
                                var componentUUID = _g[_f];
                                var uuid = componentUUID.uuid;
                                var componentSource = components[uuid];
                                if ((paper.serializeClassMap[componentSource.class] || componentSource.class) === transformClassName) {
                                    this.components[uuid] = target.transform;
                                }
                            }
                        }
                    }
                    if (target) {
                        this.objects[source.uuid] = target;
                        root = root || target;
                    }
                }
                var i = data.objects.length;
                while (i--) {
                    var source = data.objects[i];
                    var target = this.objects[source.uuid];
                    if (target) {
                        this._deserializeObject(source, target); // 场景或实体属性反序列化。
                        if (target.constructor === paper.GameObject && KEY_COMPONENTS in source) {
                            for (var _h = 0, _j = source[KEY_COMPONENTS]; _h < _j.length; _h++) {
                                var componentUUID = _j[_h];
                                this._deserializeComponent(components[componentUUID.uuid], source, target);
                            }
                        }
                    }
                }
                // 重新设置 rootID（只有编辑模式需要处理该内容）
                if (paper.Application.playerMode === 2 /* Editor */) {
                    // 重新设置rootid的值
                    for (var uuid in this._prefabRootMap) {
                        var rootDeser = this._deserializers[uuid];
                        for (var key in rootDeser.objects) {
                            var obj = rootDeser.objects[key];
                            if (obj instanceof paper.GameObject) {
                                if (obj.extras.linkedID && obj.extras.rootID === this._prefabRootMap[uuid].rootUUID) {
                                    obj.extras.rootID = this._prefabRootMap[uuid].root.uuid;
                                }
                            }
                        }
                    }
                }
            }
            if (data.components) {
                for (var _k = 0, _l = data.components; _k < _l.length; _k++) {
                    var componentSource = _l[_k];
                    var uuid = componentSource.uuid;
                    var component = this.components[uuid];
                    if (component) {
                        if (component.constructor === paper.MissingComponent &&
                            componentSource[KEY_CLASS].indexOf(component.constructor.name) < 0) {
                            continue;
                        }
                        this._deserializeObject(componentSource, component);
                    }
                    else if (rootTarget && rootTarget.constructor === paper.GameObject) {
                        component = this._deserializeComponent(componentSource);
                        root = root || component;
                        this._deserializeObject(componentSource, component);
                    }
                }
            }
            Deserializer._lastDeserializer = this;
            this.root = root;
            return root;
        };
        return Deserializer;
    }());
    paper.Deserializer = Deserializer;
    __reflect(Deserializer.prototype, "paper.Deserializer");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @private
     */
    paper.DATA_VERSION = 3;
    /**
     * @private
     */
    paper.DATA_VERSIONS = [paper.DATA_VERSION];
    var KEY_GAMEOBJECTS = "gameObjects";
    var KEY_COMPONENTS = "components";
    var KEY_EXTRAS = "extras";
    var KEY_CHILDREN = "children";
    var _inline = false;
    var _serializeds = [];
    var _deserializers = {};
    var _ignoreKeys = ["extras"];
    var _rootIgnoreKeys = ["name", "localPosition", "localRotation", "extras"];
    var _serializeData = null;
    var _defaultGameObject = null;
    /**
     * @private
     */
    function serialize(source, inline) {
        if (inline === void 0) { inline = false; }
        if (_serializeData) {
            console.warn("The deserialization is not complete.");
        }
        if (!_defaultGameObject) {
            _defaultGameObject = paper.GameObject.create("NoName" /* NoName */, "Untagged" /* Untagged */, paper.Application.sceneManager.globalScene);
            _defaultGameObject.parent = paper.GameObject.globalGameObject;
        }
        _inline = inline;
        _serializeData = { version: paper.DATA_VERSION, assets: [], objects: [], components: [] };
        _serializeObject(source);
        _serializeds.length = 0;
        for (var k in _deserializers) {
            delete _deserializers[k];
        }
        _defaultGameObject.transform.destroyChildren();
        _defaultGameObject.removeAllComponents();
        var serializeData = _serializeData;
        _serializeData = null;
        return serializeData;
    }
    paper.serialize = serialize;
    /**
     * @private
     */
    function clone(object) {
        var data = serialize(object, true);
        var deserializer = new paper.Deserializer();
        return deserializer.deserialize(data);
    }
    paper.clone = clone;
    /**
     * @private
     */
    function equal(source, target) {
        var typeSource = typeof source;
        var typeTarget = typeof target;
        if (typeSource !== typeTarget) {
            return false;
        }
        if (source === null && target === null) {
            return true;
        }
        if (source === null || target === null) {
            return false;
        }
        switch (typeSource) {
            case "undefined":
            case "boolean":
            case "number":
            case "string":
            case "symbol":
            case "function":
                return source === target;
            case "object":
            default:
                break;
        }
        if ((Array.isArray(source) || ArrayBuffer.isView(source)) &&
            (Array.isArray(target) || ArrayBuffer.isView(target))) {
            var sl = source.length;
            if (sl !== target.length) {
                return false;
            }
            if (sl === 0) {
                return true;
            }
            for (var i = 0; i < sl; ++i) {
                if (!equal(source[i], target[i])) {
                    return false;
                }
            }
            return true;
        }
        if (source.constructor !== target.constructor) {
            return false;
        }
        if (source instanceof paper.Asset ||
            source.constructor === paper.GameObject ||
            source instanceof paper.BaseComponent) {
            return source === target;
        }
        if (source.constructor === Object) {
            for (var k in source) {
                if (!equal(source[k], target[k])) {
                    return false;
                }
            }
            return true;
        }
        if (egret.is(source, "paper.ISerializable")) {
            return equal(source.serialize(), target.serialize());
        }
        if (source instanceof paper.BaseObject) {
            return equal(serializeStruct(source), serializeStruct(target));
        }
        throw new Error("Unsupported data.");
    }
    paper.equal = equal;
    /**
     * @private
     */
    function serializeAsset(source) {
        if (!source.name) {
            return { asset: -1 };
        }
        if (_serializeData && _serializeData.assets) {
            var index = _serializeData.assets.indexOf(source.name);
            if (index < 0) {
                index = _serializeData.assets.length;
                _serializeData.assets.push(source.name);
            }
            return { asset: index };
        }
        return { asset: -1 };
    }
    paper.serializeAsset = serializeAsset;
    /**
     * 创建指定对象的结构体。
     */
    function serializeStruct(source) {
        var className = egret.getQualifiedClassName(source);
        var target = { class: className };
        _serializeChildren(source, target, null, null);
        return target;
    }
    paper.serializeStruct = serializeStruct;
    function _getSerializedKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        var serializeKeys = serializedClass.__serializeKeys;
        if (serializeKeys) {
            keys = keys || [];
            for (var key in serializeKeys) {
                keys.push(serializeKeys[key] || key);
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getSerializedKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    function _serializeReference(source) {
        var className = egret.getQualifiedClassName(source);
        return { uuid: source.uuid, class: className };
    }
    function _findPrefabRoot(gameObject) {
        while (!gameObject.extras.prefab) {
            gameObject = gameObject.parent;
        }
        return gameObject;
    }
    function _serializeObject(source) {
        if (_serializeds.indexOf(source.uuid) >= 0) {
            return true;
        }
        var target = _serializeReference(source);
        var temp = null;
        var ignoreKeys = _ignoreKeys;
        if (source instanceof paper.GameObject) {
            if (source.isDestroyed) {
                console.warn("Missing game object.");
                return false;
            }
            if (source.extras && source.extras.linkedID) {
                var rootPrefabObject = _findPrefabRoot(source);
                var prefabName = rootPrefabObject.extras.prefab.name;
                if (!(prefabName in _deserializers)) {
                    var prefabGameObject = paper.Prefab.create(prefabName, _defaultGameObject.scene);
                    prefabGameObject.parent = _defaultGameObject;
                    _deserializers[prefabName] = paper.Deserializer._lastDeserializer;
                }
                var deserializer = _deserializers[prefabName];
                temp = deserializer.objects[source.extras.linkedID];
                if (source.extras.prefab) {
                    ignoreKeys = _rootIgnoreKeys;
                }
            }
            else {
                temp = _defaultGameObject;
            }
            _serializeData.objects.push(target);
        }
        else if (source instanceof paper.BaseComponent) {
            if (source.isDestroyed) {
                console.warn("Missing component.");
                return false;
            }
            if (source.extras && source.extras.linkedID) {
                var rootPrefabObject = _findPrefabRoot(source.gameObject);
                var prefabName = rootPrefabObject.extras.prefab.name;
                if (!(prefabName in _deserializers)) {
                    var prefabGameObject = paper.Prefab.create(prefabName, _defaultGameObject.scene);
                    prefabGameObject.parent = _defaultGameObject;
                    _deserializers[prefabName] = paper.Deserializer._lastDeserializer;
                }
                var deserializer = _deserializers[prefabName];
                temp = deserializer.components[source.extras.linkedID];
                if (source.gameObject.extras.prefab) {
                    ignoreKeys = _rootIgnoreKeys;
                }
            }
            else {
                temp = _defaultGameObject.getOrAddComponent(source.constructor);
            }
            _serializeData.components.push(target);
        }
        else {
            _serializeData.objects.push(target);
        }
        _serializeds.push(source.uuid);
        _serializeChildren(source, target, temp, ignoreKeys);
        return true;
    }
    function _serializeChildren(source, target, temp, ignoreKeys) {
        var serializedKeys = _getSerializedKeys(source.constructor);
        if (!serializedKeys) {
            return;
        }
        for (var _i = 0, serializedKeys_1 = serializedKeys; _i < serializedKeys_1.length; _i++) {
            var k = serializedKeys_1[_i];
            if (temp && (!ignoreKeys || ignoreKeys.indexOf(k) < 0) && equal(source[k], temp[k])) {
                continue;
            }
            target[k] = _serializeChild(source[k], source, k);
        }
    }
    function _serializeChild(source, parent, key) {
        if (source === null || source === undefined) {
            return source;
        }
        switch (typeof source) {
            case "function":
                return undefined;
            case "object": {
                if (Array.isArray(source) || ArrayBuffer.isView(source)) {
                    var target = [];
                    for (var _i = 0, _a = source; _i < _a.length; _i++) {
                        var element = _a[_i];
                        var result = _serializeChild(element, parent, key);
                        if (result !== undefined) {
                            target.push(result);
                        }
                    }
                    return target;
                }
                if (source.constructor === Object) {
                    var target = {};
                    for (var k in source) {
                        var result = _serializeChild(source[k], parent, key);
                        if (result !== undefined) {
                            target[k] = result;
                        }
                    }
                    return target;
                }
                if (egret.is(source, "paper.ISerializable")) {
                    return source.serialize();
                }
                if (source instanceof paper.BaseObject) {
                    if (source.constructor === paper.Scene) {
                        return undefined; // Pass.
                    }
                    if (source instanceof paper.Asset) {
                        return serializeAsset(source);
                    }
                    if (source.constructor === paper.GameObject || source instanceof paper.BaseComponent) {
                        if (source.constructor === paper.GameObject && source.hideFlags === 3 /* HideAndDontSave */) {
                            return undefined; // Pass.
                        }
                        else if (source.constructor === egret3d.Transform && source.gameObject.hideFlags === 3 /* HideAndDontSave */) {
                            return undefined; // Pass.
                        }
                        if (parent) {
                            if (parent.constructor === paper.Scene) {
                                if (key === KEY_GAMEOBJECTS) {
                                    return _serializeObject(source) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                            else if (parent.constructor === paper.GameObject) {
                                if (key === KEY_COMPONENTS) {
                                    return _serializeObject(source) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                            else if (parent.constructor === egret3d.Transform) {
                                if (key === KEY_CHILDREN) {
                                    return _serializeObject(source.gameObject) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                        }
                        return _serializeReference(source);
                    }
                    return serializeStruct(source);
                }
                console.warn("Serialize error.", source);
                return undefined; // Pass.
            }
            default:
                return source;
        }
    }
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * Shader 通用宏定义。
     */
    var ShaderDefine;
    (function (ShaderDefine) {
        ShaderDefine["USE_COLOR"] = "USE_COLOR";
        ShaderDefine["USE_MAP"] = "USE_MAP";
        ShaderDefine["USE_NORMALMAP"] = "USE_NORMALMAP";
        ShaderDefine["USE_BUMPMAP"] = "USE_BUMPMAP";
        ShaderDefine["USE_LIGHTMAP"] = "USE_LIGHTMAP";
        ShaderDefine["USE_SHADOWMAP"] = "USE_SHADOWMAP";
        ShaderDefine["USE_SKINNING"] = "USE_SKINNING";
        ShaderDefine["USE_SIZEATTENUATION"] = "USE_SIZEATTENUATION";
        //
        ShaderDefine["FLAT_SHADED"] = "FLAT_SHADED";
        ShaderDefine["ENVMAP_TYPE_CUBE_UV"] = "ENVMAP_TYPE_CUBE_UV";
        //
        ShaderDefine["MAX_BONES"] = "MAX_BONES";
        //
        ShaderDefine["NUM_POINT_LIGHTS"] = "NUM_POINT_LIGHTS";
        ShaderDefine["NUM_SPOT_LIGHTS"] = "NUM_SPOT_LIGHTS";
        ShaderDefine["SHADOWMAP_TYPE_PCF"] = "SHADOWMAP_TYPE_PCF";
        ShaderDefine["SHADOWMAP_TYPE_PCF_SOFT"] = "SHADOWMAP_TYPE_PCF_SOFT";
        ShaderDefine["DEPTH_PACKING_3200"] = "DEPTH_PACKING 3200";
        ShaderDefine["DEPTH_PACKING_3201"] = "DEPTH_PACKING 3201";
        //
        ShaderDefine["USE_FOG"] = "USE_FOG";
        ShaderDefine["FOG_EXP2"] = "FOG_EXP2";
        //
        ShaderDefine["FLIP_V"] = "FLIP_V";
    })(ShaderDefine = egret3d.ShaderDefine || (egret3d.ShaderDefine = {}));
    /**
     * Shader 通用 Uniform 名称。
     */
    var ShaderUniformName;
    (function (ShaderUniformName) {
        ShaderUniformName["Diffuse"] = "diffuse";
        ShaderUniformName["Opacity"] = "opacity";
        ShaderUniformName["Size"] = "size";
        ShaderUniformName["Map"] = "map";
        ShaderUniformName["Specular"] = "specular";
        ShaderUniformName["Shininess"] = "shininess";
        ShaderUniformName["UVTransform"] = "uvTransform";
    })(ShaderUniformName = egret3d.ShaderUniformName || (egret3d.ShaderUniformName = {}));
    /**
     *
     */
    var HumanoidMask;
    (function (HumanoidMask) {
        HumanoidMask[HumanoidMask["Head"] = 0] = "Head";
        HumanoidMask[HumanoidMask["Body"] = 1] = "Body";
        HumanoidMask[HumanoidMask["LeftArm"] = 2] = "LeftArm";
        HumanoidMask[HumanoidMask["RightArm"] = 3] = "RightArm";
        HumanoidMask[HumanoidMask["LeftHand"] = 4] = "LeftHand";
        HumanoidMask[HumanoidMask["RightHand"] = 5] = "RightHand";
        HumanoidMask[HumanoidMask["LeftLeg"] = 6] = "LeftLeg";
        HumanoidMask[HumanoidMask["RightLeg"] = 7] = "RightLeg";
        HumanoidMask[HumanoidMask["LeftHandIK"] = 8] = "LeftHandIK";
        HumanoidMask[HumanoidMask["RightHandIK"] = 9] = "RightHandIK";
        HumanoidMask[HumanoidMask["LeftFootIK"] = 10] = "LeftFootIK";
        HumanoidMask[HumanoidMask["RightFootIK"] = 11] = "RightFootIK";
    })(HumanoidMask = egret3d.HumanoidMask || (egret3d.HumanoidMask = {}));
    /**
     *
     */
    var HumanoidJoint;
    (function (HumanoidJoint) {
        HumanoidJoint["Heck"] = "H_Neck";
        HumanoidJoint["Head"] = "H_Head";
        HumanoidJoint["LeftEye"] = "H_LeftEye";
        HumanoidJoint["RightEye"] = "H_RightEye";
        HumanoidJoint["Jaw"] = "H_Jaw";
        HumanoidJoint["Hips"] = "B_Hips";
        HumanoidJoint["Spine"] = "B_Spine";
        HumanoidJoint["Chest"] = "B_Chest";
        HumanoidJoint["UpperChest"] = "B_UpperChest";
        HumanoidJoint["LeftShoulder"] = "LA_Shoulder";
        HumanoidJoint["LeftUpperArm"] = "LA_UpperArm";
        HumanoidJoint["LeftLowerArm"] = "LA_LowerArm";
        HumanoidJoint["LeftHand"] = "LA_Hand";
        HumanoidJoint["RightShoulder"] = "RA_Shoulder";
        HumanoidJoint["RightUpperArm"] = "RA_UpperArm";
        HumanoidJoint["RightLowerArm"] = "RA_LowerArm";
        HumanoidJoint["RightHand"] = "RA_Hand";
        HumanoidJoint["LeftUpperLeg"] = "LL_UpperLeg";
        HumanoidJoint["LeftLowerLeg"] = "LL_LowerLeg";
        HumanoidJoint["LeftFoot"] = "LL_Foot";
        HumanoidJoint["LeftToes"] = "LL_Toes";
        HumanoidJoint["RightUpperLeg"] = "RL_UpperLeg";
        HumanoidJoint["RightLowerLeg"] = "RL_LowerLeg";
        HumanoidJoint["RightFoot"] = "RL_Foot";
        HumanoidJoint["RightToes"] = "RL_Toes";
        HumanoidJoint["LeftThumbProximal"] = "LH_ThumbProximal";
        HumanoidJoint["LeftThumbIntermediate"] = "LH_ThumbIntermediate";
        HumanoidJoint["LeftThumbDistal"] = "LH_ThumbDistal";
        HumanoidJoint["LeftIndexProximal"] = "LH_IndexProximal";
        HumanoidJoint["LeftIndexIntermediate"] = "LH_IndexIntermediate";
        HumanoidJoint["LeftIndexDistal"] = "LH_IndexDistal";
        HumanoidJoint["LeftMiddleProximal"] = "LH_MiddleProximal";
        HumanoidJoint["LeftMiddleIntermediate"] = "LH_MiddleIntermediate";
        HumanoidJoint["LeftMiddleDistal"] = "LH_MiddleDistal";
        HumanoidJoint["LeftRingProximal"] = "LH_RingProximal";
        HumanoidJoint["LeftRingIntermediate"] = "LH_RingIntermediate";
        HumanoidJoint["LeftRingDistal"] = "LH_RingDistal";
        HumanoidJoint["LeftLittleProximal"] = "LH_LittleProximal";
        HumanoidJoint["LeftLittleIntermediate"] = "LH_LittleIntermediate";
        HumanoidJoint["LeftLittleDistal"] = "LH_LittleDistal";
        HumanoidJoint["RightThumbProximal"] = "RH_ThumbProximal";
        HumanoidJoint["RightThumbIntermediate"] = "RH_ThumbIntermediate";
        HumanoidJoint["RightThumbDistal"] = "RH_ThumbDistal";
        HumanoidJoint["RightIndexProximal"] = "RH_IndexProximal";
        HumanoidJoint["RightIndexIntermediate"] = "RH_IndexIntermediate";
        HumanoidJoint["RightIndexDistal"] = "RH_IndexDistal";
        HumanoidJoint["RightMiddleProximal"] = "RH_MiddleProximal";
        HumanoidJoint["RightMiddleIntermediate"] = "RH_MiddleIntermediate";
        HumanoidJoint["RightMiddleDistal"] = "RH_MiddleDistal";
        HumanoidJoint["RightRingProximal"] = "RH_RingProximal";
        HumanoidJoint["RightRingIntermediate"] = "RH_RingIntermediate";
        HumanoidJoint["RightRingDistal"] = "RH_RingDistal";
        HumanoidJoint["RightLittleProximal"] = "RH_LittleProximal";
        HumanoidJoint["RightLittleIntermediate"] = "RH_LittleIntermediate";
        HumanoidJoint["RightLittleDistal"] = "RH_LittleDistal";
    })(HumanoidJoint = egret3d.HumanoidJoint || (egret3d.HumanoidJoint = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    var _helpRotation = egret3d.Quaternion.create();
    var _helpMatrix3 = egret3d.Matrix3.create();
    var _helpMatrix = egret3d.Matrix4.create();
    var TransformDirty;
    (function (TransformDirty) {
        TransformDirty[TransformDirty["All"] = 63] = "All";
        TransformDirty[TransformDirty["EXT"] = 62] = "EXT";
        TransformDirty[TransformDirty["PRS"] = 7] = "PRS";
        TransformDirty[TransformDirty["MIM"] = 48] = "MIM";
        TransformDirty[TransformDirty["Position"] = 1] = "Position";
        TransformDirty[TransformDirty["Rotation"] = 2] = "Rotation";
        TransformDirty[TransformDirty["Scale"] = 4] = "Scale";
        TransformDirty[TransformDirty["Euler"] = 8] = "Euler";
        TransformDirty[TransformDirty["Matrix"] = 16] = "Matrix";
        TransformDirty[TransformDirty["InverseMatrix"] = 32] = "InverseMatrix";
    })(TransformDirty || (TransformDirty = {}));
    /**
     * 变换组件。
     * - 实现实体之间的父子关系。
     * - 实现 3D 空间坐标系变换。
     */
    var Transform = (function (_super) {
        __extends(Transform, _super);
        function Transform() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._localDirty = 63 /* All */;
            _this._worldDirty = 63 /* All */;
            /**
             * 世界矩阵的行列式，如果小于0，说明进行了反转
             * @internal
             */
            _this._worldMatrixDeterminant = 0.0;
            _this._localPosition = egret3d.Vector3.create();
            _this._localRotation = egret3d.Quaternion.create();
            _this._localEuler = egret3d.Vector3.create();
            _this._localEulerAngles = egret3d.Vector3.create();
            _this._localScale = egret3d.Vector3.ONE.clone();
            _this._position = egret3d.Vector3.create();
            _this._rotation = egret3d.Quaternion.create();
            _this._euler = egret3d.Vector3.create();
            _this._eulerAngles = egret3d.Vector3.create();
            _this._scale = egret3d.Vector3.ONE.clone();
            _this._localToParentMatrix = egret3d.Matrix4.create();
            _this._worldToLocalMatrix = egret3d.Matrix4.create();
            _this._localToWorldMatrix = egret3d.Matrix4.create();
            /**
             * @internal
             */
            _this._children = [];
            _this._observers = [];
            /**
             * @internal
             */
            _this._parent = null;
            return _this;
        }
        Transform.prototype._removeFromChildren = function (value) {
            var index = 0;
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child === value) {
                    this._children.splice(index, 1);
                    break;
                }
                index++;
            }
        };
        Transform.prototype._getRotationAndScale = function () {
            var scale = egret3d.Matrix3.create().fromScale(this._localScale).release();
            var rotation = egret3d.Matrix3.create().fromMatrix4(_helpMatrix.fromRotation(this._localRotation)).release();
            if (this._parent) {
                return this._parent._getRotationAndScale().multiply(rotation).multiply(scale);
            }
            return rotation.multiply(scale);
        };
        // private _setRotationAndScale(value: Readonly<Matrix3>) {
        //     const rotationAndScale = this._getRotationAndScale().inverse().multiply(value);
        //     this._localScale.set(rotationAndScale.rawData[0], rotationAndScale.rawData[4], rotationAndScale.rawData[8]).update();
        // }
        Transform.prototype._dirtify = function (isLocalDirty, dirty) {
            if (isLocalDirty) {
                this._localDirty |= dirty | 48 /* MIM */;
                if (dirty & 2 /* Rotation */) {
                    this._localDirty |= 4 /* Scale */ | 8 /* Euler */;
                }
                else if (dirty & 4 /* Scale */) {
                    this._localDirty |= 2 /* Rotation */;
                }
                if (true) {
                    if (dirty & 1 /* Position */) {
                        var isError = false;
                        var localPosition = this._localPosition;
                        if (localPosition.x !== localPosition.x) {
                            isError = true;
                            localPosition.x = 0.0;
                        }
                        if (localPosition.y !== localPosition.y) {
                            isError = true;
                            localPosition.y = 0.0;
                        }
                        if (localPosition.z !== localPosition.z) {
                            isError = true;
                            localPosition.z = 0.0;
                        }
                        if (isError) {
                            console.error("Error local position.");
                        }
                    }
                    if (dirty & 2 /* Rotation */) {
                        var isError = false;
                        var localRotation = this._localRotation;
                        if (localRotation.x !== localRotation.x) {
                            isError = true;
                            localRotation.x = 0.0;
                        }
                        if (localRotation.y !== localRotation.y) {
                            isError = true;
                            localRotation.y = 0.0;
                        }
                        if (localRotation.z !== localRotation.z) {
                            isError = true;
                            localRotation.z = 0.0;
                        }
                        if (localRotation.w !== localRotation.w) {
                            isError = true;
                            localRotation.w = 0.0;
                        }
                        if (isError) {
                            console.error("Error local rotation.");
                        }
                    }
                    if (dirty & 4 /* Scale */) {
                        var isError = false;
                        var localScale = this._localScale;
                        if (localScale.x !== localScale.x) {
                            isError = true;
                            localScale.x = 0.0;
                        }
                        if (localScale.y !== localScale.y) {
                            isError = true;
                            localScale.y = 0.0;
                        }
                        if (localScale.z !== localScale.z) {
                            isError = true;
                            localScale.z = 0.0;
                        }
                        if (isError) {
                            console.error("Error local scale.");
                        }
                    }
                }
            }
            if (!(this._worldDirty & dirty) || !(this._worldDirty & 16 /* Matrix */)) {
                if (dirty & 1 /* Position */) {
                    this._worldDirty |= dirty | 48 /* MIM */;
                }
                else {
                    this._worldDirty = 63 /* All */;
                }
                for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child._dirtify(false, dirty);
                }
            }
            var observers = this._observers;
            if (observers.length > 0) {
                for (var _b = 0, _c = this._observers; _b < _c.length; _b++) {
                    var observer = _c[_b];
                    observer.onTransformChange();
                }
            }
        };
        Transform.prototype._updateMatrix = function (isWorldSpace) {
            if (isWorldSpace) {
                var localMatrix = this.localToParentMatrix;
                if (this._parent) {
                    this._localToWorldMatrix.multiply(this._parent.localToWorldMatrix, localMatrix);
                }
                else {
                    this._localToWorldMatrix.copy(localMatrix);
                }
                this._worldMatrixDeterminant = this._localToWorldMatrix.determinant;
                this._worldDirty &= ~16 /* Matrix */;
            }
            else {
                if ((this._localDirty & 2 /* Rotation */) || (this._localDirty & 4 /* Scale */)) {
                    this._localToParentMatrix.compose(this.localPosition, this.localRotation, this.localScale);
                    this._localDirty &= ~7 /* PRS */;
                }
                else if (this._localDirty & 1 /* Position */) {
                    this._localToParentMatrix.fromTranslate(this.localPosition, true);
                    this._localDirty &= ~1 /* Position */;
                }
                this._localDirty &= ~16 /* Matrix */;
            }
        };
        Transform.prototype._updateEuler = function (isWorldSpace, order) {
            if (isWorldSpace) {
                this.rotation.toEuler(this._euler, order);
                this._eulerAngles.multiplyScalar(57.29577951308232 /* RAD_DEG */, this._euler);
                this._worldDirty &= ~8 /* Euler */;
            }
            else {
                this.localRotation.toEuler(this._localEuler, order);
                this._localEulerAngles.multiplyScalar(57.29577951308232 /* RAD_DEG */, this._localEuler);
                this._localDirty &= ~8 /* Euler */;
            }
        };
        Transform.prototype._addToCollecter = function () {
            var parentChangedGameObjects = paper._parentChangedGameObjects;
            if (parentChangedGameObjects.indexOf(this.gameObject) < 0) {
                parentChangedGameObjects.push(this.gameObject);
            }
        };
        Transform.prototype._onParentChange = function (newParent, oldParent) {
            var prevActive = oldParent ? oldParent.gameObject.activeInHierarchy : this.gameObject.activeSelf;
            if ((newParent ? newParent.gameObject.activeInHierarchy : this.gameObject.activeSelf) !== prevActive) {
                this.gameObject._activeInHierarchyDirty(prevActive);
            }
            this._dirtify(false, 7 /* PRS */);
            this._addToCollecter();
        };
        Transform.prototype._onPositionUpdate = function (position) {
            if (position === this._localPosition) {
                this._dirtify(true, 1 /* Position */);
            }
            else {
                this.position = position;
            }
        };
        Transform.prototype._onRotationUpdate = function (rotation) {
            if (rotation === this._localRotation) {
                this._dirtify(true, 2 /* Rotation */);
            }
            else {
                this.rotation = rotation;
            }
        };
        Transform.prototype._onEulerUpdate = function (euler) {
            if (euler === this._localEuler) {
                this.localEuler = euler;
            }
            else {
                this.euler = euler;
            }
        };
        Transform.prototype._onEulerAnglesUpdate = function (euler) {
            if (euler === this._localEulerAngles) {
                this.localEulerAngles = euler;
            }
            else {
                this.eulerAngles = euler;
            }
        };
        Transform.prototype._onScaleUpdate = function (scale) {
            if (scale === this._localScale) {
                this._dirtify(true, 4 /* Scale */);
            }
            else {
                this.scale = scale;
            }
        };
        Transform.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this._localPosition.onUpdateTarget = this._position.onUpdateTarget = this;
            this._localPosition.onUpdate = this._position.onUpdate = this._onPositionUpdate;
            this._localRotation.onUpdateTarget = this._rotation.onUpdateTarget = this;
            this._localRotation.onUpdate = this._rotation.onUpdate = this._onRotationUpdate;
            this._localEuler.onUpdateTarget = this._euler.onUpdateTarget = this;
            this._localEuler.onUpdate = this._euler.onUpdate = this._onEulerUpdate;
            this._localEulerAngles.onUpdateTarget = this._eulerAngles.onUpdateTarget = this;
            this._localEulerAngles.onUpdate = this._eulerAngles.onUpdate = this._onEulerAnglesUpdate;
            this._localScale.onUpdateTarget = this._scale.onUpdateTarget = this;
            this._localScale.onUpdate = this._scale.onUpdate = this._onScaleUpdate;
            this._addToCollecter();
        };
        Transform.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this._children.length = 0;
            this._observers.length = 0;
        };
        /**
         * @internal
         */
        Transform.prototype.getAllChildren = function (out) {
            if (out === void 0) { out = []; }
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (Array.isArray(out)) {
                    out.push(child);
                }
                else {
                    var childName = child.gameObject.name;
                    if (childName in out) {
                        var transformOrTransforms = out[childName];
                        if (Array.isArray(transformOrTransforms)) {
                            transformOrTransforms.push(child);
                        }
                        else {
                            out[childName] = [transformOrTransforms, child];
                        }
                    }
                    else {
                        out[childName] = child;
                    }
                }
                child.getAllChildren(out);
            }
            return out;
        };
        /**
         * 销毁该组件所有子（孙）级变换组件。
         */
        Transform.prototype.destroyChildren = function () {
            var i = this._children.length;
            while (i--) {
                this._children[i].gameObject.destroy();
            }
        };
        /**
         *
         * @param observer
         */
        Transform.prototype.registerObserver = function (observer) {
            var observers = this._observers;
            if (observers.indexOf(observer) < 0) {
                observers.push(observer);
            }
        };
        /**
         *
         * @param observer
         */
        Transform.prototype.unregisterObserver = function (observer) {
            var observers = this._observers;
            var index = observers.indexOf(observer);
            if (index >= 0) {
                observers.splice(index, 1);
            }
        };
        /**
         * 该组件是否包含某个子（孙）级变换组件。
         */
        Transform.prototype.contains = function (transform) {
            if (transform === this) {
                return false;
            }
            var ancestor = transform;
            while (ancestor !== this && ancestor !== null) {
                ancestor = ancestor.parent;
            }
            return ancestor === this;
        };
        /**
         * 更改该组件的父级变换组件。
         * @param parent 父级变换组件。
         * @param worldTransformStays 是否保留当前世界空间变换。
         */
        Transform.prototype.setParent = function (parent, worldTransformStays) {
            if (worldTransformStays === void 0) { worldTransformStays = false; }
            var prevParent = this._parent;
            if (prevParent === parent) {
                return this;
            }
            if (this.gameObject === paper.GameObject.globalGameObject) {
                return this;
            }
            if (parent &&
                this.gameObject.scene !== parent.gameObject.scene) {
                console.warn("Cannot change the parent to a different scene.");
                return this;
            }
            if (this === parent || (parent && this.contains(parent))) {
                console.error("Set the parent error.");
                return this;
            }
            if (worldTransformStays) {
                _helpVector3.copy(this.position);
                _helpRotation.copy(this.rotation);
                // _helpMatrix3.copy(this._getRotationAndScale()); //
            }
            if (prevParent) {
                prevParent._removeFromChildren(this);
            }
            if (parent) {
                parent._children.push(this);
            }
            this._parent = parent;
            this._onParentChange(parent, prevParent);
            if (worldTransformStays) {
                this.position = _helpVector3;
                this.rotation = _helpRotation;
                // this._setRotationAndScale(_helpMatrix3); //
            }
            return this;
        };
        /**
         *
         */
        Transform.prototype.getChildIndex = function (value) {
            if (value.parent !== this) {
                return -1;
            }
            return this._children.indexOf(value);
        };
        /**
         *
         */
        Transform.prototype.setChildIndex = function (value, index) {
            if (value.parent !== this) {
                return;
            }
            var prevIndex = this._children.indexOf(value);
            if (prevIndex === index) {
                return;
            }
            this._children.splice(prevIndex, 1);
            this._children.splice(index, 0, value);
        };
        /**
         *
         */
        Transform.prototype.getChildAt = function (index) {
            return 0 <= index && index < this._children.length ? this._children[index] : null;
        };
        /**
         * 通过指定的名称或路径获取该组件的子（孙）级变换组件。
         * @param nameOrPath 名称或路径。
         */
        Transform.prototype.find = function (nameOrPath) {
            var names = nameOrPath.split("/");
            var ancestor = this;
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_1 = names_1[_i];
                if (!name_1) {
                    return ancestor;
                }
                var prevAncestor = ancestor;
                for (var _a = 0, _b = ancestor._children; _a < _b.length; _a++) {
                    var child = _b[_a];
                    if (child.gameObject.name === name_1) {
                        ancestor = child;
                        break;
                    }
                }
                if (prevAncestor === ancestor) {
                    return null;
                }
            }
            return ancestor;
        };
        Transform.prototype.setLocalPosition = function (p1, p2, p3) {
            var localPosition = this._localPosition;
            if (p1.hasOwnProperty("x")) {
                localPosition.x = p1.x;
                localPosition.y = p1.y;
                localPosition.z = p1.z;
            }
            else {
                localPosition.x = p1;
                localPosition.y = p2 || 0.0;
                localPosition.z = p3 || 0.0;
            }
            this._dirtify(true, 1 /* Position */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localPosition", {
            /**
             * 该组件的本地位置。
             * - 并不会返回一个新的 `egret3d.Vector3` 实例。
             * - 可以调用 `vector3.update()` 将对该向量的修改同步到该组件，`gameObject.transform.localPosition.add(egret3d.Vector3.ONE).update()`。
             */
            get: function () {
                return this._localPosition;
            },
            set: function (value) {
                this._localPosition.x = value.x;
                this._localPosition.y = value.y;
                this._localPosition.z = value.z;
                this._dirtify(true, 1 /* Position */);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setLocalRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localRotation.x = p1.x;
                this._localRotation.y = p1.y;
                this._localRotation.z = p1.z;
                this._localRotation.w = p1.w;
            }
            else {
                this._localRotation.x = p1;
                this._localRotation.y = p2 || 0.0;
                this._localRotation.z = p3 || 0.0;
                this._localRotation.w = p4 !== undefined ? p4 : 1.0;
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localRotation", {
            /**
             * 该组件的本地四元数旋转。
             * - 并不会返回一个新的 `egret3d.Quaternion` 实例。
             * - 可以调用 `quaternion.update()` 将对该四元数的修改同步到该组件，`gameObject.transform.localRotation.multiplyScalar(0.1).update()`。
             */
            get: function () {
                return this._localRotation;
            },
            set: function (value) {
                this._localRotation.x = value.x;
                this._localRotation.y = value.y;
                this._localRotation.z = value.z;
                this._localRotation.w = value.w;
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setLocalEuler = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localEuler.x = p1.x;
                this._localEuler.y = p1.y;
                this._localEuler.z = p1.z;
                this._localEulerAngles.multiplyScalar(57.29577951308232 /* RAD_DEG */, this._localEuler);
                this._localRotation.fromEuler(this._localEuler, p2);
            }
            else {
                this._localEuler.x = p1;
                this._localEuler.y = p2;
                this._localEuler.z = p3;
                this._localEulerAngles.multiplyScalar(57.29577951308232 /* RAD_DEG */, this._localEuler);
                this._localRotation.fromEuler(this._localEuler, p4);
            }
            this._dirtify(true, 2 /* Rotation */);
            this._localDirty &= ~8 /* Euler */;
            return this;
        };
        Object.defineProperty(Transform.prototype, "localEuler", {
            /**
             * 该组件的本地欧拉旋转。（弧度制）
             */
            get: function () {
                if (this._localDirty & 8 /* Euler */) {
                    this._updateEuler(false);
                }
                return this._localEuler;
            },
            set: function (value) {
                this._localEuler.x = value.x;
                this._localEuler.y = value.y;
                this._localEuler.z = value.z;
                this._localEulerAngles.multiplyScalar(57.29577951308232 /* RAD_DEG */, this._localEuler);
                this._localRotation.fromEuler(this._localEuler);
                this._dirtify(true, 2 /* Rotation */);
                this._localDirty &= ~8 /* Euler */;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setLocalEulerAngles = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localEulerAngles.x = p1.x;
                this._localEulerAngles.y = p1.y;
                this._localEulerAngles.z = p1.z;
                this._localEuler.multiplyScalar(0.017453292519943295 /* DEG_RAD */, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler, p2);
            }
            else {
                this._localEulerAngles.x = p1;
                this._localEulerAngles.y = p2;
                this._localEulerAngles.z = p3;
                this._localEuler.multiplyScalar(0.017453292519943295 /* DEG_RAD */, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler, p4);
            }
            this._dirtify(true, 2 /* Rotation */);
            this._localDirty &= ~8 /* Euler */;
            return this;
        };
        Object.defineProperty(Transform.prototype, "localEulerAngles", {
            /**
             * 该组件的本地欧拉旋转。（角度制）
             */
            get: function () {
                if (this._localDirty & 8 /* Euler */) {
                    this._updateEuler(false);
                }
                return this._localEulerAngles;
            },
            set: function (value) {
                this._localEulerAngles.x = value.x;
                this._localEulerAngles.y = value.y;
                this._localEulerAngles.z = value.z;
                this._localEuler.multiplyScalar(0.017453292519943295 /* DEG_RAD */, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler);
                this._dirtify(true, 2 /* Rotation */);
                this._localDirty &= ~8 /* Euler */;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setLocalScale = function (p1, p2, p3) {
            var EPSILON = 2.220446049250313e-16 /* EPSILON */;
            if (p1.hasOwnProperty("x")) {
                this._localScale.x = p1.x || EPSILON;
                this._localScale.y = p1.y || EPSILON;
                this._localScale.z = p1.z || EPSILON;
            }
            else {
                this._localScale.x = p1 || EPSILON;
                this._localScale.y = (p2 !== undefined ? p2 : p1) || EPSILON;
                this._localScale.z = (p3 !== undefined ? p3 : p1) || EPSILON;
            }
            this._dirtify(true, 4 /* Scale */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localScale", {
            /**
             * 该组件的本地缩放。
             */
            get: function () {
                return this._localScale;
            },
            set: function (value) {
                var EPSILON = 2.220446049250313e-16 /* EPSILON */;
                this._localScale.x = value.x || EPSILON;
                this._localScale.y = value.y || EPSILON;
                this._localScale.z = value.z || EPSILON;
                this._dirtify(true, 4 /* Scale */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "localToParentMatrix", {
            /**
             * 该组件的本地矩阵。
             */
            get: function () {
                if (this._localDirty & 16 /* Matrix */) {
                    this._updateMatrix(false);
                }
                return this._localToParentMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localPosition.x = p1.x;
                this._localPosition.y = p1.y;
                this._localPosition.z = p1.z;
            }
            else {
                this._localPosition.x = p1;
                this._localPosition.y = p2 || 0.0;
                this._localPosition.z = p3 || 0.0;
            }
            if (this._parent) {
                this._localPosition.applyMatrix(this._parent.worldToLocalMatrix);
            }
            this._dirtify(true, 1 /* Position */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "position", {
            /**
             * 该组件的世界位置。
             */
            get: function () {
                if (this._worldDirty & 1 /* Position */) {
                    this.localToWorldMatrix.decompose(this._position, null, null);
                    this._worldDirty &= ~1 /* Position */;
                }
                return this._position;
            },
            set: function (value) {
                this._localPosition.x = value.x;
                this._localPosition.y = value.y;
                this._localPosition.z = value.z;
                if (this._parent) {
                    this._localPosition.applyMatrix(this._parent.worldToLocalMatrix);
                }
                this._dirtify(true, 1 /* Position */);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localRotation.x = p1.x;
                this._localRotation.y = p1.y;
                this._localRotation.z = p1.z;
                this._localRotation.w = p1.w;
            }
            else {
                this._localRotation.x = p1;
                this._localRotation.y = p2 || 0.0;
                this._localRotation.z = p3 || 0.0;
                this._localRotation.w = p4 !== undefined ? p4 : 1.0;
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "rotation", {
            /**
             * 该组件的世界旋转。
             */
            get: function () {
                if (this._worldDirty & 2 /* Rotation */) {
                    this.localToWorldMatrix.decompose(null, this._rotation, null);
                    this._worldDirty &= ~2 /* Rotation */;
                }
                return this._rotation;
            },
            set: function (value) {
                this._localRotation.x = value.x;
                this._localRotation.y = value.y;
                this._localRotation.z = value.z;
                this._localRotation.w = value.w;
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setEuler = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                this._localRotation.fromEuler(q1, q2);
            }
            else {
                _helpVector3.set(q1, q2, q3);
                this._localRotation.fromEuler(_helpVector3, q4);
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "euler", {
            /**
             * 该组件的世界欧拉旋转。（弧度制）
             */
            get: function () {
                if (this._worldDirty & 8 /* Euler */) {
                    this._updateEuler(true);
                }
                return this._euler;
            },
            set: function (value) {
                this._localRotation.fromEuler(value);
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setEulerAngles = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                _helpVector3.multiplyScalar(0.017453292519943295 /* DEG_RAD */, q1);
                this._localRotation.fromEuler(_helpVector3, q2);
            }
            else {
                _helpVector3.set(q1 * 0.017453292519943295 /* DEG_RAD */, q2 * 0.017453292519943295 /* DEG_RAD */, q3 * 0.017453292519943295 /* DEG_RAD */);
                this._localRotation.fromEuler(_helpVector3, q4);
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "eulerAngles", {
            /**
             * 该组件的世界欧拉旋转。（角度制）
             */
            get: function () {
                if (this._worldDirty & 8 /* Euler */) {
                    this._updateEuler(true);
                }
                return this._eulerAngles;
            },
            set: function (value) {
                _helpVector3.multiplyScalar(0.017453292519943295 /* DEG_RAD */, value);
                this._localRotation.fromEuler(_helpVector3);
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "scale", {
            /**
             * 该组件的世界缩放。
             */
            get: function () {
                if (this._worldDirty & 4 /* Scale */) {
                    this.localToWorldMatrix.decompose(null, null, this._scale);
                    this._worldDirty &= ~4 /* Scale */;
                }
                return this._scale;
            },
            /**
             * @deprecated
             */
            set: function (value) {
                console.error("Can not set transform scale.");
                this.localScale = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "localToWorldMatrix", {
            /**
             * 从该组件空间坐标系到世界空间坐标系的变换矩阵。
             */
            get: function () {
                if (this._worldDirty & 16 /* Matrix */) {
                    this._updateMatrix(true);
                }
                return this._localToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "worldToLocalMatrix", {
            /**
             * 从世界空间坐标系到该组件空间坐标系的变换矩阵。
             */
            get: function () {
                if (this._worldDirty & 32 /* InverseMatrix */) {
                    this._worldToLocalMatrix.inverse(this.localToWorldMatrix);
                    this._worldDirty &= ~32 /* InverseMatrix */;
                }
                return this._worldToLocalMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.translate = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                if (p2) {
                    this.position = this._localPosition.add(p1, this.position);
                }
                else {
                    this.localPosition = this._localPosition.add(p1);
                }
            }
            else {
                _helpVector3.set(p1, p2, p3);
                if (p4) {
                    this.position = this._localPosition.add(_helpVector3, this.position);
                }
                else {
                    this.localPosition = this._localPosition.add(_helpVector3);
                }
            }
            return this;
        };
        Transform.prototype.rotate = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                if (p2) {
                    this.euler = this._localEuler.add(p1, this.euler);
                }
                else {
                    this.localEuler; // Update euler.
                    this.localEuler = this._localEuler.add(p1);
                }
            }
            else {
                _helpVector3.set(p1, p2, p3);
                if (p4) {
                    this.euler = this._localEuler.add(_helpVector3, this.euler);
                }
                else {
                    this.localEuler; // Update euler.
                    this.localEuler = this._localEuler.add(_helpVector3);
                }
            }
            return this;
        };
        /**
         * 将该组件绕指定轴旋转指定弧度。
         * @param axis 指定轴。
         * @param angle 指定弧度。
         * @param isWorldSpace 是否是世界坐标系。
         */
        Transform.prototype.rotateOnAxis = function (axis, angle, isWorldSpace) {
            _helpRotation.fromAxis(axis, angle);
            if (isWorldSpace) {
                this.localRotation = this._localRotation.premultiply(_helpRotation).normalize();
            }
            else {
                this.localRotation = this._localRotation.multiply(_helpRotation).normalize();
            }
            return this;
        };
        /**
         * 将该组件绕世界指定点和世界指定轴旋转指定弧度。
         * @param worldPosition 世界指定点。
         * @param worldAxis 世界指定轴。
         * @param angle 指定弧度。
         */
        Transform.prototype.rotateAround = function (worldPosition, worldAxis, angle) {
            this.rotateOnAxis(worldAxis, angle, true);
            this.position = this._localPosition.applyMatrix(_helpMatrix.fromRotation(_helpRotation.fromAxis(worldAxis, angle)).fromTranslate(worldPosition, true), this.position);
            return this;
        };
        /**
         * 通过旋转使得该组件的 Z 轴正方向指向目标点。
         * @param target 目标点。
         * @param up 旋转后，该组件在世界空间坐标系下描述的 Y 轴正方向。
         */
        Transform.prototype.lookAt = function (target, up) {
            if (up === void 0) { up = egret3d.Vector3.UP; }
            this.rotation = this._localRotation.fromMatrix(_helpMatrix.lookAt(this.position, target instanceof Transform ? target.position : target, up));
            return this;
        };
        /**
         * 通过旋转使得该组件的 Z 轴正方向指向目标方向。
         * @param target 目标方向。
         * @param up 旋转后，该组件在世界空间坐标系下描述的 Y 轴正方向。
         */
        Transform.prototype.lookRotation = function (direction, up) {
            if (up === void 0) { up = egret3d.Vector3.UP; }
            this.rotation = this._localRotation.fromMatrix(_helpMatrix.lookRotation(direction, up));
            return this;
        };
        /**
         * 获取该组件在世界空间坐标系下描述的 X 轴正方向。
         * @param out 输出向量。
         */
        Transform.prototype.getRight = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.localToWorldMatrix, egret3d.Vector3.RIGHT);
        };
        /**
         * 获取该组件在世界空间坐标系下描述的 Y 轴正方向。
         * @param out 输出向量。
         */
        Transform.prototype.getUp = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.localToWorldMatrix, egret3d.Vector3.UP);
        };
        /**
         * 获取该组件在世界空间坐标系下描述的 Z 轴正方向。
         * @param out 输出向量。
         */
        Transform.prototype.getForward = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.localToWorldMatrix, egret3d.Vector3.FORWARD);
        };
        Object.defineProperty(Transform.prototype, "childCount", {
            /**
             * 该组件的全部子级变换组件总数。（不包含孙级）
             */
            get: function () {
                return this._children.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "children", {
            /**
             * 该组件实体的全部子级变换组件。（不包含孙级）
             */
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "parent", {
            /**
             * 该组件实体的父级变换组件。
             */
            get: function () {
                return this._parent;
            },
            set: function (value) {
                this.setParent(value, false);
            },
            enumerable: true,
            configurable: true
        });
        // public get root{
        // }
        /**
         * @deprecated
         */
        Transform.prototype.getLocalPosition = function () {
            return this._localPosition;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalRotation = function () {
            return this._localRotation;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalEuler = function (order) {
            if (this._localDirty & 8 /* Euler */) {
                this._updateEuler(false, order);
            }
            return this._localEuler;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalEulerAngles = function (order) {
            if (this._localDirty & 8 /* Euler */) {
                this._updateEuler(false, order);
            }
            return this._localEulerAngles;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalScale = function () {
            return this._localScale;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getPosition = function () {
            if (this._worldDirty & 1 /* Position */) {
                this.localToWorldMatrix.decompose(this._position, null, null);
                this._worldDirty &= ~1 /* Position */;
            }
            return this._position;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getRotation = function () {
            if (this._worldDirty & 2 /* Rotation */) {
                this.localToWorldMatrix.decompose(null, this._rotation, null);
                this._worldDirty &= ~2 /* Rotation */;
            }
            return this._rotation;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getEuler = function (order) {
            if (this._worldDirty & 8 /* Euler */) {
                this._updateEuler(true, order);
            }
            return this._euler;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getEulerAngles = function (order) {
            if (this._worldDirty & 8 /* Euler */) {
                this._updateEuler(true, order);
            }
            return this._eulerAngles;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getScale = function () {
            if (this._worldDirty & 4 /* Scale */) {
                this.localToWorldMatrix.decompose(null, null, this._scale);
                this._worldDirty &= ~4 /* Scale */;
            }
            return this._scale;
        };
        Transform.prototype.setScale = function (p1, p2, p3) {
            console.error("Can not set transform scale.");
            if (p1 instanceof egret3d.Vector3) {
                this.localScale = p1;
            }
            else {
                this.localScale.set(p1, p2 === undefined ? p1 : p2, p3 === undefined ? p1 : p3);
            }
            return this;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalMatrix = function () {
            if (this._localDirty & 16 /* Matrix */) {
                this._updateMatrix(false);
            }
            return this._localToParentMatrix;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getWorldMatrix = function () {
            if (this._worldDirty & 16 /* Matrix */) {
                this._updateMatrix(true);
            }
            return this._localToWorldMatrix;
        };
        Object.defineProperty(Transform.prototype, "localMatrix", {
            /**
             * @deprecated
             */
            get: function () {
                if (this._localDirty & 16 /* Matrix */) {
                    this._updateMatrix(false);
                }
                return this._localToParentMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "worldMatrix", {
            /**
             * @deprecated
             */
            get: function () {
                if (this._worldDirty & 16 /* Matrix */) {
                    this._updateMatrix(true);
                }
                return this._localToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField("localPosition")
        ], Transform.prototype, "_localPosition", void 0);
        __decorate([
            paper.serializedField("localRotation")
        ], Transform.prototype, "_localRotation", void 0);
        __decorate([
            paper.serializedField("localScale")
        ], Transform.prototype, "_localScale", void 0);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Transform.prototype, "localPosition", null);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */, { step: 1.0 })
        ], Transform.prototype, "localEulerAngles", null);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Transform.prototype, "localScale", null);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Transform.prototype, "children", null);
        return Transform;
    }(paper.BaseComponent));
    egret3d.Transform = Transform;
    __reflect(Transform.prototype, "egret3d.Transform");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 全局舞台信息组件。
     * TODO 调整文件结构，标记接口源码链接。
     */
    var Stage = (function (_super) {
        __extends(Stage, _super);
        function Stage() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 当屏幕尺寸改变时派发事件。
             */
            _this.onScreenResize = new signals.Signal();
            /**
             * 当舞台尺寸改变时派发事件。
             */
            _this.onResize = new signals.Signal();
            /**
             *
             */
            _this.scaler = 1.0;
            _this._rotated = false;
            _this._matchFactor = 1.0;
            _this._screenSize = { w: 1024, h: 1024 };
            _this._size = { w: 1024, h: 1024 };
            _this._viewport = egret3d.Rectangle.create(0.0, 0.0, 1.0, 1.0);
            return _this;
        }
        Stage.prototype._updateViewport = function () {
            var screenSize = this._screenSize;
            var size = this._size;
            var viewport = this._viewport;
            if (paper.Application.isMobile) {
                var screenW = screenSize.w;
                var screenH = screenSize.h;
                if (this._rotated = (size.w > size.h) ? screenSize.h > screenSize.w : screenSize.w > screenSize.h) {
                    screenW = screenSize.h;
                    screenH = screenSize.w;
                }
                var scalerW = size.w / screenW;
                var scalerH = size.h / screenH;
                this.scaler = egret3d.math.lerp(scalerW, scalerH, this._matchFactor);
                viewport.w = Math.ceil(screenW * this.scaler);
                viewport.h = Math.ceil(screenH * this.scaler);
            }
            else {
                var scalerW = Math.min(size.w, screenSize.w) / screenSize.w;
                var scalerH = size.h / screenSize.h;
                this.scaler = egret3d.math.lerp(scalerW, scalerH, this._matchFactor);
                this._rotated = false;
                viewport.w = Math.ceil(screenSize.w * this.scaler);
                viewport.h = Math.ceil(screenSize.h * this.scaler);
            }
            // size.h = viewport.h / this.scaler;
        };
        Stage.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this);
            egret3d.stage = this;
            this._size.w = config.size.w || 1.0;
            this._size.h = config.size.h || 1.0;
            this._screenSize.w = config.screenSize.w || 1.0;
            this._screenSize.h = config.screenSize.h || 1.0;
            this._updateViewport();
        };
        /**
         * 屏幕到舞台坐标的转换。
         */
        Stage.prototype.screenToStage = function (value, out) {
            var screenSize = this._screenSize;
            var viewPort = this._viewport;
            var x = value.x, y = value.y;
            if (this._rotated) {
                out.y = (screenSize.w - (x - viewPort.x)) * (viewPort.w / screenSize.h);
                out.x = (y - viewPort.y) * (viewPort.h / screenSize.w);
            }
            else {
                out.x = (x - viewPort.x) * (viewPort.w / screenSize.w);
                out.y = (y - viewPort.y) * (viewPort.h / screenSize.h);
            }
            return this;
        };
        /**
         * 舞台到屏幕坐标的转换。
            // TODO
         */
        Stage.prototype.stageToScreen = function (value, out) {
            return this;
        };
        Object.defineProperty(Stage.prototype, "rotated", {
            /**
             * 舞台是否因屏幕尺寸的改变而发生了旋转。
             * - 旋转不会影响渲染视口的宽高交替，引擎通过反向旋转外部画布来抵消屏幕的旋转。
             */
            get: function () {
                return this._rotated;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "matchFactor", {
            /**
             * 以宽或高适配的系数。
             */
            get: function () {
                return this._matchFactor;
            },
            set: function (value) {
                if (this._matchFactor === value) {
                    return;
                }
                this._matchFactor = value;
                this._updateViewport();
                this.onResize.dispatch();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "screenSize", {
            /**
             * 屏幕尺寸。
             */
            get: function () {
                return this._screenSize;
            },
            set: function (value) {
                this._screenSize.w = value.w || 1.0;
                this._screenSize.h = value.h || 1.0;
                this._updateViewport();
                this.onScreenResize.dispatch();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "size", {
            /**
             * 舞台初始尺寸。
             */
            get: function () {
                return this._size;
            },
            set: function (value) {
                this._size.w = value.w || 1.0;
                this._size.h = value.h || 1.0;
                this._updateViewport();
                this.onResize.dispatch();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "viewport", {
            /**
             * 渲染视口。
             */
            get: function () {
                return this._viewport;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "screenViewport", {
            /**
             * @deprecated
             */
            get: function () {
                return this._viewport;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */, { readonly: true })
        ], Stage.prototype, "rotated", null);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0, maximum: 1.0 })
        ], Stage.prototype, "matchFactor", null);
        __decorate([
            paper.editor.property("SIZE" /* SIZE */)
        ], Stage.prototype, "screenSize", null);
        __decorate([
            paper.editor.property("SIZE" /* SIZE */)
        ], Stage.prototype, "size", null);
        __decorate([
            paper.editor.property("RECT" /* RECT */, { readonly: true })
        ], Stage.prototype, "viewport", null);
        return Stage;
    }(paper.SingletonComponent));
    egret3d.Stage = Stage;
    __reflect(Stage.prototype, "egret3d.Stage");
    /**
     * 全局舞台信息组件实例。
     */
    egret3d.stage = null;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    /**
     * 提供默认的几何网格资源的快速访问方式，以及创建几何网格或几何网格实体的方法。
     */
    var DefaultMeshes = (function (_super) {
        __extends(DefaultMeshes, _super);
        function DefaultMeshes() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMeshes.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            // TODO 颜色，更多类型。
            {
                var mesh = egret3d.Mesh.create(3, 0, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh.name = "builtin/triangle.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.TRIANGLE = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.5, 0.0,
                    -0.5, -0.5, 0.0,
                    0.5, -0.5, 0.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane();
                mesh.name = "builtin/quad.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.QUAD = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane(1.0, 1.0, -0.5, 0.0);
                mesh.name = "builtin/quad_particle.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.QUAD_PARTICLE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane(2.0, 2.0);
                mesh.name = "builtin/fullscreen_quad.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.FULLSCREEN_QUAD = mesh;
                // 后期渲染专用，UV反转一下，这样shader中就不用反转了
                var uvs = mesh.getUVs();
                for (var i = 1, l = uvs.length; i < l; i += 2) {
                    uvs[i] = 1.0 - uvs[i];
                }
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane(10.0, 10.0);
                mesh.name = "builtin/plane.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.PLANE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCube();
                mesh.name = "builtin/cube.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CUBE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCylinder(0.0, Math.sqrt(0.5), 1.0, 0.0, 0.0, 0.0, 4, 1, false, Math.PI * 0.25);
                mesh.name = "builtin/pyramid.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.PYRAMID = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCylinder(0.0, 0.5, 1.0, 0.0, 0.0, 0.0, 16, 1);
                mesh.name = "builtin/cone.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CONE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCylinder();
                mesh.name = "builtin/cylinder.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CYLINDER = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createTorus();
                mesh.name = "builtin/torus.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.TORUS = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createSphere();
                mesh.name = "builtin/sphere.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.SPHERE = mesh;
            }
            {
                var mesh = egret3d.Mesh.create(4, 2, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh.name = "builtin/line_x.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.LINE_X = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,
                    0.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = egret3d.Mesh.create(4, 2, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh.name = "builtin/line_y.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.LINE_Y = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = egret3d.Mesh.create(4, 2, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh.name = "builtin/line_z.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.LINE_Z = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    0.0, 0.0, 1.0,
                    0.0, 0.0, 0.0,
                    0.0, 0.0, 1.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = egret3d.MeshBuilder.createCircle();
                mesh.name = "builtin/circle_line.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CIRCLE_LINE = mesh;
            }
            {
                var mesh = egret3d.Mesh.create(8, 24, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh.name = "builtin/cube_line.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.CUBE_LINE = mesh;
                //
                mesh.setAttributes("POSITION" /* POSITION */, [
                    // Z-
                    -0.5, 0.5, -0.5,
                    0.5, 0.5, -0.5,
                    0.5, -0.5, -0.5,
                    -0.5, -0.5, -0.5,
                    // Z+
                    0.5, 0.5, 0.5,
                    0.5, -0.5, 0.5,
                    -0.5, -0.5, 0.5,
                    -0.5, 0.5, 0.5,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                ]);
                mesh.setIndices([
                    0, 1, 1, 2, 2, 3, 3, 0,
                    4, 5, 5, 6, 6, 7, 7, 4,
                    0, 7, 1, 4, 2, 5, 3, 6,
                ]);
            }
        };
        /**
         * 创建带有指定网格资源的实体。
         * @param mesh 网格资源。
         * @param name 实体的名称。
         * @param tag 实体的标识。
         * @param scene 实体的场景。
         */
        DefaultMeshes.createObject = function (mesh, name, tag, scene) {
            var gameObject = paper.GameObject.create(name, tag, scene);
            var meshFilter = gameObject.addComponent(egret3d.MeshFilter);
            var renderer = gameObject.addComponent(egret3d.MeshRenderer);
            meshFilter.mesh = mesh;
            switch (mesh) {
                case this.QUAD:
                case this.QUAD_PARTICLE:
                case this.PLANE:
                    renderer.material = egret3d.DefaultMaterials.MESH_BASIC_DOUBLESIDE;
                    break;
                case this.LINE_X:
                case this.LINE_Y:
                case this.LINE_Z:
                    renderer.material = egret3d.DefaultMaterials.LINEDASHED_COLOR;
                    break;
                case this.CIRCLE_LINE:
                case this.CUBE_LINE:
                    renderer.material = egret3d.DefaultMaterials.LINEDASHED;
                    break;
            }
            return gameObject;
        };
        return DefaultMeshes;
    }(paper.SingletonComponent));
    egret3d.DefaultMeshes = DefaultMeshes;
    __reflect(DefaultMeshes.prototype, "egret3d.DefaultMeshes");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 默认的纹理。
     */
    var DefaultTextures = (function (_super) {
        __extends(DefaultTextures, _super);
        function DefaultTextures() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultTextures.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            var texture;
            texture = egret3d.Texture.createColorTexture("builtin/white.image.json", 255, 255, 255);
            DefaultTextures.WHITE = texture;
            paper.Asset.register(texture);
            texture = egret3d.Texture.createColorTexture("builtin/gray.image.json", 128, 128, 128);
            DefaultTextures.GRAY = texture;
            paper.Asset.register(texture);
            texture = egret3d.Texture.createGridTexture("builtin/grid.image.json");
            DefaultTextures.GRID = texture;
            paper.Asset.register(texture);
            texture = egret3d.Texture.createColorTexture("builtin/missing.image.json", 255, 0, 255);
            DefaultTextures.MISSING = texture;
            paper.Asset.register(texture);
        };
        return DefaultTextures;
    }(paper.SingletonComponent));
    egret3d.DefaultTextures = DefaultTextures;
    __reflect(DefaultTextures.prototype, "egret3d.DefaultTextures");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 默认的 shader。
     */
    var DefaultShaders = (function (_super) {
        __extends(DefaultShaders, _super);
        function DefaultShaders() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultShaders.prototype._createShader = function (name, config, renderQueue, tStates, defines) {
            var shader = egret3d.Shader.create(name, config);
            if (renderQueue) {
                shader._renderQueue = renderQueue;
            }
            shader._states = {
                enable: [],
                functions: {},
            };
            egret3d.Shader.copyStates(tStates, shader._states);
            if (defines) {
                shader._defines = defines;
            }
            paper.Asset.register(shader);
            return shader;
        };
        DefaultShaders.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            //
            var helpMaterial = egret3d.Material.create(egret3d.Shader.create("", egret3d.ShaderLib.meshbasic));
            var helpStates = helpMaterial.technique.states;
            //
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders.MESH_BASIC = this._createShader("builtin/meshbasic.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_BASIC_DOUBLESIDE = this._createShader("builtin/meshbasic_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders.MESH_LAMBERT = this._createShader("builtin/meshlambert.shader.json", egret3d.ShaderLib.meshlambert, 2000 /* Geometry */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_LAMBERT_DOUBLESIDE = this._createShader("builtin/meshlambert_doubleside.shader.json", egret3d.ShaderLib.meshlambert, 2000 /* Geometry */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders.MESH_PHONG = this._createShader("builtin/meshphong.shader.json", egret3d.ShaderLib.meshphong, 2000 /* Geometry */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_PHONE_DOUBLESIDE = this._createShader("builtin/meshphong_doubleside.shader.json", egret3d.ShaderLib.meshphong, 2000 /* Geometry */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders.MESH_PHYSICAL = this._createShader("builtin/meshphysical.shader.json", egret3d.ShaderLib.meshphysical, 2000 /* Geometry */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_PHYSICAL_DOUBLESIDE = this._createShader("builtin/meshphysical_doubleside.shader.json", egret3d.ShaderLib.meshphysical, 2000 /* Geometry */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* Back */).setBlend(1 /* Blend */, 3000 /* Transparent */);
            DefaultShaders.TRANSPARENT = this._createShader("builtin/transparent.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(1 /* Blend */, 3000 /* Transparent */);
            DefaultShaders.TRANSPARENT_DOUBLESIDE = this._createShader("builtin/transparent_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* Back */).setBlend(3 /* Add */, 3000 /* Transparent */);
            DefaultShaders.TRANSPARENT_ADDITIVE = this._createShader("builtin/transparent_additive.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(3 /* Add */, 3000 /* Transparent */);
            DefaultShaders.TRANSPARENT_ADDITIVE_DOUBLESIDE = this._createShader("builtin/transparent_additive_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* Back */).setBlend(7 /* Multiply */, 3000 /* Transparent */);
            DefaultShaders.TRANSPARENT_MULTIPLY = this._createShader("builtin/transparent_multiply.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(7 /* Multiply */, 3000 /* Transparent */);
            DefaultShaders.TRANSPARENT_MULTIPLY_DOUBLESIDE = this._createShader("builtin/transparent_multiply_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders.LINEDASHED = this._createShader("builtin/linedashed.shader.json", egret3d.ShaderLib.linedashed, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders.VERTEX_COLOR = this._createShader("builtin/vertcolor.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpStates, ["USE_MAP" /* USE_MAP */, "USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MATERIAL_COLOR = this._createShader("builtin/materialcolor.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* Back */).setBlend(1 /* Blend */, 3000 /* Transparent */);
            DefaultShaders.TRANSPARENT_COLOR = this._createShader("builtin/transparent_color.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* Back */).setBlend(3 /* Additive */, 3000 /* Transparent */);
            DefaultShaders.TRANSPARENT_ADDITIVE_COLOR = this._createShader("builtin/transparent_additive_color.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.PARTICLE = this._createShader("builtin/particle.shader.json", egret3d.ShaderLib.particle, 2000 /* Geometry */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(1 /* Blend */, 3000 /* Transparent */);
            DefaultShaders.PARTICLE_BLEND = this._createShader("builtin/particle_blend.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(3 /* Add */, 3000 /* Transparent */);
            DefaultShaders.PARTICLE_ADDITIVE = this._createShader("builtin/particle_additive.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(7 /* Multiply */, 3000 /* Transparent */);
            DefaultShaders.PARTICLE_MULTIPLY = this._createShader("builtin/particle_multiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(2 /* Blend_PreMultiply */, 3000 /* Transparent */);
            DefaultShaders.PARTICLE_BLEND_PREMULTIPLY = this._createShader("builtin/particle_blend_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(4 /* Add_PreMultiply */, 3000 /* Transparent */);
            DefaultShaders.PARTICLE_ADDITIVE_PREMULTIPLY = this._createShader("builtin/particle_additive_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(8 /* Multiply_PreMultiply */, 3000 /* Transparent */);
            DefaultShaders.PARTICLE_MULTIPLY_PREMULTIPLY = this._createShader("builtin/particle_multiply_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.CUBE = this._createShader("builtin/cube.shader.json", egret3d.ShaderLib.cube, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.DEPTH = this._createShader("builtin/depth.shader.json", egret3d.ShaderLib.depth, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.DISTANCE_RGBA = this._createShader("builtin/distance_rgba.shader.json", egret3d.ShaderLib.distanceRGBA, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.EQUIRECT = this._createShader("builtin/equirect.shader.json", egret3d.ShaderLib.equirect, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.NORMAL = this._createShader("builtin/normal.shader.json", egret3d.ShaderLib.normal, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.POINTS = this._createShader("builtin/points.shader.json", egret3d.ShaderLib.points, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.SHADOW = this._createShader("builtin/shadow.shader.json", egret3d.ShaderLib.shadow, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.SPRITE = this._createShader("builtin/sprite.shader.json", egret3d.ShaderLib.sprite, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(false, false);
            DefaultShaders.COPY = this._createShader("builtin/copy.shader.json", egret3d.ShaderLib.copy, 2000 /* Geometry */, helpStates, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.dispose();
        };
        return DefaultShaders;
    }(paper.SingletonComponent));
    egret3d.DefaultShaders = DefaultShaders;
    __reflect(DefaultShaders.prototype, "egret3d.DefaultShaders");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DefaultMaterials = (function (_super) {
        __extends(DefaultMaterials, _super);
        function DefaultMaterials() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMaterials.prototype._createMaterial = function (name, shader) {
            var material = egret3d.Material.create(name, shader);
            paper.Asset.register(material);
            return material;
        };
        DefaultMaterials.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            DefaultMaterials.MESH_BASIC = this._createMaterial("builtin/meshbasic.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setTexture(egret3d.DefaultTextures.WHITE);
            DefaultMaterials.MESH_BASIC_DOUBLESIDE = this._createMaterial("builtin/meshbasic_doubleside.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setTexture(egret3d.DefaultTextures.WHITE)
                .setCullFace(false);
            DefaultMaterials.MESH_LAMBERT = this._createMaterial("builtin/meshlambert.mat.json", egret3d.DefaultShaders.MESH_LAMBERT)
                .setTexture(egret3d.DefaultTextures.WHITE);
            DefaultMaterials.MESH_LAMBERT_DOUBLESIDE = this._createMaterial("builtin/meshlambert_doubleside.mat.json", egret3d.DefaultShaders.MESH_LAMBERT)
                .setTexture(egret3d.DefaultTextures.WHITE)
                .setCullFace(false);
            DefaultMaterials.LINEDASHED = this._createMaterial("builtin/linedashed.mat.json", egret3d.DefaultShaders.LINEDASHED);
            DefaultMaterials.LINEDASHED_COLOR = this._createMaterial("builtin/linedashed_color.mat.json", egret3d.DefaultShaders.LINEDASHED)
                .addDefine("USE_COLOR" /* USE_COLOR */);
            DefaultMaterials.MISSING = this._createMaterial("builtin/missing.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setColor(egret3d.Color.PURPLE);
            DefaultMaterials.SHADOW_DEPTH = this._createMaterial("builtin/shadow_depth.mat.json", egret3d.DefaultShaders.DEPTH)
                .addDefine("DEPTH_PACKING 3201" /* DEPTH_PACKING_3201 */);
            DefaultMaterials.SHADOW_DISTANCE = this._createMaterial("builtin/shadow_distance.mat.json", egret3d.DefaultShaders.DISTANCE_RGBA);
            DefaultMaterials.COPY = this._createMaterial("builtin/copy.mat.json", egret3d.DefaultShaders.COPY);
        };
        return DefaultMaterials;
    }(paper.SingletonComponent));
    egret3d.DefaultMaterials = DefaultMaterials;
    __reflect(DefaultMaterials.prototype, "egret3d.DefaultMaterials");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 激活的摄像机和灯光。
     */
    var CameraAndLightCollecter = (function (_super) {
        __extends(CameraAndLightCollecter, _super);
        function CameraAndLightCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.lightDirty = false;
            /**
             *
             */
            _this.cameras = [];
            /**
             *
             */
            _this.lights = [];
            return _this;
        }
        CameraAndLightCollecter.prototype._sortCameras = function (a, b) {
            var aOrder = a.renderTarget ? a.order : a.order * 1000 + 1;
            var bOrder = b.renderTarget ? b.order : b.order * 1000 + 1;
            return aOrder - bOrder;
        };
        /**
         * 更新摄像机。
         */
        CameraAndLightCollecter.prototype.updateCameras = function (gameObjects) {
            this.cameras.length = 0;
            for (var _i = 0, gameObjects_1 = gameObjects; _i < gameObjects_1.length; _i++) {
                var gameObject = gameObjects_1[_i];
                this.cameras.push(gameObject.getComponent(egret3d.Camera));
            }
        };
        CameraAndLightCollecter.prototype.updateLights = function (gameObjects) {
            this.lightDirty = true;
            this.lights.length = 0;
            for (var _i = 0, gameObjects_2 = gameObjects; _i < gameObjects_2.length; _i++) {
                var gameObject = gameObjects_2[_i];
                this.lights.push(gameObject.getComponent(egret3d.BaseLight, true));
            }
        };
        CameraAndLightCollecter.prototype.sortCameras = function () {
            // TODO camera order event.
            this.cameras.sort(this._sortCameras);
        };
        Object.defineProperty(CameraAndLightCollecter.prototype, "cameraCount", {
            /**
             * 摄像机计数
             */
            get: function () {
                return this.cameras.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraAndLightCollecter.prototype, "lightCount", {
            /**
             * 灯光计数。
             */
            get: function () {
                return this.lights.length;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("UINT" /* UINT */, { readonly: true })
        ], CameraAndLightCollecter.prototype, "cameraCount", null);
        __decorate([
            paper.editor.property("UINT" /* UINT */, { readonly: true })
        ], CameraAndLightCollecter.prototype, "lightCount", null);
        return CameraAndLightCollecter;
    }(paper.SingletonComponent));
    egret3d.CameraAndLightCollecter = CameraAndLightCollecter;
    __reflect(CameraAndLightCollecter.prototype, "egret3d.CameraAndLightCollecter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 全局绘制信息收集组件。
     */
    var DrawCallCollecter = (function (_super) {
        __extends(DrawCallCollecter, _super);
        function DrawCallCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 此帧可能参与渲染的渲染组件列表。
             * - 未进行视锥剔除的。
             */
            _this.renderers = [];
            /**
             * 此帧可能参与渲染的绘制信息列表。
             * - 未进行视锥剔除的。
             */
            _this.drawCalls = [];
            /**
             * 此帧新添加的绘制信息列表。
             * - 渲染前清除。
             */
            _this.addDrawCalls = [];
            _this._drawCallsDirty = false;
            return _this;
        }
        /**
         * @internal
         */
        DrawCallCollecter.prototype._update = function () {
            var addDrawCalls = this.addDrawCalls;
            if (addDrawCalls.length > 0) {
                addDrawCalls.length = 0;
            }
            if (this._drawCallsDirty) {
                var index = 0;
                var removeCount = 0;
                var _a = this, renderers = _a.renderers, drawCalls = _a.drawCalls;
                for (var _i = 0, renderers_1 = renderers; _i < renderers_1.length; _i++) {
                    var renderer = renderers_1[_i];
                    if (renderer) {
                        if (removeCount > 0) {
                            renderers[index - removeCount] = renderer;
                            renderers[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
                if (removeCount > 0) {
                    renderers.length -= removeCount;
                }
                index = 0;
                removeCount = 0;
                for (var _b = 0, drawCalls_1 = drawCalls; _b < drawCalls_1.length; _b++) {
                    var drawCall = drawCalls_1[_b];
                    if (drawCall) {
                        drawCall.drawCount = 0;
                        if (removeCount > 0) {
                            drawCalls[index - removeCount] = drawCall;
                            drawCalls[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
                if (removeCount > 0) {
                    drawCalls.length -= removeCount;
                }
                this._drawCallsDirty = false;
            }
        };
        /**
         *
         * @param drawCall
         */
        DrawCallCollecter.prototype.addDrawCall = function (drawCall) {
            this.drawCalls.push(drawCall);
            this.addDrawCalls.push(drawCall);
        };
        /**
         * 移除指定渲染组件的绘制信息列表。
         */
        DrawCallCollecter.prototype.removeDrawCalls = function (renderer) {
            var _a = this, renderers = _a.renderers, drawCalls = _a.drawCalls, addDrawCalls = _a.addDrawCalls;
            var index = renderers.indexOf(renderer);
            if (index < 0) {
                return;
            }
            var i = drawCalls.length;
            while (i--) {
                var drawCall = drawCalls[i];
                if (drawCall && drawCall.renderer === renderer) {
                    drawCalls[i] = null;
                    drawCall.release();
                }
            }
            i = addDrawCalls.length;
            while (i--) {
                var drawCall = addDrawCalls[i];
                if (drawCall && drawCall.renderer === renderer) {
                    addDrawCalls[i] = null;
                }
            }
            renderers[index] = null;
            this._drawCallsDirty = true;
        };
        /**
         * 是否包含指定渲染组件的绘制信息列表。
         */
        DrawCallCollecter.prototype.hasDrawCalls = function (renderer) {
            return this.renderers.indexOf(renderer) >= 0;
        };
        return DrawCallCollecter;
    }(paper.SingletonComponent));
    egret3d.DrawCallCollecter = DrawCallCollecter;
    __reflect(DrawCallCollecter.prototype, "egret3d.DrawCallCollecter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 全局碰撞信息收集组件。
     */
    var ContactCollecter = (function (_super) {
        __extends(ContactCollecter, _super);
        function ContactCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 当前帧开始碰撞的。
             */
            _this.begin = [];
            /**
             * 当前帧维持碰撞的。
             */
            _this.stay = [];
            /**
             * 当前帧结束碰撞的。
             */
            _this.end = [];
            return _this;
        }
        /**
         * @internal
         */
        ContactCollecter.prototype._update = function () {
            if (this.begin.length > 0) {
                this.begin.length = 0;
            }
            if (this.end.length > 0) {
                this.end.length = 0;
            }
        };
        return ContactCollecter;
    }(paper.SingletonComponent));
    egret3d.ContactCollecter = ContactCollecter;
    __reflect(ContactCollecter.prototype, "egret3d.ContactCollecter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Pointer 按钮的类型。
     * - https://www.w3.org/TR/pointerevents/#the-button-property
     */
    var PointerButtonType;
    (function (PointerButtonType) {
        PointerButtonType[PointerButtonType["None"] = -1] = "None";
        PointerButtonType[PointerButtonType["LeftMouse"] = 0] = "LeftMouse";
        PointerButtonType[PointerButtonType["TouchContact"] = 0] = "TouchContact";
        PointerButtonType[PointerButtonType["Pencontac"] = 0] = "Pencontac";
        PointerButtonType[PointerButtonType["MiddleMouse"] = 1] = "MiddleMouse";
        PointerButtonType[PointerButtonType["RightMouse"] = 2] = "RightMouse";
        PointerButtonType[PointerButtonType["PenBarrel"] = 2] = "PenBarrel";
        PointerButtonType[PointerButtonType["Back"] = 3] = "Back";
        PointerButtonType[PointerButtonType["X1"] = 3] = "X1";
        PointerButtonType[PointerButtonType["Forward"] = 4] = "Forward";
        PointerButtonType[PointerButtonType["X2"] = 4] = "X2";
        PointerButtonType[PointerButtonType["PenEraser"] = 5] = "PenEraser";
    })(PointerButtonType = egret3d.PointerButtonType || (egret3d.PointerButtonType = {}));
    /**
     * Pointer 按钮的状态类型。
     * - https://www.w3.org/TR/pointerevents/#the-buttons-property
     */
    var PointerButtonsType;
    (function (PointerButtonsType) {
        PointerButtonsType[PointerButtonsType["None"] = 0] = "None";
        PointerButtonsType[PointerButtonsType["LeftMouse"] = 1] = "LeftMouse";
        PointerButtonsType[PointerButtonsType["TouchContact"] = 1] = "TouchContact";
        PointerButtonsType[PointerButtonsType["PenContac"] = 1] = "PenContac";
        PointerButtonsType[PointerButtonsType["MiddleMouse"] = 4] = "MiddleMouse";
        PointerButtonsType[PointerButtonsType["RightMouse"] = 2] = "RightMouse";
        PointerButtonsType[PointerButtonsType["PenBarrel"] = 2] = "PenBarrel";
        PointerButtonsType[PointerButtonsType["Back"] = 8] = "Back";
        PointerButtonsType[PointerButtonsType["X1"] = 8] = "X1";
        PointerButtonsType[PointerButtonsType["Forward"] = 16] = "Forward";
        PointerButtonsType[PointerButtonsType["X2"] = 16] = "X2";
        PointerButtonsType[PointerButtonsType["PenEraser"] = 32] = "PenEraser";
    })(PointerButtonsType = egret3d.PointerButtonsType || (egret3d.PointerButtonsType = {}));
    /**
     * 按键枚举。
     */
    var KeyCode;
    (function (KeyCode) {
        KeyCode["Unknown"] = "Unknown";
        KeyCode["F1"] = "F1";
        KeyCode["F2"] = "F2";
        KeyCode["F3"] = "F3";
        KeyCode["F4"] = "F4";
        KeyCode["F5"] = "F5";
        KeyCode["F6"] = "F6";
        KeyCode["F7"] = "F7";
        KeyCode["F8"] = "F8";
        KeyCode["F9"] = "F9";
        KeyCode["F10"] = "F10";
        KeyCode["F11"] = "F11";
        KeyCode["F12"] = "F12";
        KeyCode["Digit0"] = "Digit0";
        KeyCode["Digit1"] = "Digit1";
        KeyCode["Digit2"] = "Digit2";
        KeyCode["Digit3"] = "Digit3";
        KeyCode["Digit4"] = "Digit4";
        KeyCode["Digit5"] = "Digit5";
        KeyCode["Digit6"] = "Digit6";
        KeyCode["Digit7"] = "Digit7";
        KeyCode["Digit8"] = "Digit8";
        KeyCode["Digit9"] = "Digit9";
        KeyCode["KeyA"] = "KeyA";
        KeyCode["KeyB"] = "KeyB";
        KeyCode["KeyC"] = "KeyC";
        KeyCode["KeyD"] = "KeyD";
        KeyCode["KeyE"] = "KeyE";
        KeyCode["KeyF"] = "KeyF";
        KeyCode["KeyG"] = "KeyG";
        KeyCode["KeyH"] = "KeyH";
        KeyCode["KeyI"] = "KeyI";
        KeyCode["KeyJ"] = "KeyJ";
        KeyCode["KeyK"] = "KeyK";
        KeyCode["KeyL"] = "KeyL";
        KeyCode["KeyM"] = "KeyM";
        KeyCode["KeyN"] = "KeyN";
        KeyCode["KeyO"] = "KeyO";
        KeyCode["KeyP"] = "KeyP";
        KeyCode["KeyQ"] = "KeyQ";
        KeyCode["KeyR"] = "KeyR";
        KeyCode["KeyS"] = "KeyS";
        KeyCode["KeyT"] = "KeyT";
        KeyCode["KeyU"] = "KeyU";
        KeyCode["KeyV"] = "KeyV";
        KeyCode["KeyW"] = "KeyW";
        KeyCode["KeyX"] = "KeyX";
        KeyCode["KeyY"] = "KeyY";
        KeyCode["KeyZ"] = "KeyZ";
        KeyCode["Backquote"] = "Backquote";
        KeyCode["Minus"] = "Minus";
        KeyCode["Equal"] = "Equal";
        KeyCode["BracketLeft"] = "BracketLeft";
        KeyCode["BracketRight"] = "BracketRight";
        KeyCode["Backslash"] = "Backslash";
        KeyCode["Semicolon"] = "Semicolon";
        KeyCode["Quote"] = "Quote";
        KeyCode["Comma"] = "Comma";
        KeyCode["Period"] = "Period";
        KeyCode["Slash"] = "Slash";
        KeyCode["Escape"] = "Escape";
        KeyCode["ScrollLock"] = "ScrollLock";
        KeyCode["Pause"] = "Pause";
        KeyCode["Backspace"] = "Backspace";
        KeyCode["Tab"] = "Tab";
        KeyCode["CapsLock"] = "CapsLock";
        KeyCode["Space"] = "Space";
        KeyCode["ContextMenu"] = "ContextMenu";
        KeyCode["ShiftLeft"] = "ShiftLeft";
        KeyCode["ControlLeft"] = "ControlLeft";
        KeyCode["AltLeft"] = "AltLeft";
        KeyCode["MetaLeft"] = "MetaLeft";
        KeyCode["ShiftRight"] = "ShiftRight";
        KeyCode["ControlRight"] = "ControlRight";
        KeyCode["AltRight"] = "AltRight";
        KeyCode["MetaRight"] = "MetaRight";
        KeyCode["Insert"] = "Insert";
        KeyCode["Delete"] = "Delete";
        KeyCode["Home"] = "Home";
        KeyCode["End"] = "End";
        KeyCode["PageUp"] = "PageUp";
        KeyCode["PageDown"] = "PageDown";
        KeyCode["ArrowUp"] = "ArrowUp";
        KeyCode["ArrowDown"] = "ArrowDown";
        KeyCode["ArrowLeft"] = "ArrowLeft";
        KeyCode["ArrowRight"] = "ArrowRight";
        KeyCode["NumpadLock"] = "NumLock";
        KeyCode["NumpadDivide"] = "NumpadDivide";
        KeyCode["NumpadMultiply"] = "NumpadMultiply";
        KeyCode["NumpadSubtract"] = "NumpadSubtract";
        KeyCode["NumpadAdd"] = "NumpadAdd";
        KeyCode["NumpadEnter"] = "NumpadEnter";
        KeyCode["NumpadDecimal"] = "NumpadDecimal";
        KeyCode["Numpad0"] = "Numpad0";
        KeyCode["Numpad1"] = "Numpad1";
        KeyCode["Numpad2"] = "Numpad2";
        KeyCode["Numpad3"] = "Numpad3";
        KeyCode["Numpad4"] = "Numpad4";
        KeyCode["Numpad5"] = "Numpad5";
        KeyCode["Numpad6"] = "Numpad6";
        KeyCode["Numpad7"] = "Numpad7";
        KeyCode["Numpad8"] = "Numpad8";
        KeyCode["Numpad9"] = "Numpad9";
    })(KeyCode = egret3d.KeyCode || (egret3d.KeyCode = {}));
    var _keyToCode = [
        "`", "Backquote" /* Backquote */,
        "1", "Digit1" /* Digit1 */,
        "2", "Digit2" /* Digit2 */,
        "3", "Digit3" /* Digit3 */,
        "4", "Digit4" /* Digit4 */,
        "5", "Digit5" /* Digit5 */,
        "6", "Digit6" /* Digit6 */,
        "7", "Digit7" /* Digit7 */,
        "8", "Digit8" /* Digit8 */,
        "9", "Digit9" /* Digit9 */,
        "0", "Digit0" /* Digit0 */,
        "-", "Minus" /* Minus */,
        "=", "Equal" /* Equal */,
        "[", "BracketLeft" /* BracketLeft */,
        "]", "BracketRight" /* BracketRight */,
        "\\", "Backslash" /* Backslash */,
        ";", "Semicolon" /* Semicolon */,
        "'", "Quote" /* Quote */,
        ",", "Comma" /* Comma */,
        ".", "Period" /* Period */,
        "/", "Slash" /* Slash */,
        "~", "Backquote" /* Backquote */,
        "!", "Digit1" /* Digit1 */,
        "@", "Digit2" /* Digit2 */,
        "#", "Digit3" /* Digit3 */,
        "$", "Digit4" /* Digit4 */,
        "%", "Digit5" /* Digit5 */,
        "^", "Digit6" /* Digit6 */,
        "&", "Digit7" /* Digit7 */,
        "*", "Digit8" /* Digit8 */,
        "(", "Digit9" /* Digit9 */,
        ")", "Digit0" /* Digit0 */,
        "_", "Minus" /* Minus */,
        "+", "Equal" /* Equal */,
        "{", "BracketLeft" /* BracketLeft */,
        "}", "BracketRight" /* BracketRight */,
        "|", "Backslash" /* Backslash */,
        ":", "Semicolon" /* Semicolon */,
        '"', "Quote" /* Quote */,
        "<", "Comma" /* Comma */,
        ">", "Period" /* Period */,
        "?", "Slash" /* Slash */,
        "a", "KeyA" /* KeyA */,
        "b", "KeyB" /* KeyB */,
        "c", "KeyC" /* KeyC */,
        "d", "KeyD" /* KeyD */,
        "e", "KeyE" /* KeyE */,
        "f", "KeyF" /* KeyF */,
        "g", "KeyG" /* KeyG */,
        "h", "KeyH" /* KeyH */,
        "i", "KeyI" /* KeyI */,
        "j", "KeyJ" /* KeyJ */,
        "k", "KeyK" /* KeyK */,
        "l", "KeyL" /* KeyL */,
        "m", "KeyM" /* KeyM */,
        "n", "KeyN" /* KeyN */,
        "o", "KeyO" /* KeyO */,
        "p", "KeyP" /* KeyP */,
        "q", "KeyQ" /* KeyQ */,
        'r', "KeyR" /* KeyR */,
        "s", "KeyS" /* KeyS */,
        "t", "KeyT" /* KeyT */,
        "u", "KeyU" /* KeyU */,
        "v", "KeyV" /* KeyV */,
        "w", "KeyW" /* KeyW */,
        "x", "KeyX" /* KeyX */,
        "y", "KeyY" /* KeyY */,
        "z", "KeyZ" /* KeyZ */,
    ];
    var _keyCodeToCode = [
        48, "Digit0" /* Digit0 */,
        49, "Digit1" /* Digit1 */,
        50, "Digit2" /* Digit2 */,
        51, "Digit3" /* Digit3 */,
        52, "Digit4" /* Digit4 */,
        53, "Digit5" /* Digit5 */,
        54, "Digit6" /* Digit6 */,
        55, "Digit7" /* Digit7 */,
        56, "Digit8" /* Digit8 */,
        57, "Digit9" /* Digit9 */,
        65, "KeyA" /* KeyA */,
        66, "KeyB" /* KeyB */,
        67, "KeyC" /* KeyC */,
        68, "KeyD" /* KeyD */,
        69, "KeyE" /* KeyE */,
        70, "KeyF" /* KeyF */,
        71, "KeyG" /* KeyG */,
        72, "KeyH" /* KeyH */,
        73, "KeyI" /* KeyI */,
        74, "KeyJ" /* KeyJ */,
        75, "KeyK" /* KeyK */,
        76, "KeyL" /* KeyL */,
        77, "KeyM" /* KeyM */,
        78, "KeyN" /* KeyN */,
        79, "KeyO" /* KeyO */,
        80, "KeyP" /* KeyP */,
        81, "KeyQ" /* KeyQ */,
        82, "KeyR" /* KeyR */,
        83, "KeyS" /* KeyS */,
        84, "KeyT" /* KeyT */,
        85, "KeyU" /* KeyU */,
        86, "KeyV" /* KeyV */,
        87, "KeyW" /* KeyW */,
        88, "KeyX" /* KeyX */,
        89, "KeyY" /* KeyY */,
        90, "KeyZ" /* KeyZ */,
        96, "Digit0" /* Digit0 */,
        97, "Digit1" /* Digit1 */,
        98, "Digit2" /* Digit2 */,
        99, "Digit3" /* Digit3 */,
        100, "Digit4" /* Digit4 */,
        101, "Digit5" /* Digit5 */,
        102, "Digit6" /* Digit6 */,
        103, "Digit7" /* Digit7 */,
        104, "Digit8" /* Digit8 */,
        105, "Digit9" /* Digit9 */,
    ];
    /**
     * 鼠标、笔、触控等的信息。
     */
    var Pointer = (function (_super) {
        __extends(Pointer, _super);
        function Pointer() {
            var _this = _super.call(this) || this;
            /**
             * 该 Pointer 持续按下的时间。
             */
            _this.holdedTime = 0.0;
            /**
             * 该 Pointer 的舞台坐标。
             */
            _this.position = egret3d.Vector3.create();
            /**
             * 该 Pointer 按下的舞台坐标。
             */
            _this.downPosition = egret3d.Vector3.create();
            /**
             * 该 Pointer 此帧的移动速度。
             */
            _this.speed = egret3d.Vector3.create();
            /**
             * 该 Pointer 最近的事件。
             */
            _this.event = null;
            /**
             * @internal
             */
            _this._prevButtons = 0 /* None */;
            /**
             * @internal
             */
            _this._prevPosition = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个 Pointer 实例。
         */
        Pointer.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new Pointer();
        };
        /**
         * 该 Pointer 此帧按下的状态。
         * @param value
         */
        Pointer.prototype.isDown = function (value, isPlayerMode) {
            if (value === void 0) { value = 1 /* TouchContact */; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return (this.event.buttons & value) !== 0 && (this._prevButtons & value) === 0;
        };
        /**
         * 该 Pointer 此帧持续按下的状态。
         * @param value
         */
        Pointer.prototype.isHold = function (value, isPlayerMode) {
            if (value === void 0) { value = 1 /* TouchContact */; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return (this.event.buttons & value) !== 0 && (this._prevButtons & value) !== 0;
        };
        /**
         * 该 Pointer 此帧抬起的状态。
         * @param value
         */
        Pointer.prototype.isUp = function (value, isPlayerMode) {
            if (value === void 0) { value = 1 /* TouchContact */; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return (this.event.buttons & value) === 0 && (this._prevButtons & value) !== 0;
        };
        /**
         * 该 Pointer 此帧移动的状态。
         * @param value
         */
        Pointer.prototype.isMove = function (distance, isPlayerMode) {
            if (distance === void 0) { distance = 5; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return null;
            }
            return Math.abs(this.speed.x) > distance || Math.abs(this.speed.y) > distance;
        };
        Pointer._instances = [];
        return Pointer;
    }(paper.BaseRelease));
    egret3d.Pointer = Pointer;
    __reflect(Pointer.prototype, "egret3d.Pointer");
    /**
     * 按键的信息。
     */
    var Key = (function () {
        function Key() {
            /**
             * 该按键持续按下的时间。
             */
            this.holdedTime = 0.0;
            /**
             * 该按键最近的事件。
             */
            this.event = null;
        }
        /**
         * 该按键此帧按下的状态。
         * @param value
         */
        Key.prototype.isDown = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return egret3d.inputCollecter._downKeys.indexOf(this) >= 0;
        };
        /**
         * 该按键此帧持续按下的状态。
         * @param value
         */
        Key.prototype.isHold = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return egret3d.inputCollecter._holdKeys.indexOf(this) >= 0;
        };
        /**
         * 该按键此帧抬起的状态。
         * @param value
         */
        Key.prototype.isUp = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 0 /* Player */)) {
                return false;
            }
            return egret3d.inputCollecter._upKeys.indexOf(this) >= 0;
        };
        return Key;
    }());
    egret3d.Key = Key;
    __reflect(Key.prototype, "egret3d.Key");
    /**
     * 全局输入信息组件。
     * - https://www.w3.org/TR/pointerevents/
     * - https://github.com/millermedeiros/js-signals/
     */
    // @requireComponent(Stage) TODO
    var InputCollecter = (function (_super) {
        __extends(InputCollecter, _super);
        function InputCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 滚轮当前值。
             */
            _this.mouseWheel = 0;
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerOver = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerEnter = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerDown = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerMove = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerUp = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerCancel = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerOut = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerLeave = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onMouseWheel = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onKeyDown = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onKeyUp = new signals.Signal();
            /**
             * @internal
             */
            _this._downPointers = [];
            /**
             * @internal
             */
            _this._holdPointers = [];
            /**
             * @internal
             */
            _this._upPointers = [];
            /**
             * @internal
             */
            _this._downKeys = [];
            /**
             * @internal
             */
            _this._holdKeys = [];
            /**
             * @internal
             */
            _this._upKeys = [];
            /**
             * 默认的 Pointer 实例。
             */
            _this.defaultPointer = Pointer.create();
            _this._pointers = {};
            _this._keys = {};
            return _this;
        }
        /**
         * @internal
         */
        InputCollecter.prototype.update = function (deltaTime) {
            for (var _i = 0, _a = this._downPointers; _i < _a.length; _i++) {
                var pointer = _a[_i];
                pointer.holdedTime = 0.0;
            }
            for (var _b = 0, _c = this._holdPointers; _b < _c.length; _b++) {
                var pointer = _c[_b];
                if (this._downPointers.indexOf(pointer) >= 0) {
                    continue;
                }
                pointer.holdedTime += deltaTime;
            }
            for (var _d = 0, _e = this._downKeys; _d < _e.length; _d++) {
                var key = _e[_d];
                key.holdedTime = 0.0;
            }
            for (var _f = 0, _g = this._holdKeys; _f < _g.length; _f++) {
                var key = _g[_f];
                if (this._downKeys.indexOf(key) >= 0) {
                    continue;
                }
                key.holdedTime += deltaTime;
            }
            return this;
        };
        /**
         * @internal
         */
        InputCollecter.prototype.clear = function () {
            this.mouseWheel = 0;
            for (var k in this._pointers) {
                var pointer = this._pointers[k];
                if (pointer.event) {
                    pointer.speed.subtract(pointer.position, pointer._prevPosition);
                    pointer._prevButtons = pointer.event.buttons;
                    pointer._prevPosition.copy(pointer.position);
                }
            }
            if (this._upPointers.length > 0) {
                this._upPointers.length = 0;
            }
            if (this._downPointers.length > 0) {
                this._downPointers.length = 0;
            }
            if (this._upKeys.length > 0) {
                this._upKeys.length = 0;
            }
            if (this._downKeys.length > 0) {
                this._downKeys.length = 0;
            }
            return this;
        };
        InputCollecter.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            egret3d.inputCollecter = this;
            this._pointers[1] = this.defaultPointer;
        };
        /**
         * 此帧按下的全部 Pointer。
         */
        InputCollecter.prototype.getDownPointers = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 0 /* Player */) {
                return [];
            }
            return this._downPointers;
        };
        /**
         * 此帧持续按下的全部 Pointer。
         */
        InputCollecter.prototype.getHoldPointers = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 0 /* Player */) {
                return [];
            }
            return this._holdPointers;
        };
        /**
         * 此帧抬起的全部 Pointer。
         */
        InputCollecter.prototype.getUpPointers = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 0 /* Player */) {
                return [];
            }
            return this._upPointers;
        };
        /**
         * 此帧按下的全部按键。
         */
        InputCollecter.prototype.getDownKeys = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 0 /* Player */) {
                return [];
            }
            return this._downKeys;
        };
        /**
         * 此帧持续按下的全部按键。
         */
        InputCollecter.prototype.getHoldKeys = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 0 /* Player */) {
                return [];
            }
            return this._holdKeys;
        };
        /**
         * 此帧抬起的全部按键。
         */
        InputCollecter.prototype.getUpKeys = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 0 /* Player */) {
                return [];
            }
            return this._upKeys;
        };
        /**
         * @internal
         */
        InputCollecter.prototype.getPointer = function (pointerID) {
            var pointers = this._pointers;
            if (!(pointerID in pointers)) {
                if (this._downPointers.length === 0 && this._holdPointers.length === 0) {
                    pointers[pointerID] = this.defaultPointer;
                }
                else {
                    pointers[pointerID] = Pointer.create();
                }
            }
            return pointers[pointerID];
        };
        /**
         * @internal
         */
        InputCollecter.prototype.removePointer = function (pointerID) {
            if (pointerID === 1) {
                return;
            }
            var pointers = this._pointers;
            if (pointerID in pointers) {
                var pointer = pointers[pointerID];
                if (pointer !== this.defaultPointer) {
                    pointer.release();
                }
                delete pointers[pointerID];
            }
        };
        /**
         * 通过键名称创建或获取一个按键实例。
         */
        InputCollecter.prototype.getKey = function (code) {
            if (typeof code === "number") {
                var index = _keyCodeToCode.indexOf(code);
                if (index >= 0) {
                    code = _keyCodeToCode[index + 1];
                }
                else {
                    if (true) {
                        console.error("Unsupported keyCode \"" + code + "\", use egret3d.keyCode enumeration instead.");
                    }
                    code = "Unknown" /* Unknown */;
                }
            }
            else if (code.length === 1) {
                var index = _keyToCode.indexOf(code);
                if (index >= 0) {
                    code = _keyToCode[index + 1];
                }
                else {
                    if (true) {
                        console.error("Unsupported key \"" + code + "\", use egret3d.keyCode enumeration instead.");
                    }
                    code = "Unknown" /* Unknown */;
                }
            }
            else if (!code) {
                if (true) {
                    console.error("Invalid code.");
                }
                code = "Unknown" /* Unknown */;
            }
            code = code.toLowerCase();
            var keys = this._keys;
            if (!(code in keys)) {
                keys[code] = new Key();
            }
            return keys[code];
        };
        Object.defineProperty(InputCollecter.prototype, "maxTouchPoints", {
            /**
             * 设备最大可支持的多点触摸数量。
             */
            get: function () {
                if (window.navigator) {
                    return window.navigator.maxTouchPoints;
                }
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        return InputCollecter;
    }(paper.SingletonComponent));
    egret3d.InputCollecter = InputCollecter;
    __reflect(InputCollecter.prototype, "egret3d.InputCollecter");
    /**
     * 全局输入信息组件实例。
     */
    egret3d.inputCollecter = null;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 碰撞体类型。
     * - 枚举需要支持的全部碰撞体类型。
     */
    var ColliderType;
    (function (ColliderType) {
        /**
         * 立方体。
         */
        ColliderType[ColliderType["Box"] = 0] = "Box";
        /**
         * 球体。
         */
        ColliderType[ColliderType["Sphere"] = 1] = "Sphere";
        /**
         * 圆柱体。
         */
        ColliderType[ColliderType["Cylinder"] = 2] = "Cylinder";
        /**
         * 圆锥体。
         */
        ColliderType[ColliderType["Cone"] = 3] = "Cone";
        /**
         * 胶囊体。
         */
        ColliderType[ColliderType["Capsule"] = 4] = "Capsule";
        /**
         * TODO
         */
        ColliderType[ColliderType["ConvexHull"] = 5] = "ConvexHull";
    })(ColliderType = egret3d.ColliderType || (egret3d.ColliderType = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 矩形。
     */
    var Rectangle = (function (_super) {
        __extends(Rectangle, _super);
        function Rectangle(x, y, w, h) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (w === void 0) { w = 0.0; }
            if (h === void 0) { h = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.w = w;
            _this.h = h;
            return _this;
        }
        /**
         * 创建一个矩形。
         * @param x 水平坐标。
         * @param y 垂直坐标。
         * @param w 宽。
         * @param h 高。
         */
        Rectangle.create = function (x, y, w, h) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (w === void 0) { w = 0.0; }
            if (h === void 0) { h = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, w, h);
                instance._released = false;
                return instance;
            }
            return new Rectangle().set(x, y, w, h);
        };
        Rectangle.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.w, value.h);
        };
        Rectangle.prototype.clone = function () {
            return Rectangle.create(this.x, this.y, this.w, this.h);
        };
        Rectangle.prototype.set = function (x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            return this;
        };
        Rectangle.prototype.serialize = function () {
            return [this.x, this.y, this.w, this.h];
        };
        Rectangle.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.w = element[2];
            this.h = element[3];
            return this;
        };
        Rectangle.prototype.contains = function (pointOrRect) {
            var minX = this.x;
            var minY = this.y;
            var maxX = this.x + this.w;
            var maxY = this.y + this.h;
            if (pointOrRect instanceof Rectangle) {
                var vMinX = pointOrRect.x;
                var vMinY = pointOrRect.y;
                var vMaxX = pointOrRect.x + pointOrRect.w;
                var vMaxY = pointOrRect.y + pointOrRect.h;
                return minX <= vMinX && vMaxX <= maxX &&
                    minY <= vMinY && vMaxY <= maxY;
            }
            return (pointOrRect.x > minX) && (pointOrRect.x < maxX) &&
                (pointOrRect.y > minY) && (pointOrRect.y < maxY);
        };
        Rectangle._instances = [];
        return Rectangle;
    }(paper.BaseRelease));
    egret3d.Rectangle = Rectangle;
    __reflect(Rectangle.prototype, "egret3d.Rectangle", ["egret3d.IRectangle", "egret3d.IVector2", "egret3d.ISize", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 立方体碰撞组件。
     */
    var BoxCollider = (function (_super) {
        __extends(BoxCollider, _super);
        function BoxCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Box;
            /**
             * 描述该组件的立方体。
             */
            _this.box = egret3d.Box.ONE.clone();
            return _this;
        }
        BoxCollider.prototype.raycast = function (ray, raycastInfo) {
            var transform = this.gameObject.transform;
            var localRay = egret3d.helpRay.applyMatrix(transform.worldToLocalMatrix, ray);
            if (this.box.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    var localToWorldMatrix = transform.localToWorldMatrix;
                    raycastInfo.distance = ray.origin.getDistance(raycastInfo.position.applyMatrix(transform.localToWorldMatrix));
                    raycastInfo.transform = transform;
                    raycastInfo.collider = this;
                    var normal = raycastInfo.normal;
                    if (normal) {
                        normal.applyDirection(localToWorldMatrix);
                    }
                }
                return true;
            }
            return false;
        };
        Object.defineProperty(BoxCollider.prototype, "aabb", {
            /**
             * @deprecated
             */
            get: function () {
                return this.box;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField("aabb"),
            paper.editor.property("NESTED" /* NESTED */)
        ], BoxCollider.prototype, "box", void 0);
        BoxCollider = __decorate([
            paper.allowMultiple
        ], BoxCollider);
        return BoxCollider;
    }(paper.BaseComponent));
    egret3d.BoxCollider = BoxCollider;
    __reflect(BoxCollider.prototype, "egret3d.BoxCollider", ["egret3d.IBoxCollider", "egret3d.ICollider", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 球体碰撞组件。
     */
    var SphereCollider = (function (_super) {
        __extends(SphereCollider, _super);
        function SphereCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Sphere;
            /**
             * 描述该组件的球体。
             */
            _this.sphere = egret3d.Sphere.create(egret3d.Vector3.ZERO, 0.5);
            return _this;
        }
        SphereCollider.prototype.raycast = function (ray, raycastInfo) {
            var transform = this.gameObject.transform;
            var worldToLocalMatrix = transform.worldToLocalMatrix;
            var localRay = egret3d.helpRay.applyMatrix(transform.worldToLocalMatrix, ray);
            if (this.sphere.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    var localToWorldMatrix = transform.localToWorldMatrix;
                    raycastInfo.distance = ray.origin.getDistance(raycastInfo.position.applyMatrix(localToWorldMatrix));
                    raycastInfo.transform = transform;
                    raycastInfo.collider = this;
                    var normal = raycastInfo.normal;
                    if (normal) {
                        // normal.applyDirection(localToWorldMatrix);
                        normal.applyMatrix3(egret3d.helpMatrix3A.fromMatrix4(worldToLocalMatrix).transpose()).normalize();
                    }
                }
                return true;
            }
            return false;
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("NESTED" /* NESTED */)
        ], SphereCollider.prototype, "sphere", void 0);
        SphereCollider = __decorate([
            paper.allowMultiple
        ], SphereCollider);
        return SphereCollider;
    }(paper.BaseComponent));
    egret3d.SphereCollider = SphereCollider;
    __reflect(SphereCollider.prototype, "egret3d.SphereCollider", ["egret3d.ISphereCollider", "egret3d.ICollider", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 圆柱（锥）碰撞组件。
     * - 与 Y 轴对齐。
     */
    var CylinderCollider = (function (_super) {
        __extends(CylinderCollider, _super);
        function CylinderCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Cylinder;
            /**
             * 该圆柱（锥）的顶部半径。
             */
            _this.topRadius = 0.5;
            /**
             * 该圆柱（锥）的底部半径。
             */
            _this.bottomRadius = 0.5;
            /**
             * 该圆柱（锥）的高度。
             */
            _this.height = 1.0;
            /**
             * 该圆柱（锥）的中心点。
             */
            _this.center = egret3d.Vector3.create();
            return _this;
        }
        CylinderCollider.prototype.raycast = function (ray, raycastInfo) {
            var transform = this.gameObject.transform;
            var worldToLocalMatrix = transform.worldToLocalMatrix;
            var localRay = egret3d.helpRay.applyMatrix(worldToLocalMatrix, ray);
            localRay.origin.subtract(this.center);
            var end = egret3d.Vector3.create().multiplyScalar(999999.0, localRay.direction).add(localRay.origin).release();
            // Oimo CylinderGeometr, ConeGeometry. TODO
            var p1x = localRay.origin.x;
            var p1y = localRay.origin.y;
            var p1z = localRay.origin.z;
            var p2x = end.x;
            var p2y = end.y;
            var p2z = end.z;
            var height = this.height;
            var halfHeight = height * 0.5;
            var radius = this.bottomRadius;
            // const dRadius = this.bottomRadius - this.topRadius;
            // const ddd = Math.sqrt(dRadius * dRadius + height * height);
            // const sinTheta = dRadius / ddd;
            // const cosTheta = height / ddd;
            var dx = p2x - p1x;
            var dy = p2y - p1y;
            var dz = p2z - p1z;
            // Y
            var tminy = 0.0;
            var tmaxy = 1.0;
            if (dy > 2.220446049250313e-16 /* EPSILON */ && dy < 2.220446049250313e-16 /* EPSILON */) {
                if (p1y <= -halfHeight || p1y >= halfHeight) {
                    return false;
                }
            }
            else {
                var invDy = 1.0 / dy;
                var t1 = (-halfHeight - p1y) * invDy;
                var t2 = (halfHeight - p1y) * invDy;
                if (t1 > t2) {
                    var tmp = t1;
                    t1 = t2;
                    t2 = tmp;
                }
                if (t1 > 0.0)
                    tminy = t1;
                if (t2 < 1.0)
                    tmaxy = t2;
            }
            if (tminy >= 1.0 || tmaxy <= 0.0)
                return false;
            // XZ
            var tminxz = 0.0;
            var tmaxxz = 1.0;
            var a = dx * dx + dz * dz;
            var b = p1x * dx + p1z * dz;
            var c = (p1x * p1x + p1z * p1z) - radius * radius;
            var d = b * b - a * c;
            if (d < 0.0)
                return false;
            if (a > 0.0) {
                var sqrtD = Math.sqrt(d);
                tminxz = (-b - sqrtD) / a;
                tmaxxz = (-b + sqrtD) / a;
                if (tminxz >= 1.0 || tmaxxz <= 0.0)
                    return false;
            }
            else {
                if (c >= 0.0)
                    return false;
                tminxz = 0.0;
                tmaxxz = 1.0;
            }
            var min;
            if (tmaxxz <= tminy || tmaxy <= tminxz)
                return false;
            if (tminxz < tminy) {
                min = tminy;
                if (min === 0.0)
                    return false; // the ray starts from inside
                if (raycastInfo && raycastInfo.normal) {
                    raycastInfo.normal.set(0.0, dy > 0.0 ? -1.0 : 1.0, 0.0);
                }
            }
            else {
                min = tminxz;
                if (min === 0.0)
                    return false; // the ray starts from inside
                if (raycastInfo && raycastInfo.normal) {
                    raycastInfo.normal.set(p1x + dx * min, 0.0, p1z + dz * min).normalize();
                }
            }
            if (raycastInfo) {
                var localToWorldMatrix = transform.localToWorldMatrix;
                raycastInfo.distance = ray.origin.getDistance(raycastInfo.position
                    .set(p1x + min * dx, p1y + min * dy, p1z + min * dz)
                    .add(this.center)
                    .applyMatrix(localToWorldMatrix));
                raycastInfo.transform = transform;
                raycastInfo.collider = this;
                var normal = raycastInfo.normal;
                if (normal) {
                    // normal.applyDirection(localToWorldMatrix);
                    normal.applyMatrix3(egret3d.helpMatrix3A.fromMatrix4(worldToLocalMatrix).transpose()).normalize();
                }
            }
            return true;
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], CylinderCollider.prototype, "topRadius", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], CylinderCollider.prototype, "bottomRadius", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], CylinderCollider.prototype, "height", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], CylinderCollider.prototype, "center", void 0);
        CylinderCollider = __decorate([
            paper.allowMultiple
        ], CylinderCollider);
        return CylinderCollider;
    }(paper.BaseComponent));
    egret3d.CylinderCollider = CylinderCollider;
    __reflect(CylinderCollider.prototype, "egret3d.CylinderCollider", ["egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    var _helpRaycastInfo = egret3d.RaycastInfo.create();
    function _raycastCollider(ray, collider, raycastInfo, hit) {
        var helpRaycastInfo = _helpRaycastInfo;
        var normal = raycastInfo.normal;
        helpRaycastInfo.backfaceCulling = raycastInfo.backfaceCulling;
        helpRaycastInfo.normal = normal ? _helpVector3 : null;
        if (collider.raycast(ray, helpRaycastInfo) &&
            (!hit || raycastInfo.distance > helpRaycastInfo.distance)) {
            var transform = collider.gameObject.transform;
            raycastInfo.distance = helpRaycastInfo.distance;
            raycastInfo.position.copy(helpRaycastInfo.position);
            raycastInfo.transform = transform;
            raycastInfo.collider = collider;
            if (normal) {
                normal.copy(_helpVector3);
            }
            return true;
        }
        return false;
    }
    function _raycastAll(ray, gameObject, maxDistance, cullingMask, raycastMesh, backfaceCulling, raycastInfos) {
        if ((gameObject.hideFlags === 3 /* HideAndDontSave */ && gameObject.tag === "EditorOnly" /* EditorOnly */ &&
            (!gameObject.transform.parent || gameObject.transform.parent.gameObject.activeInHierarchy)) ? gameObject.activeSelf : !gameObject.activeInHierarchy) {
            return false;
        }
        var raycastInfo = egret3d.RaycastInfo.create();
        raycastInfo.backfaceCulling = backfaceCulling;
        if (gameObject.layer & cullingMask) {
            if (raycastMesh) {
                if (gameObject.renderer && gameObject.renderer.enabled &&
                    gameObject.renderer.raycast(ray, raycastInfo, raycastMesh)) {
                    raycastInfo.transform = gameObject.transform;
                }
            }
            else {
                raycast(ray, gameObject, false, raycastInfo);
            }
        }
        if (raycastInfo.transform) {
            if (maxDistance <= 0.0 || raycastInfo.distance <= maxDistance) {
                raycastInfos.push(raycastInfo);
            }
            else {
                raycastInfo.transform = null;
                raycastInfo.release();
            }
        }
        else {
            raycastInfo.transform = null;
            raycastInfo.release();
        }
        if (!raycastInfo.transform) {
            for (var _i = 0, _a = gameObject.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                _raycastAll(ray, child.gameObject, maxDistance, cullingMask, raycastMesh, backfaceCulling, raycastInfos);
            }
        }
        return true;
    }
    function _sortRaycastInfo(a, b) {
        // TODO renderQueue.
        return a.distance - b.distance;
    }
    /**
     * 用世界空间坐标系的射线检测指定的实体。（不包含其子级）
     * @param ray 世界空间坐标系的射线。
     * @param gameObject 实体。
     * @param raycastMesh 是否检测网格。（需要消耗较多的 CPU 性能，尤其是蒙皮网格）
     * @param raycastInfo
     */
    function raycast(ray, gameObject, raycastMesh, raycastInfo) {
        if (raycastMesh === void 0) { raycastMesh = false; }
        if (raycastMesh) {
            if (gameObject.renderer && gameObject.renderer.enabled &&
                gameObject.renderer.raycast(ray, raycastInfo, raycastMesh)) {
                if (raycastInfo) {
                    raycastInfo.transform = gameObject.transform;
                }
                return true;
            }
            return false;
        }
        else {
            // TODO 更快的查询所有碰撞组件的方式。extends ?
            var hit = false;
            var boxColliders = gameObject.getComponents(egret3d.BoxCollider);
            var sphereColliders = gameObject.getComponents(egret3d.SphereCollider);
            var cylinderColliders = gameObject.getComponents(egret3d.CylinderCollider);
            if (boxColliders.length > 0) {
                for (var _i = 0, boxColliders_1 = boxColliders; _i < boxColliders_1.length; _i++) {
                    var collider = boxColliders_1[_i];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo) {
                        if (_raycastCollider(ray, collider, raycastInfo, hit)) {
                            hit = true;
                        }
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            if (sphereColliders.length > 0) {
                for (var _a = 0, sphereColliders_1 = sphereColliders; _a < sphereColliders_1.length; _a++) {
                    var collider = sphereColliders_1[_a];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo) {
                        if (_raycastCollider(ray, collider, raycastInfo, hit)) {
                            hit = true;
                        }
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            if (cylinderColliders.length > 0) {
                for (var _b = 0, cylinderColliders_1 = cylinderColliders; _b < cylinderColliders_1.length; _b++) {
                    var collider = cylinderColliders_1[_b];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo) {
                        if (_raycastCollider(ray, collider, raycastInfo, hit)) {
                            hit = true;
                        }
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
        }
        if (raycastInfo && raycastInfo.transform) {
            return true;
        }
        return false;
    }
    egret3d.raycast = raycast;
    /**
     * 用世界空间坐标系的射线检测指定的实体或组件列表。
     * @param ray 射线。
     * @param gameObjectsOrComponents 实体或组件列表。
     * @param maxDistance 最大相交点检测距离。
     * @param cullingMask 只对特定层的实体检测。
     * @param raycastMesh 是否检测网格。（需要消耗较多的 CPU 性能，尤其是蒙皮网格）
     */
    function raycastAll(ray, gameObjectsOrComponents, maxDistance, cullingMask, raycastMesh, backfaceCulling) {
        if (maxDistance === void 0) { maxDistance = 0.0; }
        if (cullingMask === void 0) { cullingMask = 4294967295 /* Everything */; }
        if (raycastMesh === void 0) { raycastMesh = false; }
        if (backfaceCulling === void 0) { backfaceCulling = true; }
        var raycastInfos = [];
        for (var _i = 0, gameObjectsOrComponents_1 = gameObjectsOrComponents; _i < gameObjectsOrComponents_1.length; _i++) {
            var gameObjectOrComponent = gameObjectsOrComponents_1[_i];
            _raycastAll(ray, gameObjectOrComponent.constructor === paper.GameObject ? gameObjectOrComponent : gameObjectOrComponent.gameObject, maxDistance, cullingMask, raycastMesh, backfaceCulling, raycastInfos);
        }
        raycastInfos.sort(_sortRaycastInfo);
        return raycastInfos;
    }
    egret3d.raycastAll = raycastAll;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 几何球体。
     */
    var Sphere = (function (_super) {
        __extends(Sphere, _super);
        /**
         * 请使用 `egret3d.Sphere.create()` 创建实例。
         * @see egret3d.Sphere.create()
         */
        function Sphere() {
            var _this = _super.call(this) || this;
            /**
             * 球体半径。
             */
            _this.radius = 0.0;
            /**
             * 球体中心点。
             */
            _this.center = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个几何球体。
         * @param center 球体中心点。
         * @param radius 球体半径。
         */
        Sphere.create = function (center, radius) {
            if (center === void 0) { center = egret3d.Vector3.ZERO; }
            if (radius === void 0) { radius = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(center, radius);
                instance._released = false;
                return instance;
            }
            return new Sphere().set(center, radius);
        };
        Sphere.prototype.serialize = function () {
            return [this.center.x, this.center.y, this.center.z, this.radius];
        };
        Sphere.prototype.deserialize = function (value) {
            this.radius = value[3];
            this.center.fromArray(value);
            return this;
        };
        Sphere.prototype.clone = function () {
            return Sphere.create(this.center, this.radius);
        };
        Sphere.prototype.copy = function (value) {
            return this.set(value.center, value.radius);
        };
        Sphere.prototype.set = function (center, radius) {
            this.radius = radius;
            this.center.copy(center);
            return this;
        };
        Sphere.prototype.applyMatrix = function (matrix) {
            this.center.applyMatrix(matrix);
            this.radius = this.radius * matrix.maxScaleOnAxis;
            return this;
        };
        /**
         * 根据点集设置球体信息。
         * @param points 点集。
         * @param center 中心点。（不设置则自动计算）
         */
        Sphere.prototype.fromPoints = function (points, center) {
            if (center) {
                this.center.copy(center);
            }
            else {
                this.center.copy(egret3d.helpAABBA.fromPoints(points).center);
            }
            var maxRadiusSqrt = 0.0;
            for (var i = 0, l = points.length; i < l; i++) {
                maxRadiusSqrt = Math.max(maxRadiusSqrt, this.center.getDistance(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSqrt);
            return this;
        };
        /**
         * 是否包含指定的点或其他球体。
         * @param value 点或球体。
         */
        Sphere.prototype.contains = function (value) {
            if (value instanceof Sphere) {
                var radiusDelta = this.radius - value.radius;
                if (radiusDelta >= 0.0) {
                    this.center.getSquaredDistance(value.center) <= (radiusDelta * radiusDelta);
                }
                return false;
            }
            return this.center.getSquaredDistance(value) <= this.radius * this.radius;
        };
        /**
         * 获取一个点到该球体的最近点。（如果该点在球体内部，则最近点就是该点）
         * @param point 一个点。
         * @param out 最近点。
         */
        Sphere.prototype.getClosestPointToPoint = function (point, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            var squaredDistance = this.center.getSquaredDistance(point);
            if (squaredDistance > (this.radius * this.radius)) {
                out.subtract(this.center, point).normalize();
                out.multiplyScalar(this.radius).add(this.center);
            }
            else {
                out.copy(point);
            }
            return out;
        };
        /**
         * 获取一点到该球体表面的最近距离。
         * @param value 点。
         */
        Sphere.prototype.getDistance = function (value) {
            return this.center.getDistance(value) - this.radius;
        };
        Sphere.prototype.raycast = function (ray, raycastInfo) {
            var v1 = egret3d.helpVector3A.subtract(this.center, ray.origin);
            var tca = v1.dot(ray.direction);
            var d2 = v1.dot(v1) - tca * tca;
            var radius2 = this.radius * this.radius;
            if (d2 > radius2)
                return false;
            var thc = Math.sqrt(radius2 - d2);
            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;
            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;
            // test to see if both t0 and t1 are behind the ray - if so, return null
            if (t0 < 0.0 && t1 < 0.0)
                return false;
            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            // else t0 is in front of the ray, so return the first collision point scaled by t0
            if (raycastInfo) {
                var normal = raycastInfo.normal;
                var position = ray.getPointAt(raycastInfo.distance = t0 < 0.0 ? t1 : t0, raycastInfo.position);
                if (normal) {
                    normal.subtract(position, this.center).normalize();
                }
            }
            return true;
        };
        Sphere._instances = [];
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Sphere.prototype, "radius", void 0);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Sphere.prototype, "center", void 0);
        return Sphere;
    }(paper.BaseRelease));
    egret3d.Sphere = Sphere;
    __reflect(Sphere.prototype, "egret3d.Sphere", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @beta 这是一个试验性质的 API，有可能会被删除或修改。
     */
    var CameraPostprocessing = (function (_super) {
        __extends(CameraPostprocessing, _super);
        function CameraPostprocessing() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CameraPostprocessing.prototype.render = function (camera) {
        };
        return CameraPostprocessing;
    }(paper.BaseComponent));
    egret3d.CameraPostprocessing = CameraPostprocessing;
    __reflect(CameraPostprocessing.prototype, "egret3d.CameraPostprocessing");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var LightSize;
    (function (LightSize) {
        LightSize[LightSize["Directional"] = 11] = "Directional";
        LightSize[LightSize["Point"] = 15] = "Point";
        LightSize[LightSize["Spot"] = 18] = "Spot";
    })(LightSize || (LightSize = {}));
    var _helpVector3 = egret3d.Vector3.create();
    /**
     * 相机渲染上下文。
     */
    var CameraRenderContext = (function () {
        /**
         * 禁止实例化。
         */
        function CameraRenderContext(camera) {
            /**
             *
             */
            this.camera = null;
            /**
             *
             */
            this.drawCall = null;
            /**
             *
             */
            this.lightmapUV = 1;
            this.lightmapIntensity = 1.0;
            this.lightmapScaleOffset = new Float32Array(4);
            this.lightmap = null;
            /**
             *
             */
            this.lightCount = 0;
            this.directLightCount = 0;
            this.pointLightCount = 0;
            this.spotLightCount = 0;
            // public readonly lightPosition: Float32Array = new Float32Array([0.0, 0.0, 0.0]);
            // 12: dirX, dirY, dirZ, colorR, colorG, colorB, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.directLightArray = new Float32Array(0);
            // 16: x, y, z, colorR, colorG, colorB, distance, decay, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY, shadowCameraNear, shadowCameraFar,
            this.pointLightArray = new Float32Array(0);
            // 18: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, distance, decay, coneCos, penumbraCos, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.spotLightArray = new Float32Array(0);
            this.lightShadowCameraNear = 0.0;
            this.lightShadowCameraFar = 0.0;
            this.lightCastShadows = false;
            this.directShadowMaps = [];
            this.pointShadowMaps = [];
            this.spotShadowMaps = [];
            this.directShadowMatrix = new Float32Array(0);
            this.spotShadowMatrix = new Float32Array(0);
            this.pointShadowMatrix = new Float32Array(0);
            this.matrix_mv = egret3d.Matrix4.create();
            this.matrix_mvp = egret3d.Matrix4.create();
            this.matrix_mv_inverse = egret3d.Matrix3.create();
            this.fogDensity = 0.0;
            this.fogNear = 0.0;
            this.fogFar = 0.0;
            this.fogColor = new Float32Array(3);
            this._postProcessingCamera = null;
            this._postProcessDrawCall = egret3d.DrawCall.create();
            this._drawCallCollecter = paper.GameObject.globalGameObject.getComponent(egret3d.DrawCallCollecter);
            /**
             * @internal
             */
            this.cameraPosition = new Float32Array(3);
            /**
             * @internal
             */
            this.cameraForward = new Float32Array(3);
            /**
             * @internal
             */
            this.cameraUp = new Float32Array(3);
            /**
             * 此帧的非透明绘制信息列表。
             * - 已进行视锥剔除的。
             * @internal
             */
            this.opaqueCalls = [];
            /**
             * 此帧的透明绘制信息列表。
             * - 已进行视锥剔除的。
             * @internal
             */
            this.transparentCalls = [];
            /**
             * 此帧的阴影绘制信息列表。
             * - 已进行视锥剔除的。
             * @internal
             */
            this.shadowCalls = [];
            this.camera = camera;
            {
                var gameObjectName = "PostProcessing Camera";
                var transform = paper.GameObject.globalGameObject.transform.find(gameObjectName);
                var gameObject = null;
                if (transform) {
                    gameObject = transform.gameObject;
                    this._postProcessingCamera = gameObject.getComponent(egret3d.Camera);
                }
                else {
                    gameObject = paper.GameObject.create(gameObjectName, "Untagged" /* Untagged */, paper.Scene.globalScene);
                    // gameObject.hideFlags = paper.HideFlags.HideAndDontSave;
                    gameObject.parent = paper.GameObject.globalGameObject; // TODO remove
                    var postProcessingCamera = gameObject.addComponent(egret3d.Camera);
                    postProcessingCamera.enabled = false;
                    postProcessingCamera.opvalue = 0.0;
                    postProcessingCamera.size = 1.0;
                    postProcessingCamera.near = 0.01;
                    postProcessingCamera.far = 1.0;
                    postProcessingCamera.projectionMatrix = egret3d.Matrix4.IDENTITY;
                    this._postProcessingCamera = postProcessingCamera;
                }
            }
            //
            this._postProcessDrawCall.matrix = egret3d.Matrix4.IDENTITY;
            this._postProcessDrawCall.subMeshIndex = 0;
            this._postProcessDrawCall.mesh = egret3d.DefaultMeshes.FULLSCREEN_QUAD;
        }
        /**
         * 所有非透明的, 按照从近到远排序
         */
        CameraRenderContext.prototype._sortOpaque = function (a, b) {
            var materialA = a.material;
            var materialB = b.material;
            if (materialA.renderQueue !== materialB.renderQueue) {
                return materialA.renderQueue - materialB.renderQueue;
            }
            else if (materialA._technique.program !== materialB._technique.program) {
                return materialA._technique.program - materialB._technique.program;
            }
            else if (materialA._id !== materialB._id) {
                return materialA._id - materialB._id;
            }
            else {
                return a.zdist - b.zdist;
            }
        };
        /**
         * 所有透明的，按照从远到近排序
         */
        CameraRenderContext.prototype._sortFromFarToNear = function (a, b) {
            var materialA = a.material;
            var materialB = b.material;
            if (materialA.renderQueue === materialB.renderQueue) {
                return b.zdist - a.zdist;
            }
            else {
                return materialA.renderQueue - materialB.renderQueue;
            }
        };
        /**
         * @internal
         */
        CameraRenderContext.prototype._shadowFrustumCulling = function () {
            var camera = this.camera;
            var cameraFrustum = camera.frustum;
            var shadowDrawCalls = this.shadowCalls;
            shadowDrawCalls.length = 0;
            for (var _i = 0, _a = this._drawCallCollecter.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var renderer = drawCall.renderer;
                if (renderer.castShadows &&
                    (camera.cullingMask & renderer.gameObject.layer) !== 0 &&
                    (!renderer.frustumCulled || egret3d.math.frustumIntersectsSphere(cameraFrustum, renderer.boundingSphere))) {
                    shadowDrawCalls.push(drawCall);
                }
            }
            shadowDrawCalls.sort(this._sortFromFarToNear);
        };
        /**
         * @internal
         */
        CameraRenderContext.prototype._frustumCulling = function () {
            var camera = this.camera;
            var cameraPosition = camera.gameObject.transform.position;
            var cameraFrustum = camera.frustum;
            var opaqueCalls = this.opaqueCalls;
            var transparentCalls = this.transparentCalls;
            opaqueCalls.length = 0;
            transparentCalls.length = 0;
            for (var _i = 0, _a = this._drawCallCollecter.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var renderer = drawCall.renderer;
                if ((camera.cullingMask & renderer.gameObject.layer) !== 0 &&
                    (!renderer.frustumCulled || egret3d.math.frustumIntersectsSphere(cameraFrustum, renderer.boundingSphere))) {
                    // if (drawCall.material.renderQueue >= paper.RenderQueue.Transparent && drawCall.material.renderQueue <= paper.RenderQueue.Overlay) {
                    if (drawCall.material.renderQueue >= 3000 /* Transparent */) {
                        transparentCalls.push(drawCall);
                    }
                    else {
                        opaqueCalls.push(drawCall);
                    }
                    drawCall.zdist = renderer.gameObject.transform.position.getDistance(cameraPosition);
                }
            }
            opaqueCalls.sort(this._sortOpaque);
            transparentCalls.sort(this._sortFromFarToNear);
        };
        CameraRenderContext.prototype.blit = function (src, material, dest) {
            if (material === void 0) { material = null; }
            if (dest === void 0) { dest = null; }
            if (!material) {
                material = egret3d.DefaultMaterials.COPY;
                material.setTexture(src);
            }
            var postProcessingCamera = this._postProcessingCamera;
            var postProcessDrawCall = this._postProcessDrawCall;
            postProcessDrawCall.material = material;
            egret3d.renderState.updateViewport(postProcessingCamera.viewport, dest);
            egret3d.renderState.clearBuffer(256 /* Depth */ | 16384 /* Color */, egret3d.Color.WHITE);
            postProcessingCamera.projectionMatrix.identity(); // TODO
            var saveCamera = egret3d.Camera.current;
            egret3d.Camera.current = postProcessingCamera;
            egret3d.renderState.draw(postProcessDrawCall);
            egret3d.Camera.current = saveCamera;
        };
        CameraRenderContext.prototype.updateCameraTransform = function () {
            var rawData = this.camera.cameraToWorldMatrix.rawData;
            this.cameraPosition[0] = rawData[12];
            this.cameraPosition[1] = rawData[13];
            this.cameraPosition[2] = rawData[14];
            this.cameraUp[0] = rawData[4];
            this.cameraUp[1] = rawData[5];
            this.cameraUp[2] = rawData[6];
            this.cameraForward[0] = -rawData[8];
            this.cameraForward[1] = -rawData[9];
            this.cameraForward[2] = -rawData[10];
        };
        CameraRenderContext.prototype.updateLights = function (lights) {
            var allLightCount = 0, directLightCount = 0, pointLightCount = 0, spotLightCount = 0;
            this.lightCastShadows = false;
            for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
                var light = lights_1[_i];
                if (light instanceof egret3d.DirectionalLight) {
                    directLightCount++;
                }
                else if (light instanceof egret3d.PointLight) {
                    pointLightCount++;
                }
                else if (light instanceof egret3d.SpotLight) {
                    spotLightCount++;
                }
                allLightCount++;
            }
            // TODO
            if (this.directLightArray.length !== directLightCount * 11 /* Directional */) {
                this.directLightArray = new Float32Array(directLightCount * 11 /* Directional */);
            }
            if (this.pointLightArray.length !== pointLightCount * 15 /* Point */) {
                this.pointLightArray = new Float32Array(pointLightCount * 15 /* Point */);
            }
            if (this.spotLightArray.length !== spotLightCount * 18 /* Spot */) {
                this.spotLightArray = new Float32Array(spotLightCount * 18 /* Spot */);
            }
            if (this.directShadowMatrix.length !== directLightCount * 16) {
                this.directShadowMatrix = new Float32Array(directLightCount * 16);
            }
            if (this.pointShadowMatrix.length !== pointLightCount * 16) {
                this.pointShadowMatrix = new Float32Array(pointLightCount * 16);
            }
            if (this.spotShadowMatrix.length !== spotLightCount * 16) {
                this.spotShadowMatrix = new Float32Array(spotLightCount * 16);
            }
            this.directShadowMaps.length = directLightCount;
            this.pointShadowMaps.length = pointLightCount;
            this.spotShadowMaps.length = spotLightCount;
            this.lightCount = allLightCount;
            this.directLightCount = directLightCount;
            this.pointLightCount = pointLightCount;
            this.spotLightCount = spotLightCount;
            var directLightIndex = 0, pointLightIndex = 0, spotLightIndex = 0, index = 0;
            var lightArray = this.directLightArray;
            var worldToCameraMatrix = this.camera.worldToCameraMatrix;
            for (var _a = 0, lights_2 = lights; _a < lights_2.length; _a++) {
                var light = lights_2[_a];
                switch (light.constructor) {
                    case egret3d.DirectionalLight: {
                        light.gameObject.transform.getForward(_helpVector3);
                        _helpVector3.applyDirection(worldToCameraMatrix);
                        lightArray = this.directLightArray;
                        index = directLightIndex * 11 /* Directional */;
                        // lightArray[index++] = dirHelper.x; // Right-hand.
                        // lightArray[index++] = dirHelper.y;
                        // lightArray[index++] = dirHelper.z;
                        lightArray[index++] = -_helpVector3.x; // Left-hand.
                        lightArray[index++] = -_helpVector3.y;
                        lightArray[index++] = -_helpVector3.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        break;
                    }
                    case egret3d.PointLight: {
                        var position = light.gameObject.transform.position.clone().release();
                        position.applyMatrix(worldToCameraMatrix);
                        lightArray = this.pointLightArray;
                        index = pointLightIndex * 15 /* Point */;
                        lightArray[index++] = position.x;
                        lightArray[index++] = position.y;
                        lightArray[index++] = position.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        var distance = light.distance;
                        lightArray[index++] = distance;
                        lightArray[index++] = distance === 0 ? 0 : light.decay;
                        break;
                    }
                    case egret3d.SpotLight: {
                        var position = light.gameObject.transform.position.clone().release();
                        position.applyMatrix(worldToCameraMatrix);
                        light.gameObject.transform.getForward(_helpVector3);
                        _helpVector3.applyDirection(worldToCameraMatrix);
                        lightArray = this.spotLightArray;
                        index = spotLightIndex * 18 /* Spot */;
                        lightArray[index++] = position.x;
                        lightArray[index++] = position.y;
                        lightArray[index++] = position.z;
                        // lightArray[index++] = dirHelper.x; // Right-hand.
                        // lightArray[index++] = dirHelper.y;
                        // lightArray[index++] = dirHelper.z;
                        lightArray[index++] = -_helpVector3.x; // Left-hand.
                        lightArray[index++] = -_helpVector3.y;
                        lightArray[index++] = -_helpVector3.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        var distance = light.distance;
                        lightArray[index++] = distance;
                        lightArray[index++] = distance === 0 ? 0 : light.decay;
                        lightArray[index++] = Math.cos(light.angle);
                        lightArray[index++] = Math.cos(light.angle * (1 - light.penumbra));
                        break;
                    }
                }
                if (light.castShadows) {
                    // lightArray[index++] = 1;
                    // lightArray[index++] = -light.shadowBias; // Left-hand.
                    // lightArray[index++] = light.shadowRadius;
                    // lightArray[index++] = light.shadowSize;
                    // lightArray[index++] = light.shadowSize;
                    // switch (light.constructor) {
                    //     case DirectionalLight:
                    //         this.directShadowMatrix.set(light.shadowMatrix.rawData, directLightIndex * 16);
                    //         this.directShadowMaps[directLightIndex++] = light.renderTarget.texture;
                    //         break;
                    //     case PointLight:
                    //         lightArray[index++] = light.shadowCameraNear;
                    //         lightArray[index++] = light.shadowCameraFar;
                    //         this.pointShadowMatrix.set(light.shadowMatrix.rawData, pointLightIndex * 16);
                    //         this.pointShadowMaps[pointLightIndex++] = light.renderTarget.texture;
                    //         break;
                    //     case SpotLight:
                    //         this.spotShadowMatrix.set(light.shadowMatrix.rawData, spotLightIndex * 16);
                    //         this.spotShadowMaps[spotLightIndex++] = light.renderTarget.texture;
                    //         break;
                    // }
                    this.lightCastShadows = true;
                }
                else {
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    switch (light.constructor) {
                        case egret3d.DirectionalLight:
                            this.directShadowMaps[directLightIndex++] = null;
                            break;
                        case egret3d.PointLight:
                            lightArray[index++] = 0;
                            lightArray[index++] = 0;
                            this.pointShadowMaps[pointLightIndex++] = null;
                            break;
                        case egret3d.SpotLight:
                            this.spotShadowMaps[spotLightIndex++] = null;
                            break;
                    }
                }
            }
        };
        // public updateLightDepth(light: BaseLight) {
        //     const position = light.gameObject.transform.position;
        //     //
        //     this.lightPosition[0] = position.x;
        //     this.lightPosition[1] = position.y;
        //     this.lightPosition[2] = position.z;
        //     //
        //     this.lightShadowCameraNear = light.shadowCameraNear;
        //     this.lightShadowCameraFar = light.shadowCameraFar;
        // }
        CameraRenderContext.prototype.updateDrawCall = function (drawCall) {
            var renderer = drawCall.renderer;
            var scene = renderer ? renderer.gameObject.scene : this.camera.gameObject.scene; //后期渲染renderer为空，取camera的场景
            // const scene = paper.Scene.activeScene;
            var worldToCameraMatrix = this.camera.worldToCameraMatrix;
            var worldToClipMatrix = this.camera.worldToClipMatrix;
            var matrix = drawCall.matrix;
            this.drawCall = drawCall;
            this.matrix_mv.multiply(worldToCameraMatrix, matrix);
            this.matrix_mvp.multiply(worldToClipMatrix, matrix);
            this.matrix_mv_inverse.getNormalMatrix(this.matrix_mv);
            //
            var shaderContextDefine = "";
            if (renderer && renderer.constructor === egret3d.MeshRenderer &&
                renderer.lightmapIndex >= 0 &&
                scene.lightmaps.length > renderer.lightmapIndex) {
                this.lightmapUV = drawCall.mesh.glTFMesh.primitives[drawCall.subMeshIndex].attributes.TEXCOORD_1 ? 1 : 0;
                this.lightmapIntensity = scene.lightmapIntensity;
                renderer.lightmapScaleOffset.toArray(this.lightmapScaleOffset);
                this.lightmap = scene.lightmaps[renderer.lightmapIndex];
                shaderContextDefine += "#define USE_LIGHTMAP \n";
            }
            if (this.lightCount > 0) {
                if (this.directLightCount > 0) {
                    shaderContextDefine += "#define NUM_DIR_LIGHTS " + this.directLightCount + "\n";
                }
                if (this.pointLightCount > 0) {
                    shaderContextDefine += "#define NUM_POINT_LIGHTS " + this.pointLightCount + "\n";
                }
                if (this.spotLightCount > 0) {
                    shaderContextDefine += "#define NUM_SPOT_LIGHTS " + this.spotLightCount + "\n";
                }
                if (renderer && renderer.receiveShadows && this.lightCastShadows) {
                    shaderContextDefine += "#define USE_SHADOWMAP \n";
                    shaderContextDefine += "#define SHADOWMAP_TYPE_PCF \n";
                }
            }
            var fog = scene.fog;
            if (fog.mode !== 0 /* None */) {
                this.fogColor[0] = fog.color.r;
                this.fogColor[1] = fog.color.g;
                this.fogColor[2] = fog.color.b;
                shaderContextDefine += "#define USE_FOG \n"; //TODO 根据参数生成define
                if (fog.mode === 2 /* FogEXP2 */) {
                    this.fogDensity = fog.density;
                    shaderContextDefine += "#define FOG_EXP2 \n"; //TODO 根据参数生成define
                }
                else {
                    this.fogNear = fog.near;
                    this.fogFar = fog.far;
                }
            }
            if (renderer && renderer.constructor === egret3d.SkinnedMeshRenderer) {
                var skinnedMeshRenderer = renderer.source || renderer;
                if (!skinnedMeshRenderer.forceCPUSkin) {
                    shaderContextDefine += "#define USE_SKINNING \n" + ("#define MAX_BONES " + Math.min(egret3d.renderState.maxBoneCount, skinnedMeshRenderer.bones.length) + " \n");
                }
            }
            return shaderContextDefine;
        };
        return CameraRenderContext;
    }());
    egret3d.CameraRenderContext = CameraRenderContext;
    __reflect(CameraRenderContext.prototype, "egret3d.CameraRenderContext");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var CameraAndLightSystem = (function (_super) {
        __extends(CameraAndLightSystem, _super);
        function CameraAndLightSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                [
                    { componentClass: egret3d.Camera }
                ],
                [
                    { componentClass: [egret3d.DirectionalLight, egret3d.PointLight, egret3d.SpotLight] }
                ]
            ];
            _this._cameraAndLightCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.CameraAndLightCollecter);
            _this._lightCamera = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.Camera);
            return _this;
        }
        CameraAndLightSystem.prototype.onAwake = function () {
            var lightCamera = this._lightCamera;
            lightCamera.enabled = false; // Disable camera.
            lightCamera.hideFlags = 3 /* HideAndDontSave */;
        };
        CameraAndLightSystem.prototype.onAddGameObject = function (_gameObject, group) {
            var groups = this.groups;
            var cameraAndLightCollecter = this._cameraAndLightCollecter;
            if (group === groups[0]) {
                cameraAndLightCollecter.updateCameras(groups[0].gameObjects);
            }
            else if (group === groups[1]) {
                cameraAndLightCollecter.updateLights(groups[1].gameObjects);
            }
        };
        CameraAndLightSystem.prototype.onRemoveGameObject = function (_gameObject, group) {
            var groups = this.groups;
            var cameraAndLightCollecter = this._cameraAndLightCollecter;
            if (group === groups[0]) {
                cameraAndLightCollecter.updateCameras(groups[0].gameObjects);
            }
            else if (group === groups[1]) {
                cameraAndLightCollecter.updateLights(groups[1].gameObjects);
            }
        };
        CameraAndLightSystem.prototype.onUpdate = function () {
            var cameraAndLightCollecter = this._cameraAndLightCollecter;
            var cameras = cameraAndLightCollecter.cameras, lights = cameraAndLightCollecter.lights;
            if (cameras.length > 0) {
                cameraAndLightCollecter.sortCameras();
            }
            if (lights.length > 0) {
                cameraAndLightCollecter.lightDirty = true;
            }
        };
        CameraAndLightSystem.prototype.onLateUpdate = function () {
            this._cameraAndLightCollecter.lightDirty = false;
        };
        return CameraAndLightSystem;
    }(paper.BaseSystem));
    egret3d.CameraAndLightSystem = CameraAndLightSystem;
    __reflect(CameraAndLightSystem.prototype, "egret3d.CameraAndLightSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 灯光的阴影。
     */
    var LightShadow = (function () {
        /**
         * 禁止实例化。
         */
        function LightShadow() {
            /**
             *
             */
            this.radius = 0.5;
            /**
             *
             */
            this.bias = 0.01;
            /**
             *
             */
            this.size = 512;
            /**
             *
             */
            this.near = 0.03;
            /**
             *
             */
            this.far = 0.03;
            /**
             * @private
             */
            this.matrix = egret3d.Matrix4.create();
            /**
             * @private
             */
            this.camera = paper.GameObject.globalGameObject.getComponent(egret3d.Camera);
            /**
             * @private
             */
            this.renderTarget = null;
            /**
             *
             */
            this.update = null;
        }
        /**
         * @internal
         */
        LightShadow.create = function () {
            return new LightShadow();
        };
        LightShadow.prototype.serialize = function () {
            return [this.radius, this.bias, this.size, this.near, this.far];
        };
        LightShadow.prototype.deserialize = function (data) {
            this.radius = data[0];
            this.bias = data[1];
            this.size = data[2];
            this.near = data[3];
            this.far = data[4];
            return this;
        };
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], LightShadow.prototype, "radius", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01 })
        ], LightShadow.prototype, "bias", void 0);
        __decorate([
            paper.editor.property("UINT" /* UINT */)
        ], LightShadow.prototype, "size", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, maximum: 9999 })
        ], LightShadow.prototype, "near", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.02, maximum: 10000 })
        ], LightShadow.prototype, "far", void 0);
        return LightShadow;
    }());
    egret3d.LightShadow = LightShadow;
    __reflect(LightShadow.prototype, "egret3d.LightShadow", ["paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 场景。
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene(name) {
            var _this = _super.call(this) || this;
            /**
             * 该场景的名称。
             */
            _this.name = "";
            /**
             * 额外数据，仅保存在编辑器环境，项目发布时该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            /**
             * 该场景使用光照贴图时的光照强度。
             */
            _this.lightmapIntensity = 1.0;
            /**
             * 该场景的环境光。
             */
            _this.ambientColor = egret3d.Color.create(0.20, 0.20, 0.25, 1.0);
            /**
             * 该场景的雾。
             */
            _this.fog = egret3d.Fog.create();
            _this._gameObjects = [];
            _this._lightmaps = [];
            _this.name = name;
            return _this;
        }
        /**
         * 创建一个空场景。
         * @param name 场景的名称。
         */
        Scene.createEmpty = function (name, isActive) {
            // const exScene = Application.sceneManager.getSceneByName(name); TODO
            // if (exScene) {
            //     console.warn("The scene with the same name already exists.");
            //     return exScene;
            // }
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (isActive === void 0) { isActive = true; }
            var scene = new Scene(name);
            paper.Application.sceneManager.addScene(scene, isActive);
            return scene;
        };
        /**
         * 通过指定的场景资源创建一个场景。
         * @param name 场景资源的名称。
         */
        Scene.create = function (name, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            var rawScene = paper.Asset.find(name);
            if (rawScene && rawScene instanceof paper.RawScene) {
                if (rawScene) {
                    var existedScene = paper.Application.sceneManager.getScene(rawScene.name);
                    if (existedScene) {
                        console.warn("The scene with the same name already exists.");
                        return existedScene;
                    }
                }
                var scene = rawScene.createInstance();
                if (scene) {
                    if (combineStaticObjects && paper.Application.playerMode !== 2 /* Editor */) {
                        egret3d.combine(scene.gameObjects);
                    }
                    return scene;
                }
            }
            else {
                console.warn("The scene don't exists.", name);
            }
            return null;
        };
        Object.defineProperty(Scene, "globalScene", {
            /**
             * 全局静态的场景。
             * - 全局场景无法被销毁。
             */
            get: function () {
                return paper.Application.sceneManager.globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene, "editorScene", {
            /**
             * 全局静态编辑器的场景。
             */
            get: function () {
                return paper.Application.sceneManager.editorScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene, "activeScene", {
            /**
             * 当前激活的场景。
             */
            get: function () {
                return paper.Application.sceneManager.activeScene;
            },
            set: function (value) {
                paper.Application.sceneManager.activeScene = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @internal
         */
        Scene.prototype.addGameObject = function (gameObject) {
            if (this._gameObjects.indexOf(gameObject) >= 0) {
                console.warn("Add game object error.", gameObject.path);
                return;
            }
            this._gameObjects.push(gameObject);
        };
        /**
         * @internal
         */
        Scene.prototype.removeGameObject = function (gameObject) {
            var index = this._gameObjects.indexOf(gameObject);
            if (index < 0) {
                console.warn("Remove game object error.", gameObject.path);
                return;
            }
            this._gameObjects.splice(index, 1);
        };
        /**
         * 场景被销毁后，内部卸载。
         * @internal
         */
        Scene.prototype.uninitialize = function () {
            for (var _i = 0, _a = this._lightmaps; _i < _a.length; _i++) {
                var lightmap = _a[_i];
                if (lightmap) {
                    lightmap.release();
                }
            }
            // TODO
            // this.name = "";
            // this.extras
            this.lightmapIntensity = 1.0;
            this.ambientColor.set(0.20, 0.20, 0.25, 1.0);
            // this.fog.clear();
            this._lightmaps.length = 0;
        };
        /**
         * 销毁该场景和场景中的全部实体。
         */
        Scene.prototype.destroy = function () {
            if (!paper.Application.sceneManager.removeScene(this)) {
                return false;
            }
            var i = this._gameObjects.length;
            while (i--) {
                var gameObject = this._gameObjects[i];
                if (!gameObject || gameObject.transform.parent) {
                    continue;
                }
                gameObject.destroy();
            }
            // 销毁的第一时间就将实体清除。
            this._gameObjects.length = 0;
            paper.disposeCollecter.scenes.push(this);
            return true;
        };
        /**
         * 获取该场景指定名称或路径的第一个实体。
         * - 仅返回第一个符合条件的实体。
         * @param nameOrPath 名称或路径。
         */
        Scene.prototype.find = function (nameOrPath) {
            var index = nameOrPath.indexOf("/");
            if (index > 0) {
                var firstName = nameOrPath.slice(0, index);
                for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    if (gameObject.name === firstName) {
                        var child = gameObject.transform.find(nameOrPath.slice(index + 1));
                        return child ? child.gameObject : null;
                    }
                }
            }
            else {
                for (var _b = 0, _c = this._gameObjects; _b < _c.length; _b++) {
                    var gameObject = _c[_b];
                    if (gameObject.name === nameOrPath) {
                        return gameObject;
                    }
                }
            }
            return null;
        };
        /**
         * 获取该场景指定标识的第一个实体。
         * - 仅返回第一个符合条件的实体。
         * @param tag 标识。
         */
        Scene.prototype.findWithTag = function (tag) {
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    return gameObject;
                }
            }
            return null;
        };
        /**
         * 获取该场景指定标识的全部实体。
         * - 返回符合条件的全部实体。
         * @param tag 标识。
         */
        Scene.prototype.findGameObjectsWithTag = function (tag) {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        /**
         * 该场景的全部根实体。
         */
        Scene.prototype.getRootGameObjects = function () {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (!gameObject.transform.parent) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        Object.defineProperty(Scene.prototype, "gameObjectCount", {
            /**
             * 该场景的实体总数。
             */
            get: function () {
                return this._gameObjects.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "gameObjects", {
            /**
             * 该场景的全部实体。
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "lightmaps", {
            /**
             * 该场景的光照贴图列表。
             */
            get: function () {
                return this._lightmaps;
            },
            set: function (value) {
                var lightmaps = this._lightmaps;
                for (var _i = 0, lightmaps_1 = lightmaps; _i < lightmaps_1.length; _i++) {
                    var lightmap = lightmaps_1[_i];
                    if (lightmap) {
                        lightmap.release();
                    }
                }
                if (value !== lightmaps) {
                    lightmaps.length = 0;
                    for (var _a = 0, value_2 = value; _a < value_2.length; _a++) {
                        var lightmap = value_2[_a];
                        lightmaps.push(lightmap);
                    }
                }
                for (var _b = 0, lightmaps_2 = lightmaps; _b < lightmaps_2.length; _b++) {
                    var lightmap = lightmaps_2[_b];
                    if (lightmap) {
                        lightmap.retain();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Scene.prototype, "name", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "extras", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Scene.prototype, "lightmapIntensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("COLOR" /* COLOR */)
        ], Scene.prototype, "ambientColor", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("NESTED" /* NESTED */)
        ], Scene.prototype, "fog", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Scene.prototype, "gameObjects", null);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "lightmaps", null);
        return Scene;
    }(paper.BaseObject));
    paper.Scene = Scene;
    __reflect(Scene.prototype, "paper.Scene");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 平行光组件。
     */
    var DirectionalLight = (function (_super) {
        __extends(DirectionalLight, _super);
        function DirectionalLight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DirectionalLight.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            // this.shadow.renderTarget = new GlRenderTarget("DirectionalLightShadow", this.shadow.size, this.shadow.size, true); // TODO
            // this.shadow.update = this._updateShadow;
        };
        DirectionalLight.prototype._updateShadow = function (light, shadow) {
            // shadow.camera.opvalue = 0.0; // Orthographic camera.
            // shadow.camera.renderTarget = shadow.renderTarget;
            // // shadow.viewPortPixel.set(0, 0, this.shadowSize, this.shadowSize);
            // this._updateShadowMatrix(camera);
        };
        return DirectionalLight;
    }(egret3d.BaseLight));
    egret3d.DirectionalLight = DirectionalLight;
    __reflect(DirectionalLight.prototype, "egret3d.DirectionalLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _targets = [
        new egret3d.Vector3(1, 0, 0), new egret3d.Vector3(-1, 0, 0), new egret3d.Vector3(0, 0, 1),
        new egret3d.Vector3(0, 0, -1), new egret3d.Vector3(0, 1, 0), new egret3d.Vector3(0, -1, 0)
    ];
    var _ups = [
        new egret3d.Vector3(0, 1, 0), new egret3d.Vector3(0, 1, 0), new egret3d.Vector3(0, 1, 0),
        new egret3d.Vector3(0, 1, 0), new egret3d.Vector3(0, 0, 1), new egret3d.Vector3(0, 0, -1)
    ];
    var _viewPortsScale = [
        new egret3d.Vector4(2, 1, 1, 1), new egret3d.Vector4(0, 1, 1, 1), new egret3d.Vector4(3, 1, 1, 1),
        new egret3d.Vector4(1, 1, 1, 1), new egret3d.Vector4(3, 0, 1, 1), new egret3d.Vector4(1, 0, 1, 1)
    ];
    /**
     * 点光组件。
     */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.decay = 0.0;
            /**
             *
             */
            _this.distance = 10.0;
            return _this;
        }
        PointLight.prototype.updateShadow = function (camera) {
            // if (!this.renderTarget) {
            //     this.renderTarget = new GlRenderTarget("PointLight", this.shadowSize * 4, this.shadowSize * 2); //   4x2  cube
            // }
            // camera.fov = Math.PI * 0.5;
            // camera.opvalue = 1.0;
            // camera.renderTarget = this.renderTarget;
            // const context = camera.context;
            // camera.calcProjectMatrix(1.0, context.matrix_p);
            // const shadowMatrix = this.shadowMatrix;
            // shadowMatrix.fromTranslate(this.gameObject.transform.position.clone().multiplyScalar(-1).release());
        };
        PointLight.prototype.updateFace = function (camera, faceIndex) {
            // TODO
            // const position = this.gameObject.transform.position.clone().release();
            // helpVector3A.set(
            //     position.x + _targets[faceIndex].x,
            //     position.y + _targets[faceIndex].y,
            //     position.z + _targets[faceIndex].z,
            // );
            // this.viewPortPixel.x = _viewPortsScale[faceIndex].x * this.shadowSize;
            // this.viewPortPixel.y = _viewPortsScale[faceIndex].y * this.shadowSize;
            // this.viewPortPixel.w = _viewPortsScale[faceIndex].z * this.shadowSize;
            // this.viewPortPixel.h = _viewPortsScale[faceIndex].w * this.shadowSize;
            // const cameraTransform = camera.gameObject.transform;
            // cameraTransform.setPosition(position); // TODO support copy matrix.
            // cameraTransform.lookAt(helpVector3A, _ups[faceIndex]);
            // // const temp = cameraTransform.getWorldMatrix().clone().release();
            // // temp.rawData[12] = -temp.rawData[12];//Left-hand
            // const context = camera.context;
            // context.matrix_v.copy(cameraTransform.worldToLocalMatrix);
            // context.matrix_vp.multiply(context.matrix_p, context.matrix_v);
            // context.updateLightDepth(this);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], PointLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], PointLight.prototype, "distance", void 0);
        return PointLight;
    }(egret3d.BaseLight));
    egret3d.PointLight = PointLight;
    __reflect(PointLight.prototype, "egret3d.PointLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 聚光组件。
     */
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        function SpotLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.decay = 2.0;
            /**
             *
             */
            _this.distance = 0.0;
            /**
             *
             */
            _this.angle = Math.PI / 3.0;
            /**
             *
             */
            _this.penumbra = 1.0;
            return _this;
        }
        SpotLight.prototype.updateShadow = function (camera) {
            // if (!this.renderTarget) {
            //     this.renderTarget = new GlRenderTarget("SpotLight", this.shadowSize, this.shadowSize); //
            // }
            // camera.fov = this.angle;
            // camera.opvalue = 1.0;
            // camera.renderTarget = this.renderTarget;
            // camera.gameObject.transform.localToWorldMatrix.copy(this.gameObject.transform.localToWorldMatrix); //
            // this.viewPortPixel.set(0, 0, this.shadowSize, this.shadowSize);
            // this._updateShadowMatrix(camera,);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], SpotLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], SpotLight.prototype, "distance", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */)
        ], SpotLight.prototype, "angle", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01 })
        ], SpotLight.prototype, "penumbra", void 0);
        return SpotLight;
    }(egret3d.BaseLight));
    egret3d.SpotLight = SpotLight;
    __reflect(SpotLight.prototype, "egret3d.SpotLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 绘制信息。
     */
    var DrawCall = (function (_super) {
        __extends(DrawCall, _super);
        function DrawCall() {
            var _this = _super.call(this) || this;
            /**
             * 绘制次数。
             * - 用于调试模式下检测重复绘制的情况。
             */
            _this.drawCount = -1;
            /**
             * 此次绘制的渲染组件。
             */
            _this.renderer = null;
            /**
             * 此次绘制的世界矩阵。
             */
            _this.matrix = null;
            /**
             * 此次绘制的子网格索引。
             */
            _this.subMeshIndex = -1;
            /**
             * 此次绘制的网格资源。
             */
            _this.mesh = null;
            /**
             * 此次绘制的材质资源。
             */
            _this.material = null;
            /**
             *
             */
            _this.zdist = -1;
            return _this;
        }
        /**
         * 创建一个绘制信息。
         * - 只有在扩展渲染系统时才需要手动创建绘制信息。
         */
        DrawCall.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new DrawCall();
        };
        DrawCall.prototype.onClear = function () {
            this.drawCount = -1;
            this.renderer = null;
            this.matrix = null;
            this.subMeshIndex = -1;
            this.mesh = null;
            this.material = null;
            this.zdist = -1;
        };
        DrawCall._instances = [];
        return DrawCall;
    }(paper.BaseRelease));
    egret3d.DrawCall = DrawCall;
    __reflect(DrawCall.prototype, "egret3d.DrawCall");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 雾的模式。
     */
    var FogMode;
    (function (FogMode) {
        FogMode[FogMode["None"] = 0] = "None";
        FogMode[FogMode["Fog"] = 1] = "Fog";
        FogMode[FogMode["FogEXP2"] = 2] = "FogEXP2";
    })(FogMode = egret3d.FogMode || (egret3d.FogMode = {}));
    /**
     * 雾。
     */
    var Fog = (function () {
        /**
         * 禁止实例化。
         */
        function Fog() {
            /**
             * 雾的模式。
             */
            this.mode = 0 /* None */;
            /**
             * 雾的强度。
             */
            this.density = 0.01;
            /**
             * 雾的近平面。
             * - 最小值 0.01。
             */
            this.near = 0.01;
            /**
             * 雾的远平面。
             * - 最小值 0.02。
             */
            this.far = 100.0;
            /**
             * 雾的颜色。
             */
            this.color = egret3d.Color.create(0.5, 0.5, 0.5, 1);
        }
        /**
         * @internal
         */
        Fog.create = function () {
            return new Fog();
        };
        Fog.prototype.serialize = function () {
            return [this.mode, this.density, this.near, this.far]
                .concat(this.color.serialize());
        };
        Fog.prototype.deserialize = function (data) {
            this.mode = data[0];
            this.density = data[1];
            this.near = data[2];
            this.far = data[3];
            this.color.fromArray(data, 4);
            return this;
        };
        __decorate([
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(egret3d.FogMode) }) // TODO
        ], Fog.prototype, "mode", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Fog.prototype, "density", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, step: 1.0 })
        ], Fog.prototype, "near", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.02, step: 1.0 })
        ], Fog.prototype, "far", void 0);
        __decorate([
            paper.editor.property("COLOR" /* COLOR */)
        ], Fog.prototype, "color", void 0);
        return Fog;
    }());
    egret3d.Fog = Fog;
    __reflect(Fog.prototype, "egret3d.Fog", ["paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    1 /* Default */;
    /**
     * 实体。
     */
    var GameObject = (function (_super) {
        __extends(GameObject, _super);
        /**
         * 请使用 `paper.GameObject.create()` 创建实例。
         * @see paper.GameObject.create()
         * @deprecated
         */
        function GameObject(name, tag, scene) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (tag === void 0) { tag = "Untagged" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var _this = _super.call(this) || this;
            /**
             * 是否是静态模式。
             */
            _this.isStatic = false;
            /**
             *
             */
            _this.hideFlags = 0 /* None */;
            /**
             * 层级。
             * - 用于各种层遮罩。
             */
            _this.layer = 1 /* Default */;
            /**
             * 名称。
             */
            _this.name = "";
            /**
             * 标签。
             */
            _this.tag = "";
            /**
             * 变换组件。
             * @readonly
             */
            _this.transform = null;
            /**
             * 渲染组件。
             * @readonly
             */
            _this.renderer = null;
            /**
             * 额外数据，仅保存在编辑器环境，项目发布该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            _this._activeSelf = true;
            /**
             * @internal
             */
            _this._activeInHierarchy = true;
            /**
             * @internal
             */
            _this._activeDirty = true;
            _this._components = [];
            /**
             * @internal
             */
            _this._beforeRenderBehaviors = [];
            _this._cachedComponents = [];
            _this._scene = null;
            _this.name = name;
            _this.tag = tag;
            //
            _this._addToScene(scene || paper.Application.sceneManager.activeScene);
            //
            _this.addComponent(egret3d.Transform);
            return _this;
        }
        /**
         * 创建 GameObject，并添加到当前场景中。
         */
        GameObject.create = function (name, tag, scene) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (tag === void 0) { tag = "Untagged" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var gameObect;
            // if (this._instances.length > 0) {
            //     gameObect = this._instances.pop()!;
            //     gameObect.name = name;
            //     gameObect.tag = tag;
            //     gameObect._addToScene(scene);
            //     gameObect.addComponent(egret3d.Transform);
            // }
            // else {
            gameObect = new GameObject(name, tag, scene);
            // gameObect = new GameObject();
            // }
            // gameObect.name = name;
            // gameObect.tag = tag;
            // gameObect._addToScene(Application.sceneManager.activeScene);
            // gameObect.addComponent(egret3d.Transform);
            return gameObect;
        };
        Object.defineProperty(GameObject, "globalGameObject", {
            /**
             * 全局实体。
             * - 全局实体不可被销毁。
             * - 静态组件都会添加到全局实体上。
             */
            get: function () {
                if (!this._globalGameObject) {
                    this._globalGameObject = GameObject.create("Global" /* Global */, "Global" /* Global */, paper.Application.sceneManager.globalScene);
                    this._globalGameObject.dontDestroy = true;
                }
                return this._globalGameObject;
            },
            enumerable: true,
            configurable: true
        });
        GameObject.prototype._destroy = function () {
            this._scene.removeGameObject(this);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child.gameObject._destroy();
            }
            for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                var component = _c[_b];
                if (!component) {
                    continue;
                }
                this._removeComponent(component, null);
            }
            // 销毁的第一时间就将组件和场景清除，用场景的有无来判断实体是否已经销毁。
            this._components.length = 0;
            this._scene = null;
            paper.disposeCollecter.gameObjects.push(this);
        };
        GameObject.prototype._addToScene = function (value) {
            if (this._scene) {
                this._scene.removeGameObject(this);
            }
            this._scene = value;
            this._scene.addGameObject(this);
        };
        GameObject.prototype._canRemoveComponent = function (value) {
            if (value === this.transform) {
                console.warn("Cannot remove the transform component from a game object.");
                return false;
            }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    component = component.components[0]; // 只检查第一个。
                }
                var requireComponents = component.constructor.requireComponents;
                if (requireComponents && requireComponents.indexOf(value.constructor) >= 0) {
                    console.warn("Cannot remove the " + egret.getQualifiedClassName(value) + " component from the game object (" + this.path + "), because it is required from the " + egret.getQualifiedClassName(component) + " component.");
                    return false;
                }
            }
            return true;
        };
        GameObject.prototype._removeComponent = function (value, groupComponent) {
            paper.disposeCollecter.components.push(value);
            value.enabled = false;
            if (value.constructor.__isBehaviour) {
                if (value._isAwaked) {
                    value.onDestroy && value.onDestroy();
                }
                if (value.onBeforeRender) {
                    this._beforeRenderBehaviors.splice(this._beforeRenderBehaviors.indexOf(value), 1);
                }
            }
            value.gameObject = null;
            if (value === this.renderer) {
                this.renderer = null;
            }
            if (groupComponent) {
                groupComponent.removeComponent(value);
                if (groupComponent.components.length === 0) {
                    this._removeComponent(groupComponent, null);
                }
            }
            else if (value.constructor === paper.GroupComponent) {
                groupComponent = value;
                delete this._components[groupComponent.componentIndex];
                for (var _i = 0, _a = groupComponent.components; _i < _a.length; _i++) {
                    var componentInGroup = _a[_i];
                    this._removeComponent(componentInGroup, groupComponent);
                }
            }
            else {
                delete this._components[value.constructor.__index];
            }
            if (this.transform && value.hasOwnProperty("onTransformChange")) {
                this.transform.unregisterObserver(value);
            }
        };
        GameObject.prototype._getComponent = function (componentClass) {
            var componentIndex = componentClass.__index;
            return componentIndex < 0 ? null : this._components[componentIndex];
        };
        /**
         * @internal
         */
        GameObject.prototype._activeInHierarchyDirty = function (prevActive) {
            this._activeDirty = true;
            var currentActive = this.activeInHierarchy;
            if (currentActive !== prevActive) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            if (componentInGroup.constructor.__isBehaviour &&
                                !componentInGroup._isAwaked &&
                                (paper.Application.playerMode !== 2 /* Editor */ || componentInGroup.constructor.executeInEditMode)) {
                                componentInGroup.onAwake && componentInGroup.onAwake();
                                componentInGroup._isAwaked = true;
                            }
                            if (componentInGroup.enabled) {
                                componentInGroup._dispatchEnabledEvent(currentActive);
                            }
                        }
                    }
                    else {
                        if (component.constructor.__isBehaviour &&
                            !component._isAwaked &&
                            (paper.Application.playerMode !== 2 /* Editor */ || component.constructor.executeInEditMode)) {
                            component.onAwake && component.onAwake();
                            component._isAwaked = true;
                        }
                        if (component.enabled) {
                            component._dispatchEnabledEvent(currentActive);
                        }
                    }
                }
            }
            for (var _d = 0, _e = this.transform.children; _d < _e.length; _d++) {
                var child = _e[_d];
                child.gameObject._activeInHierarchyDirty(prevActive);
            }
        };
        /**
         * 实体被销毁后，内部卸载。
         * @internal
         */
        GameObject.prototype.uninitialize = function () {
            this.isStatic = false;
            this.hideFlags = 0 /* None */;
            this.layer = 1 /* Default */;
            this.name = "";
            this.tag = "";
            this.transform = null;
            this.renderer = null;
            if (this.extras) {
                this.extras = {};
            }
            this._activeSelf = true;
            this._activeInHierarchy = true;
            this._activeDirty = true;
            this._cachedComponents.length = 0;
            this._scene = null;
        };
        /**
         * 销毁实体。
         */
        GameObject.prototype.destroy = function () {
            if (this.isDestroyed) {
                console.warn("The game object has been destroyed.");
                return false;
            }
            if (this === GameObject._globalGameObject) {
                console.warn("Cannot destroy global game object.");
                return false;
            }
            var parent = this.transform.parent;
            if (parent) {
                parent._children.splice(parent._children.indexOf(this.transform), 1);
            }
            this._destroy();
            return true;
        };
        /**
         * 添加一个指定组件实例。
         * @param componentClass 组件类。
         * @param config BaseComponent 组件 `initialize(config?: any)` 方法或 Behaviour 组件 `onAwake(config?: any)` 方法的可选参数。
         */
        GameObject.prototype.addComponent = function (componentClass, config) {
            if (true && !componentClass) {
                throw new Error();
            }
            paper.registerClass(componentClass);
            // SingletonComponent.
            if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                return GameObject.globalGameObject.getOrAddComponent(componentClass, config);
            }
            var componentIndex = componentClass.__index;
            var existedComponent = this._components[componentIndex];
            // disallowMultipleComponents.
            if (!componentClass.allowMultiple && existedComponent) {
                console.warn("Cannot add the " + egret.getQualifiedClassName(componentClass) + " component to the game object (" + this.path + ") again.");
                return existedComponent;
            }
            // requireComponents.
            if (componentClass.requireComponents) {
                for (var _i = 0, _a = componentClass.requireComponents; _i < _a.length; _i++) {
                    var requireComponentClass = _a[_i];
                    this.getOrAddComponent(requireComponentClass);
                }
            }
            // Linked reference.
            var component = paper.BaseComponent.create(componentClass, this);
            if (componentClass === egret3d.Transform) {
                this.transform = component;
            }
            else if (component instanceof paper.BaseRenderer) {
                this.renderer = component;
            }
            else if (component.constructor.__isBehaviour) {
                if (component.onBeforeRender) {
                    this._beforeRenderBehaviors.push(component);
                }
            }
            // Add component.
            if (existedComponent) {
                if (existedComponent.constructor === paper.GroupComponent) {
                    existedComponent.addComponent(component);
                }
                else {
                    paper.registerClass(paper.GroupComponent);
                    var groupComponent = paper.BaseComponent.create(paper.GroupComponent, this);
                    groupComponent.initialize();
                    groupComponent.componentIndex = componentIndex;
                    groupComponent.componentClass = componentClass;
                    groupComponent.addComponent(existedComponent);
                    groupComponent.addComponent(component);
                    this._components[componentIndex] = groupComponent;
                }
            }
            else {
                this._components[componentIndex] = component;
            }
            // Component initialize.
            if (config) {
                component.initialize(config);
            }
            else {
                component.initialize();
            }
            if (this.activeInHierarchy) {
                if (component.constructor.__isBehaviour &&
                    (paper.Application.playerMode !== 2 /* Editor */ || component.constructor.executeInEditMode)) {
                    component.onAwake && component.onAwake(config);
                    component._isAwaked = true;
                }
                if (component.enabled) {
                    component._dispatchEnabledEvent(true);
                }
            }
            return component;
        };
        /**
         * 移除一个指定组件实例。
         * @param componentInstanceOrClass 组件类或组件实例。
         * @param isExtends 是否尝试移除全部派生自此组件的实例。
         */
        GameObject.prototype.removeComponent = function (componentInstanceOrClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (true && !componentInstanceOrClass) {
                throw new Error();
            }
            if (componentInstanceOrClass instanceof paper.BaseComponent) {
                var componentClass = componentInstanceOrClass.constructor;
                if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                    GameObject.globalGameObject.removeComponent(componentInstanceOrClass, isExtends);
                    return;
                }
                if (!this._canRemoveComponent(componentInstanceOrClass)) {
                    return;
                }
                this._removeComponent(componentInstanceOrClass, null);
            }
            else {
                if (componentInstanceOrClass.__isSingleton && this !== GameObject._globalGameObject) {
                    return GameObject.globalGameObject.removeComponent(componentInstanceOrClass, isExtends);
                }
                if (isExtends) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (!component) {
                            continue;
                        }
                        var groupComponent = null;
                        if (component.constructor === paper.GroupComponent) {
                            groupComponent = component;
                            component = groupComponent.components[0];
                        }
                        if (groupComponent) {
                            if (!(groupComponent.components[0] instanceof componentInstanceOrClass) ||
                                (groupComponent.components.length === 1 && !this._canRemoveComponent(groupComponent.components[0]))) {
                                continue;
                            }
                        }
                        else if (!(component instanceof componentInstanceOrClass) ||
                            !this._canRemoveComponent(component)) {
                            continue;
                        }
                        this._removeComponent(component, groupComponent);
                    }
                }
                else {
                    var component = this._getComponent(componentInstanceOrClass);
                    if (!component) {
                        return;
                    }
                    var groupComponent = null;
                    if (component.constructor === paper.GroupComponent) {
                        groupComponent = component;
                        component = groupComponent.components[0];
                    }
                    if (groupComponent) {
                        if (groupComponent.components.length === 1 && !this._canRemoveComponent(groupComponent.components[0])) {
                            return;
                        }
                    }
                    else if (!this._canRemoveComponent(component)) {
                        return;
                    }
                    this._removeComponent(component, groupComponent);
                }
            }
        };
        /**
         * 移除全部指定组件的实例。
         * - 通常只有该组件类允许同一个实体添加多个组件实例时才需要此操作。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试移除全部派生自此组件的实例。
         */
        GameObject.prototype.removeAllComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentClass) {
                if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                    GameObject.globalGameObject.removeAllComponents(componentClass, isExtends);
                    return;
                }
                if (isExtends) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (!component) {
                            continue;
                        }
                        if (component.constructor === paper.GroupComponent) {
                            var groupComponent = component;
                            if (!(groupComponent.components[0] instanceof componentClass) ||
                                !this._canRemoveComponent(groupComponent.components[0])) {
                                continue;
                            }
                        }
                        else if (!this._canRemoveComponent(component)) {
                            continue;
                        }
                        this._removeComponent(component, null);
                    }
                }
                else {
                    var component = this._getComponent(componentClass);
                    if (!component) {
                        return;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        var groupComponent = component;
                        if (!this._canRemoveComponent(groupComponent.components[0])) {
                            return;
                        }
                    }
                    else if (!this._canRemoveComponent(component)) {
                        return;
                    }
                    this._removeComponent(component, null);
                }
            }
            else {
                for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                    var component = _c[_b];
                    if (!component || component.constructor === egret3d.Transform) {
                        continue;
                    }
                    this._removeComponent(component, null);
                }
            }
        };
        /**
         * 获取一个指定组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                return GameObject.globalGameObject.getComponent(componentClass, isExtends);
            }
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component_1 = _a[_i];
                    if (!component_1) {
                        continue;
                    }
                    if (component_1.constructor === paper.GroupComponent) {
                        var groupComponent = component_1;
                        if (groupComponent.components[0] instanceof componentClass) {
                            return groupComponent.components[0];
                        }
                    }
                    else if (component_1 instanceof componentClass) {
                        return component_1;
                    }
                }
                return null;
            }
            var componentClassIndex = componentClass.__index;
            if (componentClassIndex < 0) {
                return null;
            }
            var component = this._components[componentClassIndex];
            if (!component) {
                return null;
            }
            if (component.constructor === paper.GroupComponent) {
                return component.components[0];
            }
            return component;
        };
        /**
         * 获取全部指定组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                return GameObject.globalGameObject.getComponents(componentClass, isExtends);
            }
            var components = [];
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            else {
                var component = this._getComponent(componentClass);
                if (component) {
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _d = 0, _e = component.components; _d < _e.length; _d++) {
                            var componentInGroup = _e[_d];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            return components;
        };
        /**
         * 获取一个自己或父级中指定的组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentInParent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var result = null;
            var parent = this.transform.parent;
            while (!result && parent) {
                result = parent.gameObject.getComponent(componentClass, isExtends); // 
                parent = parent.parent;
            }
            return result;
        };
        /**
         * 获取一个自己或子（孙）级中指定的组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentInChildren = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var component = this.getComponent(componentClass, isExtends);
            if (!component) {
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    component = child.gameObject.getComponentInChildren(componentClass, isExtends);
                    if (component) {
                        break;
                    }
                }
            }
            return component;
        };
        /**
         * 获取全部自己和子（孙）级中指定的组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentsInChildren = function (componentClass, isExtends, components) {
            if (isExtends === void 0) { isExtends = false; }
            if (components === void 0) { components = null; }
            components = components || [];
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    var groupComponent = component;
                    if (isExtends ? groupComponent.components[0] instanceof componentClass : groupComponent.componentClass === componentClass) {
                        for (var _b = 0, _c = groupComponent.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                }
                else if (isExtends ? component instanceof componentClass : component.constructor === componentClass) {
                    components.push(component);
                }
            }
            for (var _d = 0, _e = this.transform.children; _d < _e.length; _d++) {
                var child = _e[_d];
                child.gameObject.getComponentsInChildren(componentClass, isExtends, components);
            }
            return components;
        };
        /**
         * 从该实体已注册的全部组件中获取一个指定组件实例，如果未添加该组件，则添加该组件。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         * @param config BaseComponent 组件 `initialize(config?: any)` 方法或 Behaviour 组件 `onAwake(config?: any)` 方法的可选参数。
         */
        GameObject.prototype.getOrAddComponent = function (componentClass, isExtends, config) {
            if (isExtends === void 0) { isExtends = false; }
            return this.getComponent(componentClass, isExtends) || this.addComponent(componentClass, config);
        };
        /**
         * 向该实体已激活的全部 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (component && component.constructor.__isBehaviour && component.isActiveAndEnabled) {
                    if (methodName in component) {
                        component[methodName](parameter);
                    }
                    else if (true && requireReceiver) {
                        console.warn(this.name, egret.getQualifiedClassName(component), methodName); // TODO
                    }
                }
            }
        };
        /**
         * 向该实体和其父级的 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessageUpwards = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            //
            var parent = this.transform.parent;
            if (parent && parent.gameObject.activeInHierarchy) {
                parent.gameObject.sendMessage(methodName, parameter, requireReceiver);
            }
        };
        /**
         * 向该实体和的其子（孙）级的 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.broadcastMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.gameObject.activeInHierarchy) {
                    child.gameObject.broadcastMessage(methodName, parameter, requireReceiver);
                }
            }
        };
        Object.defineProperty(GameObject.prototype, "isDestroyed", {
            /**
             * 该实体是否已经被销毁。
             */
            get: function () {
                return !this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "dontDestroy", {
            /**
             * 该实体是否可以被销毁。
             * - 当此值为 `true` 时，将会被添加到全局场景，反之将被添加到激活场景。
             * - 设置此属性时，可能改变该实体的父级。
             */
            get: function () {
                return this._scene === paper.Application.sceneManager.globalScene;
            },
            set: function (value) {
                if (this.dontDestroy === value) {
                    return;
                }
                if (this.transform.parent && this.transform.parent.gameObject.dontDestroy !== value) {
                    this.transform.parent = null;
                }
                if (value) {
                    this._addToScene(paper.Application.sceneManager.globalScene);
                }
                else {
                    if (this === GameObject._globalGameObject) {
                        console.warn("Cannot change the `dontDestroy` value of the global game object.", this.name, this.uuid);
                        return;
                    }
                    this._addToScene(paper.Application.sceneManager.activeScene);
                }
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child.gameObject.dontDestroy = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeSelf", {
            /**
             * 该实体自身的激活状态。
             */
            get: function () {
                return this._activeSelf;
            },
            set: function (value) {
                if (this._activeSelf === value || this === GameObject._globalGameObject) {
                    return;
                }
                var parent = this.transform.parent;
                if (!parent || parent.gameObject.activeInHierarchy) {
                    var prevActive = this._activeSelf;
                    this._activeSelf = value;
                    this._activeInHierarchyDirty(prevActive);
                }
                else {
                    this._activeSelf = value; //TODO
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeInHierarchy", {
            /**
             * 该实体在场景中的激活状态。
             */
            get: function () {
                if (this._activeDirty) {
                    var parent_1 = this.transform.parent;
                    if (!parent_1 || parent_1.gameObject.activeInHierarchy) {
                        this._activeInHierarchy = this._activeSelf;
                    }
                    else {
                        this._activeInHierarchy = false;
                    }
                    this._activeDirty = false;
                }
                return this._activeInHierarchy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "path", {
            /**
             * 该实体的路径。
             */
            get: function () {
                var path = this.name;
                if (this.transform) {
                    var parent_2 = this.transform.parent;
                    while (parent_2) {
                        path = parent_2.gameObject.name + "/" + path;
                        parent_2 = parent_2.parent;
                    }
                    return this._scene.name + "/" + path;
                }
                return path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "components", {
            /**
             * 该实体已添加的全部组件。
             */
            get: function () {
                this._cachedComponents.length = 0;
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            this._cachedComponents.push(componentInGroup);
                        }
                    }
                    else {
                        this._cachedComponents.push(component);
                    }
                }
                return this._cachedComponents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "parent", {
            /**
             * 该实体的父级实体。
             */
            get: function () {
                return this.transform.parent ? this.transform.parent.gameObject : null;
            },
            set: function (gameObject) {
                this.transform.parent = gameObject ? gameObject.transform : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "scene", {
            /**
             * 该实体所属的场景。
             */
            get: function () {
                return this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "globalGameObject", {
            /**
             * 全局实体。
             * - 全局实体不可被销毁。
             * - 静态组件都会添加到全局实体上。
             */
            get: function () {
                return GameObject.globalGameObject;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         * @see paper.Scene#find()
         */
        GameObject.find = function (name, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).find(name);
        };
        /**
         * @deprecated
         * @see paper.Scene#findWithTag()
         */
        GameObject.findWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findWithTag(tag);
        };
        /**
         * @deprecated
         * @see paper.Scene#findGameObjectsWithTag()
         */
        GameObject.findGameObjectsWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findGameObjectsWithTag(tag);
        };
        /**
         * @deprecated
         */
        GameObject.raycast = function (ray, gameObjects, maxDistance, cullingMask, raycastMesh) {
            if (maxDistance === void 0) { maxDistance = 0.0; }
            if (cullingMask === void 0) { cullingMask = 4294967295 /* Everything */; }
            if (raycastMesh === void 0) { raycastMesh = false; }
            return egret3d.raycastAll(ray, gameObjects, maxDistance, cullingMask, raycastMesh);
        };
        /**
         * @internal
         */
        GameObject._instances = [];
        GameObject._globalGameObject = null;
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], GameObject.prototype, "isStatic", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "hideFlags", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.Layer) }) // TODO
        ], GameObject.prototype, "layer", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("TEXT" /* TEXT */)
        ], GameObject.prototype, "name", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.DefaultTags) }) // TODO
        ], GameObject.prototype, "tag", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "_activeSelf", void 0);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], GameObject.prototype, "activeSelf", null);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], GameObject.prototype, "components", null);
        return GameObject;
    }(paper.BaseObject));
    paper.GameObject = GameObject;
    __reflect(GameObject.prototype, "paper.GameObject");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格筛选组件。
     * - 为网格渲染组件提供网格资源。
     */
    var MeshFilter = (function (_super) {
        __extends(MeshFilter, _super);
        function MeshFilter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._mesh = null;
            return _this;
        }
        MeshFilter.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                this._mesh.release();
            }
            this._mesh = null;
        };
        Object.defineProperty(MeshFilter.prototype, "mesh", {
            /**
             * 该组件的网格资源。
             */
            get: function () {
                return this._mesh;
            },
            set: function (value) {
                if (this._mesh === value) {
                    return;
                }
                if (this._mesh) {
                    this._mesh.release();
                }
                this._mesh = value;
                if (this._mesh) {
                    this._mesh.retain();
                }
                MeshFilter.onMeshChanged.dispatch(this);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当网格筛选组件的网格资源改变时派发事件。
         */
        MeshFilter.onMeshChanged = new signals.Signal();
        __decorate([
            paper.editor.property("MESH" /* MESH */),
            paper.serializedField("_mesh")
        ], MeshFilter.prototype, "mesh", null);
        return MeshFilter;
    }(paper.BaseComponent));
    egret3d.MeshFilter = MeshFilter;
    __reflect(MeshFilter.prototype, "egret3d.MeshFilter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Spherical = (function (_super) {
        __extends(Spherical, _super);
        /**
         * 请使用 `egret3d.Spherical.create()` 创建实例。
         * @see egret3d.Spherical.create()
         */
        function Spherical() {
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.radius = 1.0;
            /**
             *
             */
            _this.phi = 0.0;
            /**
             *
             */
            _this.theta = 0.0;
            return _this;
        }
        /**
         *
         */
        Spherical.create = function (radius, phi, theta) {
            if (radius === void 0) { radius = 1.0; }
            if (phi === void 0) { phi = 0.0; }
            if (theta === void 0) { theta = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(radius, phi, theta);
                instance._released = false;
                return instance;
            }
            return new Spherical().set(radius, phi, theta);
        };
        Spherical.prototype.serialize = function () {
            return [this.radius, this.phi, this.theta];
        };
        Spherical.prototype.deserialize = function (value) {
            this.radius = value[0];
            this.phi = value[1];
            this.theta = value[2];
            return this;
        };
        Spherical.prototype.clone = function () {
            return Spherical.create(this.radius, this.phi, this.theta);
        };
        Spherical.prototype.copy = function (value) {
            return this.set(value.radius, value.phi, value.theta);
        };
        Spherical.prototype.set = function (radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        };
        Spherical.prototype.fromCartesianCoords = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                p3 = p1.z;
                p2 = p1.y;
                p1 = p1.x;
            }
            this.radius = Math.sqrt(p1 * p1 + p2 * p2 + p3 * p3);
            if (this.radius === 0.0) {
                this.theta = 0.0;
                this.phi = 0.0;
            }
            else {
                this.theta = Math.atan2(p1, p3); // TODO
                this.phi = Math.acos(egret3d.math.clamp(p2 / this.radius, -1.0, 1.0));
            }
            return this;
        };
        Spherical.prototype.makeSafe = function () {
            var EPS = 0.000001;
            this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
            return this;
        };
        Spherical._instances = [];
        return Spherical;
    }(paper.BaseRelease));
    egret3d.Spherical = Spherical;
    __reflect(Spherical.prototype, "egret3d.Spherical", ["paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格渲染组件系统。
     * - 为网格渲染组件生成绘制信息。
     */
    var MeshRendererSystem = (function (_super) {
        __extends(MeshRendererSystem, _super);
        function MeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                {
                    componentClass: egret3d.MeshFilter,
                    listeners: [{
                            type: egret3d.MeshFilter.onMeshChanged, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject, true);
                                if (component.gameObject.renderer) {
                                    component.gameObject.renderer._localBoundingBoxDirty = true;
                                }
                            }
                        }]
                },
                {
                    componentClass: egret3d.MeshRenderer,
                    listeners: [{
                            type: egret3d.MeshRenderer.onMaterialsChanged, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject, true);
                            }
                        }]
                },
            ];
            _this._drawCallCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCallCollecter);
            _this._materialFilter = [];
            return _this;
        }
        MeshRendererSystem.prototype._updateDrawCalls = function (gameObject, checkState) {
            if (checkState && (!this.enabled || !this.groups[0].hasGameObject(gameObject))) {
                return;
            }
            var drawCallCollecter = this._drawCallCollecter;
            var filter = gameObject.getComponent(egret3d.MeshFilter);
            var renderer = gameObject.renderer;
            var mesh = filter.mesh;
            var materials = renderer.materials;
            var materialCount = materials.length;
            drawCallCollecter.removeDrawCalls(renderer); // Clear drawCalls.
            if (!mesh || materialCount === 0) {
                return;
            }
            var primitives = mesh.glTFMesh.primitives;
            var subMeshCount = primitives.length;
            if (true && subMeshCount === 0) {
                throw new Error();
            }
            var materialFilter = this._materialFilter;
            var matrix = gameObject.transform.localToWorldMatrix;
            materialFilter.length = materialCount;
            drawCallCollecter.renderers.push(renderer);
            for (var i = 0; i < subMeshCount; ++i) {
                var materialIndex = primitives[i].material;
                var material = null;
                if (materialIndex === undefined) {
                    material = egret3d.DefaultMaterials.MESH_BASIC;
                }
                else if (materialIndex < materialCount) {
                    material = materials[materialIndex];
                    materialFilter[materialIndex] = true;
                }
                if (material) {
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.renderer = renderer;
                    drawCall.matrix = matrix;
                    drawCall.subMeshIndex = i;
                    drawCall.mesh = mesh;
                    drawCall.material = material;
                    drawCallCollecter.addDrawCall(drawCall);
                }
            }
            for (var i = 0; i < materialCount; ++i) {
                if (materialFilter[i]) {
                    continue;
                }
                var material = materials[i];
                for (var j = 0; j < subMeshCount; ++j) {
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.renderer = renderer;
                    drawCall.matrix = matrix;
                    drawCall.subMeshIndex = j;
                    drawCall.mesh = mesh;
                    drawCall.material = material;
                    drawCallCollecter.addDrawCall(drawCall);
                }
            }
            materialFilter.length = 0;
        };
        MeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this.groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._updateDrawCalls(gameObject, false);
            }
        };
        MeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this.groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
            }
        };
        MeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._updateDrawCalls(gameObject, false);
        };
        MeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
        };
        return MeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.MeshRendererSystem = MeshRendererSystem;
    __reflect(MeshRendererSystem.prototype, "egret3d.MeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = egret3d.Matrix4.create();
    /**
     * 蒙皮网格渲染组件。
     */
    var SkinnedMeshRenderer = (function (_super) {
        __extends(SkinnedMeshRenderer, _super);
        function SkinnedMeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 强制使用 cpu 蒙皮。
             * - 骨骼数超过硬件支持的最大骨骼数量，或顶点权重大于 4 个，需要使用 CPU 蒙皮。
             * - CPU 蒙皮性能较低，仅是兼容方案，应合理的控制骨架的最大骨骼数量。
             */
            _this.forceCPUSkin = false;
            /**
             *
             */
            _this.boneMatrices = null;
            /**
             *
             */
            _this.source = null;
            _this._skinnedDirty = true;
            _this._bones = [];
            _this._rootBone = null;
            /**
             * @internal
             */
            _this._retargetBoneNames = null;
            _this._mesh = null;
            _this._skinnedVertices = null;
            return _this;
        }
        SkinnedMeshRenderer.prototype._skinning = function (vertexOffset, vertexCount) {
            if (this._skinnedDirty) {
                var mesh = this._mesh;
                var boneMatrices = this.boneMatrices;
                var p0 = _helpVector3A;
                var p1 = _helpVector3B;
                var p2 = _helpVector3C;
                var vertices = mesh.getVertices();
                var indices = mesh.getIndices();
                var joints = mesh.getAttributes("JOINTS_0" /* JOINTS_0 */);
                var weights = mesh.getAttributes("WEIGHTS_0" /* WEIGHTS_0 */);
                if (!this._skinnedVertices) {
                    this._skinnedVertices = new Float32Array(vertices.length);
                }
                if (vertexCount === 0) {
                    vertexCount = indices.length;
                }
                else {
                    vertexCount += vertexOffset;
                }
                for (var i = vertexOffset; i < vertexCount; ++i) {
                    var index = indices[i];
                    var vertexIndex = index * 3;
                    var jointIndex = index * 4;
                    p0.fromArray(vertices, vertexIndex);
                    p1.clear();
                    for (var i_1 = 0; i_1 < 4; ++i_1) {
                        var weight = weights[jointIndex + i_1];
                        if (weight <= 0.01) {
                            continue;
                        }
                        p1.add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + i_1] * 16), p0).multiplyScalar(weight));
                    }
                    p1.toArray(this._skinnedVertices, vertexIndex);
                }
                this._skinnedDirty = false;
            }
            return this._skinnedVertices;
        };
        /**
         * @internal
         */
        SkinnedMeshRenderer.prototype._update = function () {
            var boneMatrices = this.boneMatrices;
            if (boneMatrices) {
                // TODO cache 剔除，脏标记。
                // TODO bind to GPU
                var mesh = this._mesh;
                var bones = this._bones;
                var inverseBindMatrices = mesh.inverseBindMatrices;
                for (var i = 0, l = bones.length; i < l; ++i) {
                    var offset = i * 16;
                    var bone = bones[i];
                    var matrix = bone ? bone.localToWorldMatrix : egret3d.Matrix4.IDENTITY;
                    _helpMatrix.fromArray(inverseBindMatrices, offset).premultiply(matrix).toArray(boneMatrices, offset);
                }
                if (this.forceCPUSkin) {
                    // this._skinning(0, 0); TODO
                }
                this._skinnedDirty = true;
            }
        };
        SkinnedMeshRenderer.prototype.initialize = function (reset) {
            _super.prototype.initialize.call(this);
            if (!reset) {
                return;
            }
            // TODO cache 剔除，脏标记。
            this._bones.length = 0;
            this._rootBone = null;
            this.boneMatrices = null;
            if (this._mesh) {
                var config = this._mesh.config;
                var skin = config.skins[0];
                var children = this.gameObject.transform.parent.getAllChildren({});
                if (skin.skeleton !== undefined) {
                    var rootNode = config.nodes[skin.skeleton];
                    if (rootNode.name in children) {
                        var transforms = children[rootNode.name];
                        this._rootBone = Array.isArray(transforms) ? transforms[0] : transforms;
                    }
                }
                for (var _i = 0, _a = skin.joints; _i < _a.length; _i++) {
                    var joint = _a[_i];
                    var node = config.nodes[joint];
                    if (node.name in children) {
                        var transforms = children[node.name];
                        this._bones.push(Array.isArray(transforms) ? transforms[0] : transforms);
                    }
                    else {
                        this._bones.push(null);
                    }
                }
                this.boneMatrices = new Float32Array(this._bones.length * 16);
                if (this._bones.length > egret3d.renderState.maxBoneCount) {
                    this.forceCPUSkin = true;
                    console.warn("The bone count of this mesh has exceeded the maxBoneCount and will use the forced CPU skin.", this._mesh.name);
                }
                // this._update(); TODO
            }
        };
        SkinnedMeshRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                this._mesh.release();
            }
            this.boneMatrices = null;
            this._bones.length = 0;
            this._rootBone = null;
            this._retargetBoneNames = null;
            this._mesh = null;
            this._skinnedVertices = null;
        };
        SkinnedMeshRenderer.prototype.recalculateLocalBox = function () {
            // TODO 蒙皮网格的 aabb 需要能自定义，或者强制更新。
            var mesh = this._mesh;
            if (mesh) {
                this._localBoundingBox.clear();
                var vertices = mesh.getVertices(); // T pose mesh aabb.
                var position = egret3d.helpVector3A;
                for (var i = 0, l = vertices.length; i < l; i += 3) {
                    position.set(vertices[i], vertices[i + 1], vertices[i + 2]);
                    this._localBoundingBox.add(position);
                }
            }
        };
        /**
         * 实时获取网格资源的指定三角形顶点位置。
         * - 采用 CPU 蒙皮指定顶点。
         */
        SkinnedMeshRenderer.prototype.getTriangle = function (triangleIndex, out) {
            if (!out) {
                out = egret3d.Triangle.create();
            }
            var mesh = this._mesh;
            var boneMatrices = this.boneMatrices;
            if (mesh && boneMatrices) {
                mesh.getTriangle(triangleIndex, out, this._skinning(triangleIndex * 3, 3));
            }
            return out;
        };
        SkinnedMeshRenderer.prototype.raycast = function (p1, p2, p3) {
            var mesh = this._mesh;
            var boneMatrices = this.boneMatrices;
            if (!mesh || !boneMatrices) {
                return false;
            }
            var raycastMesh = false;
            var raycastInfo = undefined;
            var transform = this.gameObject.transform;
            var localRay = egret3d.helpRay.applyMatrix(transform.worldToLocalMatrix, p1);
            var localBoundingBox = this.localBoundingBox;
            if (p2) {
                if (p2 === true) {
                    raycastMesh = true;
                }
                else {
                    raycastMesh = p3 || false;
                    raycastInfo = p2;
                }
            }
            if (raycastMesh) {
                if (localBoundingBox.raycast(localRay) && mesh.raycast(p1, raycastInfo, this.forceCPUSkin ? null : this._skinning(0, 0))) {
                    if (raycastInfo) {
                        raycastInfo.transform = transform;
                    }
                    return true;
                }
            }
            else if (localBoundingBox.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    raycastInfo.distance = p1.origin.getDistance(raycastInfo.position.applyMatrix(transform.localToWorldMatrix));
                    raycastInfo.transform = transform;
                }
                return true;
            }
            return false;
        };
        Object.defineProperty(SkinnedMeshRenderer.prototype, "bones", {
            /**
             * 该渲染组件的骨骼列表。
             */
            get: function () {
                return this._bones;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "rootBone", {
            /**
             * 该渲染组件的根骨骼。
             */
            get: function () {
                return this._rootBone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "mesh", {
            /**
             * 该渲染组件的网格资源。
             */
            get: function () {
                return this._mesh;
            },
            set: function (value) {
                if (value && !value.config.scenes && !value.config.nodes && !value.config.skins) {
                    console.warn("Invalid skinned mesh.", value.name);
                    return;
                }
                if (this._mesh === value) {
                    return;
                }
                if (this._mesh) {
                    this._mesh.release();
                }
                this._mesh = value;
                if (this._mesh) {
                    this._mesh.retain();
                }
                SkinnedMeshRenderer.onMeshChanged.dispatch(this);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当蒙皮网格渲染组件的网格资源改变时派发事件。
         */
        SkinnedMeshRenderer.onMeshChanged = new signals.Signal();
        __decorate([
            paper.editor.property("MESH" /* MESH */),
            paper.serializedField("_mesh")
        ], SkinnedMeshRenderer.prototype, "mesh", null);
        return SkinnedMeshRenderer;
    }(egret3d.MeshRenderer));
    egret3d.SkinnedMeshRenderer = SkinnedMeshRenderer;
    __reflect(SkinnedMeshRenderer.prototype, "egret3d.SkinnedMeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 蒙皮网格渲染组件系统。
     * - 为蒙皮网格渲染组件生成绘制信息。
     * - 更新蒙皮网格的骨骼矩阵信息。
     */
    var SkinnedMeshRendererSystem = (function (_super) {
        __extends(SkinnedMeshRendererSystem, _super);
        function SkinnedMeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                {
                    componentClass: egret3d.SkinnedMeshRenderer,
                    listeners: [
                        {
                            type: egret3d.SkinnedMeshRenderer.onMeshChanged, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject, true);
                                if (component.gameObject.renderer) {
                                    component.gameObject.renderer._localBoundingBoxDirty = true;
                                }
                            }
                        },
                        {
                            type: egret3d.SkinnedMeshRenderer.onMaterialsChanged, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject, true);
                            }
                        },
                    ]
                }
            ];
            _this._drawCallCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCallCollecter);
            _this._materialFilter = [];
            return _this;
        }
        SkinnedMeshRendererSystem.prototype._updateDrawCalls = function (gameObject, checkState) {
            if (checkState && !this.enabled || !this.groups[0].hasGameObject(gameObject)) {
                return;
            }
            var drawCallCollecter = this._drawCallCollecter;
            var renderer = gameObject.renderer;
            var mesh = renderer.mesh;
            var materials = renderer.materials;
            var materialCount = materials.length;
            drawCallCollecter.removeDrawCalls(renderer); // Clear drawCalls.
            if (!mesh || materialCount === 0) {
                return;
            }
            var primitives = mesh.glTFMesh.primitives;
            var subMeshCount = primitives.length;
            if (true && subMeshCount === 0) {
                throw new Error();
            }
            var materialFilter = this._materialFilter;
            var matrix = egret3d.Matrix4.IDENTITY;
            materialFilter.length = materialCount;
            drawCallCollecter.renderers.push(renderer);
            for (var i = 0; i < subMeshCount; ++i) {
                var materialIndex = primitives[i].material;
                var material = null;
                if (materialIndex === undefined) {
                    material = egret3d.DefaultMaterials.MESH_BASIC;
                }
                else if (materialIndex < materialCount) {
                    material = materials[materialIndex];
                    materialFilter[materialIndex] = true;
                }
                if (material) {
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.renderer = renderer;
                    drawCall.matrix = matrix;
                    drawCall.subMeshIndex = i;
                    drawCall.mesh = mesh;
                    drawCall.material = material;
                    drawCallCollecter.addDrawCall(drawCall);
                }
            }
            for (var i = 0; i < materialCount; ++i) {
                if (materialFilter[i]) {
                    continue;
                }
                var material = materials[i];
                for (var j = 0; j < subMeshCount; ++j) {
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.renderer = renderer;
                    drawCall.matrix = matrix;
                    drawCall.subMeshIndex = j;
                    drawCall.mesh = mesh;
                    drawCall.material = material;
                    drawCallCollecter.addDrawCall(drawCall);
                }
            }
            materialFilter.length = 0;
        };
        SkinnedMeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this.groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._updateDrawCalls(gameObject, false);
            }
        };
        SkinnedMeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this.groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
            }
        };
        SkinnedMeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            var renderer = gameObject.renderer;
            if (renderer.mesh && !renderer.source && !renderer.boneMatrices) {
                renderer.initialize(true);
            }
            this._updateDrawCalls(gameObject, false);
        };
        SkinnedMeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
        };
        SkinnedMeshRendererSystem.prototype.onUpdate = function () {
            for (var _i = 0, _a = this.groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                gameObject.renderer._update();
            }
        };
        return SkinnedMeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.SkinnedMeshRendererSystem = SkinnedMeshRendererSystem;
    __reflect(SkinnedMeshRendererSystem.prototype, "egret3d.SkinnedMeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 可以添加egret2d显示对象（包括EUI）进行渲染。
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Egret2DRenderer = (function (_super) {
        __extends(Egret2DRenderer, _super);
        function Egret2DRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._order = -1;
            /**
             * TODO
             */
            _this.frustumCulled = false;
            _this._screenAdapter = new egret3d.ConstantAdapter();
            _this._stageWidth = 0;
            _this._stageHeight = 0;
            _this._scaler = 1;
            return _this;
        }
        Object.defineProperty(Egret2DRenderer.prototype, "screenAdapter", {
            get: function () {
                return this._screenAdapter;
            },
            set: function (adapter) {
                adapter.$dirty = true;
                this._screenAdapter = adapter;
            },
            enumerable: true,
            configurable: true
        });
        Egret2DRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.stage = new egret.Stage();
            this.stage.maxTouches = 98;
            this.root = new egret.DisplayObjectContainer();
            this.stage.addChild(this.root);
            if (!this._renderer) {
                this._renderer = egret.web.Renderer.getInstance(egret3d.WebGLCapabilities.webgl || egret3d.Egret2DRendererSystem.webgl);
            }
            var stage = this.stage;
            var displayList = new egret.sys.DisplayList(stage);
            displayList.renderBuffer = new egret.sys.RenderBuffer(undefined, undefined, true);
            stage.$displayList = displayList;
            // TODO
            var webInput = paper.Application.systemManager.getSystem(egret3d.Egret2DRendererSystem).webInput;
            if (webInput) {
                egret.web.$cacheTextAdapter(webInput, stage, egret3d.Egret2DRendererSystem.canvas.parentNode, egret3d.Egret2DRendererSystem.canvas);
            }
        };
        Egret2DRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this.stage.removeChild(this.root);
        };
        Egret2DRenderer.prototype.recalculateLocalBox = function () {
            // TODO
            this._localBoundingBox.size = egret3d.Vector3.ZERO;
        };
        Egret2DRenderer.prototype.raycast = function (p1, p2, p3) {
            // TODO
            return false;
        };
        /**
         * screen position to ui position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 从屏幕坐标转换到当前2D系统的坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Egret2DRenderer.prototype.screenPosToUIPos = function (pos, out) {
            if (out === void 0) { out = new egret3d.Vector2(); }
            out.x = pos.x / this._scaler;
            out.y = pos.y / this._scaler;
            return out;
        };
        Object.defineProperty(Egret2DRenderer.prototype, "scaler", {
            /**
             * 从屏幕坐标到当前2D系统的坐标的缩放系数
             */
            get: function () {
                return this._scaler;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        Egret2DRenderer.prototype.update = function (deltaTime, w, h) {
            this._order = -1;
            var stage2d = this.stage;
            if (this._stageWidth !== w || this._stageHeight !== h || this.screenAdapter.$dirty) {
                var result = { w: 0, h: 0, s: 0 };
                this.screenAdapter.calculateScaler(w, h, result);
                this.screenAdapter.$dirty = false;
                // this._scaler = this.root.scaleX = this.root.scaleY = result.s;
                stage2d.$displayList["offsetMatrix"].a = result.s;
                stage2d.$displayList["offsetMatrix"].d = result.s;
                this._scaler = result.s;
                var stageWidth = result.w;
                var stageHeight = result.h;
                stage2d.$stageWidth = stageWidth;
                stage2d.$stageHeight = stageHeight;
                // stage.$displayList.setClipRect(screenWidth, screenHeight);
                stage2d.pushResize(w, h);
                stage2d.dispatchEventWith(egret.Event.RESIZE);
                this._stageWidth = w;
                this._stageHeight = h;
            }
            // // clear catched events
            // this._catchedEvent = {};
        };
        /**
         * @internal
         */
        Egret2DRenderer.prototype._draw = function () {
            this._renderer.beforeRender();
            this.stage.drawToSurface();
        };
        return Egret2DRenderer;
    }(paper.BaseRenderer));
    egret3d.Egret2DRenderer = Egret2DRenderer;
    __reflect(Egret2DRenderer.prototype, "egret3d.Egret2DRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Egret 传统 2D 渲染系统。
     */
    var Egret2DRendererSystem = (function (_super) {
        __extends(Egret2DRendererSystem, _super);
        function Egret2DRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                { componentClass: egret3d.Egret2DRenderer }
            ];
            /**
             * TODO
             * @internal
             */
            _this.webInput = egret.Capabilities.runtimeType === egret.RuntimeType.WEB ? new egret["web"].HTMLInput() : null;
            _this._sortedDirty = false;
            _this._sortedRenderers = [];
            return _this;
        }
        Egret2DRendererSystem.prototype._onSortRenderers = function (a, b) {
            return b._order - a._order;
        };
        Egret2DRendererSystem.prototype._sortRenderers = function () {
            if (this._sortedDirty) {
                this._sortedRenderers.sort(this._onSortRenderers);
                this._sortedDirty = false;
            }
            return this._sortedRenderers;
        };
        Egret2DRendererSystem.prototype._onTouchStart = function (pointer, signal) {
            if (paper.Application.playerMode !== 0 /* Player */) {
                return;
            }
            for (var _i = 0, _a = this._sortRenderers(); _i < _a.length; _i++) {
                var renderer = _a[_i];
                var event_1 = pointer.event;
                var scaler = renderer.scaler;
                if (renderer.stage.$onTouchBegin(pointer.position.x / scaler, pointer.position.y / scaler, event_1.pointerId)) {
                    break;
                }
            }
        };
        Egret2DRendererSystem.prototype._onTouchMove = function (pointer, signal) {
            if (paper.Application.playerMode !== 0 /* Player */) {
                return;
            }
            for (var _i = 0, _a = this._sortRenderers(); _i < _a.length; _i++) {
                var renderer = _a[_i];
                var event_2 = pointer.event;
                var scaler = renderer.scaler;
                if (renderer.stage.$onTouchMove(pointer.position.x / scaler, pointer.position.y / scaler, event_2.pointerId)) {
                    break;
                }
            }
        };
        Egret2DRendererSystem.prototype._onTouchEnd = function (pointer, signal) {
            if (paper.Application.playerMode !== 0 /* Player */) {
                return;
            }
            for (var _i = 0, _a = this._sortRenderers(); _i < _a.length; _i++) {
                var renderer = _a[_i];
                var event_3 = pointer.event;
                var scaler = renderer.scaler;
                if (renderer.stage.$onTouchEnd(pointer.position.x / scaler, pointer.position.y / scaler, event_3.pointerId)) {
                    break;
                }
            }
        };
        Egret2DRendererSystem.prototype.onAwake = function (config) {
            Egret2DRendererSystem.canvas = config.canvas;
            Egret2DRendererSystem.webgl = config.webgl;
            var webgl = Egret2DRendererSystem.webgl;
            if (!webgl) {
                return;
            }
            var webInput = this.webInput;
            if (webInput) {
                var canvas = Egret2DRendererSystem.canvas;
                webInput._initStageDelegateDiv(canvas.parentNode, canvas);
                webInput.$updateSize();
            }
        };
        Egret2DRendererSystem.prototype.onEnable = function () {
            egret3d.inputCollecter.onPointerDown.add(this._onTouchStart, this);
            egret3d.inputCollecter.onPointerCancel.add(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerUp.add(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerMove.add(this._onTouchMove, this);
        };
        Egret2DRendererSystem.prototype.onDisable = function () {
            egret3d.inputCollecter.onPointerDown.remove(this._onTouchStart, this);
            egret3d.inputCollecter.onPointerCancel.remove(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerUp.remove(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerMove.remove(this._onTouchMove, this);
        };
        Egret2DRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._sortedDirty = true;
            this._sortedRenderers.push(gameObject.renderer);
        };
        Egret2DRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            var index = this._sortedRenderers.indexOf(gameObject.renderer);
            if (index >= 0) {
                this._sortedRenderers.splice(index, 1);
            }
        };
        Egret2DRendererSystem.prototype.onUpdate = function (deltaTime) {
            var _a = egret3d.stage.viewport, w = _a.w, h = _a.h;
            for (var _i = 0, _b = this.groups[0].gameObjects; _i < _b.length; _i++) {
                var gameObject = _b[_i];
                gameObject.renderer.update(deltaTime, w, h);
            }
        };
        /**
         * @deprecated
         */
        Egret2DRendererSystem.canvas = null;
        /**
         * @deprecated
         */
        Egret2DRendererSystem.webgl = null;
        return Egret2DRendererSystem;
    }(paper.BaseSystem));
    egret3d.Egret2DRendererSystem = Egret2DRendererSystem;
    __reflect(Egret2DRendererSystem.prototype, "egret3d.Egret2DRendererSystem");
})(egret3d || (egret3d = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var egret;
(function (egret) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var Renderer = (function () {
            function Renderer(context) {
                this.context = context;
                var egretWebGLRenderContext = this.egretWebGLRenderContext = egret.web.WebGLRenderContext.getInstance(0, 0);
                egretWebGLRenderContext.setContext(context);
                this.drawCmdManager = egretWebGLRenderContext.drawCmdManager;
                this.vao = egretWebGLRenderContext.vao;
                // egretWebGLRenderContext.drawFunc = this.$drawWebGL.bind(this);
                egretWebGLRenderContext.$drawWebGL = this.$drawWebGL.bind(this);
                egret.sys.RenderBuffer = egret.web.WebGLRenderBuffer;
                egret.sys.systemRenderer = new egret.web.WebGLRenderer();
                egret.sys.canvasRenderer = new egret.CanvasRenderer();
                egret.sys.customHitTestBuffer = new egret.web.WebGLRenderBuffer(3, 3);
                egret.sys.canvasHitTestBuffer = new egret.web.CanvasRenderBuffer(3, 3);
                egret.Capabilities['$renderMode'] = "webgl";
                this.vertexBuffer = context.createBuffer();
                this.indexBuffer = context.createBuffer();
                // app.addEventListener("beforeRender", function() {
                //     egret.ticker.update();
                // }, this);
            }
            Renderer.getInstance = function (context) {
                if (!this._instance) {
                    this._instance = new Renderer(context);
                }
                return this._instance;
            };
            Renderer.prototype.beforeRender = function () {
                var gl = this.context;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.disable(gl.STENCIL_TEST);
                gl.colorMask(true, true, true, true);
                this.setBlendMode("source-over");
                // 目前只使用0号材质单元，默认开启
                gl.activeTexture(gl.TEXTURE0);
                this.currentProgram = null;
            };
            Renderer.prototype.$drawWebGL = function () {
                if (this.drawCmdManager.drawDataLen == 0) {
                    return;
                }
                this.uploadVerticesArray(this.vao.getVertices());
                // 有mesh，则使用indicesForMesh
                if (this.vao.hasMesh) {
                    this.uploadIndicesArray(this.vao.getMeshIndices());
                }
                var length = this.drawCmdManager.drawDataLen;
                var offset = 0;
                for (var i = 0; i < length; i++) {
                    var data = this.drawCmdManager.drawData[i];
                    if (!data) {
                        continue;
                    }
                    offset = this.drawData(data, offset);
                    // 计算draw call
                    if (data.type == 6 /* ACT_BUFFER */) {
                        this._activatedBuffer = data.buffer;
                        this.egretWebGLRenderContext.activatedBuffer = data.buffer;
                    }
                    if (data.type == 0 /* TEXTURE */ || data.type == 1 /* PUSH_MASK */ || data.type == 2 /* POP_MASK */) {
                        if (this._activatedBuffer && this._activatedBuffer.$computeDrawCall) {
                            this._activatedBuffer.$drawCalls++;
                        }
                    }
                }
                // 切换回默认indices
                if (this.vao.hasMesh) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                // 清空数据
                this.drawCmdManager.clear();
                this.vao.clear();
            };
            /**
             * 执行绘制命令
             */
            Renderer.prototype.drawData = function (data, offset) {
                if (!data) {
                    return;
                }
                var gl = this.context;
                var program;
                var filter = data.filter;
                switch (data.type) {
                    case 0 /* TEXTURE */:
                        if (filter) {
                            if (filter.type === "custom") {
                                program = web.EgretWebGLProgram.getProgram(gl, filter.$vertexSrc, filter.$fragmentSrc, filter.$shaderKey);
                            }
                            else if (filter.type === "colorTransform") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.colorTransform_frag, "colorTransform");
                            }
                            else if (filter.type === "blurX") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "blurY") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.glow_frag, "glow");
                            }
                        }
                        else {
                            program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.texture_frag, "texture");
                        }
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawTextureElements(data, offset);
                        break;
                    case 1 /* PUSH_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawPushMaskElements(data, offset);
                        break;
                    case 2 /* POP_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawPopMaskElements(data, offset);
                        break;
                    case 3 /* BLEND */:
                        this.setBlendMode(data.value);
                        break;
                    case 4 /* RESIZE_TARGET */:
                        data.buffer.rootRenderTarget.resize(data.width, data.height);
                        this.onResize(data.width, data.height);
                        break;
                    case 5 /* CLEAR_COLOR */:
                        if (this._activatedBuffer) {
                            var target = this._activatedBuffer.rootRenderTarget;
                            if (target.width != 0 || target.height != 0) {
                                target.clear(true);
                            }
                        }
                        break;
                    case 6 /* ACT_BUFFER */:
                        this.activateBuffer(data.buffer, data.width, data.height);
                        break;
                    case 7 /* ENABLE_SCISSOR */:
                        var buffer = this._activatedBuffer;
                        if (buffer) {
                            if (buffer.rootRenderTarget) {
                                buffer.rootRenderTarget.enabledStencil();
                            }
                            buffer.enableScissor(data.x, data.y, data.width, data.height);
                        }
                        break;
                    case 8 /* DISABLE_SCISSOR */:
                        buffer = this._activatedBuffer;
                        if (buffer) {
                            buffer.disableScissor();
                        }
                        break;
                    default:
                        break;
                }
                return offset;
            };
            Renderer.prototype.activeProgram = function (gl, program) {
                if (program != this.currentProgram) {
                    gl.useProgram(program.id);
                    // 目前所有attribute buffer的绑定方法都是一致的
                    var attribute = program.attributes;
                    for (var key in attribute) {
                        if (key === "aVertexPosition") {
                            gl.vertexAttribPointer(attribute["aVertexPosition"].location, 2, gl.FLOAT, false, 4 * 4, 0);
                            gl.enableVertexAttribArray(attribute["aVertexPosition"].location);
                        }
                        else if (key === "aTextureCoord") {
                            gl.vertexAttribPointer(attribute["aTextureCoord"].location, 2, gl.UNSIGNED_SHORT, true, 4 * 4, 2 * 4);
                            gl.enableVertexAttribArray(attribute["aTextureCoord"].location);
                        }
                        else if (key === "aColor") {
                            gl.vertexAttribPointer(attribute["aColor"].location, 1, gl.FLOAT, false, 4 * 4, 3 * 4);
                            gl.enableVertexAttribArray(attribute["aColor"].location);
                        }
                        else if (key === "aParticlePosition") {
                            gl.vertexAttribPointer(attribute["aParticlePosition"].location, 2, gl.FLOAT, false, 22 * 4, 0);
                            gl.enableVertexAttribArray(attribute["aParticlePosition"].location);
                        }
                        else if (key === "aParticleTextureCoord") {
                            gl.vertexAttribPointer(attribute["aParticleTextureCoord"].location, 2, gl.FLOAT, false, 22 * 4, 2 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleTextureCoord"].location);
                        }
                        else if (key === "aParticleScale") {
                            gl.vertexAttribPointer(attribute["aParticleScale"].location, 2, gl.FLOAT, false, 22 * 4, 4 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleScale"].location);
                        }
                        else if (key === "aParticleRotation") {
                            gl.vertexAttribPointer(attribute["aParticleRotation"].location, 2, gl.FLOAT, false, 22 * 4, 6 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleRotation"].location);
                        }
                        else if (key === "aParticleRed") {
                            gl.vertexAttribPointer(attribute["aParticleRed"].location, 2, gl.FLOAT, false, 22 * 4, 8 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleRed"].location);
                        }
                        else if (key === "aParticleGreen") {
                            gl.vertexAttribPointer(attribute["aParticleGreen"].location, 2, gl.FLOAT, false, 22 * 4, 10 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleGreen"].location);
                        }
                        else if (key === "aParticleBlue") {
                            gl.vertexAttribPointer(attribute["aParticleBlue"].location, 2, gl.FLOAT, false, 22 * 4, 12 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleBlue"].location);
                        }
                        else if (key === "aParticleAlpha") {
                            gl.vertexAttribPointer(attribute["aParticleAlpha"].location, 2, gl.FLOAT, false, 22 * 4, 14 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleAlpha"].location);
                        }
                        else if (key === "aParticleEmitRotation") {
                            gl.vertexAttribPointer(attribute["aParticleEmitRotation"].location, 2, gl.FLOAT, false, 22 * 4, 16 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleEmitRotation"].location);
                        }
                        else if (key === "aParticleEmitRadius") {
                            gl.vertexAttribPointer(attribute["aParticleEmitRadius"].location, 2, gl.FLOAT, false, 22 * 4, 18 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleEmitRadius"].location);
                        }
                        else if (key === "aParticleTime") {
                            gl.vertexAttribPointer(attribute["aParticleTime"].location, 2, gl.FLOAT, false, 22 * 4, 20 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleTime"].location);
                        }
                        //===== particle end =====
                    }
                    this.currentProgram = program;
                }
            };
            Renderer.prototype.syncUniforms = function (program, filter, data) {
                var uniforms = program.uniforms;
                for (var key in uniforms) {
                    if (key === "projectionVector") {
                        uniforms[key].setValue({ x: this.projectionX, y: this.projectionY });
                    }
                    else if (key === "uTextureSize") {
                        uniforms[key].setValue({ x: data.textureWidth, y: data.textureHeight });
                    }
                    else if (key === "uSampler") {
                    }
                    else if (key === "uGlobalMatrix") {
                        uniforms[key].setValue([data.a, data.c, data.tx, data.b, data.d, data.ty, 0, 0, 1]);
                    }
                    else if (key === "uGlobalAlpha") {
                        uniforms[key].setValue(data.alpha);
                    }
                    else {
                        var value = filter.$uniforms[key];
                        if (value !== undefined) {
                            uniforms[key].setValue(value);
                        }
                        else {
                            // egret.warn("filter custom: uniform " + key + " not defined!");
                        }
                    }
                }
            };
            /**
             * 画texture
             **/
            Renderer.prototype.drawTextureElements = function (data, offset) {
                var gl = this.context;
                if (data.texture.isCanvas) {
                    gl.wxBindCanvasTexture(gl.TEXTURE_2D, data.texture);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, data.texture);
                }
                var size = data.count * 3;
                gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                return size;
            };
            /**
             * 启用RenderBuffer
             */
            Renderer.prototype.activateBuffer = function (buffer, width, height) {
                buffer.rootRenderTarget.activate();
                if (!this.bindIndices) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                buffer.restoreStencil();
                buffer.restoreScissor();
                this.onResize(width, height);
            };
            Renderer.prototype.onResize = function (width, height) {
                this.projectionX = width / 2;
                this.projectionY = -height / 2;
                if (this.context) {
                    this.context.viewport(0, 0, width, height);
                }
            };
            /**
             * 上传顶点数据
             */
            Renderer.prototype.uploadVerticesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ARRAY_BUFFER, array, gl.STREAM_DRAW);
            };
            /**
             * 上传索引数据
             */
            Renderer.prototype.uploadIndicesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
                this.bindIndices = true;
            };
            /**
             * 画push mask
             **/
            Renderer.prototype.drawPushMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this._activatedBuffer;
                if (buffer) {
                    if (buffer.rootRenderTarget) {
                        buffer.rootRenderTarget.enabledStencil();
                    }
                    if (buffer.stencilHandleCount == 0) {
                        buffer.enableStencil();
                        gl.clear(gl.STENCIL_BUFFER_BIT); // clear
                    }
                    var level = buffer.stencilHandleCount;
                    buffer.stencilHandleCount++;
                    gl.colorMask(false, false, false, false);
                    gl.stencilFunc(gl.EQUAL, level, 0xFF);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                    // gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                    gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                    gl.colorMask(true, true, true, true);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                }
                return size;
            };
            /**
             * 画pop mask
             **/
            Renderer.prototype.drawPopMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this._activatedBuffer;
                if (buffer) {
                    buffer.stencilHandleCount--;
                    if (buffer.stencilHandleCount == 0) {
                        buffer.disableStencil(); // skip this draw
                    }
                    else {
                        var level = buffer.stencilHandleCount;
                        gl.colorMask(false, false, false, false);
                        gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                        // gl.bindTexture(gl.TEXTURE_2D, null);
                        gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                        gl.stencilFunc(gl.EQUAL, level, 0xFF);
                        gl.colorMask(true, true, true, true);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                    }
                }
                return size;
            };
            /**
             * 设置混色
             */
            Renderer.prototype.setBlendMode = function (value) {
                var gl = this.context;
                var blendModeWebGL = Renderer.blendModesForGL[value];
                if (blendModeWebGL) {
                    gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
                }
            };
            Renderer.initBlendMode = function () {
                Renderer.blendModesForGL = {};
                Renderer.blendModesForGL["source-over"] = [1, 771];
                Renderer.blendModesForGL["lighter"] = [1, 1];
                Renderer.blendModesForGL["lighter-in"] = [770, 771];
                Renderer.blendModesForGL["destination-out"] = [0, 771];
                Renderer.blendModesForGL["destination-in"] = [0, 770];
            };
            Renderer.blendModesForGL = null;
            return Renderer;
        }());
        web.Renderer = Renderer;
        __reflect(Renderer.prototype, "egret.web.Renderer");
        Renderer.initBlendMode();
    })(web = egret.web || (egret.web = {}));
})(egret || (egret = {}));
var egret3d;
(function (egret3d) {
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 恒定像素的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ConstantAdapter = (function () {
        function ConstantAdapter() {
            this.$dirty = true;
            this._scaleFactor = 1;
        }
        Object.defineProperty(ConstantAdapter.prototype, "scaleFactor", {
            /**
             * scaleFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置缩放值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._scaleFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        ConstantAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler = this._scaleFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ConstantAdapter;
    }());
    egret3d.ConstantAdapter = ConstantAdapter;
    __reflect(ConstantAdapter.prototype, "egret3d.ConstantAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 拉伸扩展的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ExpandAdapter = (function () {
        function ExpandAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ExpandAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ExpandAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasHeight / this._resolution.y;
            }
            else {
                scaler = canvasWidth / this._resolution.x;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ExpandAdapter;
    }());
    egret3d.ExpandAdapter = ExpandAdapter;
    __reflect(ExpandAdapter.prototype, "egret3d.ExpandAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ShrinkAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 缩放的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ShrinkAdapter = (function () {
        function ShrinkAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ShrinkAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ShrinkAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasWidth / this._resolution.x;
            }
            else {
                scaler = canvasHeight / this._resolution.y;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ShrinkAdapter;
    }());
    egret3d.ShrinkAdapter = ShrinkAdapter;
    __reflect(ShrinkAdapter.prototype, "egret3d.ShrinkAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * MatchWidthOrHeightAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 适应宽高适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MatchWidthOrHeightAdapter = (function () {
        function MatchWidthOrHeightAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
            this._matchFactor = 1.0; // width : height
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MatchWidthOrHeightAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        Object.defineProperty(MatchWidthOrHeightAdapter.prototype, "matchFactor", {
            /**
             * matchFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置匹配系数，0-1之间，越小越倾向以宽度适配，越大越倾向以高度适配。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._matchFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        MatchWidthOrHeightAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler1 = canvasWidth / this._resolution.x;
            var scaler2 = canvasHeight / this._resolution.y;
            var scaler = scaler1 + (scaler2 - scaler1) * this._matchFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return MatchWidthOrHeightAdapter;
    }());
    egret3d.MatchWidthOrHeightAdapter = MatchWidthOrHeightAdapter;
    __reflect(MatchWidthOrHeightAdapter.prototype, "egret3d.MatchWidthOrHeightAdapter", ["egret3d.IScreenAdapter"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 动画组件。
     */
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.autoPlay = false;
            /**
             * 动画速度。
             */
            _this.timeScale = 1.0;
            /**
             * @internal
             */
            _this._statesDirty = false;
            _this._animations = [];
            /**
             * @internal
             */
            _this._fadeStates = [];
            /**
             * @internal
             */
            _this._binders = {};
            _this._animationController = null;
            _this._lastAnimationLayer = null;
            return _this;
        }
        /**
         * @internal
         */
        Animation.prototype._getBinder = function (name, type) {
            var blendLayers = this._binders;
            name += "/" + type;
            if (!(name in blendLayers)) {
                blendLayers[name] = egret3d.AnimationBinder.create();
            }
            return blendLayers[name];
        };
        Animation.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            var fadeStatess = this._fadeStates;
            for (var _i = 0, fadeStatess_1 = fadeStatess; _i < fadeStatess_1.length; _i++) {
                var fadeStates = fadeStatess_1[_i];
                for (var _a = 0, fadeStates_1 = fadeStates; _a < fadeStates_1.length; _a++) {
                    var fadeState = fadeStates_1[_a];
                    fadeState.release();
                }
            }
            var binders = this._binders;
            for (var k in binders) {
                binders[k].release();
                delete binders[k];
            }
            for (var _b = 0, _c = this._animations; _b < _c.length; _b++) {
                var animation = _c[_b];
                animation.release();
            }
            if (this._animationController) {
                this._animationController.release();
            }
            this._animations.length = 0;
            this._fadeStates.length = 0;
            // this._binders;
            this._animationController = null;
            this._lastAnimationLayer = null;
        };
        /**
         * 融合播放一个指定的动画。
         * @param animationClipName 动画剪辑的名称。
         * @param fadeTime 融合的时间。
         * @param playTimes 播放次数。（-1：采用动画数据配置，0：循环播放，N：循环播放 N 次）
         * @param layerIndex 动画层索引。
         * @param layerAdditive 动画层混合方式是否为叠加。
         */
        Animation.prototype.fadeIn = function (animationClipName, fadeTime, playTimes, layerIndex, layerAdditive) {
            if (playTimes === void 0) { playTimes = -1; }
            if (layerIndex === void 0) { layerIndex = 0; }
            if (layerAdditive === void 0) { layerAdditive = false; }
            // 
            var animationAsset = null;
            var animationClip = null;
            for (var _i = 0, _a = this._animations; _i < _a.length; _i++) {
                var eachAnimationAsset = _a[_i];
                animationAsset = eachAnimationAsset;
                animationClip = eachAnimationAsset.getAnimationClip(animationClipName);
                if (animationClip !== null) {
                    break;
                }
            }
            if (!animationAsset || !animationClip) {
                console.warn("There is no animation clip named \"" + animationClipName + "\" in the \"" + this.gameObject.path + "\" gameObject.", animationClipName, this.gameObject.path);
                return null;
            }
            //
            if (!this._animationController) {
                this._animationController = egret3d.AnimationController.create("").retain();
            }
            var animationController = this._animationController;
            var animationLayers = animationController.layers;
            if (layerIndex > animationLayers.length) {
                console.warn("The animation layers must be continuous.");
                return null;
            }
            var animationLayer = animationController.getOrAddLayer(layerIndex);
            animationLayer.additive = layerAdditive;
            var animationNode = {
                asset: "",
                clip: "",
                timeScale: 1.0,
            };
            //
            var fadeStatess = this._fadeStates;
            if (layerIndex >= fadeStatess.length) {
                fadeStatess[layerIndex] = [];
            }
            for (var _b = 0, _c = fadeStatess[layerIndex]; _b < _c.length; _b++) {
                var fadeStates = _c[_b];
                fadeStates.fadeOut(fadeTime);
            }
            var lastFadeState = egret3d.AnimationFadeState.create();
            lastFadeState.totalTime = fadeTime;
            fadeStatess[layerIndex].push(lastFadeState);
            //
            var animationState = egret3d.AnimationState.create();
            animationState._initialize(this, animationLayer, animationNode, animationAsset, animationClip);
            animationState.playTimes = playTimes < 0 ? (animationClip.playTimes || 0) : playTimes;
            lastFadeState.states.push(animationState);
            //
            this._statesDirty = true;
            this._lastAnimationLayer = animationLayer;
            return animationState;
        };
        /**
         * 播放一个指定的动画。
         * @param animationClipNameOrNames
         * @param playTimes 播放次数。（-1：采用动画数据配置，0：循环播放，N：循环播放 N 次）
         */
        Animation.prototype.play = function (animationClipNameOrNames, playTimes) {
            if (animationClipNameOrNames === void 0) { animationClipNameOrNames = null; }
            if (playTimes === void 0) { playTimes = -1; }
            if (!this._animationController) {
                this._animationController = egret3d.AnimationController.create("").retain();
            }
            var animationController = this._animationController;
            var animationLayer = animationController.getOrAddLayer(0);
            //
            if (!animationLayer._clipNames) {
                animationLayer._clipNames = [];
            }
            var clipNames = animationLayer._clipNames;
            clipNames.length = 0;
            if (Array.isArray(animationClipNameOrNames)) {
                if (animationClipNameOrNames.length > 0) {
                    for (var _i = 0, animationClipNameOrNames_1 = animationClipNameOrNames; _i < animationClipNameOrNames_1.length; _i++) {
                        var animationName = animationClipNameOrNames_1[_i];
                        clipNames.push(animationName);
                    }
                    animationClipNameOrNames = clipNames.shift();
                }
                else {
                    animationClipNameOrNames = "";
                }
            }
            else if (!animationClipNameOrNames) {
                animationClipNameOrNames = "";
            }
            var animationState = null;
            if (animationClipNameOrNames) {
                animationState = this.fadeIn(animationClipNameOrNames, 0.0, playTimes);
            }
            else {
                var lastAnimationState = this.lastAnimationState;
                if (lastAnimationState) {
                    if (!lastAnimationState.isPlaying && !lastAnimationState.isCompleted) {
                        animationState = lastAnimationState;
                        lastAnimationState.play();
                    }
                    else {
                        animationState = this.fadeIn(lastAnimationState.animationClip.name, 0.0, playTimes);
                    }
                }
                else {
                    var animations = this._animations;
                    if (animations.length > 0) {
                        animationClipNameOrNames = animations[0].config.animations[0].extensions.paper.clips[0].name;
                        animationState = this.fadeIn(animationClipNameOrNames, 0.0, playTimes);
                    }
                }
            }
            return animationState;
        };
        /**
         *
         */
        Animation.prototype.stop = function (animationName, layerIndex) {
            if (animationName === void 0) { animationName = null; }
            if (layerIndex === void 0) { layerIndex = 0; }
            if (animationName) {
                var animationState = this.getState(animationName, layerIndex);
                if (animationState) {
                    animationState.stop();
                }
            }
            else {
                var fadeStatess = this._fadeStates;
                for (var _i = 0, fadeStatess_2 = fadeStatess; _i < fadeStatess_2.length; _i++) {
                    var fadeStates = fadeStatess_2[_i];
                    for (var _a = 0, fadeStates_2 = fadeStates; _a < fadeStates_2.length; _a++) {
                        var fadeState = fadeStates_2[_a];
                        for (var _b = 0, _c = fadeState.states; _b < _c.length; _b++) {
                            var animationState = _c[_b];
                            animationState.stop();
                        }
                    }
                }
            }
        };
        /**
         *
         */
        Animation.prototype.getState = function (animationName, layerIndex) {
            if (layerIndex === void 0) { layerIndex = 0; }
            var fadeStatess = this._fadeStates;
            if (fadeStatess.length > layerIndex) {
                var fadeStates = fadeStatess[layerIndex];
                var i = fadeStates.length;
                while (i--) {
                    var fadeState = fadeStates[i];
                    for (var _i = 0, _a = fadeState.states; _i < _a.length; _i++) {
                        var animationState = _a[_i];
                        if (animationState.animationClip.name === animationName) {
                            return animationState;
                        }
                    }
                }
            }
            return null;
        };
        /**
         *
         */
        Animation.prototype.hasAnimation = function (animationClipName) {
            for (var _i = 0, _a = this._animations; _i < _a.length; _i++) {
                var animationAsset = _a[_i];
                var animationClip = animationAsset.getAnimationClip(animationClipName);
                if (animationClip) {
                    return true;
                }
            }
            return false;
        };
        Object.defineProperty(Animation.prototype, "lastAnimationnName", {
            /**
             *
             */
            get: function () {
                var lastAnimationState = this.lastAnimationState;
                return lastAnimationState ? lastAnimationState.animationClip.name : "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animations", {
            /**
             * 动画数据列表。
             */
            get: function () {
                return this._animations;
            },
            set: function (value) {
                var animations = this._animations;
                for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {
                    var animation = animations_1[_i];
                    animation.release();
                }
                if (value !== animations) {
                    animations.length = 0;
                    for (var _a = 0, value_3 = value; _a < value_3.length; _a++) {
                        var animation = value_3[_a];
                        animations.push(animation);
                    }
                }
                for (var _b = 0, animations_2 = animations; _b < animations_2.length; _b++) {
                    var animation = animations_2[_b];
                    animation.retain();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animationController", {
            /**
             *
             */
            get: function () {
                return this._animationController;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "lastAnimationState", {
            /**
             *
             */
            get: function () {
                var animationController = this._animationController;
                var lastAnimationLayer = this._lastAnimationLayer;
                if (animationController && lastAnimationLayer) {
                    var layerIndex = animationController.layers.indexOf(lastAnimationLayer);
                    var fadeStatess = this._fadeStates;
                    if (fadeStatess.length > layerIndex) {
                        var fadeStates = fadeStatess[layerIndex];
                        if (fadeStates.length === 0) {
                            return null;
                        }
                        var animationStates = fadeStates[fadeStates.length - 1].states;
                        return animationStates[animationStates.length - 1];
                    }
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Animation.prototype, "autoPlay", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */)
        ], Animation.prototype, "timeScale", void 0);
        __decorate([
            paper.serializedField
        ], Animation.prototype, "_animationController", void 0);
        __decorate([
            paper.serializedField("_animations")
        ], Animation.prototype, "animations", null);
        return Animation;
    }(paper.BaseComponent));
    egret3d.Animation = Animation;
    __reflect(Animation.prototype, "egret3d.Animation");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var AnimationFadeState = (function (_super) {
        __extends(AnimationFadeState, _super);
        function AnimationFadeState() {
            var _this = _super.call(this) || this;
            _this.states = [];
            return _this;
        }
        AnimationFadeState.create = function () {
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationFadeState();
                instance.onClear();
            }
            return instance;
        };
        AnimationFadeState.prototype.onClear = function () {
            for (var _i = 0, _a = this.states; _i < _a.length; _i++) {
                var state = _a[_i];
                state.release();
            }
            this.fadeState = -1;
            this.subFadeState = -1;
            this.progress = 0.0;
            this.time = 0.0;
            this.totalTime = 0.0;
            this.states.length = 0;
        };
        AnimationFadeState.prototype.fadeOut = function (totalTime) {
            if (this.fadeState > 0) {
                if (totalTime > this.totalTime - this.time) {
                    return this;
                }
            }
            else {
                this.fadeState = 1;
                this.subFadeState = -1;
                if (totalTime <= 0.0 || this.progress <= 0.0) {
                    this.progress = 2.220446049250313e-16 /* EPSILON */; // Modify fade progress to different value.
                }
            }
            this.totalTime = this.progress > 2.220446049250313e-16 /* EPSILON */ ? totalTime / this.progress : 0.0;
            this.time = this.totalTime * (1.0 - this.progress);
            return this;
        };
        AnimationFadeState._instances = [];
        return AnimationFadeState;
    }(paper.BaseRelease));
    egret3d.AnimationFadeState = AnimationFadeState;
    __reflect(AnimationFadeState.prototype, "egret3d.AnimationFadeState");
    /**
     * 动画状态。
     */
    var AnimationState = (function (_super) {
        __extends(AnimationState, _super);
        function AnimationState() {
            var _this = _super.call(this) || this;
            /**
             * @private
             */
            _this.channels = [];
            return _this;
        }
        /**
         * @internal
         */
        AnimationState.create = function () {
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationState();
                instance.onClear();
            }
            return instance;
        };
        AnimationState.prototype.onClear = function () {
            for (var _i = 0, _a = this.channels; _i < _a.length; _i++) {
                var channel = _a[_i];
                channel.release();
            }
            this.playTimes = 0;
            this.currentPlayTimes = 0;
            this.weight = 1.0;
            this.channels.length = 0;
            this.animationNode = null;
            this.animationAsset = null;
            this.animation = null;
            this.animationClip = null;
            this._playheadEnabled = true;
            this._playState = -1;
            this._time = 0.0;
            this._currentTime = -1.0;
            this._globalWeight = 0.0;
        };
        /**
         * @internal
         */
        AnimationState.prototype._initialize = function (animation, animationLayer, animationNode, animationAsset, animationClip) {
            var assetConfig = animationAsset.config;
            this.animationAsset = animationAsset;
            this.animation = assetConfig.animations[0]; // TODO 动画数据暂不合并。
            this.animationClip = animationClip;
            this.animationLayer = animationLayer;
            this.animationNode = animationNode;
            if (this.animation.channels) {
                var animationMask = animationLayer.mask;
                var jointNames = animationMask ? animationMask.jointNames : null;
                var rootGameObject = animation.gameObject;
                var children = rootGameObject.transform.getAllChildren({});
                children["__root__"] = rootGameObject.transform; // 
                for (var _i = 0, _a = this.animation.channels; _i < _a.length; _i++) {
                    var glTFChannel = _a[_i];
                    var nodeIndex = glTFChannel.target.node;
                    var pathName = glTFChannel.target.path;
                    if (nodeIndex === undefined) {
                        // const channel = AnimationChannel.create();
                        // channel.components = animation;
                        // this.channels.push(channel);
                        switch (pathName) {
                            default:
                                console.warn("Unknown animation channel.", pathName);
                                break;
                        }
                    }
                    else {
                        var nodeName = this.animationAsset.getNode(nodeIndex).name;
                        if (!(nodeName in children) || (jointNames && jointNames.indexOf(nodeName) < 0)) {
                            continue;
                        }
                        var channel = egret3d.AnimationChannel.create();
                        var transforms = children[nodeName];
                        var binder = animation._getBinder(nodeName, pathName);
                        channel.glTFChannel = glTFChannel;
                        channel.glTFSampler = this.animation.samplers[glTFChannel.sampler];
                        channel.inputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.input));
                        channel.outputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.output));
                        this.channels.push(channel);
                        if (binder) {
                            channel.binder = binder;
                            binder.components = transforms; // TODO 更多组件
                        }
                        else {
                            channel.binder = transforms;
                        }
                        switch (pathName) {
                            case "translation":
                                channel.updateTarget = channel.onUpdateTranslation;
                                if (!binder.bindPose) {
                                    binder.bindPose = egret3d.Vector3.create().copy(transforms.localPosition);
                                }
                                if (!binder.updateTarget) {
                                    binder.updateTarget = binder.onUpdateTranslation;
                                }
                                break;
                            case "rotation":
                                channel.updateTarget = channel.onUpdateRotation;
                                if (!binder.bindPose) {
                                    binder.bindPose = egret3d.Quaternion.create().copy(transforms.localRotation);
                                }
                                if (!binder.updateTarget) {
                                    binder.updateTarget = binder.onUpdateRotation;
                                }
                                break;
                            case "scale":
                                channel.updateTarget = channel.onUpdateScale;
                                if (!binder.bindPose) {
                                    binder.bindPose = egret3d.Vector3.create().copy(transforms.localScale);
                                }
                                if (!binder.updateTarget) {
                                    binder.updateTarget = binder.onUpdateScale;
                                }
                                break;
                            case "weights":
                                // TODO
                                break;
                            case "custom":
                                switch (channel.glTFChannel.extensions.paper.type) {
                                    case "paper.GameObject":
                                        switch (channel.glTFChannel.extensions.paper.property) {
                                            case "activeSelf":
                                                channel.updateTarget = channel.onUpdateActive;
                                                break;
                                        }
                                        break;
                                    default:
                                        console.warn("Unknown animation channel.", channel.glTFChannel.extensions.paper.type);
                                        break;
                                }
                                break;
                            default:
                                console.warn("Unknown animation channel.", pathName);
                                break;
                        }
                    }
                }
            }
        };
        /**
         * 继续该动画状态的播放。
         */
        AnimationState.prototype.play = function () {
            this._playheadEnabled = true;
            return this;
        };
        /**
         * 停止该动画状态的播放。
         */
        AnimationState.prototype.stop = function () {
            this._playheadEnabled = false;
            return this;
        };
        Object.defineProperty(AnimationState.prototype, "isPlaying", {
            /**
             * 该动画状态是否正在播放。
             */
            get: function () {
                return this._playheadEnabled && this._playState !== 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isCompleted", {
            /**
             * 该动画状态是否播放完毕。
             */
            get: function () {
                return this._playState === 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "timeScale", {
            /**
             * 该动画状态的播放速度。
             */
            get: function () {
                return this.animationNode.timeScale;
            },
            set: function (value) {
                if (true && value !== value) {
                    throw new Error();
                }
                this.animationNode.timeScale = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "totalTime", {
            /**
             * 该动画状态的总播放时间。
             */
            get: function () {
                return this.animationClip.duration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "currentTime", {
            /**
             * 该动画状态的当前播放时间。
             */
            get: function () {
                return this._currentTime;
            },
            enumerable: true,
            configurable: true
        });
        AnimationState._instances = [];
        return AnimationState;
    }(paper.BaseRelease));
    egret3d.AnimationState = AnimationState;
    __reflect(AnimationState.prototype, "egret3d.AnimationState");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var AnimationBinder = (function (_super) {
        __extends(AnimationBinder, _super);
        function AnimationBinder() {
            return _super.call(this) || this;
        }
        AnimationBinder.create = function () {
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationBinder();
                instance.onClear();
            }
            return instance;
        };
        AnimationBinder.prototype.onClear = function () {
            this.clear();
            if (this.bindPose) {
                this.bindPose.release(); // TODO
            }
            this.bindPose = null;
            this.components = null;
            this.updateTarget = null;
        };
        AnimationBinder.prototype.clear = function () {
            this.dirty = 0;
            this.totalWeight = 0.0;
            this.weight = 1.0;
        };
        AnimationBinder.prototype.updateBlend = function (animationState) {
            var globalWeight = animationState._globalWeight;
            if (this.dirty > 0) {
                if (this.totalWeight < 1.0 - 2.220446049250313e-16 /* EPSILON */) {
                    this.dirty++;
                    this.weight = globalWeight * (1.0 - this.totalWeight);
                    this.totalWeight += this.weight;
                    return true;
                }
                return false;
            }
            this.dirty++;
            this.totalWeight += globalWeight;
            this.weight = globalWeight;
            return true;
        };
        AnimationBinder.prototype.onUpdateTranslation = function () {
            var components = this.components;
            var isArray = Array.isArray(components);
            var target = (isArray ? components[0].localPosition : components.localPosition);
            if (this.totalWeight < 1.0 - 2.220446049250313e-16 /* EPSILON */) {
                var weight = 1.0 - this.totalWeight;
                var bindPose = this.bindPose;
                target.x += bindPose.x * weight;
                target.y += bindPose.y * weight;
                target.z += bindPose.z * weight;
            }
            if (isArray) {
                for (var _i = 0, _a = components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.localPosition = target;
                }
            }
            else {
                target.update();
            }
        };
        AnimationBinder.prototype.onUpdateRotation = function () {
            var components = this.components;
            var isArray = Array.isArray(components);
            var target = (isArray ? components[0].localRotation : components.localRotation);
            if (this.totalWeight < 1.0 - 2.220446049250313e-16 /* EPSILON */) {
                var weight = 1.0 - this.totalWeight;
                var bindPose = this.bindPose;
                target.x += bindPose.x * weight;
                target.y += bindPose.y * weight;
                target.z += bindPose.z * weight;
                target.w += bindPose.w * weight;
            }
            target.normalize();
            if (isArray) {
                for (var _i = 0, _a = components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.localRotation = target;
                }
            }
            else {
                target.update();
            }
        };
        AnimationBinder.prototype.onUpdateScale = function () {
            var components = this.components;
            var isArray = Array.isArray(components);
            var target = (isArray ? components[0].localScale : components.localScale);
            if (this.totalWeight < 1.0 - 2.220446049250313e-16 /* EPSILON */) {
                var weight = 1.0 - this.totalWeight;
                var bindPose = this.bindPose;
                target.x += bindPose.x * weight;
                target.y += bindPose.y * weight;
                target.z += bindPose.z * weight;
            }
            if (isArray) {
                for (var _i = 0, _a = components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.localScale = target;
                }
            }
            else {
                target.update();
            }
        };
        AnimationBinder._instances = [];
        return AnimationBinder;
    }(paper.BaseRelease));
    egret3d.AnimationBinder = AnimationBinder;
    __reflect(AnimationBinder.prototype, "egret3d.AnimationBinder");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpQuaternionA = egret3d.Quaternion.create();
    var _helpQuaternionB = egret3d.Quaternion.create();
    /**
     * @private
     */
    var AnimationChannel = (function (_super) {
        __extends(AnimationChannel, _super);
        function AnimationChannel() {
            return _super.call(this) || this;
        }
        AnimationChannel.create = function () {
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationChannel();
                instance.onClear();
            }
            return instance;
        };
        AnimationChannel.prototype.onClear = function () {
            this.enabled = true;
            this.binder = null;
            this.updateTarget = null;
        };
        AnimationChannel.prototype.onUpdateTranslation = function (animationlayer, animationState) {
            var additive = animationlayer.additive;
            var currentTime = animationState._currentTime;
            var interpolation = this.glTFSampler.interpolation;
            var outputBuffer = this.outputBuffer;
            var binder = this.binder;
            var components = binder.components;
            var frameIndex = this.getFrameIndex(currentTime);
            var x, y, z;
            if (frameIndex >= 0) {
                var offset = frameIndex * 3;
                x = outputBuffer[offset++];
                y = outputBuffer[offset++];
                z = outputBuffer[offset++];
                if (!interpolation || interpolation !== "STEP") {
                    var inputBuffer = this.inputBuffer;
                    var frameStart = inputBuffer[frameIndex];
                    var progress = (currentTime - frameStart) / (inputBuffer[frameIndex + 1] - frameStart);
                    x += (outputBuffer[offset++] - x) * progress;
                    y += (outputBuffer[offset++] - y) * progress;
                    z += (outputBuffer[offset++] - z) * progress;
                }
            }
            else {
                x = outputBuffer[0];
                y = outputBuffer[1];
                z = outputBuffer[2];
            }
            if (additive) {
                x -= outputBuffer[0];
                y -= outputBuffer[1];
                z -= outputBuffer[2];
            }
            var isArray = Array.isArray(components);
            var weight = binder.weight;
            var target = (isArray ? components[0].localPosition : components.localPosition);
            if (binder.dirty > 1) {
                target.x += x * weight;
                target.y += y * weight;
                target.z += z * weight;
            }
            else {
                if (weight !== 1.0) {
                    target.x = x * weight;
                    target.y = y * weight;
                    target.z = z * weight;
                }
                else {
                    target.x = x;
                    target.y = y;
                    target.z = z;
                }
            }
        };
        AnimationChannel.prototype.onUpdateRotation = function (animationlayer, animationState) {
            var helpQuaternionA = _helpQuaternionA;
            var helpQuaternionB = _helpQuaternionB;
            var additive = animationlayer.additive;
            var currentTime = animationState._currentTime;
            var interpolation = this.glTFSampler.interpolation;
            var outputBuffer = this.outputBuffer;
            var binder = this.binder;
            var components = binder.components;
            var frameIndex = this.getFrameIndex(currentTime);
            var x, y, z, w;
            if (frameIndex >= 0) {
                var offset = frameIndex * 4;
                x = outputBuffer[offset++];
                y = outputBuffer[offset++];
                z = outputBuffer[offset++];
                w = outputBuffer[offset++];
                if (!interpolation || interpolation !== "STEP") {
                    var inputBuffer = this.inputBuffer;
                    var frameStart = inputBuffer[frameIndex];
                    var progress = (currentTime - frameStart) / (inputBuffer[frameIndex + 1] - frameStart);
                    x += (outputBuffer[offset++] - x) * progress;
                    y += (outputBuffer[offset++] - y) * progress;
                    z += (outputBuffer[offset++] - z) * progress;
                    w += (outputBuffer[offset++] - w) * progress;
                }
            }
            else {
                x = outputBuffer[0];
                y = outputBuffer[1];
                z = outputBuffer[2];
                w = outputBuffer[3];
            }
            if (additive) {
                helpQuaternionA.fromArray(outputBuffer).multiply(helpQuaternionB.set(x, y, z, w)).inverse();
            }
            var isArray = Array.isArray(components);
            var weight = binder.weight;
            var target = (isArray ? components[0].localRotation : components.localRotation);
            if (binder.dirty > 1) {
                if (additive) {
                    target.multiply(helpQuaternionA.lerp(egret3d.Quaternion.IDENTITY, helpQuaternionA, weight));
                }
                else {
                    if (helpQuaternionA.set(x, y, z, w).dot(target) < 0.0) {
                        weight = -weight;
                    }
                    target.x += x * weight;
                    target.y += y * weight;
                    target.z += z * weight;
                    target.w += w * weight;
                }
            }
            else if (additive) {
                var bindPose = binder.bindPose;
                target.x = bindPose.x;
                target.y = bindPose.y;
                target.z = bindPose.z;
                target.w = bindPose.w;
                if (weight !== 1.0) {
                    target.multiply(helpQuaternionA.lerp(egret3d.Quaternion.IDENTITY, helpQuaternionA, weight));
                }
                else {
                    target.multiply(helpQuaternionA);
                }
            }
            else if (weight !== 1.0) {
                target.x = x * weight;
                target.y = y * weight;
                target.z = z * weight;
                target.w = w * weight;
            }
            else {
                target.x = x;
                target.y = y;
                target.z = z;
                target.w = w;
            }
        };
        AnimationChannel.prototype.onUpdateScale = function (animationlayer, animationState) {
            var additive = animationlayer.additive;
            var currentTime = animationState._currentTime;
            var interpolation = this.glTFSampler.interpolation;
            var outputBuffer = this.outputBuffer;
            var binder = this.binder;
            var components = binder.components;
            var frameIndex = this.getFrameIndex(currentTime);
            var x, y, z;
            if (frameIndex >= 0) {
                var offset = frameIndex * 3;
                x = outputBuffer[offset++];
                y = outputBuffer[offset++];
                z = outputBuffer[offset++];
                if (!interpolation || interpolation !== "STEP") {
                    var inputBuffer = this.inputBuffer;
                    var frameStart = inputBuffer[frameIndex];
                    var progress = (currentTime - frameStart) / (inputBuffer[frameIndex + 1] - frameStart);
                    x += (outputBuffer[offset++] - x) * progress;
                    y += (outputBuffer[offset++] - y) * progress;
                    z += (outputBuffer[offset++] - z) * progress;
                }
            }
            else {
                x = outputBuffer[0];
                y = outputBuffer[1];
                z = outputBuffer[2];
            }
            if (additive) {
                x -= outputBuffer[0];
                y -= outputBuffer[1];
                z -= outputBuffer[2];
            }
            var isArray = Array.isArray(components);
            var weight = binder.weight;
            var target = (isArray ? components[0].localScale : components.localScale);
            if (binder.dirty > 1) {
                target.x += x * weight;
                target.y += y * weight;
                target.z += z * weight;
            }
            else {
                if (weight !== 1.0) {
                    target.x = x * weight;
                    target.y = y * weight;
                    target.z = z * weight;
                }
                else {
                    target.x = x;
                    target.y = y;
                    target.z = z;
                }
            }
        };
        AnimationChannel.prototype.onUpdateActive = function (animationlayer, animationState) {
            var currentTime = animationState._currentTime;
            var outputBuffer = this.outputBuffer;
            var components = this.binder;
            var frameIndex = this.getFrameIndex(currentTime);
            //
            var activeSelf = (frameIndex >= 0 ? outputBuffer[frameIndex] : outputBuffer[0]) !== 0;
            if (Array.isArray(components)) {
                for (var _i = 0, _a = components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.gameObject.activeSelf = activeSelf;
                }
            }
            else {
                components.gameObject.activeSelf = activeSelf;
            }
        };
        AnimationChannel.prototype.getFrameIndex = function (currentTime) {
            var inputBuffer = this.inputBuffer;
            var frameCount = inputBuffer.length;
            if (true && frameCount === 0) {
                throw new Error();
            }
            if (frameCount === 1) {
                return -1;
            }
            else if (currentTime <= inputBuffer[0]) {
                return 0;
            }
            else if (currentTime >= inputBuffer[frameCount - 1]) {
                return frameCount - 2;
            }
            var beginIndex = 0;
            var endIndex = frameCount - 1;
            while (endIndex - beginIndex > 1) {
                var middleIndex = beginIndex + ((endIndex - beginIndex) * 0.5) >> 0;
                if (currentTime >= inputBuffer[middleIndex]) {
                    beginIndex = middleIndex;
                }
                else {
                    endIndex = middleIndex;
                }
            }
            return beginIndex;
        };
        AnimationChannel._instances = [];
        return AnimationChannel;
    }(paper.BaseRelease));
    egret3d.AnimationChannel = AnimationChannel;
    __reflect(AnimationChannel.prototype, "egret3d.AnimationChannel");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 动画事件类型。
     */
    var AnimationEventType;
    (function (AnimationEventType) {
        AnimationEventType[AnimationEventType["Start"] = 0] = "Start";
        AnimationEventType[AnimationEventType["LoopComplete"] = 1] = "LoopComplete";
        AnimationEventType[AnimationEventType["Complete"] = 2] = "Complete";
        AnimationEventType[AnimationEventType["KeyFrame"] = 3] = "KeyFrame";
        AnimationEventType[AnimationEventType["Sound"] = 4] = "Sound";
    })(AnimationEventType = egret3d.AnimationEventType || (egret3d.AnimationEventType = {}));
    /**
     * 动画事件。
     */
    var AnimationEvent = (function (_super) {
        __extends(AnimationEvent, _super);
        function AnimationEvent() {
            var _this = _super.call(this) || this;
            _this.type = 0 /* Start */;
            _this.animationState = null;
            _this.frameEvent = null;
            return _this;
        }
        AnimationEvent.create = function (type, animationState, keyFrameEvent) {
            if (keyFrameEvent === void 0) { keyFrameEvent = null; }
            var instance = null;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationEvent();
            }
            instance.type = type;
            instance.animationState = animationState;
            instance.frameEvent = keyFrameEvent;
            return instance;
        };
        AnimationEvent._instances = [];
        return AnimationEvent;
    }(paper.BaseRelease));
    egret3d.AnimationEvent = AnimationEvent;
    __reflect(AnimationEvent.prototype, "egret3d.AnimationEvent");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 动画系统。
     */
    var AnimationSystem = (function (_super) {
        __extends(AnimationSystem, _super);
        function AnimationSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.interests = [
                { componentClass: egret3d.Animation }
            ];
            _this._events = [];
            _this._animation = null;
            return _this;
        }
        AnimationSystem.prototype._updateAnimationFadeState = function (animationFadeState, deltaTime) {
            if (deltaTime < 0.0) {
                deltaTime = -deltaTime;
            }
            var isFadeOut = animationFadeState.fadeState === 1;
            var totalTime = animationFadeState.totalTime;
            var time = animationFadeState.time += deltaTime;
            if (animationFadeState.subFadeState === -1) {
                animationFadeState.subFadeState = 0;
            }
            if (time >= totalTime) {
                animationFadeState.subFadeState = 1;
                animationFadeState.progress = isFadeOut ? 0.0 : 1.0;
            }
            else if (time > 0.0) {
                animationFadeState.progress = isFadeOut ? (1.0 - time / totalTime) : (time / totalTime);
            }
            else {
                animationFadeState.progress = isFadeOut ? 1.0 : 0.0;
            }
            if (animationFadeState.subFadeState === 1) {
                if (!isFadeOut) {
                    animationFadeState.fadeState = 0;
                    animationFadeState.subFadeState = 0; //
                }
            }
        };
        AnimationSystem.prototype._updateAnimationState = function (animationFadeState, animationState, deltaTime, forceUpdate) {
            var animation = this._animation;
            var gameObject = animation.gameObject;
            var animationLayer = animationState.animationLayer;
            // const animationNode = animationState.animationNode;
            var weight = animationLayer.weight * animationFadeState.progress * animationState.weight;
            // if (this.parent) { TODO
            //     this._globalWeight *= this.parent._globalWeight;
            // }
            animationState._globalWeight = weight;
            // Update time.
            if (animationState._playheadEnabled) {
                deltaTime *= animation.timeScale * animationState.timeScale;
                animationState._time += deltaTime;
            }
            // const isBlendDirty = this._fadeState !== 0 || this._subFadeState === 0;
            var prevPlayState = animationState._playState;
            var prevPlayTimes = animationState.currentPlayTimes;
            var prevTime = animationState._currentTime;
            var playTimes = animationState.playTimes;
            var duration = animationState.animationClip.duration;
            var totalTime = playTimes * duration;
            var currentTime = 0.0;
            if (playTimes > 0 && (animationState._time >= totalTime || animationState._time <= -totalTime)) {
                if (animationState._playState <= 0 && animationState._playheadEnabled) {
                    animationState._playState = 1;
                }
                animationState.currentPlayTimes = playTimes;
                if (animationState._time >= totalTime) {
                    currentTime = duration;
                }
                else {
                    currentTime = 0.0;
                }
            }
            else {
                if (animationState._playState !== 0 && animationState._playheadEnabled) {
                    animationState._playState = 0;
                }
                if (animationState._time < 0.0) {
                    animationState._time = -animationState._time;
                    animationState.currentPlayTimes = (animationState._time / duration) >> 0;
                    currentTime = duration - (animationState._time % duration);
                }
                else {
                    animationState.currentPlayTimes = (animationState._time / duration) >> 0;
                    currentTime = animationState._time % duration;
                }
            }
            currentTime += animationState.animationClip.position;
            animationState._currentTime = currentTime;
            if (forceUpdate || weight !== 0.0) {
                var mask = animationLayer.mask;
                if (mask && mask._dirty) {
                    var jointNames = mask.jointNames;
                    var nodes = animationState.animationAsset.config.nodes;
                    for (var _i = 0, _a = animationState.channels; _i < _a.length; _i++) {
                        var channel = _a[_i];
                        if (jointNames && jointNames.length > 0) {
                            var jointIndex = channel.glTFChannel.target.node;
                            channel.enabled = jointIndex === undefined || jointNames.indexOf(nodes[jointIndex].name) >= 0;
                        }
                        else {
                            channel.enabled = true;
                        }
                    }
                }
                for (var _b = 0, _c = animationState.channels; _b < _c.length; _b++) {
                    var channel = _c[_b];
                    if (!channel.updateTarget || !channel.enabled) {
                        continue;
                    }
                    var binder = channel.binder;
                    if (binder.constructor === egret3d.AnimationBinder) {
                        if (binder.updateBlend(animationState)) {
                            channel.updateTarget(animationLayer, animationState);
                        }
                    }
                    else {
                        channel.updateTarget(animationLayer, animationState);
                    }
                }
            }
            // this._events; // TODO buffer event.
            if (prevPlayState === -1 && animationState._playState !== -1) {
                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(0 /* Start */, animationState), false);
            }
            //
            var loopEvent = false;
            var frameEvents = animationState.animation.extensions.paper.events;
            if (deltaTime !== 0.0 && frameEvents) {
                if (deltaTime > 0.0) {
                    if (prevTime < currentTime) {
                        for (var _d = 0, frameEvents_1 = frameEvents; _d < frameEvents_1.length; _d++) {
                            var event_4 = frameEvents_1[_d];
                            if (prevTime < event_4.position && event_4.position <= currentTime) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_4), false);
                            }
                        }
                    }
                    else {
                        for (var _e = 0, frameEvents_2 = frameEvents; _e < frameEvents_2.length; _e++) {
                            var event_5 = frameEvents_2[_e];
                            if (prevTime < event_5.position) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_5), false);
                            }
                        }
                        gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(1 /* LoopComplete */, animationState), false);
                        for (var _f = 0, frameEvents_3 = frameEvents; _f < frameEvents_3.length; _f++) {
                            var event_6 = frameEvents_3[_f];
                            if (event_6.position <= currentTime) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_6), false);
                            }
                        }
                        loopEvent = true;
                    }
                }
                else {
                    if (prevTime > currentTime) {
                        for (var _g = 0, frameEvents_4 = frameEvents; _g < frameEvents_4.length; _g++) {
                            var event_7 = frameEvents_4[_g];
                            if (currentTime <= event_7.position && event_7.position < prevTime) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_7), false);
                            }
                        }
                    }
                    else {
                        for (var _h = 0, frameEvents_5 = frameEvents; _h < frameEvents_5.length; _h++) {
                            var event_8 = frameEvents_5[_h];
                            if (event_8.position < prevTime) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_8), false);
                            }
                        }
                        gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(1 /* LoopComplete */, animationState), false);
                        for (var _j = 0, frameEvents_6 = frameEvents; _j < frameEvents_6.length; _j++) {
                            var event_9 = frameEvents_6[_j];
                            if (currentTime <= event_9.position) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_9), false);
                            }
                        }
                        loopEvent = true;
                    }
                }
            }
            if (animationState.currentPlayTimes !== prevPlayTimes) {
                if (!loopEvent) {
                    gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(1 /* LoopComplete */, animationState), false);
                }
                if (animationState._playState === 1) {
                    var clipNames = animationLayer._clipNames;
                    if (clipNames && clipNames.length > 0) {
                        animation.play(clipNames.shift());
                    }
                    else {
                        gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(2 /* Complete */, animationState), false);
                    }
                }
            }
        };
        AnimationSystem.prototype.onAddComponent = function (component) {
            if (component.autoPlay && (!component.lastAnimationState || !component.lastAnimationState.isPlaying)) {
                component.play();
            }
        };
        AnimationSystem.prototype.onUpdate = function (deltaTime) {
            for (var _i = 0, _a = this.groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                var animation = this._animation = gameObject.getComponent(egret3d.Animation);
                var animationController = animation.animationController;
                if (!animationController) {
                    continue;
                }
                var animationLayers = animationController.layers;
                var animationFadeStates = animation._fadeStates;
                var blendlayers = animation._binders;
                for (var k in blendlayers) {
                    var blendLayer = blendlayers[k];
                    blendLayer.clear();
                }
                if (animation._statesDirty) {
                    animation._statesDirty = false;
                }
                for (var i = animationFadeStates.length - 1; i >= 0; i--) {
                    var fadeStates = animationFadeStates[i];
                    for (var j = 0, r = 0, lJ = fadeStates.length; j < lJ; ++j) {
                        var forceUpdate = false;
                        var fadeState = fadeStates[j];
                        var sFadeState = fadeState.fadeState;
                        var sSubFadeState = fadeState.subFadeState;
                        if (sFadeState === 1 && sSubFadeState === 1) {
                            r++;
                            fadeState.release();
                        }
                        else {
                            if (r > 0) {
                                fadeStates[j - r] = fadeState;
                            }
                            if (sFadeState !== 0 || sSubFadeState !== 0) {
                                forceUpdate = true;
                                this._updateAnimationFadeState(fadeState, deltaTime);
                            }
                            for (var _b = 0, _c = fadeState.states; _b < _c.length; _b++) {
                                var animationState = _c[_b];
                                this._updateAnimationState(fadeState, animationState, deltaTime, forceUpdate);
                            }
                        }
                        if (j === lJ - 1 && r > 0) {
                            fadeStates.length -= r;
                            animation._statesDirty = true;
                        }
                    }
                }
                for (var _d = 0, animationLayers_1 = animationLayers; _d < animationLayers_1.length; _d++) {
                    var layer = animationLayers_1[_d];
                    var mask = layer.mask;
                    if (mask && mask._dirty) {
                        mask._dirty = false;
                    }
                }
                for (var k in blendlayers) {
                    var blendLayer = blendlayers[k];
                    blendLayer.updateTarget();
                }
            }
        };
        return AnimationSystem;
    }(paper.BaseSystem));
    egret3d.AnimationSystem = AnimationSystem;
    __reflect(AnimationSystem.prototype, "egret3d.AnimationSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         * @private
         * 渲染类型为Mesh的属性格式
         */
        var MeshShaderAttributeFormat = [
            { key: "POSITION" /* POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "COLOR_0" /* COLOR_0 */, type: "VEC4" /* VEC4 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "_START_POSITION" /* _START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_START_VELOCITY" /* _START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "_START_COLOR" /* _START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "_START_SIZE" /* _START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "_START_ROTATION" /* _START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "_TIME" /* _TIME */, type: "VEC2" /* VEC2 */ },
            { key: "_RANDOM0" /* _RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "_RANDOM1" /* _RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "_WORLD_POSITION" /* _WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_WORLD_ROTATION" /* _WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
         * @private
         * 渲染类型为Billboard的属性格式
         */
        var BillboardShaderAttributeFormat = [
            { key: "_CORNER" /* _CORNER */, type: "VEC2" /* VEC2 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "_START_POSITION" /* _START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_START_VELOCITY" /* _START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "_START_COLOR" /* _START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "_START_SIZE" /* _START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "_START_ROTATION" /* _START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "_TIME" /* _TIME */, type: "VEC2" /* VEC2 */ },
            { key: "_RANDOM0" /* _RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "_RANDOM1" /* _RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "_WORLD_POSITION" /* _WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_WORLD_ROTATION" /* _WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
        * @internal
        */
        function createBatchMesh(renderer, maxParticleCount) {
            var meshAttributes = [];
            var meshAttributesType = {};
            if (renderer.renderMode === 4 /* Mesh */) {
                var mesh = renderer.mesh;
                var orginIndexBuffer = mesh.getIndices();
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _i = 0, MeshShaderAttributeFormat_1 = MeshShaderAttributeFormat; _i < MeshShaderAttributeFormat_1.length; _i++) {
                    var attribute = MeshShaderAttributeFormat_1[_i];
                    meshAttributes.push(attribute.key);
                    meshAttributesType[attribute.key] = attribute.type;
                }
                var totalVertexCount = mesh.vertexCount * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = egret3d.Mesh.create(totalVertexCount, totalIndexCount, meshAttributes, meshAttributesType);
                batchMesh.drawMode = 35048 /* Dynamic */;
                //
                var index = 0;
                //提前填充
                var orginPostionBuffer = mesh.getAttributes("POSITION" /* POSITION */);
                var orginUVBuffer = mesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                var orginColorBuffer = mesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var positionBuffer = batchMesh.getAttributes("POSITION" /* POSITION */);
                var colorBuffer = batchMesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var vector2Offset = i * 2;
                    var vector3Offset = i * 3;
                    var vector4Offset = i * 4;
                    var orginVertexIndex = i % mesh.vertexCount;
                    positionBuffer[vector3Offset] = orginPostionBuffer[orginVertexIndex * 3];
                    positionBuffer[vector3Offset + 1] = orginPostionBuffer[orginVertexIndex * 3 + 1];
                    positionBuffer[vector3Offset + 2] = orginPostionBuffer[orginVertexIndex * 3 + 2];
                    if (orginUVBuffer) {
                        uvBuffer[vector2Offset] = orginUVBuffer[orginVertexIndex * 2];
                        uvBuffer[vector2Offset + 1] = orginUVBuffer[orginVertexIndex * 2 + 1];
                    }
                    if (orginColorBuffer) {
                        colorBuffer[vector4Offset] = orginColorBuffer[orginVertexIndex * 4];
                        colorBuffer[vector4Offset + 1] = orginColorBuffer[orginVertexIndex * 4 + 1];
                        colorBuffer[vector4Offset + 2] = orginColorBuffer[orginVertexIndex * 4 + 2];
                        colorBuffer[vector4Offset + 3] = orginColorBuffer[orginVertexIndex * 4 + 3];
                    }
                    else {
                        colorBuffer[vector4Offset] = 1;
                        colorBuffer[vector4Offset + 1] = 1;
                        colorBuffer[vector4Offset + 2] = 1;
                        colorBuffer[vector4Offset + 3] = 1;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * mesh.vertexCount;
                    for (var j = 0; j < orginIndexBufferCount; j++) {
                        indexBuffer[index++] = orginIndexBuffer[j] + indexOffset;
                    }
                }
                return batchMesh;
            }
            else {
                var orginIndexBuffer = [0, 2, 1, 0, 3, 2];
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _a = 0, BillboardShaderAttributeFormat_1 = BillboardShaderAttributeFormat; _a < BillboardShaderAttributeFormat_1.length; _a++) {
                    var attribute = BillboardShaderAttributeFormat_1[_a];
                    meshAttributes.push(attribute.key);
                    meshAttributesType[attribute.key] = attribute.type;
                }
                var vertexStride = 4;
                var totalVertexCount = vertexStride * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = egret3d.Mesh.create(totalVertexCount, totalIndexCount, meshAttributes, meshAttributesType);
                batchMesh.drawMode = 35048 /* Dynamic */;
                var cornerBuffer = batchMesh.getAttributes("_CORNER" /* _CORNER */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var orginVertexIndex = i % vertexStride;
                    var vector2Offset = i * 2;
                    switch (orginVertexIndex) {
                        case 0:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 1:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 2:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                        case 3:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * 6;
                    var firstVertex = i * vertexStride;
                    var secondVertex = firstVertex + 2;
                    indexBuffer[indexOffset + 0] = firstVertex;
                    indexBuffer[indexOffset + 1] = secondVertex;
                    indexBuffer[indexOffset + 2] = firstVertex + 1;
                    indexBuffer[indexOffset + 3] = firstVertex;
                    indexBuffer[indexOffset + 4] = firstVertex + 3;
                    indexBuffer[indexOffset + 5] = secondVertex;
                }
                return batchMesh;
            }
        }
        particle.createBatchMesh = createBatchMesh;
        /**
         * @internal
         */
        function generatePositionAndDirection(position, direction, shape) {
            position.x = position.y = position.z = 0;
            direction.x = direction.y = 0;
            direction.z = 1.0;
            //
            switch (shape.shapeType) {
                case 4 /* Cone */:
                case 7 /* ConeShell */:
                    {
                        _generateConeParticlePosition(shape, position, direction);
                    }
                    break;
                case 8 /* ConeVolume */:
                case 9 /* ConeVolumeShell */:
                    {
                        _generateConeVolumeParticlePosition(shape, position, direction);
                    }
                    break;
                case 5 /* Box */:
                    {
                        _generateBoxParticlePosition(shape, position, direction);
                    }
                    break;
                case 0 /* Sphere */:
                case 1 /* SphereShell */:
                    {
                        _generateSphereParticlePosition(shape, position, direction);
                    }
                    break;
                case 10 /* Circle */:
                    {
                        _generateCircleParticlePosition(shape, position, direction);
                    }
                    break;
            }
            direction.normalize();
        }
        particle.generatePositionAndDirection = generatePositionAndDirection;
        function _randomPostionCircle(out) {
            var angle = Math.random() * Math.PI * 2;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideCircle(out) {
            _randomPostionCircle(out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionArcCircle(arc, out) {
            arc *= Math.PI / 180.0;
            var angle = Math.random() * arc;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideArcCircle(arc, out) {
            _randomPositionArcCircle(arc, out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionSphere(out) {
            var ranZ = Math.random() * 2 - 1.0;
            var angle = Math.random() * Math.PI * 2;
            var range = Math.sqrt(1.0 - ranZ * ranZ);
            out.x = Math.cos(angle) * range;
            out.y = Math.sin(angle) * range;
            out.z = ranZ;
        }
        function _randomPositionInsideSphere(out) {
            _randomPositionSphere(out);
            var range = Math.pow(Math.random(), 1.0 / 3.0);
            out.x = out.x * range;
            out.y = out.y * range;
            out.z = out.z * range;
        }
        function _generateConeParticlePosition(shape, position, direction) {
            var temp = egret3d.Vector3.create().release();
            if (shape.shapeType === 4 /* Cone */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = temp.z * shape.radius;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            if (shape.randomDirection) {
                _randomPositionInsideCircle(direction);
                direction.x = direction.x * sinValue;
                direction.y = direction.y * sinValue;
                direction.z = cosValue;
            }
            else {
                direction.x = temp.x * sinValue;
                direction.y = temp.y * sinValue;
                direction.z = cosValue;
            }
        }
        function _generateConeVolumeParticlePosition(shape, position, direction) {
            var temp = egret3d.Vector3.create().release();
            if (shape.shapeType === 8 /* ConeVolume */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            direction.x = temp.x * sinValue;
            direction.y = temp.y * sinValue;
            direction.z = cosValue;
            egret3d.Vector3.normalize(direction);
            var len = Math.random() * shape.length;
            direction.x = direction.x * len;
            direction.y = direction.y * len;
            direction.z = direction.z * len;
            position.x += direction.x;
            position.y += direction.y;
            position.z += direction.z;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
        }
        function _generateBoxParticlePosition(shape, position, direction) {
            position.x = shape.box.x * (Math.random() - 0.5);
            position.y = shape.box.y * (Math.random() - 0.5);
            position.z = shape.box.z * (Math.random() - 0.5);
            if (shape.randomDirection) {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
            else {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
        }
        function _generateSphereParticlePosition(shape, position, direction) {
            var temp = egret3d.Vector3.create().release();
            if (!shape.spherizeDirection) {
                if (shape.shapeType === 0 /* Sphere */) {
                    _randomPositionInsideSphere(position);
                }
                else {
                    _randomPositionSphere(position);
                }
            }
            position.x = position.x * shape.radius;
            position.y = position.y * shape.radius;
            position.z = position.z * shape.radius;
            if (shape.randomDirection || shape.spherizeDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
        function _generateCircleParticlePosition(shape, position, direction) {
            var temp = egret3d.Vector3.create().release();
            _randomPositionArcCircle(shape.arc, temp);
            position.x = -temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        particle.onMainChanged = new signals.Signal();
        particle.onColorChanged = new signals.Signal();
        particle.onVelocityChanged = new signals.Signal();
        particle.onSizeChanged = new signals.Signal();
        particle.onRotationChanged = new signals.Signal();
        particle.onTextureSheetChanged = new signals.Signal();
        particle.onShapeChanged = new signals.Signal();
        particle.onStartSize3DChanged = new signals.Signal();
        particle.onStartRotation3DChanged = new signals.Signal();
        particle.onSimulationSpaceChanged = new signals.Signal();
        particle.onScaleModeChanged = new signals.Signal();
        particle.onMaxParticlesChanged = new signals.Signal();
        /**
         *
         */
        var CurveMode;
        (function (CurveMode) {
            CurveMode[CurveMode["Constant"] = 0] = "Constant";
            CurveMode[CurveMode["Curve"] = 1] = "Curve";
            CurveMode[CurveMode["TwoCurves"] = 2] = "TwoCurves";
            CurveMode[CurveMode["TwoConstants"] = 3] = "TwoConstants";
        })(CurveMode = particle.CurveMode || (particle.CurveMode = {}));
        /**
         *
         */
        var ColorGradientMode;
        (function (ColorGradientMode) {
            ColorGradientMode[ColorGradientMode["Color"] = 0] = "Color";
            ColorGradientMode[ColorGradientMode["Gradient"] = 1] = "Gradient";
            ColorGradientMode[ColorGradientMode["TwoColors"] = 2] = "TwoColors";
            ColorGradientMode[ColorGradientMode["TwoGradients"] = 3] = "TwoGradients";
            ColorGradientMode[ColorGradientMode["RandomColor"] = 4] = "RandomColor";
        })(ColorGradientMode = particle.ColorGradientMode || (particle.ColorGradientMode = {}));
        /**
         *
         */
        var SimulationSpace;
        (function (SimulationSpace) {
            SimulationSpace[SimulationSpace["Local"] = 0] = "Local";
            SimulationSpace[SimulationSpace["World"] = 1] = "World";
            SimulationSpace[SimulationSpace["Custom"] = 2] = "Custom";
        })(SimulationSpace = particle.SimulationSpace || (particle.SimulationSpace = {}));
        /**
         *
         */
        var ScalingMode;
        (function (ScalingMode) {
            ScalingMode[ScalingMode["Hierarchy"] = 0] = "Hierarchy";
            ScalingMode[ScalingMode["Local"] = 1] = "Local";
            ScalingMode[ScalingMode["Shape"] = 2] = "Shape";
        })(ScalingMode = particle.ScalingMode || (particle.ScalingMode = {}));
        /**
         *
         */
        var ShapeType;
        (function (ShapeType) {
            ShapeType[ShapeType["None"] = -1] = "None";
            ShapeType[ShapeType["Sphere"] = 0] = "Sphere";
            ShapeType[ShapeType["SphereShell"] = 1] = "SphereShell";
            ShapeType[ShapeType["Hemisphere"] = 2] = "Hemisphere";
            ShapeType[ShapeType["HemisphereShell"] = 3] = "HemisphereShell";
            ShapeType[ShapeType["Cone"] = 4] = "Cone";
            ShapeType[ShapeType["Box"] = 5] = "Box";
            ShapeType[ShapeType["Mesh"] = 6] = "Mesh";
            ShapeType[ShapeType["ConeShell"] = 7] = "ConeShell";
            ShapeType[ShapeType["ConeVolume"] = 8] = "ConeVolume";
            ShapeType[ShapeType["ConeVolumeShell"] = 9] = "ConeVolumeShell";
            ShapeType[ShapeType["Circle"] = 10] = "Circle";
            ShapeType[ShapeType["CircleEdge"] = 11] = "CircleEdge";
            ShapeType[ShapeType["SingleSidedEdge"] = 12] = "SingleSidedEdge";
            ShapeType[ShapeType["MeshRenderer"] = 13] = "MeshRenderer";
            ShapeType[ShapeType["SkinnedMeshRenderer"] = 14] = "SkinnedMeshRenderer";
            ShapeType[ShapeType["BoxShell"] = 15] = "BoxShell";
            ShapeType[ShapeType["BoxEdge"] = 16] = "BoxEdge";
        })(ShapeType = particle.ShapeType || (particle.ShapeType = {}));
        /**
         *
         */
        var ShapeMultiModeValue;
        (function (ShapeMultiModeValue) {
            ShapeMultiModeValue[ShapeMultiModeValue["Random"] = 0] = "Random";
            ShapeMultiModeValue[ShapeMultiModeValue["Loop"] = 1] = "Loop";
            ShapeMultiModeValue[ShapeMultiModeValue["PingPong"] = 2] = "PingPong";
            ShapeMultiModeValue[ShapeMultiModeValue["BurstSpread"] = 3] = "BurstSpread";
        })(ShapeMultiModeValue = particle.ShapeMultiModeValue || (particle.ShapeMultiModeValue = {}));
        /**
         *
         */
        var AnimationType;
        (function (AnimationType) {
            AnimationType[AnimationType["WholeSheet"] = 0] = "WholeSheet";
            AnimationType[AnimationType["SingleRow"] = 1] = "SingleRow";
        })(AnimationType = particle.AnimationType || (particle.AnimationType = {}));
        /**
         *
         */
        var UVChannelFlags;
        (function (UVChannelFlags) {
            UVChannelFlags[UVChannelFlags["UV0"] = 1] = "UV0";
            UVChannelFlags[UVChannelFlags["UV1"] = 2] = "UV1";
            UVChannelFlags[UVChannelFlags["UV2"] = 4] = "UV2";
            UVChannelFlags[UVChannelFlags["UV3"] = 8] = "UV3";
        })(UVChannelFlags = particle.UVChannelFlags || (particle.UVChannelFlags = {}));
        /**
         *
         */
        var GradientMode;
        (function (GradientMode) {
            GradientMode[GradientMode["Blend"] = 0] = "Blend";
            GradientMode[GradientMode["Fixed"] = 1] = "Fixed";
        })(GradientMode = particle.GradientMode || (particle.GradientMode = {}));
        var _helpColorA = egret3d.Color.create();
        var _helpColorB = egret3d.Color.create();
        /**
         * TODO
         */
        var Keyframe = (function () {
            function Keyframe() {
            }
            Keyframe.prototype.serialize = function () {
                return [this.time, this.value];
            };
            Keyframe.prototype.deserialize = function (element) {
                this.time = element[0];
                this.value = element[1];
                return this;
            };
            Keyframe.prototype.copy = function (source) {
                this.time = source.time;
                this.value = source.value;
            };
            return Keyframe;
        }());
        particle.Keyframe = Keyframe;
        __reflect(Keyframe.prototype, "egret3d.particle.Keyframe", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var AnimationCurve = (function () {
            function AnimationCurve() {
                /**
                 * 功能与效率平衡长度取4
                 */
                this._keys = new Array();
                this._floatValues = new Float32Array(8);
            }
            AnimationCurve.prototype.serialize = function () {
                return this._keys.map(function (keyFrame) { return keyFrame.serialize(); });
            };
            AnimationCurve.prototype.deserialize = function (element) {
                this._keys.length = 0;
                for (var i = 0, l = element.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.deserialize(element[i]);
                    this._keys.push(keyframe);
                }
                return this;
            };
            AnimationCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this._keys.length; i < l; i++) {
                    var curKeyFrame = this._keys[i];
                    if (curKeyFrame.time < t) {
                        continue;
                    }
                    //
                    var lastIndex = i === 0 ? 0 : i - 1;
                    var lastKeyFrame = this._keys[lastIndex];
                    var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                    return egret3d.math.lerp(lastKeyFrame.value, curKeyFrame.value, tt);
                }
                throw "AnimationCurve: invalid t or keys.length is 0";
            };
            Object.defineProperty(AnimationCurve.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    var offset = 0;
                    for (var _i = 0, _a = this._keys; _i < _a.length; _i++) {
                        var keyFrame = _a[_i];
                        res[offset++] = keyFrame.time;
                        res[offset++] = keyFrame.value;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            AnimationCurve.prototype.copy = function (source) {
                this._keys.length = 0;
                var sourceKeys = source._keys;
                for (var i = 0, l = sourceKeys.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.time = sourceKeys[i].time;
                    keyframe.value = sourceKeys[i].value;
                    this._keys.push(keyframe);
                }
            };
            return AnimationCurve;
        }());
        particle.AnimationCurve = AnimationCurve;
        __reflect(AnimationCurve.prototype, "egret3d.particle.AnimationCurve", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var Burst = (function () {
            function Burst() {
                this.time = 0.0;
                this.minCount = 0;
                this.maxCount = 100;
                this.cycleCount = 1;
                this.repeatInterval = 1.0;
            }
            Burst.prototype.serialize = function () {
                return [this.time, this.minCount, this.maxCount, this.cycleCount, this.repeatInterval];
            };
            Burst.prototype.deserialize = function (element) {
                this.time = element[0];
                this.minCount = element[1];
                this.maxCount = element[2];
                this.cycleCount = element[3];
                this.repeatInterval = element[4];
                return this;
            };
            return Burst;
        }());
        particle.Burst = Burst;
        __reflect(Burst.prototype, "egret3d.particle.Burst", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var GradientColorKey = (function () {
            function GradientColorKey() {
                this.time = 0.0;
                this.color = egret3d.Color.create();
            }
            GradientColorKey.prototype.serialize = function () {
                return { time: this.time, color: this.color.serialize() };
            };
            GradientColorKey.prototype.deserialize = function (element) {
                this.time = element.time;
                this.color.deserialize(element.color);
                return this;
            };
            return GradientColorKey;
        }());
        particle.GradientColorKey = GradientColorKey;
        __reflect(GradientColorKey.prototype, "egret3d.particle.GradientColorKey", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var GradientAlphaKey = (function () {
            function GradientAlphaKey() {
                this.time = 0.0;
                this.alpha = 0.0;
            }
            GradientAlphaKey.prototype.serialize = function () {
                return { time: this.time, alpha: this.alpha };
            };
            GradientAlphaKey.prototype.deserialize = function (element) {
                this.alpha = element.alpha;
                this.time = element.time;
                return this;
            };
            return GradientAlphaKey;
        }());
        particle.GradientAlphaKey = GradientAlphaKey;
        __reflect(GradientAlphaKey.prototype, "egret3d.particle.GradientAlphaKey", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var Gradient = (function () {
            function Gradient() {
                this.mode = 0 /* Blend */;
                this.alphaKeys = new Array();
                this.colorKeys = new Array();
                this._alphaValue = new Float32Array(8);
                this._colorValue = new Float32Array(16);
            }
            Gradient.prototype.serialize = function () {
                return {
                    mode: this.mode,
                    alphaKeys: this.alphaKeys.map(function (v) { return v.serialize(); }),
                    colorKeys: this.colorKeys.map(function (v) { return v.serialize(); }),
                };
            };
            Gradient.prototype.deserialize = function (element) {
                this.colorKeys.length = 0;
                for (var i = 0, l = element.colorKeys.length; i < l; i++) {
                    var color = new GradientColorKey();
                    color.deserialize(element.colorKeys[i]);
                    this.colorKeys.push(color);
                }
                //
                this.alphaKeys.length = 0;
                for (var i = 0, l = element.alphaKeys.length; i < l; i++) {
                    var alpha = new GradientAlphaKey();
                    alpha.deserialize(element.alphaKeys[i]);
                    this.alphaKeys.push(alpha);
                }
                return this;
            };
            Gradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this.alphaKeys.length; i < l; i++) {
                    var curKeyFrame = this.alphaKeys[i];
                    if (curKeyFrame.time > t) {
                        var lastIndex = i === 0 ? 0 : i - 1;
                        var lastKeyFrame = this.alphaKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                        out.a = egret3d.math.lerp(lastKeyFrame.alpha, curKeyFrame.alpha, tt);
                        break;
                    }
                }
                for (var i = 0, l = this.colorKeys.length; i < l; i++) {
                    var colorKey = this.colorKeys[i];
                    if (colorKey.time > t) {
                        var lastIndex = i === 0 ? 0 : i - 1;
                        var lastKeyFrame = this.colorKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (colorKey.time - lastKeyFrame.time);
                        out.r = egret3d.math.lerp(lastKeyFrame.color.r, colorKey.color.r, tt);
                        out.g = egret3d.math.lerp(lastKeyFrame.color.g, colorKey.color.g, tt);
                        out.b = egret3d.math.lerp(lastKeyFrame.color.b, colorKey.color.b, tt);
                        break;
                    }
                }
                return out;
            };
            Object.defineProperty(Gradient.prototype, "alphaValues", {
                get: function () {
                    var res = this._alphaValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.alphaKeys; _i < _a.length; _i++) {
                        var alpha = _a[_i];
                        res[offset++] = alpha.time;
                        res[offset++] = alpha.alpha;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Gradient.prototype, "colorValues", {
                get: function () {
                    var res = this._colorValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.colorKeys; _i < _a.length; _i++) {
                        var color = _a[_i];
                        res[offset++] = color.time;
                        res[offset++] = color.color.r;
                        res[offset++] = color.color.g;
                        res[offset++] = color.color.b;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            return Gradient;
        }());
        particle.Gradient = Gradient;
        __reflect(Gradient.prototype, "egret3d.particle.Gradient", ["paper.ISerializable"]);
        /**
         * TODO create
         */
        var MinMaxCurve = (function () {
            function MinMaxCurve() {
                this.mode = 0 /* Constant */;
                this.constant = 0.0;
                this.constantMin = 0.0;
                this.constantMax = 1.0;
                this.curve = new AnimationCurve();
                this.curveMin = new AnimationCurve();
                this.curveMax = new AnimationCurve();
            }
            MinMaxCurve.prototype.serialize = function () {
                return {
                    mode: this.mode,
                    constant: this.constant,
                    constantMin: this.constantMin,
                    constantMax: this.constantMax,
                    curve: this.curve.serialize(),
                    curveMin: this.curveMin.serialize(),
                    curveMax: this.curveMax.serialize(),
                };
            };
            MinMaxCurve.prototype.deserialize = function (element) {
                // 该兼容代码可以在插件导出全数据后移除。
                this.mode = element.mode;
                this.constant = element.constant || 0;
                this.constantMin = element.constantMin || 0;
                this.constantMax = element.constantMax || 0;
                element.curve && this.curve.deserialize(element.curve);
                element.curveMin && this.curveMin.deserialize(element.curveMin);
                element.curveMax && this.curveMax.deserialize(element.curveMax);
                return this;
            };
            MinMaxCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Constant */) {
                    return this.constant;
                }
                else if (this.mode === 3 /* TwoConstants */) {
                    return (Math.random() * (this.constantMax - this.constantMin) + this.constantMin);
                }
                else if (this.mode === 1 /* Curve */) {
                    return this.curve.evaluate(t);
                }
                else {
                    var min = this.curveMin.evaluate(t);
                    var max = this.curveMax.evaluate(t);
                    return (Math.random() * (min - max) + min);
                }
            };
            MinMaxCurve.prototype.copy = function (source) {
                this.mode = source.mode;
                this.constant = source.constant;
                this.constantMin = source.constantMin;
                this.constantMax = source.constantMax;
                this.curve.copy(source.curve);
                this.curveMin.copy(source.curveMin);
                this.curveMax.copy(source.curveMax);
            };
            return MinMaxCurve;
        }());
        particle.MinMaxCurve = MinMaxCurve;
        __reflect(MinMaxCurve.prototype, "egret3d.particle.MinMaxCurve", ["paper.ISerializable"]);
        /**
         * TODO create
         */
        var MinMaxGradient = (function () {
            function MinMaxGradient() {
                this.mode = 1 /* Gradient */;
                this.color = egret3d.Color.create();
                this.colorMin = egret3d.Color.create();
                this.colorMax = egret3d.Color.create();
                this.gradient = new Gradient();
                this.gradientMin = new Gradient();
                this.gradientMax = new Gradient();
            }
            MinMaxGradient.prototype.serialize = function () {
                return {
                    mode: this.mode,
                    color: this.color.serialize(),
                    colorMin: this.colorMin.serialize(),
                    colorMax: this.colorMax.serialize(),
                    gradient: this.gradient.serialize(),
                    gradientMin: this.gradientMin.serialize(),
                    gradientMax: this.gradientMax.serialize(),
                };
            };
            MinMaxGradient.prototype.deserialize = function (element) {
                // 该兼容代码可以在插件导出全数据后移除。
                this.mode = element.mode;
                if (element.color) {
                    this.color.deserialize(element.color);
                }
                if (element.colorMin) {
                    this.colorMin.deserialize(element.colorMin);
                }
                if (element.colorMax) {
                    this.colorMax.deserialize(element.colorMax);
                }
                if (element.gradient) {
                    this.gradient.deserialize(element.gradient);
                }
                if (element.gradientMin) {
                    this.gradientMin.deserialize(element.gradientMin);
                }
                if (element.gradientMax) {
                    this.gradientMax.deserialize(element.gradientMax);
                }
                return this;
            };
            MinMaxGradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Color */) {
                    out.r = this.color.r;
                    out.g = this.color.g;
                    out.b = this.color.b;
                    out.a = this.color.a;
                }
                else if (this.mode === 2 /* TwoColors */) {
                    out.r = Math.random() * (this.colorMax.r - this.colorMin.r) + this.colorMin.r;
                    out.g = Math.random() * (this.colorMax.g - this.colorMin.g) + this.colorMin.g;
                    out.b = Math.random() * (this.colorMax.b - this.colorMin.b) + this.colorMin.b;
                    out.a = Math.random() * (this.colorMax.a - this.colorMin.a) + this.colorMin.a;
                }
                else if (this.mode === 1 /* Gradient */) {
                    return this.gradient.evaluate(t, out);
                }
                else if (this.mode === 3 /* TwoGradients */) {
                    this.gradientMin.evaluate(t, _helpColorA);
                    this.gradientMax.evaluate(t, _helpColorB);
                    out.r = (Math.random() * (_helpColorA.r - _helpColorB.r) + _helpColorA.r);
                    out.g = (Math.random() * (_helpColorA.g - _helpColorB.g) + _helpColorA.g);
                    out.b = (Math.random() * (_helpColorA.b - _helpColorB.b) + _helpColorA.b);
                    out.a = (Math.random() * (_helpColorA.a - _helpColorB.a) + _helpColorA.a);
                }
                else {
                    out.r = Math.random();
                    out.g = Math.random();
                    out.b = Math.random();
                    out.a = Math.random();
                }
                return out;
            };
            return MinMaxGradient;
        }());
        particle.MinMaxGradient = MinMaxGradient;
        __reflect(MinMaxGradient.prototype, "egret3d.particle.MinMaxGradient", ["paper.ISerializable"]);
        /**
         * 粒子模块基类。
         */
        var ParticleModule = (function (_super) {
            __extends(ParticleModule, _super);
            function ParticleModule(component) {
                var _this = _super.call(this) || this;
                _this.enable = false;
                _this._component = component;
                return _this;
            }
            ParticleModule.prototype.deserialize = function (_element) {
                this.enable = true;
                return this;
            };
            __decorate([
                paper.serializedField
            ], ParticleModule.prototype, "enable", void 0);
            return ParticleModule;
        }(paper.BaseObject));
        particle.ParticleModule = ParticleModule;
        __reflect(ParticleModule.prototype, "egret3d.particle.ParticleModule");
        /**
         *
         */
        var MainModule = (function (_super) {
            __extends(MainModule, _super);
            function MainModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 *
                 */
                _this.loop = false;
                /**
                 *
                 */
                _this.playOnAwake = false;
                /**
                 *
                 */
                _this.duration = 0.0;
                /**
                 *
                 */
                _this.startDelay = new MinMaxCurve();
                /**
                 *
                 */
                _this.startLifetime = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSpeed = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSizeX = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSizeY = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSizeZ = new MinMaxCurve();
                /**
                 *
                 */
                _this.startRotationX = new MinMaxCurve();
                /**
                 *
                 */
                _this.startRotationY = new MinMaxCurve();
                /**
                 *
                 */
                _this.startRotationZ = new MinMaxCurve();
                /**
                 *
                 */
                _this.startColor = new MinMaxGradient();
                /**
                 *
                 */
                _this.gravityModifier = new MinMaxCurve(); //TODO
                _this._startSize3D = false;
                _this._startRotation3D = false;
                _this._simulationSpace = 0 /* Local */;
                _this._scaleMode = 0 /* Hierarchy */;
                _this._maxParticles = 0;
                return _this;
            }
            MainModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.duration = element.duration;
                this.loop = element.loop || element.looping; // TODO 兼容代码 looping。
                this.startDelay.deserialize(element.startDelay);
                this.startLifetime.deserialize(element.startLifetime);
                this.startSpeed.deserialize(element.startSpeed);
                this._startSize3D = element.startSize3D || false;
                this.startSizeX.deserialize(element.startSizeX);
                this.startSizeY.deserialize(element.startSizeY);
                this.startSizeZ.deserialize(element.startSizeZ);
                this._startRotation3D = (element._startRotation3D || element.startRotation3D) || false;
                this.startRotationX.deserialize(element.startRotationX);
                this.startRotationY.deserialize(element.startRotationY);
                this.startRotationZ.deserialize(element.startRotationZ);
                this.startColor.deserialize(element.startColor);
                this.gravityModifier.deserialize(element.gravityModifier);
                this._simulationSpace = (element._simulationSpace || element.simulationSpace) || 0;
                this._scaleMode = (element._scaleMode || element.scaleMode) || 0 /* Hierarchy */;
                this.playOnAwake = element.playOnAwake;
                this._maxParticles = (element._maxParticles || element.maxParticles) || 0;
                return this;
            };
            Object.defineProperty(MainModule.prototype, "startSize3D", {
                get: function () {
                    return this._startSize3D;
                },
                set: function (value) {
                    if (this._startSize3D === value) {
                        return;
                    }
                    this._startSize3D = value;
                    particle.onStartSize3DChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "startRotation3D", {
                /**
                 *
                 */
                get: function () {
                    return this._startRotation3D;
                },
                set: function (value) {
                    if (this._startRotation3D === value) {
                        return;
                    }
                    this._startRotation3D = value;
                    particle.onStartRotation3DChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "simulationSpace", {
                /**
                 *
                 */
                get: function () {
                    return this._simulationSpace;
                },
                set: function (value) {
                    if (this._simulationSpace === value) {
                        return;
                    }
                    this._simulationSpace = value;
                    particle.onSimulationSpaceChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "scaleMode", {
                /**
                 *
                 */
                get: function () {
                    return this._scaleMode;
                },
                set: function (value) {
                    if (this._scaleMode === value) {
                        return;
                    }
                    this._scaleMode = value;
                    particle.onScaleModeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "maxParticles", {
                /**
                 *
                 */
                get: function () {
                    return this._maxParticles;
                },
                set: function (value) {
                    if (this._maxParticles === value) {
                        return;
                    }
                    this._maxParticles = value;
                    particle.onMaxParticlesChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "loop", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "playOnAwake", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "duration", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startDelay", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startLifetime", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSpeed", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startColor", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "gravityModifier", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_startSize3D", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_startRotation3D", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_simulationSpace", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_scaleMode", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_maxParticles", void 0);
            return MainModule;
        }(ParticleModule));
        particle.MainModule = MainModule;
        __reflect(MainModule.prototype, "egret3d.particle.MainModule");
        /**
         *
         */
        var EmissionModule = (function (_super) {
            __extends(EmissionModule, _super);
            function EmissionModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 *
                 */
                _this.rateOverTime = new MinMaxCurve();
                /**
                 *
                 */
                _this.bursts = [];
                return _this;
            }
            EmissionModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.rateOverTime.deserialize(element.rateOverTime);
                if (element.bursts) {
                    this.bursts.length = 0;
                    for (var i = 0, l = element.bursts.length; i < l; i++) {
                        var burst = new Burst();
                        burst.deserialize(element.bursts[i]);
                        this.bursts.push(burst);
                    }
                }
                return this;
            };
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "rateOverTime", void 0);
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "bursts", void 0);
            return EmissionModule;
        }(ParticleModule));
        particle.EmissionModule = EmissionModule;
        __reflect(EmissionModule.prototype, "egret3d.particle.EmissionModule");
        /**
         *
         */
        var ShapeModule = (function (_super) {
            __extends(ShapeModule, _super);
            function ShapeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 *
                 */
                _this.shapeType = 0 /* Sphere */;
                /**
                 *
                 */
                _this.radius = 0.0;
                /**
                 *
                 */
                _this.angle = 0.0;
                /**
                 *
                 */
                _this.length = 0.0;
                /**
                 *
                 */
                _this.arcSpeed = new MinMaxCurve();
                /**
                 *
                 */
                _this.arcMode = 0 /* Random */;
                _this.arc = 0.0;
                /**
                 *
                 */
                _this.radiusSpread = 0.0;
                /**
                 *
                 */
                _this.radiusMode = 0 /* Random */;
                /**
                 *
                 */
                _this.box = egret3d.Vector3.create();
                /**
                 *
                 */
                _this.randomDirection = false;
                /**
                 *
                 */
                _this.spherizeDirection = false;
                return _this;
            }
            ShapeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.shapeType = element.shapeType;
                this.radius = element.radius;
                this.angle = element.angle;
                this.length = element.length;
                this.arc = element.arc || 0.0;
                this.arcSpeed.deserialize(element.arcSpeed);
                this.arcMode = element.arcMode;
                this.radiusSpread = element.radiusSpread;
                this.radiusMode = element.radiusMode;
                this.box.deserialize(element.box);
                this.randomDirection = element.randomDirection;
                this.spherizeDirection = element.spherizeDirection;
                return this;
            };
            /**
             * @internal
             */
            ShapeModule.prototype.invalidUpdate = function () {
                particle.onShapeChanged.dispatch(this._component);
            };
            /**
             * @internal
             */
            ShapeModule.prototype.generatePositionAndDirection = function (position, direction) {
                particle.generatePositionAndDirection(position, direction, this);
            };
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "shapeType", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radius", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "angle", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "length", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcSpeed", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arc", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusSpread", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "box", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "randomDirection", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "spherizeDirection", void 0);
            return ShapeModule;
        }(ParticleModule));
        particle.ShapeModule = ShapeModule;
        __reflect(ShapeModule.prototype, "egret3d.particle.ShapeModule");
        /**
         *
         */
        var VelocityOverLifetimeModule = (function (_super) {
            __extends(VelocityOverLifetimeModule, _super);
            function VelocityOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._mode = 0 /* Constant */;
                _this._space = 0 /* Local */;
                _this._x = new MinMaxCurve();
                _this._y = new MinMaxCurve();
                _this._z = new MinMaxCurve();
                return _this;
            }
            VelocityOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._mode = (element._mode || element.mode) || 0 /* Constant */;
                this._space = (element._space || element.space) || 0 /* Local */;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "mode", {
                /**
                 *
                 */
                get: function () {
                    return this._mode;
                },
                set: function (value) {
                    if (this._mode === value) {
                        return;
                    }
                    this._mode = value;
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "space", {
                /**
                 *
                 */
                get: function () {
                    return this._space;
                },
                set: function (value) {
                    if (this._space === value) {
                        return;
                    }
                    this._space = value;
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "x", {
                /**
                 *
                 */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x.copy(value);
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "y", {
                /**
                 *
                 */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y.copy(value);
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "z", {
                /**
                 *
                 */
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z.copy(value);
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_mode", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_space", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_z", void 0);
            return VelocityOverLifetimeModule;
        }(ParticleModule));
        particle.VelocityOverLifetimeModule = VelocityOverLifetimeModule;
        __reflect(VelocityOverLifetimeModule.prototype, "egret3d.particle.VelocityOverLifetimeModule");
        /**
         *
         */
        var ColorOverLifetimeModule = (function (_super) {
            __extends(ColorOverLifetimeModule, _super);
            function ColorOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._color = new MinMaxGradient(); // TODO readonly
                return _this;
            }
            ColorOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._color.deserialize(element._color || element.color);
                return this;
            };
            Object.defineProperty(ColorOverLifetimeModule.prototype, "color", {
                /**
                 *
                 */
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._color = value; // TODO copy
                    particle.onColorChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ColorOverLifetimeModule.prototype, "_color", void 0);
            return ColorOverLifetimeModule;
        }(ParticleModule));
        particle.ColorOverLifetimeModule = ColorOverLifetimeModule;
        __reflect(ColorOverLifetimeModule.prototype, "egret3d.particle.ColorOverLifetimeModule");
        /**
         *
         */
        var SizeOverLifetimeModule = (function (_super) {
            __extends(SizeOverLifetimeModule, _super);
            function SizeOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._separateAxes = false;
                _this._size = new MinMaxCurve();
                _this._x = new MinMaxCurve();
                _this._y = new MinMaxCurve();
                _this._z = new MinMaxCurve();
                return _this;
            }
            SizeOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._size.deserialize(element._size || element.size);
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(SizeOverLifetimeModule.prototype, "separateAxes", {
                /**
                 *
                 */
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes === value) {
                        return;
                    }
                    this._separateAxes = value;
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "size", {
                /**
                 *
                 */
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    this._size.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "x", {
                /**
                 *
                 */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "y", {
                /**
                 *
                 */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "z", {
                /**
                 *
                 */
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_size", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_z", void 0);
            return SizeOverLifetimeModule;
        }(ParticleModule));
        particle.SizeOverLifetimeModule = SizeOverLifetimeModule;
        __reflect(SizeOverLifetimeModule.prototype, "egret3d.particle.SizeOverLifetimeModule");
        /**
         *
         */
        var RotationOverLifetimeModule = (function (_super) {
            __extends(RotationOverLifetimeModule, _super);
            function RotationOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._separateAxes = false;
                _this._x = new MinMaxCurve();
                _this._y = new MinMaxCurve();
                _this._z = new MinMaxCurve();
                return _this;
            }
            RotationOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(RotationOverLifetimeModule.prototype, "separateAxes", {
                /**
                 *
                 */
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes === value) {
                        return;
                    }
                    this._separateAxes = value;
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "x", {
                /**
                 *
                 */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x.copy(value);
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "y", {
                /**
                 *
                 */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y.copy(value);
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "z", {
                /**
                 *
                 */
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z.copy(value);
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_z", void 0);
            return RotationOverLifetimeModule;
        }(ParticleModule));
        particle.RotationOverLifetimeModule = RotationOverLifetimeModule;
        __reflect(RotationOverLifetimeModule.prototype, "egret3d.particle.RotationOverLifetimeModule");
        /**
         *
         */
        var TextureSheetAnimationModule = (function (_super) {
            __extends(TextureSheetAnimationModule, _super);
            function TextureSheetAnimationModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._useRandomRow = false;
                _this._animation = 0 /* WholeSheet */;
                _this._numTilesX = 1;
                _this._numTilesY = 1;
                _this._cycleCount = 1;
                _this._rowIndex = 0;
                _this._frameOverTime = new MinMaxCurve();
                _this._startFrame = new MinMaxCurve();
                _this._floatValues = new Float32Array(4);
                return _this;
            }
            TextureSheetAnimationModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._numTilesX = (element._numTilesX || element.numTilesX) || 0;
                this._numTilesY = (element._numTilesY || element.numTilesY) || 0;
                this._animation = (element._animation || element.animation) || 0 /* WholeSheet */;
                this._useRandomRow = (element._useRandomRow || element.useRandomRow) || false;
                this._frameOverTime.deserialize(element._frameOverTime || element.frameOverTime);
                this._startFrame.deserialize(element._startFrame || element.startFrame);
                this._cycleCount = (element._cycleCount || element.cycleCount) || 0;
                this._rowIndex = (element._rowIndex || element.rowIndex) || 0;
                return this;
            };
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesX", {
                /**
                 *
                 */
                get: function () {
                    return this._numTilesX;
                },
                set: function (value) {
                    if (this._numTilesX === value) {
                        return;
                    }
                    this._numTilesX = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesY", {
                /**
                 *
                 */
                get: function () {
                    return this._numTilesY;
                },
                set: function (value) {
                    if (this._numTilesY === value) {
                        return;
                    }
                    this._numTilesY = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "animation", {
                /**
                 *
                 */
                get: function () {
                    return this._animation;
                },
                set: function (value) {
                    if (this._animation === value) {
                        return;
                    }
                    this._animation = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "useRandomRow", {
                /**
                 *
                 */
                get: function () {
                    return this._useRandomRow;
                },
                set: function (value) {
                    if (this._useRandomRow === value) {
                        return;
                    }
                    this._useRandomRow = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "frameOverTime", {
                /**
                 *
                 */
                get: function () {
                    return this._frameOverTime;
                },
                set: function (value) {
                    this._frameOverTime.copy(value);
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "startFrame", {
                /**
                 *
                 */
                get: function () {
                    return this._startFrame;
                },
                set: function (value) {
                    this._startFrame.copy(value);
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "cycleCount", {
                /**
                 *
                 */
                get: function () {
                    return this._cycleCount;
                },
                set: function (value) {
                    if (this._cycleCount === value) {
                        return;
                    }
                    this._cycleCount = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "rowIndex", {
                /**
                 *
                 */
                get: function () {
                    return this._rowIndex;
                },
                set: function (value) {
                    if (this._rowIndex === value) {
                        return;
                    }
                    this._rowIndex = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    if (this.enable) {
                        var subU = 1.0 / this._numTilesX;
                        var subV = 1.0 / this._numTilesY;
                        var startFrmaeCount = Math.floor(this._startFrame.constant);
                        var startRow = 0;
                        switch (this._animation) {
                            case 1 /* SingleRow */:
                                {
                                    if (this._useRandomRow) {
                                        startRow = Math.floor(Math.random() * this._numTilesY);
                                    }
                                    else {
                                        startRow = this._rowIndex;
                                    }
                                    break;
                                }
                            case 0 /* WholeSheet */:
                                {
                                    startRow = Math.floor(startFrmaeCount / this._numTilesX);
                                    break;
                                }
                        }
                        var startCol = Math.floor(startFrmaeCount % this._numTilesX);
                        res[0] = subU;
                        res[1] = subV;
                        res[2] = startCol * subU;
                        res[3] = startRow * subV;
                    }
                    else {
                        res[0] = 1.0;
                        res[1] = 1.0;
                        res[2] = 0.0;
                        res[3] = 0.0;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_useRandomRow", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_animation", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesX", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesY", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_cycleCount", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_rowIndex", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_frameOverTime", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_startFrame", void 0);
            return TextureSheetAnimationModule;
        }(ParticleModule));
        particle.TextureSheetAnimationModule = TextureSheetAnimationModule;
        __reflect(TextureSheetAnimationModule.prototype, "egret3d.particle.TextureSheetAnimationModule");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        //
        var positionHelper = new egret3d.Vector3();
        var velocityHelper = new egret3d.Vector3();
        var startSizeHelper = new egret3d.Vector3();
        var startColorHelper = egret3d.Color.create();
        var startRotationHelper = new egret3d.Vector3();
        var GRAVITY = new egret3d.Vector3(0, -9.81, 0); //TODO没有物理系统，暂时先放到这里
        /**
         * @internal
         */
        var ParticleBatcher = (function () {
            function ParticleBatcher() {
                this._dirty = false;
                this._time = 0.0;
                this._emittsionTime = 0;
                this._frameRateTime = 0;
                //最新存活位置
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                //最后存活位置
                this._lastAliveCursor = 0;
                this._forceUpdate = false;
                //原始顶点数量
                this._vertexStride = 0;
                //当前爆发的索引
                this._burstIndex = 0;
                //
                this._readEmitCount = 0;
                //最终重力
                this._finalGravity = new egret3d.Vector3();
            }
            /**
            * 计算粒子爆发数量
            * @param startTime
            * @param endTime
            */
            ParticleBatcher.prototype._getBurstCount = function (startTime, endTime) {
                var totalEmitCount = 0;
                var bursts = this._comp.emission.bursts;
                for (var l = bursts.length; this._burstIndex < l; this._burstIndex++) {
                    var burst = bursts[this._burstIndex];
                    if (burst.time >= startTime && burst.time < endTime) {
                        // totalEmitCount += numberLerp(burst.minCount, burst.maxCount, Math.random());
                        totalEmitCount += burst.maxCount;
                    }
                    else {
                        break;
                    }
                }
                return totalEmitCount;
            };
            /**
             * 判断粒子是否已经过期
             * @param particleIndex
             */
            ParticleBatcher.prototype._isParticleExpired = function (particleIndex) {
                var startTimeOffset = particleIndex * this._vertexStride * 2;
                return this._time - this._startTimeBuffer[startTimeOffset + 1] + 0.0001 > this._startTimeBuffer[startTimeOffset];
            };
            /**
             *
             * @param time 批量增加粒子
             * @param startCursor
             * @param endCursor
             */
            ParticleBatcher.prototype._addParticles = function (time, startCursor, count, lastEmittsionTime) {
                var comp = this._comp;
                var main = comp.main;
                var velocityModule = comp.velocityOverLifetime;
                var colorModule = comp.colorOverLifetime;
                var sizeModule = comp.sizeOverLifetime;
                var rotationModule = comp.rotationOverLifetime;
                var textureSheetModule = comp.textureSheetAnimation;
                var isVelocityRandom = velocityModule.enable && (velocityModule.mode === 3 /* TwoConstants */ || velocityModule.mode === 2 /* TwoCurves */);
                var isColorRandom = colorModule.enable && colorModule.color.mode === 3 /* TwoGradients */;
                var isSizeRandom = sizeModule.enable && (sizeModule.size.mode === 3 /* TwoConstants */ || sizeModule.size.mode === 2 /* TwoCurves */);
                var isRotationRandom = rotationModule.enable && (rotationModule.x.mode === 3 /* TwoConstants */ || rotationModule.x.mode === 2 /* TwoCurves */);
                var isTextureRandom = textureSheetModule.enable && (textureSheetModule.startFrame.mode === 3 /* TwoConstants */ || textureSheetModule.startFrame.mode === 2 /* TwoCurves */);
                var needRandom0 = isColorRandom || isSizeRandom || isRotationRandom || isTextureRandom;
                var worldPosition = this._worldPostionCache;
                var worldRotation = this._worldRotationCache;
                var isWorldSpace = main.simulationSpace === 1 /* World */;
                var startPositionBuffer = this._startPositionBuffer;
                var startVelocityBuffer = this._startVelocityBuffer;
                var startColorBuffer = this._startColorBuffer;
                var startSizeBuffer = this._startSizeBuffer;
                var startRotationBuffer = this._startRotationBuffer;
                var startTimeBuffer = this._startTimeBuffer;
                var random0Buffer = this._random0Buffer;
                var random1Buffer = this._random1Buffer;
                var worldPostionBuffer = this._worldPostionBuffer;
                var worldRoationBuffer = this._worldRoationBuffer;
                var isSize3D = main.startSize3D;
                var isRotation3D = main.startRotation3D;
                var age = Math.min(lastEmittsionTime / main.duration, 1.0);
                var vertexStride = this._vertexStride;
                var addCount = 0, startIndex = 0, endIndex = 0;
                var lifetime = 0.0;
                var startSpeed = 0.0;
                var startSize = 0.0;
                var randomVelocityX = 0.0, randomVelocityY = 0.0, randomVelocityZ = 0.0;
                var randomColor = 0.0, randomSize = 0.0, randomRotation = 0.0, randomTextureAnimation = 0.0;
                var vector2Offset = 0, vector3Offset = 0, vector4Offset = 0;
                while (addCount !== count) {
                    comp.shape.generatePositionAndDirection(positionHelper, velocityHelper);
                    main.startColor.evaluate(age, startColorHelper);
                    lifetime = main.startLifetime.evaluate(age);
                    startSpeed = main.startSpeed.evaluate(age);
                    velocityHelper.x *= startSpeed;
                    velocityHelper.y *= startSpeed;
                    velocityHelper.z *= startSpeed;
                    if (isSize3D) {
                        startSizeHelper.x = main.startSizeX.evaluate(age);
                        startSizeHelper.y = main.startSizeY.evaluate(age);
                        startSizeHelper.z = main.startSizeZ.evaluate(age);
                    }
                    else {
                        startSize = main.startSizeX.evaluate(age);
                        startSizeHelper.x = startSize;
                        startSizeHelper.y = startSize;
                        startSizeHelper.z = startSize;
                    }
                    if (isRotation3D) {
                        startRotationHelper.x = main.startRotationX.evaluate(age);
                        startRotationHelper.y = main.startRotationY.evaluate(age);
                        startRotationHelper.z = main.startRotationZ.evaluate(age);
                    }
                    else {
                        startRotationHelper.x = main.startRotationX.evaluate(age);
                    }
                    randomVelocityX = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityY = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityZ = isVelocityRandom ? Math.random() : 0.0;
                    randomColor = isColorRandom ? Math.random() : 0.0;
                    randomSize = isSizeRandom ? Math.random() : 0.0;
                    randomRotation = isRotationRandom ? Math.random() : 0.0;
                    randomTextureAnimation = isTextureRandom ? Math.random() : 0.0;
                    for (startIndex = startCursor * vertexStride, endIndex = startIndex + vertexStride; startIndex < endIndex; startIndex++) {
                        vector2Offset = startIndex * 2;
                        vector3Offset = startIndex * 3;
                        vector4Offset = startIndex * 4;
                        //
                        startPositionBuffer[vector3Offset] = positionHelper.x;
                        startPositionBuffer[vector3Offset + 1] = positionHelper.y;
                        startPositionBuffer[vector3Offset + 2] = positionHelper.z;
                        startVelocityBuffer[vector3Offset] = velocityHelper.x;
                        startVelocityBuffer[vector3Offset + 1] = velocityHelper.y;
                        startVelocityBuffer[vector3Offset + 2] = velocityHelper.z;
                        startColorBuffer[vector4Offset] = startColorHelper.r;
                        startColorBuffer[vector4Offset + 1] = startColorHelper.g;
                        startColorBuffer[vector4Offset + 2] = startColorHelper.b;
                        startColorBuffer[vector4Offset + 3] = startColorHelper.a;
                        startSizeBuffer[vector3Offset] = startSizeHelper.x;
                        startSizeBuffer[vector3Offset + 1] = startSizeHelper.y;
                        startSizeBuffer[vector3Offset + 2] = startSizeHelper.z;
                        startRotationBuffer[vector3Offset] = startRotationHelper.x;
                        startRotationBuffer[vector3Offset + 1] = startRotationHelper.y;
                        startRotationBuffer[vector3Offset + 2] = startRotationHelper.z;
                        startTimeBuffer[vector2Offset] = lifetime;
                        startTimeBuffer[vector2Offset + 1] = time;
                        //
                        if (needRandom0) {
                            random0Buffer[vector4Offset] = randomColor;
                            random0Buffer[vector4Offset + 1] = randomSize;
                            random0Buffer[vector4Offset + 2] = randomRotation;
                            random0Buffer[vector4Offset + 3] = randomTextureAnimation;
                        }
                        if (isVelocityRandom) {
                            random1Buffer[vector4Offset] = randomVelocityX;
                            random1Buffer[vector4Offset + 1] = randomVelocityY;
                            random1Buffer[vector4Offset + 2] = randomVelocityZ;
                            random1Buffer[vector4Offset + 3] = 0;
                        }
                        if (isWorldSpace) {
                            worldPostionBuffer[vector3Offset] = worldPosition.x;
                            worldPostionBuffer[vector3Offset + 1] = worldPosition.y;
                            worldPostionBuffer[vector3Offset + 2] = worldPosition.z;
                            worldRoationBuffer[vector4Offset] = worldRotation.x;
                            worldRoationBuffer[vector4Offset + 1] = worldRotation.y;
                            worldRoationBuffer[vector4Offset + 2] = worldRotation.z;
                            worldRoationBuffer[vector4Offset + 3] = worldRotation.w;
                        }
                    }
                    startCursor++;
                    if (startCursor >= main.maxParticles) {
                        startCursor = 0;
                    }
                    addCount++;
                }
                //TODO理论上应该是每帧更新，不过现在没有物理系统，先放到这里
                var gravityModifier = main.gravityModifier.constant;
                this._finalGravity.x = GRAVITY.x * gravityModifier;
                this._finalGravity.y = GRAVITY.y * gravityModifier;
                this._finalGravity.z = GRAVITY.z * gravityModifier;
            };
            ParticleBatcher.prototype._tryEmit = function () {
                if (!this._isParticleExpired(this._firstAliveCursor)) {
                    return false;
                }
                //
                var maxParticles = this._comp.main.maxParticles;
                var nextCursor = this._firstAliveCursor + 1 >= maxParticles ? 0 : this._firstAliveCursor + 1;
                //
                if (nextCursor === this._lastAliveCursor) {
                    this._forceUpdate = true;
                }
                this._firstAliveCursor = nextCursor;
                return true;
            };
            ParticleBatcher.prototype.clean = function () {
                this._time = 0.0;
                this._dirty = false;
                this._emittsionTime = 0.0;
                this._frameRateTime = 0.0;
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                this._lastAliveCursor = 0;
                this._forceUpdate = false;
                this._vertexStride = 0;
                this._vertexAttributes = null;
                this._burstIndex = 0;
                this._readEmitCount = 0;
                this._startPositionBuffer = null;
                this._startVelocityBuffer = null;
                this._startColorBuffer = null;
                this._startSizeBuffer = null;
                this._startRotationBuffer = null;
                this._startTimeBuffer = null;
                this._random0Buffer = null;
                this._random1Buffer = null;
                this._worldPostionBuffer = null;
                this._worldRoationBuffer = null;
                this._worldPostionCache = null;
                this._worldRotationCache = null;
                this._comp = null;
                this._renderer = null;
            };
            ParticleBatcher.prototype.resetTime = function () {
                this._burstIndex = 0;
                this._emittsionTime = 0;
                this._readEmitCount = 0;
            };
            ParticleBatcher.prototype.init = function (comp, renderer) {
                this._comp = comp;
                this._renderer = renderer;
                var mesh = particle.createBatchMesh(renderer, comp.main.maxParticles);
                this._vertexStride = renderer.renderMode === 4 /* Mesh */ ? renderer.mesh.vertexCount : 4;
                this._startPositionBuffer = mesh.getAttributes("_START_POSITION" /* _START_POSITION */);
                this._startVelocityBuffer = mesh.getAttributes("_START_VELOCITY" /* _START_VELOCITY */);
                this._startColorBuffer = mesh.getAttributes("_START_COLOR" /* _START_COLOR */);
                this._startSizeBuffer = mesh.getAttributes("_START_SIZE" /* _START_SIZE */);
                this._startRotationBuffer = mesh.getAttributes("_START_ROTATION" /* _START_ROTATION */);
                this._startTimeBuffer = mesh.getAttributes("_TIME" /* _TIME */);
                this._random0Buffer = mesh.getAttributes("_RANDOM0" /* _RANDOM0 */);
                this._random1Buffer = mesh.getAttributes("_RANDOM1" /* _RANDOM1 */);
                this._worldPostionBuffer = mesh.getAttributes("_WORLD_POSITION" /* _WORLD_POSITION */);
                this._worldRoationBuffer = mesh.getAttributes("_WORLD_ROTATION" /* _WORLD_ROTATION */);
                var primitive = mesh.glTFMesh.primitives[0];
                this._vertexAttributes = [];
                for (var k in primitive.attributes) {
                    this._vertexAttributes.push(k);
                }
                renderer.batchMesh = mesh;
                renderer.batchMaterial = renderer.materials[0].clone();
                mesh.uploadSubIndexBuffer();
            };
            ParticleBatcher.prototype.update = function (elapsedTime) {
                if (!this._comp || this._comp.isPaused) {
                    return;
                }
                //
                this._time += elapsedTime;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                while (this._lastAliveCursor !== this._firstAliveCursor || this._forceUpdate) {
                    if (!this._isParticleExpired(this._lastAliveCursor)) {
                        break;
                    }
                    this._forceUpdate = false;
                    this._lastAliveCursor++;
                    if (this._lastAliveCursor >= mainModule.maxParticles) {
                        this._lastAliveCursor = 0;
                    }
                }
                var transform = comp.gameObject.transform;
                this._worldPostionCache = transform.position.clone();
                this._worldRotationCache = transform.rotation.clone();
                if (comp._isPlaying && this._time >= mainModule.startDelay.constant && comp.emission.enable) {
                    this._updateEmission(elapsedTime);
                }
                this._updateRender();
            };
            ParticleBatcher.prototype._updateEmission = function (elapsedTime) {
                var comp = this._comp;
                var mainModule = comp.main;
                var lastEmittsionTime = this._emittsionTime;
                this._emittsionTime += elapsedTime;
                var isOver = this._emittsionTime > mainModule.duration;
                var aliveParticleCount = this.aliveParticleCount;
                var totalEmitCount = 0;
                if (!isOver) {
                    if (comp.emission.bursts.length > 0) {
                        this._readEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                    }
                }
                else {
                    if (mainModule.loop) {
                        this._readEmitCount = 0;
                        this._readEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                        this._emittsionTime -= mainModule.duration;
                        this._burstIndex = 0;
                        this._readEmitCount += this._getBurstCount(0, this._emittsionTime);
                    }
                    else {
                        comp.stop(false);
                    }
                }
                //
                for (var i = 0; i < this._readEmitCount; i++) {
                    if (this._tryEmit()) {
                        totalEmitCount++;
                        this._readEmitCount--;
                    }
                }
                var rateOverTime = comp.emission.rateOverTime.constant;
                if (rateOverTime > 0) {
                    var minEmissionTime = 1 / rateOverTime;
                    this._frameRateTime += elapsedTime;
                    while (this._frameRateTime > minEmissionTime) {
                        if (!this._tryEmit()) {
                            break;
                        }
                        totalEmitCount++;
                        this._frameRateTime -= minEmissionTime;
                    }
                }
                totalEmitCount = Math.min(mainModule.maxParticles - aliveParticleCount, totalEmitCount);
                if (totalEmitCount > 0 && !isOver) {
                    this._addParticles(this._time, this._lastFrameFirstCursor, totalEmitCount, lastEmittsionTime);
                    this._dirty = true;
                }
            };
            ParticleBatcher.prototype._updateRender = function () {
                var renderer = this._renderer;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                if (this._dirty) {
                    // renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes);
                    var bufferOffset = this._lastFrameFirstCursor * this._vertexStride;
                    if (this._firstAliveCursor > this._lastFrameFirstCursor) {
                        var bufferCount = (this._firstAliveCursor - this._lastFrameFirstCursor) * this._vertexStride;
                        renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, bufferCount);
                    }
                    else {
                        var addCount = mainModule.maxParticles - this._lastFrameFirstCursor;
                        renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, addCount * this._vertexStride);
                        renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, 0, this._firstAliveCursor * this._vertexStride);
                    }
                    this._lastFrameFirstCursor = this._firstAliveCursor;
                    this._dirty = false;
                }
                var transform = comp.gameObject.transform;
                var material = renderer.batchMaterial;
                if (mainModule.simulationSpace === 0 /* Local */) {
                    material.setVector3("u_worldPosition" /* WORLD_POSITION */, this._worldPostionCache);
                    material.setVector4("u_worldRotation" /* WORLD_ROTATION */, this._worldRotationCache);
                }
                //
                switch (mainModule.scaleMode) {
                    case 1 /* Local */:
                        {
                            var scale = transform.localScale;
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                    case 2 /* Shape */:
                        {
                            var scale = transform.scale;
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, egret3d.Vector3.ONE);
                        }
                        break;
                    case 0 /* Hierarchy */:
                        {
                            var scale = transform.scale;
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                }
                material.setFloat("u_currentTime" /* CURRENTTIME */, this._time);
                material.setVector3("u_gravity" /* GRAVIT */, this._finalGravity);
            };
            Object.defineProperty(ParticleBatcher.prototype, "aliveParticleCount", {
                get: function () {
                    if (this._firstAliveCursor >= this._lastAliveCursor) {
                        return this._firstAliveCursor - this._lastAliveCursor;
                    }
                    else {
                        return this._comp.main.maxParticles - this._lastAliveCursor + this._firstAliveCursor;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return ParticleBatcher;
        }());
        particle.ParticleBatcher = ParticleBatcher;
        __reflect(ParticleBatcher.prototype, "egret3d.particle.ParticleBatcher");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         * 粒子组件。
         */
        var ParticleComponent = (function (_super) {
            __extends(ParticleComponent, _super);
            function ParticleComponent() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * 主模块。
                 */
                _this.main = new particle.MainModule(_this);
                /**
                 * 发射模块。
                 */
                _this.emission = new particle.EmissionModule(_this);
                /**
                 * 发射形状模块。
                 */
                _this.shape = new particle.ShapeModule(_this);
                /**
                 * 速率变换模块。
                 */
                _this.velocityOverLifetime = new particle.VelocityOverLifetimeModule(_this);
                /**
                 * 旋转变换模块。
                 */
                _this.rotationOverLifetime = new particle.RotationOverLifetimeModule(_this);
                /**
                 * 尺寸变化模块。
                 */
                _this.sizeOverLifetime = new particle.SizeOverLifetimeModule(_this);
                /**
                 * 颜色变化模块。
                 */
                _this.colorOverLifetime = new particle.ColorOverLifetimeModule(_this);
                /**
                 * 序列帧变化模块。
                 */
                _this.textureSheetAnimation = new particle.TextureSheetAnimationModule(_this);
                /**
                 * @internal
                 */
                _this._isPlaying = false;
                /**
                 * @internal
                 */
                _this._isPaused = false;
                _this._timeScale = 1.0;
                _this._batcher = new particle.ParticleBatcher();
                return _this;
            }
            ParticleComponent.prototype._clean = function (cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = false; }
                if (cleanPlayState) {
                    this._isPlaying = false;
                    this._isPaused = false;
                }
                this._batcher.clean();
            };
            ParticleComponent.prototype.initialize = function () {
                _super.prototype.initialize.call(this);
                this._clean();
            };
            ParticleComponent.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initBatcher = function (cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = false; }
                this._clean(cleanPlayState);
                this._batcher.init(this, this.gameObject.getComponent(particle.ParticleRenderer));
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.update = function (elapsedTime) {
                this._batcher.update(elapsedTime * this._timeScale);
            };
            ParticleComponent.prototype.play = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (this._isPaused) {
                    this._isPaused = false;
                }
                else {
                    this._isPlaying = true;
                    this._isPaused = false;
                    this._batcher.resetTime();
                }
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                        var child = children_1[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.play(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.pause = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPaused = true;
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
                        var child = children_2[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.pause(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.stop = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPlaying = false;
                this._batcher.resetTime();
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                        var child = children_3[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.clear = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                        var child = children_4[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            Object.defineProperty(ParticleComponent.prototype, "timeScale", {
                /**
                 * 播放速度    不能小于0
                 */
                get: function () {
                    return this._timeScale;
                },
                set: function (value) {
                    if (value < 0.0) {
                        value = 0.0;
                    }
                    this._timeScale = value;
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_5 = children; _i < children_5.length; _i++) {
                        var child = children_5[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp) {
                            particleComp.timeScale = value;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPlaying", {
                get: function () {
                    return this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPaused", {
                get: function () {
                    return this._isPaused;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isAlive", {
                get: function () {
                    return this._batcher.aliveParticleCount > 0 || this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "loop", {
                get: function () {
                    return this.main.loop;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "main", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "emission", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "shape", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "velocityOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "rotationOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "sizeOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "colorOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "textureSheetAnimation", void 0);
            __decorate([
                paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
            ], ParticleComponent.prototype, "timeScale", null);
            return ParticleComponent;
        }(paper.BaseComponent));
        particle.ParticleComponent = ParticleComponent;
        __reflect(ParticleComponent.prototype, "egret3d.particle.ParticleComponent");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var _helpMatrix = egret3d.Matrix4.create();
        /**
         * 粒子渲染模式。
         */
        var ParticleRenderMode;
        (function (ParticleRenderMode) {
            ParticleRenderMode[ParticleRenderMode["Billboard"] = 0] = "Billboard";
            ParticleRenderMode[ParticleRenderMode["Stretch"] = 1] = "Stretch";
            ParticleRenderMode[ParticleRenderMode["HorizontalBillboard"] = 2] = "HorizontalBillboard";
            ParticleRenderMode[ParticleRenderMode["VerticalBillboard"] = 3] = "VerticalBillboard";
            ParticleRenderMode[ParticleRenderMode["Mesh"] = 4] = "Mesh";
            ParticleRenderMode[ParticleRenderMode["None"] = 5] = "None";
        })(ParticleRenderMode = particle.ParticleRenderMode || (particle.ParticleRenderMode = {}));
        /**
         * 粒子着色器的变量名。
         * @internal
         */
        var ParticleMaterialUniform;
        (function (ParticleMaterialUniform) {
            ParticleMaterialUniform["WORLD_POSITION"] = "u_worldPosition";
            ParticleMaterialUniform["WORLD_ROTATION"] = "u_worldRotation";
            ParticleMaterialUniform["POSITION_SCALE"] = "u_positionScale";
            ParticleMaterialUniform["SIZE_SCALE"] = "u_sizeScale";
            ParticleMaterialUniform["SCALING_MODE"] = "u_scalingMode";
            ParticleMaterialUniform["GRAVIT"] = "u_gravity";
            ParticleMaterialUniform["START_SIZE3D"] = "START_SIZE3D";
            ParticleMaterialUniform["START_ROTATION3D"] = "u_startRotation3D";
            ParticleMaterialUniform["SIMULATION_SPACE"] = "u_simulationSpace";
            ParticleMaterialUniform["CURRENTTIME"] = "u_currentTime";
            ParticleMaterialUniform["ALPHAS_GRADIENT"] = "u_alphaGradient[0]";
            ParticleMaterialUniform["COLOR_GRADIENT"] = "u_colorGradient[0]";
            ParticleMaterialUniform["ALPHA_GRADIENT_MAX"] = "u_alphaGradientMax[0]";
            ParticleMaterialUniform["COLOR_GRADIENT_MAX"] = "u_colorGradientMax[0]";
            ParticleMaterialUniform["VELOCITY_CONST"] = "u_velocityConst";
            ParticleMaterialUniform["VELOCITY_CURVE_X"] = "u_velocityCurveX[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_Y"] = "u_velocityCurveY[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_Z"] = "u_velocityCurveZ[0]";
            ParticleMaterialUniform["VELOCITY_CONST_MAX"] = "u_velocityConstMax";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_X"] = "u_velocityCurveMaxX[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_Y"] = "u_velocityCurveMaxY[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_Z"] = "u_velocityCurveMaxZ[0]";
            ParticleMaterialUniform["SPACE_TYPE"] = "u_spaceType";
            ParticleMaterialUniform["SIZE_CURVE"] = "u_sizeCurve[0]";
            ParticleMaterialUniform["SIZE_CURVE_X"] = "u_sizeCurveX[0]";
            ParticleMaterialUniform["SIZE_CURVE_Y"] = "u_sizeCurveY[0]";
            ParticleMaterialUniform["SIZE_CURVE_Z"] = "u_sizeCurveZ[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX"] = "u_sizeCurveMax[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_X"] = "u_sizeCurveMaxX[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_Y"] = "u_sizeCurveMaxY[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_Z"] = "u_sizeCurveMaxZ[0]";
            ParticleMaterialUniform["ROTATION_CONST"] = "u_rotationConst";
            ParticleMaterialUniform["ROTATION_CONST_SEPRARATE"] = "u_rotationConstSeprarate";
            ParticleMaterialUniform["ROTATION_CURVE"] = "u_rotationCurve[0]";
            ParticleMaterialUniform["ROTATE_CURVE_X"] = "u_rotationCurveX[0]";
            ParticleMaterialUniform["ROTATE_CURVE_y"] = "u_rotationCurveY[0]";
            ParticleMaterialUniform["ROTATE_CURVE_Z"] = "u_rotationCurveZ[0]";
            ParticleMaterialUniform["ROTATE_CURVE_W"] = "u_rotationCurveW[0]";
            ParticleMaterialUniform["ROTATION_CONST_MAX"] = "u_rotationConstMax";
            ParticleMaterialUniform["ROTATION_CONST_MAX_SEPRARATE"] = "u_rotationConstMaxSeprarate";
            ParticleMaterialUniform["ROTATION_CURVE_MAX"] = "u_rotationCurveMax[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_X"] = "u_rotationCurveMaxX[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_Y"] = "u_rotationCurveMaxY[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_Z"] = "u_rotationCurveMaxZ[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_W"] = "u_rotationCurveMaxW[0]";
            ParticleMaterialUniform["CYCLES"] = "u_cycles";
            ParticleMaterialUniform["SUB_UV"] = "u_subUV";
            ParticleMaterialUniform["UV_CURVE"] = "u_uvCurve[0]";
            ParticleMaterialUniform["UV_CURVE_MAX"] = "u_uvCurveMax[0]";
            ParticleMaterialUniform["LENGTH_SCALE"] = "u_lengthScale";
            ParticleMaterialUniform["SPEED_SCALE"] = "u_speeaScale";
        })(ParticleMaterialUniform = particle.ParticleMaterialUniform || (particle.ParticleMaterialUniform = {}));
        /**
         * 粒子着色器的宏定义。
         * @internal
         */
        var ParticleMaterialDefine;
        (function (ParticleMaterialDefine) {
            ParticleMaterialDefine["SPHERHBILLBOARD"] = "SPHERHBILLBOARD";
            ParticleMaterialDefine["STRETCHEDBILLBOARD"] = "STRETCHEDBILLBOARD";
            ParticleMaterialDefine["HORIZONTALBILLBOARD"] = "HORIZONTALBILLBOARD";
            ParticleMaterialDefine["VERTICALBILLBOARD"] = "VERTICALBILLBOARD";
            ParticleMaterialDefine["ROTATIONOVERLIFETIME"] = "ROTATIONOVERLIFETIME";
            ParticleMaterialDefine["ROTATIONCONSTANT"] = "ROTATIONCONSTANT";
            ParticleMaterialDefine["ROTATIONTWOCONSTANTS"] = "ROTATIONTWOCONSTANTS";
            ParticleMaterialDefine["ROTATIONSEPERATE"] = "ROTATIONSEPERATE";
            ParticleMaterialDefine["ROTATIONCURVE"] = "ROTATIONCURVE";
            ParticleMaterialDefine["ROTATIONTWOCURVES"] = "ROTATIONTWOCURVES";
            ParticleMaterialDefine["TEXTURESHEETANIMATIONCURVE"] = "TEXTURESHEETANIMATIONCURVE";
            ParticleMaterialDefine["TEXTURESHEETANIMATIONTWOCURVE"] = "TEXTURESHEETANIMATIONTWOCURVE";
            ParticleMaterialDefine["VELOCITYCONSTANT"] = "VELOCITYCONSTANT";
            ParticleMaterialDefine["VELOCITYCURVE"] = "VELOCITYCURVE";
            ParticleMaterialDefine["VELOCITYTWOCONSTANT"] = "VELOCITYTWOCONSTANT";
            ParticleMaterialDefine["VELOCITYTWOCURVE"] = "VELOCITYTWOCURVE";
            ParticleMaterialDefine["COLOROGRADIENT"] = "COLOROGRADIENT";
            ParticleMaterialDefine["COLORTWOGRADIENTS"] = "COLORTWOGRADIENTS";
            ParticleMaterialDefine["SIZECURVE"] = "SIZECURVE";
            ParticleMaterialDefine["SIZETWOCURVES"] = "SIZETWOCURVES";
            ParticleMaterialDefine["SIZECURVESEPERATE"] = "SIZECURVESEPERATE";
            ParticleMaterialDefine["SIZETWOCURVESSEPERATE"] = "SIZETWOCURVESSEPERATE";
            ParticleMaterialDefine["RENDERMESH"] = "RENDERMESH";
            ParticleMaterialDefine["SHAPE"] = "SHAPE";
        })(ParticleMaterialDefine = particle.ParticleMaterialDefine || (particle.ParticleMaterialDefine = {}));
        /**
         * 粒子渲染器。
         */
        var ParticleRenderer = (function (_super) {
            __extends(ParticleRenderer, _super);
            function ParticleRenderer() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * TODO
                 */
                _this.frustumCulled = false;
                _this.velocityScale = 1.0;
                _this.lengthScale = 1.0;
                _this._renderMode = 0 /* Billboard */;
                _this._mesh = null;
                return _this;
            }
            ParticleRenderer.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                if (this._mesh) {
                    this._mesh.release();
                }
                this._renderMode = 0 /* Billboard */;
                this.velocityScale = 1.0;
                this.lengthScale = 1.0;
                this._mesh = null;
            };
            ParticleRenderer.prototype.recalculateLocalBox = function () {
                this._localBoundingBox.copy(egret3d.Box.ONE);
            };
            ParticleRenderer.prototype.raycast = function (p1, p2, p3) {
                var raycastMesh = false;
                var raycastInfo = undefined;
                var localRay = egret3d.helpRay.applyMatrix(this.gameObject.transform.worldToLocalMatrix, p1);
                var localBoundingBox = this.localBoundingBox;
                if (p2) {
                    if (p2 === true) {
                        raycastMesh = true;
                    }
                    else {
                        raycastMesh = p3 || false;
                        raycastInfo = p2;
                    }
                }
                if (localBoundingBox.raycast(localRay, raycastInfo)) {
                    if (raycastInfo) {
                        var worldMatrix = this.gameObject.transform.localToWorldMatrix;
                        raycastInfo.position.applyMatrix(worldMatrix);
                        raycastInfo.distance = p1.origin.getDistance(raycastInfo.position);
                    }
                    return true;
                }
                return false;
            };
            Object.defineProperty(ParticleRenderer.prototype, "renderMode", {
                /**
                 *
                 */
                get: function () {
                    return this._renderMode;
                },
                set: function (value) {
                    if (this._renderMode === value) {
                        return;
                    }
                    this._renderMode = value;
                    ParticleRenderer.onRenderModeChanged.dispatch(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "mesh", {
                /**
                 *
                 */
                get: function () {
                    return this._mesh;
                },
                set: function (value) {
                    if (this._mesh === value) {
                        return;
                    }
                    if (this._mesh) {
                        this._mesh.release();
                    }
                    this._mesh = value;
                    if (this._mesh) {
                        this._mesh.retain();
                    }
                    ParticleRenderer.onMeshChanged.dispatch(this);
                },
                enumerable: true,
                configurable: true
            });
            /**
             * 渲染模式改变
             */
            ParticleRenderer.onRenderModeChanged = new signals.Signal();
            /**
             * TODO
             */
            ParticleRenderer.onVelocityScaleChanged = new signals.Signal();
            /**
             * TODO
             */
            ParticleRenderer.onLengthScaleChanged = new signals.Signal();
            /**
             *
             */
            ParticleRenderer.onMeshChanged = new signals.Signal();
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "velocityScale", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "lengthScale", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_renderMode", void 0);
            __decorate([
                paper.editor.property("MESH" /* MESH */),
                paper.serializedField("_mesh")
            ], ParticleRenderer.prototype, "mesh", null);
            return ParticleRenderer;
        }(paper.BaseRenderer));
        particle.ParticleRenderer = ParticleRenderer;
        __reflect(ParticleRenderer.prototype, "egret3d.particle.ParticleRenderer");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         *
         */
        var ParticleSystem = (function (_super) {
            __extends(ParticleSystem, _super);
            function ParticleSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.interests = [
                    {
                        componentClass: particle.ParticleComponent,
                        listeners: [
                            { type: particle.onStartSize3DChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onStartSize3DChanged); } },
                            { type: particle.onStartRotation3DChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onStartRotation3DChanged); } },
                            { type: particle.onSimulationSpaceChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onSimulationSpaceChanged); } },
                            { type: particle.onScaleModeChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onScaleModeChanged); } },
                            { type: particle.onVelocityChanged, listener: _this._onVelocityOverLifetime.bind(_this) },
                            { type: particle.onColorChanged, listener: _this._onColorOverLifetime.bind(_this) },
                            { type: particle.onSizeChanged, listener: _this._onSizeOverLifetime.bind(_this) },
                            { type: particle.onRotationChanged, listener: _this._onRotationOverLifetime.bind(_this) },
                            { type: particle.onTextureSheetChanged, listener: _this._onTextureSheetAnimation.bind(_this) },
                        ]
                    },
                    {
                        componentClass: particle.ParticleRenderer,
                        listeners: [
                            { type: particle.ParticleRenderer.onMeshChanged, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: particle.ParticleRenderer.onMaterialsChanged, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            // { type: ParticleRendererEventType.LengthScaleChanged, listener: (comp: ParticleRenderer) => { this._onRenderUpdate(comp, ParticleRendererEventType.LengthScaleChanged); } },
                            // { type: ParticleRendererEventType.VelocityScaleChanged, listener: (comp: ParticleRenderer) => { this._onRenderUpdate(comp, ParticleRendererEventType.VelocityScaleChanged); } },
                            { type: particle.ParticleRenderer.onRenderModeChanged, listener: function (comp) { _this._onRenderUpdate(comp, particle.ParticleRenderer.onRenderModeChanged); } },
                        ]
                    }
                ];
                _this._drawCallCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCallCollecter);
                return _this;
            }
            /**
            * Buffer改变的时候，有可能是初始化，也有可能是mesh改变，此时全部刷一下
            */
            ParticleSystem.prototype._onUpdateBatchMesh = function (comp, cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = true; }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                comp.initBatcher(cleanPlayState);
                //
                this._onRenderUpdate(renderer, particle.ParticleRenderer.onRenderModeChanged);
                this._onRenderUpdate(renderer, particle.ParticleRenderer.onVelocityScaleChanged);
                this._onRenderUpdate(renderer, particle.ParticleRenderer.onLengthScaleChanged);
                //
                this._onMainUpdate(comp, particle.onSizeChanged);
                this._onMainUpdate(comp, particle.onStartRotation3DChanged);
                this._onMainUpdate(comp, particle.onSimulationSpaceChanged);
                this._onMainUpdate(comp, particle.onScaleModeChanged);
                this._onShapeChanged(comp);
                this._onVelocityOverLifetime(comp);
                this._onColorOverLifetime(comp);
                this._onSizeOverLifetime(comp);
                this._onRotationOverLifetime(comp);
                this._onTextureSheetAnimation(comp);
            };
            ParticleSystem.prototype._onRenderUpdate = function (render, type) {
                if (!this.enabled || !this.groups[0].hasGameObject(render.gameObject)) {
                    return;
                }
                var material = render.batchMaterial;
                switch (type) {
                    case particle.ParticleRenderer.onRenderModeChanged: {
                        this._onRenderMode(render);
                        break;
                    }
                    case particle.ParticleRenderer.onLengthScaleChanged: {
                        material.setFloat("u_lengthScale" /* LENGTH_SCALE */, render.lengthScale);
                        break;
                    }
                    case particle.ParticleRenderer.onVelocityScaleChanged: {
                        material.setFloat("u_speeaScale" /* SPEED_SCALE */, render.velocityScale);
                        break;
                    }
                }
            };
            /**
             *
             * @param render 渲染模式改变
             */
            ParticleSystem.prototype._onRenderMode = function (render) {
                var material = render.batchMaterial;
                material.removeDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                material.removeDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                material.removeDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                material.removeDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                material.removeDefine("RENDERMESH" /* RENDERMESH */);
                var mode = render.renderMode;
                switch (mode) {
                    case 0 /* Billboard */: {
                        material.addDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                        break;
                    }
                    case 1 /* Stretch */: {
                        material.addDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                        break;
                    }
                    case 2 /* HorizontalBillboard */: {
                        material.addDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                        break;
                    }
                    case 3 /* VerticalBillboard */: {
                        material.addDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                        break;
                    }
                    case 4 /* Mesh */: {
                        material.addDefine("RENDERMESH" /* RENDERMESH */);
                        break;
                    }
                    default: {
                        throw "_onRenderMode:invalid renderMode";
                    }
                }
            };
            ParticleSystem.prototype._onMainUpdate = function (component, type) {
                if (!this.enabled || !this.groups[0].hasGameObject(component.gameObject)) {
                    return;
                }
                var renderer = component.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                var mainModule = component.main;
                switch (type) {
                    case particle.onStartSize3DChanged: {
                        material.setBoolean("START_SIZE3D" /* START_SIZE3D */, mainModule.startSize3D);
                        break;
                    }
                    case particle.onStartRotation3DChanged: {
                        material.setBoolean("u_startRotation3D" /* START_ROTATION3D */, mainModule.startRotation3D);
                        break;
                    }
                    case particle.onSimulationSpaceChanged: {
                        material.setInt("u_simulationSpace" /* SIMULATION_SPACE */, mainModule.simulationSpace);
                        break;
                    }
                    case particle.onScaleModeChanged: {
                        material.setInt("u_scalingMode" /* SCALING_MODE */, mainModule.scaleMode);
                        break;
                    }
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onShapeChanged = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("SHAPE" /* SHAPE */);
                if (comp.shape.enable) {
                    material.addDefine("SHAPE" /* SHAPE */);
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onVelocityOverLifetime = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                material.removeDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                material.removeDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                material.removeDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                var velocityModule = comp.velocityOverLifetime;
                if (velocityModule.enable) {
                    var mode = velocityModule.mode;
                    switch (mode) {
                        case 0 /* Constant */: {
                            material.addDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                            //
                            var vec3 = new egret3d.Vector3(velocityModule.x.evaluate(), velocityModule.y.evaluate(), velocityModule.z.evaluate());
                            material.setVector3("u_velocityConst" /* VELOCITY_CONST */, vec3);
                            break;
                        }
                        case 1 /* Curve */: {
                            material.addDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                            //
                            material.setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule.x.curve.floatValues);
                            material.setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule.y.curve.floatValues);
                            material.setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule.z.curve.floatValues);
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            material.addDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                            //
                            var minVec3 = new egret3d.Vector3(velocityModule.x.constantMin, velocityModule.y.constantMin, velocityModule.z.constantMin);
                            var maxVec3 = new egret3d.Vector3(velocityModule.x.constantMax, velocityModule.y.constantMax, velocityModule.z.constantMax);
                            material.setVector3("u_velocityConst" /* VELOCITY_CONST */, minVec3);
                            material.setVector3("u_velocityConstMax" /* VELOCITY_CONST_MAX */, maxVec3);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                            //
                            material.setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule.x.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule.y.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule.z.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveMaxX[0]" /* VELOCITY_CURVE_MAX_X */, velocityModule.x.curveMax.floatValues);
                            material.setVector2v("u_velocityCurveMaxY[0]" /* VELOCITY_CURVE_MAX_Y */, velocityModule.y.curveMax.floatValues);
                            material.setVector2v("u_velocityCurveMaxZ[0]" /* VELOCITY_CURVE_MAX_Z */, velocityModule.z.curveMax.floatValues);
                            break;
                        }
                    }
                    material.setInt("u_spaceType" /* SPACE_TYPE */, velocityModule.space);
                }
            };
            /**
             * 更新颜色模块
             * @param component
             */
            ParticleSystem.prototype._onColorOverLifetime = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                material.removeDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                var colorModule = comp.colorOverLifetime;
                if (colorModule.enable) {
                    var color = colorModule.color;
                    switch (color.mode) {
                        case 1 /* Gradient */: {
                            material.addDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                            //
                            material.setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradient.alphaValues);
                            material.setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradient.colorValues);
                            break;
                        }
                        case 3 /* TwoGradients */: {
                            material.addDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                            //
                            material.setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradientMin.alphaValues);
                            material.setVector2v("u_alphaGradientMax[0]" /* ALPHA_GRADIENT_MAX */, color.gradientMax.alphaValues);
                            material.setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradientMin.colorValues);
                            material.setVector4v("u_colorGradientMax[0]" /* COLOR_GRADIENT_MAX */, color.gradientMax.colorValues);
                            break;
                        }
                    }
                }
            };
            /**
             * 更新大小模块
             * @param component
             */
            ParticleSystem.prototype._onSizeOverLifetime = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("SIZECURVE" /* SIZECURVE */);
                material.removeDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                material.removeDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                material.removeDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                var sizeModule = comp.sizeOverLifetime;
                if (sizeModule.enable) {
                    var separateAxes = sizeModule.separateAxes;
                    var mode = sizeModule.x.mode;
                    switch (mode) {
                        case 1 /* Curve */: {
                            if (separateAxes) {
                                material.addDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                                //
                                material.setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule.x.curve.floatValues);
                                material.setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule.y.curve.floatValues);
                                material.setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule.z.curve.floatValues);
                            }
                            else {
                                material.addDefine("SIZECURVE" /* SIZECURVE */);
                                //
                                material.setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule.size.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            if (separateAxes) {
                                material.addDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                                //
                                material.setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule.x.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule.y.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule.z.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveMaxX[0]" /* SIZE_CURVE_MAX_X */, sizeModule.x.curveMax.floatValues);
                                material.setVector2v("u_sizeCurveMaxY[0]" /* SIZE_CURVE_MAX_Y */, sizeModule.y.curveMax.floatValues);
                                material.setVector2v("u_sizeCurveMaxZ[0]" /* SIZE_CURVE_MAX_Z */, sizeModule.z.curveMax.floatValues);
                            }
                            else {
                                material.addDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                                //
                                material.setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule.size.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveMax[0]" /* SIZE_CURVE_MAX */, sizeModule.size.curveMax.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            /**
             * 更新旋转模块
             * @param comp
             */
            ParticleSystem.prototype._onRotationOverLifetime = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                material.removeDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                material.removeDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                material.removeDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                material.removeDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                material.removeDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                var rotationModule = comp.rotationOverLifetime;
                if (rotationModule.enable) {
                    var mode = comp.rotationOverLifetime.x.mode;
                    var separateAxes = rotationModule.separateAxes;
                    if (separateAxes) {
                        material.addDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                    }
                    else {
                        material.addDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                    }
                    switch (mode) {
                        case 0 /* Constant */: {
                            material.addDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                            //
                            if (separateAxes) {
                                material.setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule.x.constant, rotationModule.y.constant, rotationModule.z.constant));
                            }
                            else {
                                material.setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule.z.constant);
                            }
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            material.addDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                            //
                            if (separateAxes) {
                                material.setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule.x.constantMin, rotationModule.y.constantMin, rotationModule.z.constantMin));
                                material.setVector3("u_rotationConstMaxSeprarate" /* ROTATION_CONST_MAX_SEPRARATE */, new egret3d.Vector3(rotationModule.x.constantMax, rotationModule.y.constantMax, rotationModule.z.constantMax));
                            }
                            else {
                                material.setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule.z.constantMin);
                                material.setFloat("u_rotationConstMax" /* ROTATION_CONST_MAX */, rotationModule.z.constantMax);
                            }
                            break;
                        }
                        case 1 /* Curve */: {
                            material.addDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                            //
                            if (separateAxes) {
                                material.setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule.x.curve.floatValues);
                                material.setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule.y.curve.floatValues);
                                material.setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule.z.curve.floatValues);
                            }
                            else {
                                material.setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule.z.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                            //
                            if (separateAxes) {
                                material.setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule.x.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule.y.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule.z.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveMaxX[0]" /* ROTATION_CURVE_MAX_X */, rotationModule.x.curveMax.floatValues);
                                material.setVector2v("u_rotationCurveMaxY[0]" /* ROTATION_CURVE_MAX_Y */, rotationModule.y.curveMax.floatValues);
                                material.setVector2v("u_rotationCurveMaxZ[0]" /* ROTATION_CURVE_MAX_Z */, rotationModule.z.curveMax.floatValues);
                            }
                            else {
                                material.setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule.z.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveMax[0]" /* ROTATION_CURVE_MAX */, rotationModule.z.curveMin.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            ParticleSystem.prototype._onTextureSheetAnimation = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                material.removeDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                var module = comp.textureSheetAnimation;
                if (module.enable) {
                    var type = module.frameOverTime.mode;
                    switch (type) {
                        case 1 /* Curve */: {
                            material.addDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                            //
                            material.setVector2v("u_uvCurve[0]" /* UV_CURVE */, module.frameOverTime.curve.floatValues);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                            //
                            material.setVector2v("u_uvCurve[0]" /* UV_CURVE */, module.frameOverTime.curveMin.floatValues);
                            material.setVector2v("u_uvCurveMax[0]" /* UV_CURVE_MAX */, module.frameOverTime.curveMax.floatValues);
                            break;
                        }
                    }
                    if (type === 1 /* Curve */ || type === 2 /* TwoCurves */) {
                        material.setFloat("u_cycles" /* CYCLES */, module.cycleCount);
                        material.setVector4v("u_subUV" /* SUB_UV */, module.floatValues);
                    }
                }
            };
            ParticleSystem.prototype._updateDrawCalls = function (gameObject, cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = true; }
                if (!this.enabled || !this.groups[0].hasGameObject(gameObject)) {
                    return;
                }
                var drawCallCollecter = this._drawCallCollecter;
                var component = gameObject.getComponent(particle.ParticleComponent);
                var renderer = gameObject.getComponent(particle.ParticleRenderer);
                //
                this._onUpdateBatchMesh(component, cleanPlayState);
                drawCallCollecter.removeDrawCalls(renderer);
                if (!renderer.batchMesh || !renderer.batchMaterial) {
                    return;
                }
                if (renderer.renderMode === 5 /* None */) {
                    console.error("ParticleSystem : error renderMode");
                }
                this._drawCallCollecter.renderers.push(renderer);
                //
                var subMeshIndex = 0;
                for (var _i = 0, _a = renderer.batchMesh.glTFMesh.primitives; _i < _a.length; _i++) {
                    var _primitive = _a[_i];
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.renderer = renderer;
                    drawCall.matrix = gameObject.transform.localToWorldMatrix;
                    drawCall.subMeshIndex = subMeshIndex++;
                    drawCall.mesh = renderer.batchMesh;
                    drawCall.material = renderer.batchMaterial || egret3d.DefaultMaterials.MISSING;
                    drawCallCollecter.addDrawCall(drawCall);
                }
            };
            ParticleSystem.prototype.onEnable = function () {
                for (var _i = 0, _a = this.groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    this._updateDrawCalls(gameObject);
                }
            };
            ParticleSystem.prototype.onAddGameObject = function (gameObject, _group) {
                this._updateDrawCalls(gameObject, false);
                var component = gameObject.getComponent(particle.ParticleComponent);
                if (component.main.playOnAwake) {
                    component.play();
                }
            };
            ParticleSystem.prototype.onRemoveGameObject = function (gameObject) {
                this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
                // component.stop();
            };
            ParticleSystem.prototype.onUpdate = function (deltaTime) {
                if (deltaTime > 0.3) {
                    deltaTime = 0.3; //防止dt过大，引起周期错乱
                }
                for (var _i = 0, _a = this.groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    gameObject.getComponent(particle.ParticleComponent).update(deltaTime);
                }
            };
            ParticleSystem.prototype.onDisable = function () {
                for (var _i = 0, _a = this.groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    this._drawCallCollecter.removeDrawCalls(gameObject.renderer);
                }
            };
            return ParticleSystem;
        }(paper.BaseSystem));
        particle.ParticleSystem = ParticleSystem;
        __reflect(ParticleSystem.prototype, "egret3d.particle.ParticleSystem");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
// namespace egret3d {
//     export class Audio extends paper.BaseComponent {
//     }
// } 
var egret3d;
(function (egret3d) {
    //最大允许合并的顶点数，超过就是下一批次
    egret3d.MAX_VERTEX_COUNT_PER_BUFFER = 50000;
    //
    var helpVec3_1 = egret3d.Vector3.create();
    var helpVec3_2 = egret3d.Vector3.create();
    var helpInverseMatrix = egret3d.Matrix4.create();
    //缓存已经校验过的对象，用于过滤
    var cacheInstances = [];
    var beforeCombineCount = 0;
    /**
     * 尝试对场景内所有静态对象合并
     */
    function autoCombine(scene) {
        combine(scene.gameObjects);
    }
    egret3d.autoCombine = autoCombine;
    /**
     * 尝试合并静态对象列表。
     * @param instances
     * @param root
     */
    function combine(instances) {
        cacheInstances.length = 0;
        beforeCombineCount = 0;
        var allCombines = {};
        //1.通过材质填充合并列表
        for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
            var obj = instances_1[_i];
            _colletCombineInstance(obj, allCombines);
        }
        console.log("合并前:" + beforeCombineCount);
        var afterCombineCount = 0;
        //2.相同材质的合并
        for (var key in allCombines) {
            var combines = allCombines[key];
            for (var _a = 0, combines_1 = combines; _a < combines_1.length; _a++) {
                var combine_1 = combines_1[_a];
                _combineInstance(combine_1);
                afterCombineCount++;
            }
        }
        console.log("合并后:" + afterCombineCount + "节省:" + (beforeCombineCount - afterCombineCount));
        cacheInstances.length = 0;
    }
    egret3d.combine = combine;
    /**
     * TODO(root暂时不支持)尝试合并静态对象列表，如果root有值，合并后可以操作root对象的transform，来实现整体移动，旋转，缩放；反之，相同材质列表的第一个对象为合并节点。
     * @param instances
     * @param root
     */
    function _colletCombineInstance(target, out, root) {
        //过滤重复的对象
        if (cacheInstances.indexOf(target.uuid) >= 0) {
            return;
        }
        cacheInstances.push(target.uuid);
        //
        for (var _i = 0, _a = target.transform.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child) {
                _colletCombineInstance(child.gameObject, out, root);
            }
        }
        //不是静态的不考虑合并
        if (!target.isStatic) {
            return;
        }
        var meshFilter = target.getComponent(egret3d.MeshFilter);
        var meshRenderer = target.getComponent(egret3d.MeshRenderer);
        //合并条件判断
        if (!meshFilter || !meshFilter.mesh || !meshRenderer || !meshRenderer.materials || meshRenderer.materials.length < 1) {
            return;
        }
        beforeCombineCount++;
        var materials = meshRenderer.materials;
        var meshData = meshFilter.mesh;
        //合并筛选的条件:光照贴图_材质0_材质1... ：0_234_532...
        var key = meshRenderer.lightmapIndex + "_";
        materials.forEach(function (element) { key = key + "_" + element.uuid; });
        if (!out[key]) {
            out[key] = [];
            out[key].push(new CombineInstance());
        }
        var combines = out[key];
        //找相同材质合成列表的最后一个，如果最后一个顶点超过允许最大数了，就新建一个，下个批次处理
        var combine = combines[combines.length - 1];
        if (combine.vertexCount + meshData.vertexCount > egret3d.MAX_VERTEX_COUNT_PER_BUFFER) {
            combine = new CombineInstance();
            out[key].push(combine);
        }
        //合并节点以传入的对象为优先，如果没有传入，那么以每种材质的第一个对象为准
        if (!combine.root) {
            combine.root = root ? root : target;
            combine.lightmapIndex = meshRenderer.lightmapIndex;
        }
        //适配最大格式
        var primitives = meshData.glTFMesh.primitives;
        for (var i = 0; i < primitives.length; i++) {
            var primitive = primitives[i];
            for (var attStr in primitives[i].attributes) {
                var attrType = attStr;
                if (!combine.meshAttribute[attrType]) {
                    combine.vertexBufferSize += meshData.getAccessor(primitive.attributes[attStr]).typeCount;
                }
                combine.meshAttribute[attrType] = attrType;
            }
            combine.indexBufferTotalSize += meshData.getBufferLength(meshData.getAccessor(primitive.indices)) / Uint16Array.BYTES_PER_ELEMENT;
        }
        //
        combine.vertexCount += meshData.vertexCount;
        combine.instances.push(target);
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     */
    function _combineInstance(combineInstance) {
        var combineMesh = _combineMesh(combineInstance);
        var combineRoot = combineInstance.root;
        //把合成好的放入root中，重新绘制
        var meshFilter = combineRoot.getComponent(egret3d.MeshFilter);
        meshFilter.mesh = combineMesh;
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     * @param root
     */
    function _combineMesh(combineInstance) {
        //
        helpInverseMatrix.copy(combineInstance.root.transform.worldToLocalMatrix);
        var meshAttribute = combineInstance.meshAttribute;
        var lightmapScaleOffset = combineInstance.root.renderer.lightmapScaleOffset;
        var newAttribute = [];
        var tempIndexBuffers = [];
        var tempVertexBuffers = {};
        for (var key in meshAttribute) {
            tempVertexBuffers[key] = [];
            newAttribute.push(key);
        }
        //
        var startIndex = 0;
        var endIndex = 0;
        for (var _i = 0, _a = combineInstance.instances; _i < _a.length; _i++) {
            var instance = _a[_i];
            var meshFilter = instance.getComponent(egret3d.MeshFilter);
            var meshRenderer = instance.getComponent(egret3d.MeshRenderer);
            var worldMatrix = instance.transform.localToWorldMatrix;
            var mesh = meshFilter.mesh;
            var orginLightmapScaleOffset = meshRenderer.lightmapScaleOffset;
            var primitives = mesh.glTFMesh.primitives;
            //共享一个的buffer，vbo只处理一个submesh就可以了
            var combineOnce = true;
            for (var i = 0; i < primitives.length; i++) {
                var primitive = primitives[i];
                if (combineOnce) {
                    combineOnce = false;
                    var orginVertexCount = mesh.vertexCount;
                    var orginAttributes = primitives[i].attributes;
                    var positionBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.POSITION));
                    //vertexBuffers
                    for (var j = 0; j < positionBuffer.length; j += 3) {
                        helpVec3_1.x = positionBuffer[j + 0];
                        helpVec3_1.y = positionBuffer[j + 1];
                        helpVec3_1.z = positionBuffer[j + 2];
                        //转换成世界坐标后在转换为合并节点的本地坐标
                        worldMatrix.transformVector3(helpVec3_1, helpVec3_2);
                        helpInverseMatrix.transformVector3(helpVec3_2, helpVec3_1);
                        //
                        tempVertexBuffers["POSITION" /* POSITION */].push(helpVec3_1.x, helpVec3_1.y, helpVec3_1.z);
                    }
                    //
                    if (meshAttribute["NORMAL" /* NORMAL */]) {
                        if (orginAttributes.NORMAL) {
                            var normalBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.NORMAL));
                            var target = tempVertexBuffers["NORMAL" /* NORMAL */];
                            var count = normalBuffer.length;
                            var startIndex_1 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 3) {
                                helpVec3_1.x = normalBuffer[j + 0];
                                helpVec3_1.y = normalBuffer[j + 1];
                                helpVec3_1.z = normalBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_1 + j] = helpVec3_1.x;
                                target[startIndex_1 + j + 1] = helpVec3_1.y;
                                target[startIndex_1 + j + 2] = helpVec3_1.z;
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.NORMAL, tempVertexBuffers[gltf.AttributeSemanticType.NORMAL]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["NORMAL" /* NORMAL */], orginVertexCount, [0, 0, 0]);
                        }
                    }
                    // if (meshAttribute[gltf.AttributeSemanticType.TANGENT]) { TODO
                    //     if (orginAttributes.TANGENT) {
                    //         const tangentBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TANGENT)) as Float32Array;
                    //         const target = tempVertexBuffers[gltf.AttributeSemanticType.TANGENT];
                    //         const count = tangentBuffer.length;
                    //         let startIndex = target.length;
                    //         target.length += count;
                    //         for (let j = 0; j < count; j += 4) {
                    //             helpVec3_1.x = tangentBuffer[j + 0];
                    //             helpVec3_1.y = tangentBuffer[j + 1];
                    //             helpVec3_1.z = tangentBuffer[j + 2];
                    //             worldMatrix.transformNormal(helpVec3_1);
                    //             helpInverseMatrix.transformNormal(helpVec3_1);
                    //             helpVec3_1.normalize();
                    //             target[startIndex + j] = helpVec3_1.x;
                    //             target[startIndex + j + 1] = helpVec3_1.y;
                    //             target[startIndex + j + 2] = helpVec3_1.z;
                    //             target[startIndex + j + 3] = tangentBuffer[j + 3];
                    //         }
                    //         // _copyAccessorBufferArray(glTFAsset, orginAttributes.TANGENT, tempVertexBuffers[gltf.AttributeSemanticType.TANGENT]);
                    //     } else {
                    //         _fillDefaultArray(tempVertexBuffers[gltf.AttributeSemanticType.TANGENT], orginVertexCount, [0, 0, 0, 1]);
                    //     }
                    // }
                    if (meshAttribute["COLOR_0" /* COLOR_0 */]) {
                        if (orginAttributes.COLOR_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.COLOR_0, tempVertexBuffers["COLOR_0" /* COLOR_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_0" /* COLOR_0 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_0" /* TEXCOORD_0 */]) {
                        if (orginAttributes.TEXCOORD_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_0, tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */], orginVertexCount, [0, 0]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_1" /* TEXCOORD_1 */]) {
                        if (combineInstance.lightmapIndex >= 0) {
                            //如果有lightmap,那么将被合并的uv1的坐标转换为root下的坐标,有可能uv1没有，那用uv0来算
                            var uvBuffer = orginAttributes.TEXCOORD_1 ?
                                mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TEXCOORD_1)) :
                                mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TEXCOORD_0));
                            //
                            for (var j = 0; j < uvBuffer.length; j += 2) {
                                var u = uvBuffer[j + 0];
                                var v = uvBuffer[j + 1];
                                u = ((u * orginLightmapScaleOffset.x + orginLightmapScaleOffset.z) - lightmapScaleOffset.z) / lightmapScaleOffset.x;
                                v = ((v * orginLightmapScaleOffset.y - orginLightmapScaleOffset.y - orginLightmapScaleOffset.w) + lightmapScaleOffset.w + lightmapScaleOffset.x) / lightmapScaleOffset.x;
                                tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */].push(u, v);
                            }
                            // if (orginAttributes.TEXCOORD_1 !== undefined) {
                            //     _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_1, tempVertexBuffers[gltf.AttributeSemanticType.TEXCOORD_1]);
                            // }
                            // else {
                            //     _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_0!, tempVertexBuffers[gltf.AttributeSemanticType.TEXCOORD_1]);
                            // }
                        }
                        else {
                            if (orginAttributes.TEXCOORD_1 !== undefined) {
                                _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_1, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                            else {
                                _fillDefaultArray(tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */], orginVertexCount, [0, 0]);
                            }
                        }
                    }
                    if (meshAttribute["JOINTS_0" /* JOINTS_0 */]) {
                        if (orginAttributes.JOINTS_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.JOINTS_0, tempVertexBuffers["JOINTS_0" /* JOINTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["JOINTS_0" /* JOINTS_0 */], orginVertexCount, [0, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["WEIGHTS_0" /* WEIGHTS_0 */]) {
                        if (orginAttributes.WEIGHTS_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.WEIGHTS_0, tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */], orginVertexCount, [1, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["COLOR_1" /* COLOR_1 */]) {
                        if (orginAttributes.COLOR_1) {
                            _copyAccessorBufferArray(mesh, orginAttributes.COLOR_1, tempVertexBuffers["COLOR_1" /* COLOR_1 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_1" /* COLOR_1 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                }
                var subIndexBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(primitive.indices));
                // //indexBuffers
                if (!tempIndexBuffers[i]) {
                    tempIndexBuffers[i] = [];
                }
                for (var j = 0; j < subIndexBuffer.length; j++) {
                    var index = subIndexBuffer[j] + startIndex;
                    tempIndexBuffers[i].push(index);
                    endIndex = index > endIndex ? index : endIndex;
                }
            }
            startIndex = endIndex + 1;
            meshFilter.mesh = null;
        }
        var combineMesh = egret3d.Mesh.create(combineInstance.vertexCount, combineInstance.indexBufferTotalSize, newAttribute);
        combineMesh.drawMode = 35048 /* Dynamic */;
        var newVertexBuffers = combineMesh.buffers[0];
        var newIndexBuffers = combineMesh.buffers[1];
        var iv = 0;
        for (var key in tempVertexBuffers) {
            var arr = tempVertexBuffers[key];
            for (var _b = 0, arr_1 = arr; _b < arr_1.length; _b++) {
                var v = arr_1[_b];
                newVertexBuffers[iv++] = v;
            }
        }
        var ii = 0;
        for (var key in tempIndexBuffers) {
            var arr = tempIndexBuffers[key];
            for (var _c = 0, arr_2 = arr; _c < arr_2.length; _c++) {
                var v = arr_2[_c];
                newIndexBuffers[ii++] = v;
            }
        }
        var indicesCount = 0;
        for (var i = 1; i < tempIndexBuffers.length; i++) {
            var subLen = tempIndexBuffers[i].length;
            //第一个submesh在构造函数中已经添加，需要手动添加后续的
            combineMesh.addSubMesh(indicesCount, subLen, i);
            indicesCount += subLen;
        }
        return combineMesh;
    }
    function _copyAccessorBufferArray(mesh, accessor, target) {
        var buffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(accessor));
        var count = buffer.length;
        var startIndex = target.length;
        target.length += count;
        for (var i = 0; i < count; i++) {
            target[startIndex + i] = buffer[i];
        }
    }
    function _fillDefaultArray(target, count, defaultValue) {
        var startIndex = target.length;
        var defaultValueCount = defaultValue.length;
        target.length += count * defaultValueCount;
        for (var i = 0; i < count; i++) {
            for (var j = 0; j < defaultValueCount; j++) {
                target[startIndex++] = defaultValue[j];
            }
        }
    }
    var CombineInstance = (function () {
        function CombineInstance() {
            this.vertexCount = 0;
            this.vertexBufferSize = 0;
            this.indexBufferTotalSize = 0;
            this.lightmapIndex = -1;
            this.meshAttribute = {};
            this.root = null;
            this.instances = [];
        }
        return CombineInstance;
    }());
    __reflect(CombineInstance.prototype, "CombineInstance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @deprecated
     */
    egret3d.RAD_DEG = 57.29577951308232 /* RAD_DEG */;
    /**
     * @deprecated
     */
    egret3d.DEG_RAD = 0.017453292519943295 /* DEG_RAD */;
    /**
     * @deprecated
     */
    egret3d.EPSILON = 2.220446049250313e-16 /* EPSILON */;
    /**
     * @deprecated
     */
    egret3d.floatClamp = egret3d.math.clamp;
    /**
     * @deprecated
     */
    egret3d.numberLerp = egret3d.math.lerp;
    /**
     * @deprecated
     */
    egret3d.AABB = egret3d.Box;
    /**
     * @deprecated
     */
    egret3d.Matrix = egret3d.Matrix4;
    /**
     * @deprecated
     */
    egret3d.Prefab = paper.Prefab;
    /**
     * @deprecated
     */
    egret3d.RawScene = paper.RawScene;
    /**
     * @deprecated
     * @internal
     */
    egret3d.WebGLCapabilities = egret3d.web.WebGLRenderState;
    /**
     * @deprecated
     */
    egret3d.InputManager = {
        /**
         * @deprecated
         * @see egret3d.inputCollecter
         */
        mouse: {
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer.isHold()
             */
            isPressed: function (button) {
                var buttons = [1 /* LeftMouse */, 4 /* MiddleMouse */, 2 /* RightMouse */];
                return egret3d.inputCollecter.defaultPointer.isHold(buttons[button]);
            },
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer.isDown()
             */
            wasPressed: function (button) {
                var buttons = [1 /* LeftMouse */, 4 /* MiddleMouse */, 2 /* RightMouse */];
                return egret3d.inputCollecter.defaultPointer.isDown(buttons[button]);
            },
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer.isUp()
             */
            wasReleased: function (button) {
                var buttons = [1 /* LeftMouse */, 4 /* MiddleMouse */, 2 /* RightMouse */];
                return egret3d.inputCollecter.defaultPointer.isUp(buttons[button]);
            },
        },
        /**
         * @deprecated
         * @see egret3d.inputCollecter
         */
        touch: {
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer
             */
            getTouch: function (button) {
                return egret3d.inputCollecter.getHoldPointers()[button];
            },
        },
        /**
         * @deprecated
         * @see egret3d.inputCollecter
         */
        keyboard: {
            /**
             * @deprecated
             * @see egret3d.inputCollecter.getKey()
             */
            isPressed: function (key) {
                return egret3d.inputCollecter.getKey(key).isHold();
            },
            /**
             * @deprecated
             * @see egret3d.inputCollecter.getKey()
             */
            wasPressed: function (key) {
                return egret3d.inputCollecter.getKey(key).isUp();
            },
        },
    };
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 应用程序运行模式。
     */
    var PlayerMode;
    (function (PlayerMode) {
        PlayerMode[PlayerMode["Player"] = 0] = "Player";
        PlayerMode[PlayerMode["DebugPlayer"] = 1] = "DebugPlayer";
        PlayerMode[PlayerMode["Editor"] = 2] = "Editor";
    })(PlayerMode = paper.PlayerMode || (paper.PlayerMode = {}));
    /**
     * 应用程序。
     */
    var ECS = (function () {
        function ECS() {
            /**
             * 当应用程序的播放模式改变时派发事件。
             */
            this.onPlayerModeChange = new signals.Signal();
            /**
             * 引擎版本。
             */
            this.version = "1.4.0.001";
            /**
             * 系统管理器。
             */
            this.systemManager = paper.SystemManager.getInstance();
            /**
             * 场景管理器。
             */
            this.sceneManager = paper.SceneManager.getInstance();
            this._isFocused = false;
            this._isRunning = false;
            this._playerMode = 0 /* Player */;
            this._bindUpdate = null;
        }
        /**
         * 应用程序单例。
         */
        ECS.getInstance = function () {
            if (!this._instance) {
                this._instance = new ECS();
            }
            return this._instance;
        };
        ECS.prototype._update = function () {
            if (this._isRunning) {
                requestAnimationFrame(this._bindUpdate);
            }
            paper.clock && paper.clock.update(); // TODO
            paper.GameObjectGroup.update();
            this.systemManager.update();
        };
        /**
         * @internal
         */
        ECS.prototype.initialize = function (options) {
            this._playerMode = options.playerMode || 0 /* Player */;
            this.systemManager.register(paper.EnableSystem, 1000 /* Enable */);
            this.systemManager.register(paper.StartSystem, 2000 /* Start */);
            this.systemManager.register(paper.FixedUpdateSystem, 3000 /* FixedUpdate */);
            this.systemManager.register(paper.UpdateSystem, 4000 /* Update */);
            this.systemManager.register(paper.LateUpdateSystem, 6000 /* LateUpdate */);
            this.systemManager.register(paper.DisableSystem, 9000 /* Disable */);
        };
        /**
         * TODO
         * @internal
         */
        ECS.prototype.pause = function () {
            this._isRunning = false;
        };
        /**
         * TODO
         * @internal
         */
        ECS.prototype.resume = function () {
            if (this._isRunning) {
                return;
            }
            this._isRunning = true;
            if (!this._bindUpdate) {
                this._bindUpdate = this._update.bind(this);
            }
            this._update();
        };
        Object.defineProperty(ECS.prototype, "isMobile", {
            /**
             *
             */
            get: function () {
                var userAgent = (navigator && navigator.userAgent) ? navigator.userAgent.toLowerCase() : "";
                return userAgent.indexOf("mobile") >= 0 || userAgent.indexOf("android") >= 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isFocused", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                return this._isFocused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isRunning", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                return this._isRunning;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "playerMode", {
            /**
             * 运行模式。
             */
            get: function () {
                return this._playerMode;
            },
            set: function (value) {
                if (this._playerMode === value) {
                    return;
                }
                this._playerMode = value;
                this.onPlayerModeChange.dispatch(this.playerMode);
            },
            enumerable: true,
            configurable: true
        });
        ECS._instance = null;
        return ECS;
    }());
    paper.ECS = ECS;
    __reflect(ECS.prototype, "paper.ECS");
    /**
     * 应用程序单例。
     */
    paper.Application = ECS.getInstance();
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * Shader 资源。
     */
    var Shader = (function (_super) {
        __extends(Shader, _super);
        function Shader() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.customs = null;
            return _this;
        }
        Shader.create = function (name, shaderOrConfig) {
            var config;
            var shader;
            var parent = null;
            if (shaderOrConfig instanceof Shader) {
                // TODO
                var KHR_techniques_webgl = shaderOrConfig.config.extensions.KHR_techniques_webgl;
                var technique = KHR_techniques_webgl.techniques[0];
                var uniforms = {};
                parent = shaderOrConfig;
                for (var k in technique.uniforms) {
                    uniforms[k] = technique.uniforms[k];
                }
                config = {
                    extensions: {
                        KHR_techniques_webgl: {
                            shaders: KHR_techniques_webgl.shaders,
                            techniques: [{
                                    attributes: technique.attributes,
                                    uniforms: uniforms,
                                }]
                        }
                    }
                };
            }
            else {
                config = shaderOrConfig;
            }
            //
            shader = new Shader(name, config);
            shader.initialize(parent);
            return shader;
        };
        /**
         * @private
         */
        Shader.createDefaultStates = function () {
            var states = {
                enable: [2929 /* DepthTest */, 2884 /* CullFace */],
                functions: {
                    depthFunc: [515 /* Lequal */],
                    depthMask: [true],
                    frontFace: [2305 /* CCW */],
                    cullFace: [1029 /* Back */],
                },
            };
            return states;
        };
        /**
         * @private
         */
        Shader.copyStates = function (source, target) {
            var sourceEnable = source.enable, sourceFunctions = source.functions;
            var enable = target.enable, functions = target.functions;
            if (enable) {
                enable.length = 0;
            }
            if (functions) {
                for (var k in functions) {
                    delete functions[k];
                }
            }
            if (sourceEnable) {
                if (!enable) {
                    enable = target.enable = [];
                }
                for (var _i = 0, sourceEnable_1 = sourceEnable; _i < sourceEnable_1.length; _i++) {
                    var value = sourceEnable_1[_i];
                    enable.push(value);
                }
            }
            if (sourceFunctions) {
                if (!functions) {
                    functions = target.functions = {};
                }
                for (var k in sourceFunctions) {
                    var sourceFunction = sourceFunctions[k];
                    functions[k] = Array.isArray(sourceFunction) ? sourceFunction.concat() : sourceFunction;
                }
            }
        };
        Shader.prototype.initialize = function (parent) {
            _super.prototype.initialize.call(this);
            if (parent) {
                // this.customs = parent.customs; TODO
                this._renderQueue = parent._renderQueue;
                this._defines = parent._defines ? parent._defines.concat() : undefined;
                this._states = parent._states; // TODO
            }
        };
        /**
         * @private
         */
        Shader.prototype.addDefine = function (defineString, value) {
            if (value !== undefined) {
                if (typeof value === "number") {
                    defineString += " " + value;
                }
                else {
                    this.customs = {};
                    var customs = this.customs;
                    for (var k in value) {
                        customs[k] = value[k];
                    }
                }
            }
            var defines = this._defines = this._defines || [];
            if (defines.indexOf(defineString) < 0) {
                defines.push(defineString);
            }
            return this;
        };
        /**
         * @private
         */
        Shader.prototype.addUniform = function (name, type, value) {
            var uniforms = this.config.extensions.KHR_techniques_webgl.techniques[0].uniforms;
            uniforms[name] = {
                type: type,
                value: value,
            };
            return this;
        };
        return Shader;
    }(egret3d.GLTFAsset));
    egret3d.Shader = Shader;
    __reflect(Shader.prototype, "egret3d.Shader");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var Define = (function () {
        function Define(index, mask, context) {
            this.index = index;
            this.mask = mask;
            this.context = context;
        }
        Define.getDefine = function (defineString) {
            var defines = this._defines;
            var define = defines[defineString];
            if (!define) {
                defines[defineString] = define = new Define(this._index, this._mask, defineString);
                this._mask >>>= 1;
                if (this._mask === 0) {
                    this._index++;
                    this._mask = 0x80000000;
                }
            }
            return define;
        };
        Define._index = 0;
        Define._mask = 0x80000000;
        Define._defines = {};
        return Define;
    }());
    egret3d.Define = Define;
    __reflect(Define.prototype, "egret3d.Define");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //TODO 运行时DrawCall排序优化使用
    var _hashCode = 0;
    /**
     * 材质资源。
     */
    var Material = (function (_super) {
        __extends(Material, _super);
        function Material() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 该材质的渲染排序。
             */
            _this.renderQueue = 2000 /* Geometry */;
            /**
              * @internal
              */
            _this._id = _hashCode++;
            /**
              * @internal
              */
            _this._version = 0;
            _this._cacheDefines = "";
            _this._defines = [];
            /**
            * @internal
            */
            _this._technique = null;
            /**
             * @internal
             */
            _this._shader = null;
            return _this;
        }
        Material.create = function (shaderOrName, shaderOrConfig) {
            var hasName = typeof shaderOrName === "string";
            var name = (shaderOrName && hasName) ? shaderOrName : "";
            //
            if (shaderOrName === undefined) {
                shaderOrConfig = shaderOrConfig || egret3d.DefaultShaders.MESH_BASIC;
            }
            else if (!hasName) {
                shaderOrConfig = shaderOrName || shaderOrConfig || egret3d.DefaultShaders.MESH_BASIC;
            }
            //
            var material = new Material(name, null);
            material.initialize();
            material._reset(shaderOrConfig);
            return material;
        };
        Material.prototype._createTechnique = function (shader, glTFMaterial) {
            var _a = shader.config.extensions.KHR_techniques_webgl.techniques[0], sourceAttributes = _a.attributes, sourceUniforms = _a.uniforms;
            var materialUniformValues = glTFMaterial.extensions.KHR_techniques_webgl.values;
            var shaderDefines = shader._defines;
            var materialDefines = glTFMaterial.extensions.paper.defines;
            var technique = {
                attributes: {},
                uniforms: {},
            };
            // Remove redundant material uniform values.
            if (materialUniformValues) {
                for (var k in materialUniformValues) {
                    if (!(k in sourceUniforms)) {
                        delete materialUniformValues[k];
                    }
                }
            }
            // Copy attributes.
            for (var k in sourceAttributes) {
                var attribute = sourceAttributes[k];
                technique.attributes[k] = {
                    semantic: attribute.semantic,
                };
            }
            // Copy uniforms.
            for (var k in sourceUniforms) {
                var sourceUniform = sourceUniforms[k];
                var sourceValue = (materialUniformValues && (k in materialUniformValues)) ? materialUniformValues[k] : sourceUniform.value; // shader -> material -> technique.
                var type = sourceUniform.type;
                var value = void 0;
                if (type === 35678 /* SAMPLER_2D */ || type === 35680 /* SAMPLER_CUBE */) {
                    if (sourceValue) {
                        value = paper.Asset.find(sourceValue) || egret3d.DefaultTextures.MISSING; // Missing texture.
                    }
                    if (!value) {
                        value = egret3d.DefaultTextures.WHITE; // Default texture.
                    }
                }
                else if (Array.isArray(sourceValue)) {
                    value = sourceValue ? sourceValue.concat() : []; // TODO
                }
                else {
                    value = sourceValue ? sourceValue : []; // TODO 不应是数组。
                }
                var targetUniform = technique.uniforms[k] = { type: type, value: value };
                if (sourceUniform.semantic) {
                    targetUniform.semantic = sourceUniform.semantic;
                }
            }
            //
            if (glTFMaterial.extensions.paper.states) {
                var states = technique.states = glTFMaterial.extensions.paper.states; // TODO 如果编辑器编辑该值，最简单的方式是做关联。
                // TODO
                if (!states.enable) {
                    states.enable = [];
                }
                if (!states.functions) {
                    states.functions = {};
                }
            }
            else {
                var shaderStates = shader._states || shader.config.extensions.KHR_techniques_webgl.techniques[0].states;
                if (shaderStates) {
                    technique.states = {
                        enable: [],
                        functions: {},
                    };
                    egret3d.Shader.copyStates(shaderStates, technique.states);
                }
                else {
                    technique.states = egret3d.Shader.createDefaultStates();
                }
            }
            // Copy defines.
            if (materialDefines) {
                for (var _i = 0, materialDefines_1 = materialDefines; _i < materialDefines_1.length; _i++) {
                    var define = materialDefines_1[_i];
                    this.addDefine(define);
                }
            }
            else if (shaderDefines) {
                for (var _b = 0, shaderDefines_1 = shaderDefines; _b < shaderDefines_1.length; _b++) {
                    var define = shaderDefines_1[_b];
                    this.addDefine(define);
                }
            }
            return technique;
        };
        Material.prototype._reset = function (shaderOrConfig) {
            var glTFMaterial;
            var shader = null;
            //
            if (shaderOrConfig instanceof egret3d.Shader) {
                if (this.config) {
                    this._retainOrReleaseTextures(false);
                    glTFMaterial = this.config.materials[0];
                }
                else {
                    var config = this.config = Material.createConfig();
                    glTFMaterial = {
                        extensions: {
                            KHR_techniques_webgl: { technique: shaderOrConfig.name },
                            paper: { renderQueue: shaderOrConfig._renderQueue ? shaderOrConfig._renderQueue : 2000 /* Geometry */ }
                        }
                    };
                    config.materials = [glTFMaterial];
                }
                shader = shaderOrConfig;
            }
            else {
                var config = this.config = shaderOrConfig;
                glTFMaterial = config.materials[0];
                shader = paper.Asset.find(glTFMaterial.extensions.KHR_techniques_webgl.technique) || egret3d.DefaultShaders.MESH_BASIC;
            }
            //
            this.renderQueue = glTFMaterial.extensions.paper.renderQueue;
            this._technique = this._createTechnique(shader, glTFMaterial);
            this._shader = shader;
            this._retainOrReleaseTextures(true);
        };
        Material.prototype._retainOrReleaseTextures = function (isRatain) {
            var uniforms = this._technique.uniforms;
            for (var k in uniforms) {
                var uniform = uniforms[k];
                if (uniform.value &&
                    (uniform.type === 35678 /* SAMPLER_2D */ || uniform.type === 35680 /* SAMPLER_CUBE */)) {
                    isRatain ? uniform.value.retain() : uniform.value.release();
                }
            }
            isRatain ? this._shader.retain() : this._shader.release();
        };
        Material.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            //
            this._retainOrReleaseTextures(false);
            //
            this._version++;
            this._cacheDefines = "";
            this._defines.length = 0;
            this._technique = null;
            this._shader = null;
            return true;
        };
        /**
         * 拷贝。
         */
        Material.prototype.copy = function (value) {
            this._retainOrReleaseTextures(false);
            //
            this.renderQueue = value.renderQueue;
            this._defines.length = 0;
            this._shader = value._shader;
            // Copy uniforms.
            var sourceUniforms = value._technique.uniforms;
            var targetUniforms = this._technique.uniforms = {};
            for (var k in sourceUniforms) {
                var uniform = sourceUniforms[k];
                var uniformValue = uniform.value;
                targetUniforms[k] = {
                    type: uniform.type,
                    semantic: uniform.semantic,
                    value: Array.isArray(uniformValue) ? uniformValue.concat() : uniformValue,
                };
            }
            // Copy states and functions.
            var sourceStates = value._technique.states;
            var targetStates = this._technique.states;
            targetStates.enable = sourceStates.enable.concat();
            for (var k in sourceStates.functions) {
                var stateFunction = sourceStates.functions[k];
                targetStates.functions[k] = Array.isArray(stateFunction) ? stateFunction.concat() : stateFunction;
            }
            // Copy define.
            for (var _i = 0, _a = value._defines; _i < _a.length; _i++) {
                var define = _a[_i];
                this.addDefine(define);
            }
            //
            this._retainOrReleaseTextures(true);
            return this;
        };
        /**
         * 克隆该材质。
         */
        Material.prototype.clone = function () {
            return Material.create(this._shader).copy(this);
        };
        /**
         * 为该材质添加指定的 define。
         * @param defineString define 字符串。
         */
        Material.prototype.addDefine = function (defineString, value) {
            if (value !== undefined) {
                defineString += " " + value;
            }
            var defines = this._defines;
            if (defines.indexOf(defineString) < 0) {
                defines.push(defineString);
                defines.sort();
                this._version++;
            }
            return this;
        };
        /**
         * 从该材质移除指定的 define。
         * @param defineString define 字符串。
         */
        Material.prototype.removeDefine = function (defineString, value) {
            if (value !== undefined) {
                defineString += " " + value;
            }
            var index = this._defines.indexOf(defineString);
            if (index >= 0) {
                this._defines.splice(index, 1);
                this._version++;
            }
            return this;
        };
        Material.prototype.setBoolean = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setInt = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setIntv = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setFloat = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setFloatv = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector2 = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector2v = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector3 = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y || uniform.value[2] !== value.z) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    uniform.value[2] = value.z;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector3v = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector4 = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y || uniform.value[2] !== value.z || uniform.value[3] !== value.w) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    uniform.value[2] = value.z;
                    uniform.value[3] = value.w;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector4v = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setMatrix = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value.rawData;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setMatrixv = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        /**
         * 设置该材质的混合模式。
         * @param blend 混合模式。
         * @param renderQueue 渲染顺序。
         * @param opacity 透明度。
         */
        Material.prototype.setBlend = function (blend, renderQueue, opacity) {
            var _a = this._technique.states, enable = _a.enable, functions = _a.functions;
            switch (blend) {
                case 3 /* Add */:
                    functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                    functions.blendFuncSeparate = [770 /* SRC_ALPHA */, 1 /* ONE */, 770 /* SRC_ALPHA */, 1 /* ONE */];
                    break;
                case 4 /* Add_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                    functions.blendFuncSeparate = [1 /* ONE */, 1 /* ONE */, 1 /* ONE */, 1 /* ONE */];
                    break;
                case 1 /* Blend */:
                    functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                    functions.blendFuncSeparate = [770 /* SRC_ALPHA */, 771 /* ONE_MINUS_SRC_ALPHA */, 1 /* ONE */, 771 /* ONE_MINUS_SRC_ALPHA */];
                    break;
                case 2 /* Blend_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                    functions.blendFuncSeparate = [1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */, 1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */];
                    break;
                case 5 /* Subtractive */:
                    functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                    functions.blendFuncSeparate = [0 /* ZERO */, 769 /* ONE_MINUS_SRC_COLOR */, 0 /* ZERO */, 769 /* ONE_MINUS_SRC_COLOR */];
                    break;
                case 6 /* Subtractive_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                    functions.blendFuncSeparate = [0 /* ZERO */, 0 /* ZERO */, 769 /* ONE_MINUS_SRC_COLOR */, 771 /* ONE_MINUS_SRC_ALPHA */];
                    break;
                case 7 /* Multiply */:
                    functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                    functions.blendFuncSeparate = [0 /* ZERO */, 768 /* SRC_COLOR */, 0 /* ZERO */, 768 /* SRC_COLOR */];
                    break;
                case 8 /* Multiply_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                    functions.blendFuncSeparate = [0 /* ZERO */, 768 /* SRC_COLOR */, 0 /* ZERO */, 770 /* SRC_ALPHA */];
                    break;
                default:
                    delete functions.blendEquationSeparate;
                    delete functions.blendFuncSeparate;
                    break;
            }
            var index = enable.indexOf(3042 /* Blend */);
            if (blend === 0 /* None */) {
                if (index >= 0) {
                    enable.splice(index, 1);
                }
            }
            else {
                if (index < 0) {
                    enable.push(3042 /* Blend */);
                }
            }
            if (renderQueue) {
                this.renderQueue = renderQueue;
            }
            if (opacity !== undefined) {
                this.opacity = opacity;
            }
            return this;
        };
        /**
         * 设置该材质剔除面片的模式。
         * @param cullEnabled 是否开启剔除。
         * @param frontFace 正面的顶点顺序。
         * @param cullFace 剔除模式。
         */
        Material.prototype.setCullFace = function (cullEnabled, frontFace, cullFace) {
            if (frontFace === void 0) { frontFace = 2305 /* CCW */; }
            if (cullFace === void 0) { cullFace = 1029 /* Back */; }
            var _a = this._technique.states, enable = _a.enable, functions = _a.functions;
            var index = enable.indexOf(2884 /* CullFace */);
            if (cullEnabled) {
                if (index < 0) {
                    enable.push(2884 /* CullFace */);
                    functions.frontFace = [frontFace];
                    functions.cullFace = [cullFace];
                }
            }
            else if (index >= 0) {
                enable.splice(index, 1);
                delete functions.frontFace;
                delete functions.cullFace;
            }
            return this;
        };
        /**
         * 设置该材质的深度检测和深度缓冲。
         * @param depthTest 深度检测。
         * @param depthWrite 深度缓冲。
         */
        Material.prototype.setDepth = function (depthTest, depthWrite) {
            var _a = this._technique.states, enable = _a.enable, functions = _a.functions;
            var index = enable.indexOf(2929 /* DepthTest */);
            if (depthTest) {
                if (index < 0) {
                    enable.push(2929 /* DepthTest */);
                    functions.depthFunc = [515 /* Lequal */];
                }
            }
            else if (index >= 0) {
                enable.splice(index, 1);
                delete functions.depthFunc;
            }
            if (depthWrite) {
                functions.depthMask = [true];
            }
            else {
                functions.depthMask = [false];
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.setStencil = function (value) {
            var enable = this._technique.states.enable;
            var index = enable.indexOf(2960 /* StencilTest */);
            if (value) {
                if (index < 0) {
                    enable.push(2960 /* StencilTest */);
                }
            }
            else if (index >= 0) {
                enable.splice(index);
            }
            return this;
        };
        /**
         * 清除该材质的所有图形 API 状态。
         */
        Material.prototype.clearStates = function () {
            var _a = this._technique.states, enable = _a.enable, functions = _a.functions;
            enable.length = 0;
            for (var k in functions) {
                delete functions[k];
            }
            return this;
        };
        Material.prototype.getColor = function (p1, p2) {
            var uniformName;
            if (!p1) {
                uniformName = "diffuse" /* Diffuse */;
                p2 = egret3d.Color.create();
            }
            else if (p1 instanceof egret3d.Color) {
                uniformName = "diffuse" /* Diffuse */;
                p2 = p1;
            }
            else {
                uniformName = p1;
                if (!p2) {
                    p2 = egret3d.Color.create();
                }
            }
            var uniform = this._technique.uniforms[uniformName];
            if (uniform && uniform.value && Array.isArray(uniform.value)) {
                p2.r = uniform.value[0];
                p2.g = uniform.value[1];
                p2.b = uniform.value[2];
            }
            else if (true) {
                console.error("Invalid glTF technique uniform.");
            }
            return p2;
        };
        Material.prototype.setColor = function (p1, p2) {
            var uniformName;
            if (p1.hasOwnProperty("r")) {
                uniformName = "diffuse" /* Diffuse */;
                p2 = p1;
            }
            else {
                uniformName = p1;
            }
            this.setVector3(uniformName, egret3d.Vector3.create(p2.r, p2.g, p2.b).release());
            return this;
        };
        /**
         * 获取该材质的 UV 变换矩阵。
         * @param out 矩阵。
         */
        Material.prototype.getUVTransform = function (out) {
            if (!out) {
                out = egret3d.Matrix3.create();
            }
            var uniform = this._technique.uniforms["uvTransform" /* UVTransform */];
            if (uniform && uniform.value && Array.isArray(uniform.value)) {
                out.fromArray(uniform.value);
            }
            else if (true) {
                console.error("Invalid glTF technique uniform.");
            }
            return out;
        };
        /**
         * 设置该材质的 UV 变换矩阵。
         * @param matrix 矩阵。
         */
        Material.prototype.setUVTransform = function (matrix) {
            var array = new Array(9); // TODO
            matrix.toArray(array);
            return this.setMatrixv("uvTransform" /* UVTransform */, array);
        };
        Material.prototype.getTexture = function (uniformName) {
            if (!uniformName) {
                uniformName = "map" /* Map */;
            }
            var uniform = this._technique.uniforms[uniformName];
            if (uniform) {
                return uniform.value || null; // TODO
            }
            else {
                console.error("Invalid glTF technique uniform.", uniformName);
            }
            return null;
        };
        Material.prototype.setTexture = function (p1, p2) {
            if (p1 === null || p1 instanceof egret3d.BaseTexture) {
                p2 = p1;
                p1 = "map" /* Map */;
            }
            if (!p2) {
                p2 = egret3d.DefaultTextures.WHITE;
            }
            var uniform = this._technique.uniforms[p1];
            if (uniform) {
                if (uniform.value !== p2) {
                    var existingTexture = uniform.value;
                    if (existingTexture) {
                        existingTexture.release();
                    }
                    if (p2) {
                        p2.retain();
                        if (p2 instanceof egret3d.RenderTexture) {
                            this.addDefine("FLIP_V" /* FLIP_V */);
                        }
                    }
                    uniform.value = p2;
                    this._version++;
                }
            }
            else {
                console.error("Invalid glTF technique uniform.", p1);
            }
            return this;
        };
        Object.defineProperty(Material.prototype, "shaderDefine", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                this._cacheDefines = "";
                for (var _i = 0, _a = this._defines; _i < _a.length; _i++) {
                    var key = _a[_i];
                    this._cacheDefines += "#define " + key + " \n";
                }
                return this._cacheDefines;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "opacity", {
            /**
             * 该材质的透明度。
             */
            get: function () {
                var uniformName = "opacity" /* Opacity */;
                var uniform = this._technique.uniforms[uniformName];
                if (uniform) {
                    var value = uniform.value;
                    return (value !== value) ? 1.0 : value;
                }
                else {
                    console.error("Invalid glTF technique uniform.", uniformName);
                }
                return 1.0;
            },
            set: function (value) {
                this.setFloat("opacity" /* Opacity */, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "shader", {
            /**
             * 该材质的 shader。
             */
            get: function () {
                return this._shader;
            },
            set: function (value) {
                if (!value) {
                    console.error("Set shader error.");
                    value = egret3d.DefaultShaders.MESH_BASIC;
                }
                if (this._shader === value) {
                    return;
                }
                this._reset(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "defines", {
            /**
             *
             */
            get: function () {
                return this._defines;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "technique", {
            /**
             * 该材质的渲染技术。
             */
            get: function () {
                return this._technique;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Material.prototype.setRenderQueue = function (value) {
            this.renderQueue = value;
            return this;
        };
        /**
         * @deprecated
         */
        Material.prototype.setOpacity = function (value) {
            return this.setFloat("opacity" /* Opacity */, value);
        };
        /**
         * @deprecated
         */
        Material.prototype.setShader = function (value) {
            if (!value) {
                if (true) {
                    console.warn("Set shader error.");
                }
                value = egret3d.DefaultShaders.MESH_BASIC;
            }
            if (this._shader === value) {
                return;
            }
            this._reset(value);
            return this;
        };
        return Material;
    }(egret3d.GLTFAsset));
    egret3d.Material = Material;
    __reflect(Material.prototype, "egret3d.Material");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 贝塞尔曲线，目前定义了三种：线性贝塞尔曲线(两个点形成),二次方贝塞尔曲线（三个点形成），三次方贝塞尔曲线（四个点形成）
     */
    var Curve3 = (function () {
        /**
         * @internal
         */
        function Curve3(beizerPoints, bezierPointNum) {
            this.beizerPoints = beizerPoints;
            this.bezierPointNum = bezierPointNum;
        }
        /**
         * 线性贝塞尔曲线
         */
        Curve3.createLinearBezier = function (start, end, indices) {
            indices = indices > 2 ? indices : 3;
            var bez = new Array();
            var equation = function (t, va10, va11) {
                var res = (1.0 - t) * va10 + t * va11;
                return res;
            };
            bez.push(start);
            for (var i = 1; i <= indices; i++) {
                bez.push(new egret3d.Vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
            }
            return new Curve3(bez, indices);
        };
        /**
         * 二次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 选中的节点
         * @param v2 结尾点
         * @param bezierPointNum 将贝塞尔曲线拆分bezierPointNum段，一共有bezierPointNum + 1个点
         * @returns 贝塞尔曲线对象
         */
        Curve3.createQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
            bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2) {
                var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        /**
         * 三次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 第一个插值点
         * @param v2 第二个插值点
         * @param v3 终点
         * @param bezierPointNum 将贝塞尔曲线拆分bezierPointNum段，一共有bezierPointNum + 1个点
         * @returns 贝塞尔曲线对象
         */
        Curve3.createCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
            bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2, val3) {
                var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        return Curve3;
    }());
    egret3d.Curve3 = Curve3;
    __reflect(Curve3.prototype, "egret3d.Curve3");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 射线。
     */
    var Ray = (function (_super) {
        __extends(Ray, _super);
        /**
         * 请使用 `egret3d.Ray.create()` 创建实例。
         * @see egret3d.Ray.create()
         */
        function Ray() {
            var _this = _super.call(this) || this;
            /**
             * 射线的起点。
             */
            _this.origin = egret3d.Vector3.create();
            /**
             * 射线的方向。
             */
            _this.direction = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个射线。
         * @param origin 射线的起点。
         * @param direction 射线的方向。
         */
        Ray.create = function (origin, direction) {
            if (origin === void 0) { origin = egret3d.Vector3.ZERO; }
            if (direction === void 0) { direction = egret3d.Vector3.FORWARD; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(origin, direction);
                instance._released = false;
                return instance;
            }
            return new Ray().set(origin, direction);
        };
        Ray.prototype.serialize = function () {
            return [this.origin.x, this.origin.y, this.origin.z, this.direction.x, this.direction.y, this.direction.z];
        };
        Ray.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Ray.prototype.copy = function (value) {
            return this.set(value.origin, value.direction);
        };
        Ray.prototype.clone = function () {
            return Ray.create(this.origin, this.direction);
        };
        Ray.prototype.set = function (origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        };
        Ray.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.origin.fromArray(value, offset);
            this.direction.fromArray(value, offset + 3);
            return this;
        };
        /**
         * 设置该射线，使其从起点出发，经过终点。
         * @param from 起点。
         * @param to 终点。
         */
        Ray.prototype.fromPoints = function (from, to) {
            this.direction.subtract(to, this.origin.copy(from)).normalize();
            return this;
        };
        Ray.prototype.applyMatrix = function (matrix, input) {
            this.origin.applyMatrix(matrix, (input || this).origin);
            this.direction.applyDirection(matrix, (input || this).direction);
            return this;
        };
        /**
         * 获取一个点到该射线的最近点。
         * @param point 一个点。
         * @param out 最近点。
         */
        Ray.prototype.getClosestPointToPoint = function (point, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            var origin = out !== this.origin ? this.origin : egret3d.helpVector3A.copy(this.origin);
            var direction = this.direction;
            var directionDistance = out.subtract(point, origin).dot(direction);
            if (directionDistance < 0.0) {
                return out.copy(origin);
            }
            return out.copy(direction).multiplyScalar(directionDistance).add(origin);
        };
        /**
         * 获取从该射线的起点沿着射线方向移动一段距离的一个点。
         * - out = ray.origin + ray.direction * distanceDelta
         * @param distanceDelta 移动距离。
         * @param out 一个点。
         */
        Ray.prototype.getPointAt = function (distanceDelta, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            var origin = out !== this.origin ? this.origin : egret3d.helpVector3A.copy(this.origin);
            return out.multiplyScalar(distanceDelta, this.direction).add(origin);
        };
        /**
         * 获取一个点到该射线的最近距离的平方。
         * @param point 一个点。
         */
        Ray.prototype.getSquaredDistance = function (point) {
            var origin = this.origin;
            var directionDistance = egret3d.helpVector3A.subtract(point, origin).dot(this.direction);
            // point behind the ray
            if (directionDistance < 0.0) {
                return origin.getSquaredDistance(point);
            }
            return this.getPointAt(directionDistance, egret3d.helpVector3A).getSquaredDistance(point);
        };
        /**
         * 获取一个点到该射线的最近距离。
         * @param point 一个点。
         */
        Ray.prototype.getDistance = function (point) {
            return Math.sqrt(this.getSquaredDistance(point));
        };
        /**
         * 获取该射线起点到一个平面的最近距离。
         * - 如果射线并不与平面相交，则返回 -1。
         * @param plane 一个平面。
         */
        Ray.prototype.getDistanceToPlane = function (plane) {
            var origin = this.origin;
            var planeNormal = plane.normal;
            var denominator = planeNormal.dot(this.direction);
            if (denominator === 0.0) {
                // line is coplanar, return origin
                if (plane.getDistance(origin) === 0.0) {
                    return 0.0;
                }
                // Null is preferable to undefined since undefined means.... it is undefined
                return -1.0;
            }
            var t = -(origin.dot(planeNormal) + plane.constant) / denominator;
            // Return if the ray never intersects the plane
            return t >= 0.0 ? t : -1.0;
        };
        Ray._instances = [];
        return Ray;
    }(paper.BaseRelease));
    egret3d.Ray = Ray;
    __reflect(Ray.prototype, "egret3d.Ray", ["paper.ICCS", "paper.ISerializable"]);
    /**
     * @internal
     */
    egret3d.helpRay = Ray.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var GroupComponent = (function (_super) {
        __extends(GroupComponent, _super);
        function GroupComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.componentIndex = -1;
            _this.componentClass = null;
            _this.components = [];
            return _this;
        }
        GroupComponent.prototype.addComponent = function (component) {
            this.components.push(component);
        };
        GroupComponent.prototype.removeComponent = function (component) {
            var index = this.components.indexOf(component);
            if (index >= 0) {
                this.components.splice(1, 0);
            }
        };
        return GroupComponent;
    }(paper.BaseComponent));
    paper.GroupComponent = GroupComponent;
    __reflect(GroupComponent.prototype, "paper.GroupComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 动画资源。
     */
    var AnimationAsset = (function (_super) {
        __extends(AnimationAsset, _super);
        function AnimationAsset() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @private
         */
        AnimationAsset.create = function (name, config, buffers) {
            var animationAsset = new AnimationAsset(name, config);
            animationAsset.initialize();
            for (var _i = 0, buffers_2 = buffers; _i < buffers_2.length; _i++) {
                var b = buffers_2[_i];
                animationAsset.buffers.push(b);
            }
            return animationAsset;
        };
        AnimationAsset.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.updateAccessorTypeCount();
        };
        /*
         * 获取动画剪辑。
         */
        AnimationAsset.prototype.getAnimationClip = function (name) {
            if (!this.config.animations ||
                this.config.animations.length === 0) {
                return null;
            }
            var animation = this.config.animations[0];
            if (animation.extensions.paper.clips.length === 0) {
                return null;
            }
            if (!name) {
                return animation.extensions.paper.clips[0];
            }
            for (var _i = 0, _a = this.config.animations; _i < _a.length; _i++) {
                var animation_1 = _a[_i];
                for (var _b = 0, _c = animation_1.extensions.paper.clips; _b < _c.length; _b++) {
                    var animationClip = _c[_b];
                    if (animationClip.name === name) {
                        return animationClip;
                    }
                }
            }
            return null;
        };
        return AnimationAsset;
    }(egret3d.GLTFAsset));
    egret3d.AnimationAsset = AnimationAsset;
    __reflect(AnimationAsset.prototype, "egret3d.AnimationAsset");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var AnimationController = (function (_super) {
        __extends(AnimationController, _super);
        function AnimationController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationController.create = function (name, config) {
            var animationController;
            if (!config) {
                config = this.createConfig();
                config.extensions = {
                    paper: {
                        animationControllers: [{
                                layers: [],
                                parameters: []
                            }]
                    },
                };
            }
            animationController = new AnimationController(name, config);
            animationController.initialize();
            return animationController;
        };
        /**
         * 添加一个新的动画层。
         */
        AnimationController.prototype.addLayer = function (name) {
            var layers = this.layers;
            var layer = {
                additive: false,
                weight: 1.0,
                name: name,
                machine: {
                    name: "Default" /* Default */,
                    nodes: [],
                },
            };
            layers.push(layer);
            return layer;
        };
        AnimationController.prototype.createAnimationTree = function (machineOrTreen, name) {
            var animationTree = {
                timeScale: 1.0,
                blendType: 0 /* E1D */,
                name: name,
                parameters: [],
                nodes: []
            };
            var nodes = machineOrTreen.nodes;
            if (nodes.indexOf(animationTree) < 0) {
                nodes.push(animationTree);
            }
            return animationTree;
        };
        AnimationController.prototype.createAnimationNode = function (machineOrTreen, asset, clip) {
            var animationNode = {
                asset: asset,
                clip: clip,
                timeScale: 1.0,
            };
            var nodes = machineOrTreen.nodes;
            if (nodes.indexOf(animationNode) < 0) {
                nodes.push(animationNode);
            }
            return animationNode;
        };
        /**
         * 获取或添加一个动画层。
         * - 层索引强制连续。
         */
        AnimationController.prototype.getOrAddLayer = function (layerIndex) {
            var layers = this.layers;
            if (layerIndex >= layers.length) {
                layerIndex = layers.length;
                this.addLayer("NoName" /* NoName */);
            }
            return layers[layerIndex];
        };
        Object.defineProperty(AnimationController.prototype, "layers", {
            get: function () {
                return this.config.extensions.paper.animationControllers[0].layers;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationController;
    }(egret3d.GLTFAsset));
    egret3d.AnimationController = AnimationController;
    __reflect(AnimationController.prototype, "egret3d.AnimationController");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var AnimationMask = (function (_super) {
        __extends(AnimationMask, _super);
        function AnimationMask() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._dirty = false;
            _this._jointNamesDirty = false;
            _this._jointNames = [];
            return _this;
        }
        AnimationMask.create = function (name, config) {
            var animationMask;
            if (!config) {
                config = this.createConfig();
                config.nodes = [];
                config.extensions = {
                    paper: {
                        animationMasks: [{
                                retargeting: [],
                                joints: []
                            }]
                    },
                };
            }
            animationMask = new AnimationMask(name, config);
            animationMask.initialize();
            return animationMask;
        };
        AnimationMask.prototype._addJoint = function (nodes, joints, jointIndex, recursive) {
            if (joints.indexOf(jointIndex) < 0) {
                joints.push(jointIndex);
                this._dirty = true;
                this._jointNamesDirty = true;
            }
            if (recursive) {
                var node = nodes[jointIndex];
                var children = node.children;
                if (!children) {
                    return;
                }
                for (var _i = 0, children_6 = children; _i < children_6.length; _i++) {
                    var index = children_6[_i];
                    this._addJoint(nodes, joints, index, recursive);
                }
            }
        };
        AnimationMask.prototype.createJoints = function (mesh) {
            var nodes = this.config.nodes;
            nodes.length = 0;
            for (var _i = 0, _a = mesh.config.nodes; _i < _a.length; _i++) {
                var meshNode = _a[_i];
                var node = {
                    name: meshNode.name
                };
                if (meshNode.children) {
                    node.children = meshNode.children.concat();
                }
                nodes.push(node);
            }
            return this;
        };
        AnimationMask.prototype.addJoint = function (name, recursive) {
            if (recursive === void 0) { recursive = true; }
            var index = 0;
            var nodes = this.config.nodes;
            var joints = this.config.extensions.paper.animationMasks[0].joints;
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i];
                if (node.name === name) {
                    this._addJoint(nodes, joints, index, recursive);
                    return this;
                }
                index++;
            }
            console.warn("Invalid joint mask name.", name);
            return this;
        };
        AnimationMask.prototype.removeJoint = function (name, recursive) {
            if (recursive === void 0) { recursive = true; }
            var index = 0;
            var nodes = this.config.nodes;
            var joints = this.config.extensions.paper.animationMasks[0].joints;
            for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
                var node = nodes_2[_i];
                if (node.name === name) {
                    if (joints.indexOf(index) >= 0) {
                        joints.splice(index, 1);
                    }
                    break;
                }
                index++;
            }
            // recursive // TODO
            return this;
        };
        AnimationMask.prototype.removeJoints = function () {
            var joints = this.config.extensions.paper.animationMasks[0].joints;
            joints.length = 0;
            this._dirty = true;
            this._jointNamesDirty = true;
            return this;
        };
        Object.defineProperty(AnimationMask.prototype, "jointNames", {
            get: function () {
                var jointNames = this._jointNames;
                if (this._jointNamesDirty) {
                    var nodes = this.config.nodes;
                    var joints = this.config.extensions.paper.animationMasks[0].joints;
                    jointNames.length = 0;
                    for (var _i = 0, joints_1 = joints; _i < joints_1.length; _i++) {
                        var index = joints_1[_i];
                        var node = nodes[index];
                        jointNames.push(node.name);
                    }
                    this._jointNamesDirty = false;
                }
                return jointNames;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationMask;
    }(egret3d.GLTFAsset));
    egret3d.AnimationMask = AnimationMask;
    __reflect(AnimationMask.prototype, "egret3d.AnimationMask");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    /**
     * 提供默认的几何网格资源，以及创建几何网格或几何网格实体的方式。
     */
    var MeshBuilder = (function () {
        function MeshBuilder() {
        }
        /**
         * 创建平面网格。
         * @param width 宽度。
         * @param height 高度。
         * @param centerOffsetX 中心点偏移 X。
         * @param centerOffsetY 中心点偏移 Y。
         * @param widthSegments 宽度分段。
         * @param heightSegments 高度分段。
         */
        MeshBuilder.createPlane = function (width, height, centerOffsetX, centerOffsetY, widthSegments, heightSegments) {
            if (width === void 0) { width = 1.0; }
            if (height === void 0) { height = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            var widthHalf = width / 2;
            var heightHalf = height / 2;
            var gridX1 = widthSegments + 1;
            var gridY1 = heightSegments + 1;
            var segmentWidth = width / widthSegments;
            var segmentHeight = height / heightSegments;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // generate vertices, normals and uvs
            for (var iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (var ix = 0; ix < gridX1; ix++) {
                    var x = ix * segmentWidth - widthHalf;
                    vertices.push(x + centerOffsetX, -y + centerOffsetY, 0.0);
                    normals.push(0.0, 0.0, -1.0);
                    uvs.push(ix / widthSegments, iy / heightSegments);
                }
            }
            // indices
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = ix + gridX1 * iy;
                    var b = ix + gridX1 * (iy + 1);
                    var c = (ix + 1) + gridX1 * (iy + 1);
                    var d = (ix + 1) + gridX1 * iy;
                    // faces
                    // a - d
                    // | / |
                    // b - c
                    indices.push(a, b, d, d, b, c);
                }
            }
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
         * 创建立方体网格。
         * @param width 宽度。
         * @param height 高度。
         * @param depth 深度。
         * @param centerOffsetX 中心点偏移 X。
         * @param centerOffsetY 中心点偏移 Y。
         * @param centerOffsetZ 中心点偏移 Z。
         * @param widthSegments 宽度分段。
         * @param heightSegments 高度分段。
         * @param depthSegments 深度分段。
         * @param differentFace 是否使用不同材质。
         */
        MeshBuilder.createCube = function (width, height, depth, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, depthSegments, differentFace) {
            if (width === void 0) { width = 1.0; }
            if (height === void 0) { height = 1.0; }
            if (depth === void 0) { depth = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (depthSegments === void 0) { depthSegments = 1; }
            if (differentFace === void 0) { differentFace = false; }
            // helper variables
            var meshVertexCount = 0;
            var vector3 = _helpVector3;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // build each side of the box geometry
            buildPlane("z", "y", "x", -1, -1, depth, height, -width, depthSegments, heightSegments); // px
            buildPlane("z", "y", "x", 1, -1, depth, height, width, depthSegments, heightSegments); // nx
            buildPlane("x", "z", "y", 1, 1, width, depth, -height, widthSegments, depthSegments); // py
            buildPlane("x", "z", "y", 1, -1, width, depth, height, widthSegments, depthSegments); // ny
            buildPlane("x", "y", "z", 1, -1, width, height, -depth, widthSegments, heightSegments); // pz
            buildPlane("x", "y", "z", -1, -1, width, height, depth, widthSegments, heightSegments); // nz
            // build geometry
            if (differentFace) {
                var faceIndexCount = indices.length / 6;
                var mesh = egret3d.Mesh.create(vertices.length / 3, 0);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                for (var i = 0; i < 6; ++i) {
                    mesh.addSubMesh(faceIndexCount, i);
                    mesh.setIndices(indices, i, faceIndexCount * i);
                }
                return mesh;
            }
            else {
                var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                mesh.setIndices(indices);
                return mesh;
            }
            function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY) {
                var segmentWidth = width / gridX;
                var segmentHeight = height / gridY;
                var widthHalf = width / 2;
                var heightHalf = height / 2;
                var depthHalf = depth / 2;
                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;
                var vertexCount = 0;
                // generate vertices, normals and uvs
                for (var iy = 0; iy < gridY1; iy++) {
                    var y = iy * segmentHeight - heightHalf;
                    for (var ix = 0; ix < gridX1; ix++) {
                        var x = ix * segmentWidth - widthHalf;
                        // set values to correct vector component
                        vector3[u] = x * udir;
                        vector3[v] = y * vdir;
                        vector3[w] = depthHalf;
                        // now apply vector to vertex buffer
                        vertices.push(vector3.x + centerOffsetX, vector3.y + centerOffsetY, vector3.z + centerOffsetZ);
                        // set values to correct vector component
                        vector3[u] = 0.0;
                        vector3[v] = 0.0;
                        vector3[w] = depth > 0.0 ? 1.0 : -1.0;
                        // now apply vector to normal buffer
                        normals.push(vector3.x, vector3.y, vector3.z);
                        // uvs
                        uvs.push(ix / gridX, iy / gridY);
                        // counters
                        vertexCount += 1;
                    }
                }
                // indices
                // 1. you need three indices to draw a single face
                // 2. a single segment consists of two faces
                // 3. so we need to generate six (2*3) indices per segment
                for (var iy = 0; iy < gridY; iy++) {
                    for (var ix = 0; ix < gridX; ix++) {
                        var a = meshVertexCount + ix + gridX1 * iy;
                        var b = meshVertexCount + ix + gridX1 * (iy + 1);
                        var c = meshVertexCount + (ix + 1) + gridX1 * (iy + 1);
                        var d = meshVertexCount + (ix + 1) + gridX1 * iy;
                        // faces
                        // a - d
                        // | / |
                        // b - c
                        indices.push(a, b, d, b, c, d);
                    }
                }
                // update total number of vertices
                meshVertexCount += vertexCount;
            }
        };
        /**
         * 创建圆柱体网格。
         * @param radiusTop 顶部半径。
         * @param radiusBottom 底部半径。
         * @param height 高度。
         * @param centerOffsetX 中心点偏移 X。
         * @param centerOffsetY 中心点偏移 Y。
         * @param centerOffsetZ 中心点偏移 Z。
         * @param radialSegments 径向分段。
         * @param heightSegments 高度分段。
         * @param openEnded 是否开口。
         * @param thetaStart 起始弧度。
         * @param thetaLength 覆盖弧度。
         * @param differentFace 是否使用不同材质。
         */
        MeshBuilder.createCylinder = function (radiusTop, radiusBottom, height, centerOffsetX, centerOffsetY, centerOffsetZ, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, differentFace) {
            if (radiusTop === void 0) { radiusTop = 0.5; }
            if (radiusBottom === void 0) { radiusBottom = 0.5; }
            if (height === void 0) { height = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (radialSegments === void 0) { radialSegments = 16; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (openEnded === void 0) { openEnded = false; }
            if (thetaStart === void 0) { thetaStart = 0.0; }
            if (thetaLength === void 0) { thetaLength = Math.PI * 2.0; }
            if (differentFace === void 0) { differentFace = false; }
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var index = 0;
            var groupStart = 0;
            var halfHeight = height / 2;
            var vector3 = _helpVector3;
            var indexArray = [];
            var subIndices = [];
            // generate geometry
            generateTorso();
            if (openEnded === false) {
                if (radiusTop > 0.0)
                    generateCap(true);
                if (radiusBottom > 0.0)
                    generateCap(false);
            }
            // build geometry
            if (differentFace) {
                var mesh = egret3d.Mesh.create(vertices.length / 3, 0);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                for (var i = 0; i < subIndices.length; i += 3) {
                    mesh.addSubMesh(subIndices[1], subIndices[2]);
                    mesh.setIndices(indices, i, subIndices[0]);
                }
                return mesh;
            }
            else {
                var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                mesh.setIndices(indices);
                return mesh;
            }
            function generateTorso() {
                var groupCount = 0;
                // this will be used to calculate the normal
                var slope = (radiusBottom - radiusTop) / height;
                // generate vertices, normals and uvs
                for (var iY = 0; iY <= heightSegments; iY++) {
                    var indexRow = [];
                    var v = iY / heightSegments;
                    // calculate the radius of the current row
                    var radius = v * (radiusBottom - radiusTop) + radiusTop;
                    for (var iX = 0; iX <= radialSegments; iX++) {
                        var u = iX / radialSegments;
                        var theta = u * thetaLength + thetaStart;
                        var sinTheta = Math.sin(theta);
                        var cosTheta = Math.cos(theta);
                        // vertex
                        vector3.x = radius * sinTheta;
                        vector3.y = -v * height + halfHeight;
                        // vertex.z = radius * cosTheta; // Right-hand coordinates system.
                        vector3.z = -radius * cosTheta; // Left-hand coordinates system.
                        vertices.push(vector3.x + centerOffsetX, vector3.y + centerOffsetY, vector3.z + centerOffsetZ);
                        // normal
                        vector3.set(sinTheta, slope, cosTheta).normalize();
                        // normals.push(vector3.x, vector3.y, vector3.z); // Right-hand coordinates system.
                        normals.push(vector3.x, vector3.y, -vector3.z); // Left-hand coordinates system.
                        // uv
                        uvs.push(u, v);
                        // save index of vertex in respective row
                        indexRow.push(index++);
                    }
                    // now save vertices of the row in our index array
                    indexArray.push(indexRow);
                }
                // generate indices
                for (var iX = 0; iX < radialSegments; iX++) {
                    for (var iY = 0; iY < heightSegments; iY++) {
                        // we use the index array to access the correct indices
                        var a = indexArray[iY][iX];
                        var b = indexArray[iY + 1][iX];
                        var c = indexArray[iY + 1][iX + 1];
                        var d = indexArray[iY][iX + 1];
                        // faces
                        indices.push(a, b, d, b, c, d);
                        // update group counter
                        groupCount += 6;
                    }
                }
                // add a group to the geometry. this will ensure multi material support
                subIndices.push(groupStart, groupCount, 0);
                // calculate new start value for groups
                groupStart += groupCount;
            }
            function generateCap(top) {
                var centerIndexStart = 0, centerIndexEnd = 0;
                var groupCount = 0;
                var radius = top ? radiusTop : radiusBottom;
                var sign = top ? 1 : -1;
                // save the index of the first center vertex
                centerIndexStart = index;
                // first we generate the center vertex data of the cap.
                // because the geometry needs one set of uvs per face,
                // we must generate a center vertex per face/segment
                for (var iX = 1; iX <= radialSegments; iX++) {
                    // vertex
                    vertices.push(0.0, halfHeight * sign, 0.0);
                    // normal
                    normals.push(0.0, sign, 0.0);
                    // uv
                    uvs.push(0.5, 0.5);
                    // increase index
                    index++;
                }
                // save the index of the last center vertex
                centerIndexEnd = index;
                // now we generate the surrounding vertices, normals and uvs
                for (var iX = 0; iX <= radialSegments; iX++) {
                    var u = iX / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var cosTheta = Math.cos(theta);
                    var sinTheta = Math.sin(theta);
                    // vertex
                    vector3.x = radius * sinTheta;
                    vector3.y = halfHeight * sign;
                    // vector3.z = radius * cosTheta; // Right-hand coordinates system.
                    vector3.z = -radius * cosTheta; // Left-hand coordinates system.
                    vertices.push(vector3.x + centerOffsetX, vector3.y + centerOffsetY, vector3.z + centerOffsetZ);
                    // normal
                    normals.push(0.0, sign, 0.0);
                    // uv
                    uvs.push((sinTheta * 0.5 * sign) + 0.5, (cosTheta * 0.5) + 0.5);
                    // increase index
                    index++;
                }
                // generate indices
                for (var iX = 0; iX < radialSegments; iX++) {
                    var c = centerIndexStart + iX;
                    var i = centerIndexEnd + iX;
                    if (top === true) {
                        // face top
                        indices.push(i, i + 1, c);
                    }
                    else {
                        // face bottom
                        indices.push(i + 1, i, c);
                    }
                    groupCount += 3;
                }
                // add a group to the geometry. this will ensure multi material support
                subIndices.push(groupStart, groupCount, top === true ? 1 : 2);
                // calculate new start value for groups
                groupStart += groupCount;
            }
        };
        /**
         * 创建圆形网格。
         */
        MeshBuilder.createCircle = function (radius, arc, axis) {
            if (radius === void 0) { radius = 0.5; }
            if (arc === void 0) { arc = 1.0; }
            if (axis === void 0) { axis = 3; }
            var vertices = [];
            for (var i = 0; i <= 64 * arc; ++i) {
                switch (axis) {
                    case 1:
                        vertices.push(0.0, Math.cos(i / 32 * Math.PI) * radius, -Math.sin(i / 32 * Math.PI) * radius);
                        break;
                    case 2:
                        vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0.0, -Math.sin(i / 32 * Math.PI) * radius);
                        break;
                    case 3:
                        vertices.push(Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius, -0.0);
                        break;
                }
            }
            var mesh = egret3d.Mesh.create(vertices.length / 3, 0, ["POSITION" /* POSITION */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.glTFMesh.primitives[0].mode = 3 /* LineStrip */;
            return mesh;
        };
        /**
         * 创建圆环网格。
         */
        MeshBuilder.createTorus = function (radius, tube, radialSegments, tubularSegments, arc, axis) {
            if (radius === void 0) { radius = 0.5; }
            if (tube === void 0) { tube = 0.1; }
            if (radialSegments === void 0) { radialSegments = 4; }
            if (tubularSegments === void 0) { tubularSegments = 12; }
            if (arc === void 0) { arc = 1.0; }
            if (axis === void 0) { axis = 3; }
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var center = egret3d.Vector3.create();
            var vertex = egret3d.Vector3.create();
            var normal = egret3d.Vector3.create();
            var j, i;
            // generate vertices, normals and uvs
            for (j = 0; j <= radialSegments; j++) {
                for (i = 0; i <= tubularSegments; i++) {
                    var u = i / tubularSegments * Math.PI * 2 * arc;
                    var v = j / radialSegments * Math.PI * 2;
                    // vertex
                    switch (axis) {
                        case 1:
                            vertex.x = tube * Math.sin(v);
                            vertex.y = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.z = (radius + tube * Math.cos(v)) * Math.sin(u);
                            break;
                        case 2:
                            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.y = tube * Math.sin(v);
                            vertex.z = (radius + tube * Math.cos(v)) * Math.sin(u);
                            break;
                        default:
                            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                            vertex.z = tube * Math.sin(v);
                    }
                    vertices.push(vertex.x, vertex.y, -vertex.z);
                    // normal
                    center.x = radius * Math.cos(u);
                    center.y = radius * Math.sin(u);
                    normal.subtract(vertex, center).normalize();
                    normals.push(normal.x, normal.y, -normal.z);
                    // uv
                    uvs.push(i / tubularSegments);
                    uvs.push(j / radialSegments);
                }
            }
            // generate indices
            for (j = 1; j <= radialSegments; j++) {
                for (i = 1; i <= tubularSegments; i++) {
                    // indices
                    var a = (tubularSegments + 1) * j + i - 1;
                    var b = (tubularSegments + 1) * (j - 1) + i - 1;
                    var c = (tubularSegments + 1) * (j - 1) + i;
                    var d = (tubularSegments + 1) * j + i;
                    // faces
                    indices.push(a, b, d, b, c, d);
                }
            }
            center.release();
            vertex.release();
            normal.release();
            // build geometry
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length, ["POSITION" /* POSITION */, "NORMAL" /* NORMAL */, "TEXCOORD_0" /* TEXCOORD_0 */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
        * 创建球体网格。
        * @param radius 半径。
        * @param centerOffsetX 中心点偏移 X。
        * @param centerOffsetY 中心点偏移 Y。
        * @param centerOffsetZ 中心点偏移 Z。
        * @param widthSegments 宽度分段。
        * @param heightSegments 高度分段。
        * @param phiStart 水平起始弧度。
        * @param phiLength 水平覆盖弧度。
        * @param thetaStart 垂直起始弧度。
        * @param thetaLength 垂直覆盖弧度。
        */
        MeshBuilder.createSphere = function (radius, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            if (radius === void 0) { radius = 0.5; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (widthSegments === void 0) { widthSegments = 24; }
            if (heightSegments === void 0) { heightSegments = 12; }
            if (phiStart === void 0) { phiStart = 0.0; }
            if (phiLength === void 0) { phiLength = Math.PI * 2.0; }
            if (thetaStart === void 0) { thetaStart = 0.0; }
            if (thetaLength === void 0) { thetaLength = Math.PI; }
            widthSegments = Math.max(3, Math.floor(widthSegments));
            heightSegments = Math.max(2, Math.floor(heightSegments));
            var thetaEnd = thetaStart + thetaLength;
            var index = 0;
            var grid = [];
            var vector3 = _helpVector3;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // generate vertices, normals and uvs
            for (var iY = 0; iY <= heightSegments; iY++) {
                var verticesRow = [];
                var v = iY / heightSegments;
                for (var iX = 0; iX <= widthSegments; iX++) {
                    var u = iX / widthSegments;
                    // vertex
                    vector3.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vector3.y = radius * Math.cos(thetaStart + v * thetaLength);
                    vector3.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertices.push(vector3.x + centerOffsetX, vector3.y + centerOffsetY, -vector3.z + centerOffsetZ);
                    // normal
                    vector3.normalize();
                    normals.push(vector3.x, vector3.y, -vector3.z);
                    // uv
                    uvs.push(u, v);
                    verticesRow.push(index++);
                }
                grid.push(verticesRow);
            }
            // indices
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];
                    if (iy !== 0 || thetaStart > 0)
                        indices.push(a, b, d);
                    if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                        indices.push(b, c, d);
                }
            }
            // build geometry
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length, ["POSITION" /* POSITION */, "NORMAL" /* NORMAL */, "TEXCOORD_0" /* TEXCOORD_0 */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        return MeshBuilder;
    }());
    egret3d.MeshBuilder = MeshBuilder;
    __reflect(MeshBuilder.prototype, "egret3d.MeshBuilder");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderLib;
    (function (ShaderLib) {
        ShaderLib.copy = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "copy_vert", "type": 35633, "uri": "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}" }, { "name": "copy_frag", "type": 35632, "uri": "uniform float opacity;\r\nuniform sampler2D map;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\tvec4 texel = texture2D( map, vUv );\r\n\tgl_FragColor = opacity * texel;\r\n}" }], "techniques": [{ "name": "copy", "attributes": {}, "uniforms": { "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.cube = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "cube_vert", "type": 35633, "uri": "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_Position.z = gl_Position.w; // set z to camera.far\r\n\r\n}\r\n" }, { "name": "cube_frag", "type": 35632, "uri": "uniform samplerCube tCube;\r\nuniform float tFlip;\r\nuniform float opacity;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\r\n\tgl_FragColor.a *= opacity;\r\n\r\n}\r\n" }], "techniques": [{ "name": "cube", "attributes": {}, "uniforms": { "tCube": { "type": 35680 }, "tFlip": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.depth = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "depth_vert", "type": 35633, "uri": "#include <common>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n}\r\n" }, { "name": "depth_frag", "type": 35632, "uri": "#if DEPTH_PACKING == 3200\r\n\r\n\tuniform float opacity;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tdiffuseColor.a = opacity;\r\n\r\n\t#endif\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\r\n\r\n\t#elif DEPTH_PACKING == 3201\r\n\r\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\r\n\r\n\t#endif\r\n\r\n}\r\n" }], "techniques": [{ "name": "depth", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "logDepthBufFC": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.distanceRGBA = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "distanceRGBA_vert", "type": 35633, "uri": "#define DISTANCE\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvWorldPosition = worldPosition.xyz;\r\n\r\n}\r\n" }, { "name": "distanceRGBA_frag", "type": 35632, "uri": "#define DISTANCE\r\n\r\nuniform vec3 referencePosition;\r\nuniform float nearDistance;\r\nuniform float farDistance;\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main () {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\tfloat dist = length( vWorldPosition - referencePosition );\r\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\r\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\r\n\r\n\tgl_FragColor = packDepthToRGBA( dist );\r\n\r\n}\r\n" }], "techniques": [{ "name": "distanceRGBA", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.equirect = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "equirect_vert", "type": 35633, "uri": "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n}\r\n" }, { "name": "equirect_frag", "type": 35632, "uri": "uniform sampler2D tEquirect;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvec3 direction = normalize( vWorldPosition );\r\n\r\n\tvec2 sampleUV;\r\n\r\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\r\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\r\n\r\n}\r\n" }], "techniques": [{ "name": "equirect", "attributes": {}, "uniforms": { "tEquirect": { "type": 35678 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.linebasic = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "linebasic_vert", "type": 35633, "uri": "#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\nuniform float linewidth;\r\nuniform vec2 resolution;\r\nattribute vec3 instanceStart;\r\nattribute vec3 instanceEnd;\r\nattribute vec3 instanceColorStart;\r\nattribute vec3 instanceColorEnd;\r\nvarying vec2 vUv;\r\n#ifdef USE_DASH\r\n\tuniform float dashScale;\r\n\tattribute float instanceDistanceStart;\r\n\tattribute float instanceDistanceEnd;\r\n\tvarying float vLineDistance;\r\n#endif\r\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\r\n\t// trim end segment so it terminates between the camera plane and the near plane\r\n\t// conservative estimate of the near plane\r\n\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\r\n\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\r\n\tfloat nearEstimate = - 0.5 * b / a;\r\n\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\r\n\tend.xyz = mix( start.xyz, end.xyz, alpha );\r\n}\r\nvoid main() {\r\n\t#ifdef USE_COLOR\r\n\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\r\n\t#endif\r\n\t#ifdef USE_DASH\r\n\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\r\n\t#endif\r\n\tfloat aspect = resolution.x / resolution.y;\r\n\tvUv = uv;\r\n\t// camera space\r\n\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\r\n\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\r\n\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\r\n\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\r\n\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\r\n\t// perhaps there is a more elegant solution -- WestLangley\r\n\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\r\n\tif ( perspective ) {\r\n\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\r\n\t\t\ttrimSegment( start, end );\r\n\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\r\n\t\t\ttrimSegment( end, start );\r\n\t\t}\r\n\t}\r\n\t// clip space\r\n\tvec4 clipStart = projectionMatrix * start;\r\n\tvec4 clipEnd = projectionMatrix * end;\r\n\t// ndc space\r\n\tvec2 ndcStart = clipStart.xy / clipStart.w;\r\n\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\r\n\t// direction\r\n\tvec2 dir = ndcEnd - ndcStart;\r\n\t// account for clip-space aspect ratio\r\n\tdir.x *= aspect;\r\n\tdir = normalize( dir );\r\n\t// perpendicular to dir\r\n\tvec2 offset = vec2( dir.y, - dir.x );\r\n\t// undo aspect ratio adjustment\r\n\tdir.x /= aspect;\r\n\toffset.x /= aspect;\r\n\t// sign flip\r\n\tif ( position.x < 0.0 ) offset *= - 1.0;\r\n\t// endcaps\r\n\tif ( position.y < 0.0 ) {\r\n\t\toffset += - dir;\r\n\t} else if ( position.y > 1.0 ) {\r\n\t\toffset += dir;\r\n\t}\r\n\t// adjust for linewidth\r\n\toffset *= linewidth;\r\n\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\r\n\toffset /= resolution.y;\r\n\t// select end\r\n\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\r\n\t// back to clip space\r\n\toffset *= clip.w;\r\n\tclip.xy += offset;\r\n\tgl_Position = clip;\r\n\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n}" }, { "name": "linebasic_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#ifdef USE_DASH\r\n\r\n\tuniform float dashSize;\r\n\tuniform float gapSize;\r\n\r\n#endif\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\t#ifdef USE_DASH\r\n\r\n\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\r\n\r\n\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\r\n\r\n\t#endif\r\n\r\n\tif ( abs( vUv.y ) > 1.0 ) {\r\n\r\n\t\tfloat a = vUv.x;\r\n\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n\t\tfloat len2 = a * a + b * b;\r\n\r\n\t\tif ( len2 > 1.0 ) discard;\r\n\r\n\t}\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <color_fragment>\r\n\r\n\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}" }], "techniques": [{ "name": "linebasic", "attributes": {}, "uniforms": { "logDepthBufFC": { "type": 5126 }, "linewidth": { "type": 5126, "value": 1 }, "dashScale": { "type": 5126, "value": 1 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "dashSize": { "type": 5126, "value": 1 }, "gapSize": { "type": 5126, "value": 1 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.linedashed = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "linedashed_vert", "type": 35633, "uri": "uniform float scale;\r\nattribute float lineDistance;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\r\n\tvLineDistance = scale * lineDistance;\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "linedashed_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\nuniform float dashSize;\r\nuniform float totalSize;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <color_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb; // simple shader\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "linedashed", "attributes": {}, "uniforms": { "scale": { "type": 5126, "value": 1 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "dashSize": { "type": 5126, "value": 1 }, "totalSize": { "type": 5126, "value": 1 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshbasic = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshbasic_vert", "type": 35633, "uri": "#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n#include <custom_vertex> // modified by egret\r\n\r\nvoid main() {\r\n \t// modified by egret\r\n\t#include <custom_begin_vertex>\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_ENVMAP\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n \t// modified by egret\r\n\t#include <custom_end_vertex>\r\n\r\n}\r\n" }, { "name": "meshbasic_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n#include <custom_fragment> // modified by egret\r\n\r\nvoid main() {\r\n\r\n \t// modified by egret\r\n\t#include <custom_begin_fragment>\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\r\n\t// accumulation (baked indirect lighting only)\r\n\t#ifdef USE_LIGHTMAP\r\n\t\r\n \t\t// modified by egret.\r\n\t\tvec4 lightmapTex = texture2D(lightMap, vUv2);\r\n\t\t// float power = pow( 2.0, lightmapTex.a * 255.0 - 128.0);\r\n\t\tfloat power = 5.0 * lightmapTex.a;\r\n\t\treflectedLight.indirectDiffuse += lightmapTex.rgb * power * lightMapIntensity;\r\n\r\n\t\t// reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\r\n\r\n\t#endif\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\r\n\r\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t// #include <encodings_fragment> // modified by egret. TODO\r\n\t#include <fog_fragment>\r\n\r\n \t// modified by egret\r\n\t#include <custom_end_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshbasic", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "refractionRatio": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "reflectivity": { "type": 5126 }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124 }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshlambert = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshlambert_vert", "type": 35633, "uri": "#define LAMBERT\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_pars_maps>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n#include <custom_vertex> // modified by egret\r\n\r\nvoid main() {\r\n\r\n \t// modified by egret\r\n\t#include <custom_begin_vertex>\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <lights_lambert_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n \t// modified by egret\r\n\t#include <custom_end_vertex>\r\n\r\n}\r\n" }, { "name": "meshlambert_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float opacity;\r\n\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_pars_maps>\r\n#include <fog_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n#include <custom_fragment> // modified by egret\r\n\r\nvoid main() {\r\n\r\n \t// modified by egret\r\n\t#include <custom_begin_fragment>\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\t#include <lightmap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n\r\n\t#ifdef DOUBLE_SIDED\r\n\r\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.directDiffuse = vLightFront;\r\n\r\n\t#endif\r\n\r\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t// #include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n \t// modified by egret\r\n\t#include <custom_end_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshlambert", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "refractionRatio": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126 }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124 }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshphong = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshphong_vert", "type": 35633, "uri": "#define PHONG\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n#include <custom_vertex> // modified by egret\r\n\r\nvoid main() {\r\n\r\n \t// modified by egret\r\n\t#include <custom_begin_vertex>\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n \t// modified by egret\r\n\t#include <custom_end_vertex>\r\n\r\n}\r\n" }, { "name": "meshphong_frag", "type": 35632, "uri": "#define PHONG\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <gradientmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_phong_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n#include <custom_fragment> // modified by egret\r\n\r\nvoid main() {\r\n\r\n \t// modified by egret\r\n\t#include <custom_begin_fragment>\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_phong_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n \t// modified by egret\r\n\t#include <custom_end_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshphong", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "refractionRatio": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "specular": { "type": 35665, "value": [1, 1, 1] }, "shininess": { "type": 5126, "value": 30 }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126 }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124 }, "gradientMap": { "type": 35678 }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664, "value": [1, 1] }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshphysical = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshphysical_vert", "type": 35633, "uri": "#define PHYSICAL\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n#include <custom_vertex> // modified by egret\r\n\r\nvoid main() {\r\n\r\n \t// modified by egret\r\n\t#include <custom_begin_vertex>\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n \t// modified by egret\r\n\t#include <custom_end_vertex>\r\n\r\n}\r\n" }, { "name": "meshphysical_frag", "type": 35632, "uri": "#define PHYSICAL\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n\r\n#ifndef STANDARD\r\n\tuniform float clearCoat;\r\n\tuniform float clearCoatRoughness;\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <bsdfs>\r\n#include <cube_uv_reflection_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <envmap_physical_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <lights_pars_begin>\r\n#include <lights_physical_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n#include <custom_fragment> // modified by egret\r\n\r\nvoid main() {\r\n\r\n \t// modified by egret\r\n\t#include <custom_begin_fragment>\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <roughnessmap_fragment>\r\n\t#include <metalnessmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_physical_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n \t// modified by egret\r\n\t#include <custom_end_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshphysical", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "roughness": { "type": 5126 }, "metalness": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "clearCoat": { "type": 5126 }, "clearCoatRoughness": { "type": 5126 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126 }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124 }, "refractionRatio": { "type": 5126 }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664, "value": [1, 1] }, "roughnessMap": { "type": 35678 }, "metalnessMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.normal = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "normal_vert", "type": 35633, "uri": "#define NORMAL\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n#endif\r\n\r\n}\r\n" }, { "name": "normal_frag", "type": 35632, "uri": "#define NORMAL\r\n\r\nuniform float opacity;\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\r\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\r\n\r\n}\r\n" }], "techniques": [{ "name": "normal", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "logDepthBufFC": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664, "value": [1, 1] } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.particle = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "particle_vert", "type": 35633, "uri": "//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.vs\r\n#include <common>\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec2 corner;\r\n#endif\r\nattribute vec3 startPosition;\r\nattribute vec3 startVelocity;\r\nattribute vec4 startColor;\r\nattribute vec3 startSize;\r\nattribute vec3 startRotation;\r\nattribute vec2 time;\r\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)||defined(ROTATIONTWOCONSTANTS)||defined(ROTATIONTWOCURVES)\r\n  attribute vec4 random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONTWOCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\r\n  attribute vec4 random1;\r\n#endif\r\nattribute vec3 startWorldPosition;\r\nattribute vec4 startWorldRotation;\r\n\r\n#include <particle_common>\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_currentTime - time.y;\r\n\tfloat t = age/time.x;\r\n\tif(t>1.0){ \t\t\t\r\n\t\t\tv_discard=1.0;\r\n\t\t\treturn;\r\n  }\r\n\t  \r\n\t#include <particle_affector>\r\n\tgl_Position=viewProjectionMatrix*vec4(center,1.0);\r\n\tv_color = computeColor(startColor, t);\r\n\tv_texcoord =computeUV(uv, t);\r\n\tv_discard=0.0;\r\n}\r\n\r\n" }, { "name": "particle_frag", "type": 35632, "uri": "//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.ps\r\n#include <common>\r\nuniform sampler2D map;\r\nuniform vec3 diffuse;\r\nuniform float opacity;\r\nvarying float v_discard;\r\nvarying vec4 v_color;\r\nvarying vec2 v_texcoord;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_mesh_color;\r\n#endif\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_mesh_color;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\r\n\tif(v_discard!=0.0)\r\n\t\tdiscard;\r\n\tgl_FragColor*=texture2D(map,v_texcoord)*vec4(diffuse, opacity)*v_color*2.0;\r\n}" }], "techniques": [{ "name": "particle", "attributes": {}, "uniforms": { "u_currentTime": { "type": 5126 }, "u_gravity": { "type": 35665 }, "u_worldPosition": { "type": 35665, "value": [0, 0, 0] }, "u_worldRotation": { "type": 35666, "value": [0, 0, 0, 1] }, "u_startRotation3D": { "type": 35670 }, "u_scalingMode": { "type": 5124 }, "u_positionScale": { "type": 35665 }, "u_sizeScale": { "type": 35665 }, "u_lengthScale": { "type": 5126 }, "u_speeaScale": { "type": 5126 }, "u_simulationSpace": { "type": 5124 }, "u_spaceType": { "type": 5124 }, "u_velocityConst": { "type": 35665 }, "u_velocityCurveX[0]": { "type": 35664 }, "u_velocityCurveY[0]": { "type": 35664 }, "u_velocityCurveZ[0]": { "type": 35664 }, "u_velocityConstMax": { "type": 35665 }, "u_velocityCurveMaxX[0]": { "type": 35664 }, "u_velocityCurveMaxY[0]": { "type": 35664 }, "u_velocityCurveMaxZ[0]": { "type": 35664 }, "u_colorGradient[0]": { "type": 35666 }, "u_alphaGradient[0]": { "type": 35664 }, "u_colorGradientMax[0]": { "type": 35666 }, "u_alphaGradientMax[0]": { "type": 35664 }, "u_sizeCurve[0]": { "type": 35664 }, "u_sizeCurveMax[0]": { "type": 35664 }, "u_sizeCurveX[0]": { "type": 35664 }, "u_sizeCurveY[0]": { "type": 35664 }, "u_sizeCurveZ[0]": { "type": 35664 }, "u_sizeCurveMaxX[0]": { "type": 35664 }, "u_sizeCurveMaxY[0]": { "type": 35664 }, "u_sizeCurveMaxZ[0]": { "type": 35664 }, "u_rotationConst": { "type": 5126 }, "u_rotationConstMax": { "type": 5126 }, "u_rotationCurve[0]": { "type": 35664 }, "u_rotationCurveMax[0]": { "type": 35664 }, "u_rotationConstSeprarate": { "type": 35665 }, "u_rotationConstMaxSeprarate": { "type": 35665 }, "u_rotationCurveX[0]": { "type": 35664 }, "u_rotationCurveY[0]": { "type": 35664 }, "u_rotationCurveZ[0]": { "type": 35664 }, "u_rotationCurveW[0]": { "type": 35664 }, "u_rotationCurveMaxX[0]": { "type": 35664 }, "u_rotationCurveMaxY[0]": { "type": 35664 }, "u_rotationCurveMaxZ[0]": { "type": 35664 }, "u_rotationCurveMaxW[0]": { "type": 35664 }, "u_cycles": { "type": 5126 }, "u_subUV": { "type": 35666 }, "u_uvCurve[0]": { "type": 35664 }, "u_uvCurveMax[0]": { "type": 35664 }, "map": { "type": 35678 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.points = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "points_vert", "type": 35633, "uri": "uniform float size;\r\nuniform float scale;\r\n\r\n#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_PointSize = size;\r\n\r\n\t#ifdef USE_SIZEATTENUATION\r\n\r\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\r\n\r\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\r\n\r\n\t#endif\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "points_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <map_particle_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_particle_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "points", "attributes": {}, "uniforms": { "size": { "type": 5126 }, "scale": { "type": 5126, "value": 1 }, "morphTargetInfluences[0]": { "type": 5126 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "map": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.shadow = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "shadow_vert", "type": 35633, "uri": "\r\n#include <fog_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "shadow_frag", "type": 35632, "uri": "uniform vec3 color;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\r\n\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "shadow", "attributes": {}, "uniforms": { "color": { "type": 35665 }, "opacity": { "type": 5126, "value": 1 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.sprite = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "sprite_vert", "type": 35633, "uri": "uniform float rotation;\r\nuniform vec2 center;\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\n\tvec2 scale;\r\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\r\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\r\n\r\n\t#ifndef USE_SIZEATTENUATION\r\n\r\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\r\n\r\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\r\n\r\n\t#endif\r\n\r\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\r\n\r\n\tvec2 rotatedPosition;\r\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\r\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\r\n\r\n\tmvPosition.xy += rotatedPosition;\r\n\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "sprite_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "sprite", "attributes": {}, "uniforms": { "rotation": { "type": 5126 }, "center": { "type": 35664 }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
    })(ShaderLib = egret3d.ShaderLib || (egret3d.ShaderLib = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderChunk;
    (function (ShaderChunk) {
        ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
        ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n uniform sampler2D alphaMap;\n\n#endif\n";
        ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
        ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n\n // reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n #if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n  float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n  reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n #endif\n\n#endif\n";
        ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n\n uniform sampler2D aoMap;\n uniform float aoMapIntensity;\n\n#endif";
        ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
        ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n";
        ShaderChunk.bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n if( decayExponent > 0.0 ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n  // based upon Frostbite 3 Moving to Physically-based Rendering\n  // page 32, equation 26: E[window1]\n  // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n  // this is intended to be used on spot and point lights who are represented as luminous intensity\n  // but who must be converted to luminous irradiance for surface lighting calculation\n  float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n  float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n  return distanceFalloff * maxDistanceCutoffFactor;\n\n#else\n\n  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n#endif\n\n }\n\n return 1.0;\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n return RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n // Original approximation by Christophe Schlick '94\n // float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n // Optimized variant (presented by Epic at SIGGRAPH '13)\n // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n // geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n // also see #12151\n\n float a2 = pow2( alpha );\n\n float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n return 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n float a2 = pow2( alpha );\n\n // dotNL and dotNV are explicitly swapped. This is not a mistake.\n float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n return 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n float a2 = pow2( alpha );\n\n float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n return RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n float alpha = pow2( roughness ); // UE4's roughness\n\n vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n float dotNH = saturate( dot( geometry.normal, halfDir ) );\n float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n float D = D_GGX( alpha, dotNH );\n\n return F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n const float LUT_SIZE  = 64.0;\n const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n const float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n float dotNV = saturate( dot( N, V ) );\n\n // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n uv = uv * LUT_SCALE + LUT_BIAS;\n\n return uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n // Real-Time Area Lighting: a Journey from Research to Production (p.102)\n // An approximation of the form factor of a horizon-clipped rectangle.\n\n float l = length( f );\n\n return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n float x = dot( v1, v2 );\n\n float y = abs( x );\n\n // rational polynomial approximation to theta / sin( theta ) / 2PI\n float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n float b = 3.4175940 + ( 4.1616724 + y ) * y;\n float v = a / b;\n\n float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n return cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n // bail if point is on back side of plane of light\n // assumes ccw winding order of light vertices\n vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n vec3 lightNormal = cross( v1, v2 );\n\n if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n // construct orthonormal basis around N\n vec3 T1, T2;\n T1 = normalize( V - N * dot( V, N ) );\n T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n // compute transform\n mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n // transform rect\n vec3 coords[ 4 ];\n coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n // project rect onto sphere\n coords[ 0 ] = normalize( coords[ 0 ] );\n coords[ 1 ] = normalize( coords[ 1 ] );\n coords[ 2 ] = normalize( coords[ 2 ] );\n coords[ 3 ] = normalize( coords[ 3 ] );\n\n // calculate vector form factor\n vec3 vectorFormFactor = vec3( 0.0 );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n // adjust for horizon clipping\n float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n // alternate method of adjusting for horizon clipping (see referece)\n // refactoring required\n float len = length( vectorFormFactor );\n float z = vectorFormFactor.z / len;\n\n const float LUT_SIZE  = 64.0;\n const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n const float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n // tabulated horizon-clipped sphere, apparently...\n vec2 uv = vec2( z * 0.5 + 0.5, len );\n uv = uv * LUT_SCALE + LUT_BIAS;\n\n float scale = texture2D( ltc_2, uv ).w;\n\n float result = len * scale;\n*/\n\n return vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n vec4 r = roughness * c0 + c1;\n\n float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n return specularColor * AB.x + AB.y;\n\n} // validated\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n return 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n //float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n //float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n float dotNH = saturate( dot( geometry.normal, halfDir ) );\n float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n float D = D_BlinnPhong( shininess, dotNH );\n\n return F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
        ShaderChunk.bumpMap_pars_frag = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n uniform float bumpScale;\n\n // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd(vec2 uv) {\n\n  vec2 dSTdx = dFdx( uv );\n  vec2 dSTdy = dFdy( uv );\n\n  float Hll = bumpScale * texture2D( bumpMap, uv ).x;\n  float dBx = bumpScale * texture2D( bumpMap, uv + dSTdx ).x - Hll;\n  float dBy = bumpScale * texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\n  return vec2( dBx, dBy );\n\n }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\n  vec3 vSigmaX = dFdx( surf_pos );\n  vec3 vSigmaY = dFdy( surf_pos );\n  vec3 vN = surf_norm;  // normalized\n\n  vec3 R1 = cross( vSigmaY, vN );\n  vec3 R2 = cross( vN, vSigmaX );\n\n  float fDet = dot( vSigmaX, R1 );\n\n  vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n  return normalize( abs( fDet ) * surf_norm - vGrad );\n\n }\n\n#endif\n";
        ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n uniform float bumpScale;\n\n // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n // http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd() {\n\n  vec2 dSTdx = dFdx( vUv );\n  vec2 dSTdy = dFdy( vUv );\n\n  float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n  float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n  float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n  return vec2( dBx, dBy );\n\n }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n  // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n  vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n  vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n  vec3 vN = surf_norm;  // normalized\n\n  vec3 R1 = cross( vSigmaY, vN );\n  vec3 R2 = cross( vN, vSigmaX );\n\n  float fDet = dot( vSigmaX, R1 );\n\n  fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n  vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n  return normalize( abs( fDet ) * surf_norm - vGrad );\n\n }\n\n#endif\n";
        ShaderChunk.clipping_planes_fragment = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0\n\n vec4 plane;\n\n #pragma unroll_loop\n for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n  plane = clippingPlanes[ i ];\n  if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\n }\n\n #if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n  bool clipped = true;\n\n  #pragma unroll_loop\n  for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n   plane = clippingPlanes[ i ];\n   clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\n  }\n\n  if ( clipped ) discard;\n\n #endif\n\n#endif\n";
        ShaderChunk.clipping_planes_pars_fragment = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0\n\n #if ! defined( PHYSICAL ) && ! defined( PHONG )\n  varying vec3 vViewPosition;\n #endif\n\n uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n";
        ShaderChunk.clipping_planes_pars_vertex = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n varying vec3 vViewPosition;\n#endif\n";
        ShaderChunk.clipping_planes_vertex = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n vViewPosition = - mvPosition.xyz;\n#endif\n\n";
        ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n diffuseColor.rgb *= vColor;\n\n#endif";
        ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif\n";
        ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif";
        ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n vColor.xyz = color.xyz;\n\n#endif";
        ShaderChunk.common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n return fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n vec3 color;\n vec3 direction;\n bool visible;\n};\n\nstruct ReflectedLight {\n vec3 directDiffuse;\n vec3 directSpecular;\n vec3 indirectDiffuse;\n vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n vec3 position;\n vec3 normal;\n vec3 viewDir;\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n float distance = dot( planeNormal, point - pointOnPlane );\n\n return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n mat3 tmp;\n\n tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n return tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n return dot( weights, color.rgb );\n\n}\n";
        ShaderChunk.common_frag_def = "//------------------------------------------------\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n//------------------------------------------------\n";
        ShaderChunk.common_vert_def = "\n//------------------------------------------------\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\n#ifdef USE_COLOR\n\n attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n attribute vec3 morphTarget0;\n attribute vec3 morphTarget1;\n attribute vec3 morphTarget2;\n attribute vec3 morphTarget3;\n #ifdef USE_MORPHNORMALS\n  attribute vec3 morphNormal0;\n  attribute vec3 morphNormal1;\n  attribute vec3 morphNormal2;\n  attribute vec3 morphNormal3;\n #else\n  attribute vec3 morphTarget4;\n  attribute vec3 morphTarget5;\n  attribute vec3 morphTarget6;\n  attribute vec3 morphTarget7;\n #endif\n#endif\n#ifdef USE_SKINNING\n attribute vec4 skinIndex;\n attribute vec4 skinWeight;\n#endif\n//------------------------------------------------\n";
        ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_textureSize (1024.0)\n\nint getFaceFromDirection(vec3 direction) {\n vec3 absDirection = abs(direction);\n int face = -1;\n if( absDirection.x > absDirection.z ) {\n  if(absDirection.x > absDirection.y )\n   face = direction.x > 0.0 ? 0 : 3;\n  else\n   face = direction.y > 0.0 ? 1 : 4;\n }\n else {\n  if(absDirection.z > absDirection.y )\n   face = direction.z > 0.0 ? 2 : 5;\n  else\n   face = direction.y > 0.0 ? 1 : 4;\n }\n return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\n\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n float dxRoughness = dFdx(roughness);\n float dyRoughness = dFdy(roughness);\n vec3 dx = dFdx( vec * scale * dxRoughness );\n vec3 dy = dFdy( vec * scale * dyRoughness );\n float d = max( dot( dx, dx ), dot( dy, dy ) );\n // Clamp the value to the max mip level counts. hard coded to 6 mips\n d = clamp(d, 1.0, cubeUV_rangeClamp);\n float mipLevel = 0.5 * log2(d);\n return vec2(floor(mipLevel), fract(mipLevel));\n}\n\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\n\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n float a = 16.0 * cubeUV_rcpTextureSize;\n\n vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n // float powScale = exp2(roughnessLevel + mipLevel);\n float powScale = exp2_packed.x * exp2_packed.y;\n // float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\n float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n // float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\n float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\n bool bRes = mipLevel == 0.0;\n scale =  bRes && (scale < a) ? a : scale;\n\n vec3 r;\n vec2 offset;\n int face = getFaceFromDirection(direction);\n\n float rcpPowScale = 1.0 / powScale;\n\n if( face == 0) {\n  r = vec3(direction.x, -direction.z, direction.y);\n  offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 1) {\n  r = vec3(direction.y, direction.x, direction.z);\n  offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 2) {\n  r = vec3(direction.z, direction.x, direction.y);\n  offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 3) {\n  r = vec3(direction.x, direction.z, direction.y);\n  offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n else if( face == 4) {\n  r = vec3(direction.y, direction.x, -direction.z);\n  offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n else {\n  r = vec3(direction.z, -direction.x, direction.y);\n  offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n r = normalize(r);\n float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n vec2 base = offset + vec2( texelOffset );\n return base + s * ( scale - 2.0 * texelOffset );\n}\n\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\n\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n float roughnessVal = roughness* cubeUV_maxLods3;\n float r1 = floor(roughnessVal);\n float r2 = r1 + 1.0;\n float t = fract(roughnessVal);\n vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n float s = mipInfo.y;\n float level0 = mipInfo.x;\n float level1 = level0 + 1.0;\n level1 = level1 > 5.0 ? 5.0 : level1;\n\n // round to nearest mipmap if we are not interpolating.\n level0 += min( floor( s + 0.5 ), 5.0 );\n\n // Tri linear interpolation.\n vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\n vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\n vec4 result = mix(color10, color20, t);\n\n return vec4(result.rgb, 1.0);\n}\n\n#endif\n";
        ShaderChunk.defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifdef FLIP_SIDED\n\n transformedNormal = - transformedNormal;\n\n#endif\n";
        ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\n uniform sampler2D displacementMap;\n uniform float displacementScale;\n uniform float displacementBias;\n\n#endif\n";
        ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\n transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";
        ShaderChunk.dithering_fragment = "#if defined( DITHERING )\n\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n";
        ShaderChunk.dithering_pars_fragment = "#if defined( DITHERING )\n\n // based on https://www.shadertoy.com/view/MslGR8\n vec3 dithering( vec3 color ) {\n  //Calculate grid position\n  float grid_position = rand( gl_FragCoord.xy );\n\n  //Shift the individual colors differently, thus making it even harder to see the dithering pattern\n  vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n  //modify shift acording to grid position.\n  dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n  //shift the color by dither_shift\n  return color + dither_shift_RGB;\n }\n\n#endif\n";
        ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\n vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n totalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n";
        ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\n uniform sampler2D emissiveMap;\n\n#endif\n";
        ShaderChunk.encodings_fragment = "  // gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
        ShaderChunk.encodings_pars_fragment = "// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n return value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n float maxComponent = max( max( value.r, value.g ), value.b );\n float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n float maxRGB = max( value.x, max( value.g, value.b ) );\n float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n M            = ceil( M * 255.0 ) / 255.0;\n return vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n float maxRGB = max( value.x, max( value.g, value.b ) );\n float D      = max( maxRange / maxRGB, 1.0 );\n D            = min( floor( D ) / 255.0, 1.0 );\n return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n vec4 vResult;\n vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n vResult.w = fract(Le);\n vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n return vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n float Le = value.z * 255.0 + value.w;\n vec3 Xp_Y_XYZp;\n Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
        ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n  vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n  // Transforming Normal Vectors with the Inverse Transformation\n  vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n  #endif\n\n #else\n\n  vec3 reflectVec = vReflect;\n\n #endif\n\n #ifdef ENVMAP_TYPE_CUBE\n\n  vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n #elif defined( ENVMAP_TYPE_EQUIREC )\n\n  vec2 sampleUV;\n\n  reflectVec = normalize( reflectVec );\n\n  sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n  sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n  vec4 envColor = texture2D( envMap, sampleUV );\n\n #elif defined( ENVMAP_TYPE_SPHERE )\n\n  reflectVec = normalize( reflectVec );\n\n  vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n  vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n #else\n\n  vec4 envColor = vec4( 0.0 );\n\n #endif\n\n envColor = envMapTexelToLinear( envColor );\n\n #ifdef ENVMAP_BLENDING_MULTIPLY\n\n  outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n #elif defined( ENVMAP_BLENDING_MIX )\n\n  outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n #elif defined( ENVMAP_BLENDING_ADD )\n\n  outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n #endif\n\n#endif\n";
        ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n uniform float reflectivity;\n uniform float envMapIntensity;\n#endif\n\n#ifdef USE_ENVMAP\n\n #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n  varying vec3 vWorldPosition;\n #endif\n\n #ifdef ENVMAP_TYPE_CUBE\n  uniform samplerCube envMap;\n #else\n  uniform sampler2D envMap;\n #endif\n uniform float flipEnvMap;\n uniform int maxMipLevel;\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n  uniform float refractionRatio;\n #else\n  varying vec3 vReflect;\n #endif\n\n#endif\n";
        ShaderChunk.envmap_pars_vertex = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n  varying vec3 vWorldPosition;\n\n #else\n\n  varying vec3 vReflect;\n  uniform float refractionRatio;\n\n #endif\n\n#endif\n";
        ShaderChunk.envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n  vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n   // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n   // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n   #else\n\n    // force the bias high to get the last LOD level as it is the most blurred.\n    vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n   vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\n  #else\n\n   vec4 envMapColor = vec4( 0.0 );\n\n  #endif\n\n  return PI * envMapColor.rgb * envMapIntensity;\n\n }\n\n // taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n  //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  float maxMIPLevelScalar = float( maxMIPLevel );\n  float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  // clamp to allowable LOD ranges.\n  return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n }\n\n vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n  #else\n\n   vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n  #endif\n\n  reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n  float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n   vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\n  #elif defined( ENVMAP_TYPE_EQUIREC )\n\n   vec2 sampleUV;\n   sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n   sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n\n   vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #endif\n\n  return envMapColor.rgb * envMapIntensity;\n\n }\n\n#endif\n";
        ShaderChunk.envmap_vertex = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n  vWorldPosition = worldPosition.xyz;\n\n #else\n\n  vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n  vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vReflect = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n  #endif\n\n #endif\n\n#endif\n";
        ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n float fogDepth = length( vFogPosition );\n\n #ifdef FOG_EXP2\n\n  float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n #else\n\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n #endif\n\n gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n";
        ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n uniform vec3 fogColor;\n varying vec3 vFogPosition;\n\n #ifdef FOG_EXP2\n\n  uniform float fogDensity;\n\n #else\n\n  uniform float fogNear;\n  uniform float fogFar;\n\n #endif\n\n#endif\n";
        ShaderChunk.fog_pars_vertex = "#ifdef USE_FOG\n\n varying vec3 vFogPosition;\n\n#endif\n";
        ShaderChunk.fog_vertex = "#ifdef USE_FOG\n\n vFogPosition = mvPosition.xyz;\n\n#endif\n";
        ShaderChunk.gradientmap_pars_fragment = "#ifdef TOON\n\n uniform sampler2D gradientMap;\n\n vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n  // dotNL will be from -1.0 to 1.0\n  float dotNL = dot( normal, lightDirection );\n  vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n  #ifdef USE_GRADIENTMAP\n\n   return texture2D( gradientMap, coord ).rgb;\n\n  #else\n\n   return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n  #endif\n\n\n }\n\n#endif\n";
        ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n";
        ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n uniform sampler2D lightMap;\n uniform float lightMapIntensity;\n\n#endif";
        ShaderChunk.lights_fragment_begin = "/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\nIncidentLight directLight;\n\n#if (defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n PointLight pointLight;\n\n #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  // pointLight = pointLights[ i ];\n  pointLight.position = vec3(pointLights[i* 15 + 0], pointLights[i * 15 + 1], pointLights[i * 15 + 2]);\n  pointLight.color = vec3(pointLights[i* 15 + 3], pointLights[i * 15 + 4], pointLights[i * 15 + 5]);\n  pointLight.distance = pointLights[i * 15 + 6];\n  pointLight.decay = pointLights[i * 15 + 7];\n\n  getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n SpotLight spotLight;\n\n #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  // spotLight = spotLights[ i ];\n  spotLight.position = vec3(spotLights[i * 18 + 0], spotLights[i * 18 + 1], spotLights[i * 18 + 2]);\n  spotLight.direction = vec3(spotLights[i * 18 + 3], spotLights[i * 18 + 4], spotLights[i * 18 + 5]);\n  spotLight.color = vec3(spotLights[i * 18 + 6], spotLights[i * 18 + 7], spotLights[i * 18 + 8]);\n  spotLight.distance = spotLights[i * 18 + 9];\n  spotLight.decay = spotLights[i * 18 + 10];\n  spotLight.coneCos = spotLights[i * 18 + 11];\n  spotLight.penumbraCos = spotLights[i * 18 + 12];\n  getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n DirectionalLight directionalLight;\n\n #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  // directionalLight = directionalLights[ i ];\n  directionalLight.direction = vec3(directionalLights[i * 11 + 0], directionalLights[i * 11 + 1], directionalLights[i * 11 + 2]);\n  directionalLight.color = vec3(directionalLights[i * 11 + 3], directionalLights[i * 11 + 4], directionalLights[i * 11 + 5]);\n  getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_RECT_AREA_LIGHTS) &&  NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n RectAreaLight rectAreaLight;\n\n #pragma unroll_loop\n for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  rectAreaLight = rectAreaLights[ i ];\n  RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n #if (defined(NUM_HEMI_LIGHTS) &&  NUM_HEMI_LIGHTS > 0 )\n\n  #pragma unroll_loop\n  for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n   irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n  }\n\n #endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n vec3 radiance = vec3( 0.0 );\n vec3 clearCoatRadiance = vec3( 0.0 );\n\n#endif\n";
        ShaderChunk.lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\n RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n\n#endif\n";
        ShaderChunk.lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\n #ifdef USE_LIGHTMAP\n\n  vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n   lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n  #endif\n\n  irradiance += lightMapIrradiance;\n\n #endif\n\n #if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n  irradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\n #ifndef STANDARD\n  clearCoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n #endif\n\n#endif\n";
        ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n vLightBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0\n PointLight pointLight;\n #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  pointLight.position = vec3(pointLights[i * 15 + 0], pointLights[i * 15 + 1], pointLights[i * 15 + 2]);\n  pointLight.color = vec3(pointLights[i * 15 + 3], pointLights[i * 15 + 4], pointLights[i * 15 + 5]);\n  pointLight.distance = pointLights[i * 15 + 6];\n  pointLight.decay = pointLights[i * 15 + 7];\n  getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n\n }\n\n#endif\n\n#if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0\n SpotLight spotLight;\n #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n  spotLight.position = vec3(spotLights[i * 18 + 0], spotLights[i * 18 + 1], spotLights[i * 18 + 2]);\n  spotLight.direction = vec3(spotLights[i * 18 + 3], spotLights[i * 18 + 4], spotLights[i * 18 + 5]);\n  spotLight.color = vec3(spotLights[i * 18 + 6], spotLights[i * 18 + 7], spotLights[i * 18 + 8]);\n  spotLight.distance = spotLights[i * 18 + 9];\n  spotLight.decay = spotLights[i * 18 + 10];\n  spotLight.coneCos = spotLights[i * 18 + 11];\n  spotLight.penumbraCos = spotLights[i * 18 + 12];\n\n  getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n }\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  // TODO (abelnation): implement\n\n }\n\n#endif\n*/\n\n#if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0\n DirectionalLight directionalLight;\n #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  directionalLight.direction = vec3(directionalLights[i * 11 + 0], directionalLights[i * 11 + 1], directionalLights[i * 11 + 2]);\n  directionalLight.color = vec3(directionalLights[i * 11 + 3], directionalLights[i * 11 + 4], directionalLights[i * 11 + 5]);\n  getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n  // directLightColor_Diffuse = directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n  // vLightFront += directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n\n }\n\n#endif\n\n#if defined(NUM_HEMI_LIGHTS) && NUM_HEMI_LIGHTS > 0\n\n #pragma unroll_loop\n for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n  vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n  #endif\n\n }\n\n#endif\n";
        ShaderChunk.lights_pars_begin = "uniform vec3 ambientLightColor;\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n vec3 irradiance = ambientLightColor;\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI;\n\n #endif\n\n return irradiance;\n\n}\n\n#if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0\n\n struct DirectionalLight {\n  vec3 direction;\n  vec3 color;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n };\n\n uniform float directionalLights[NUM_DIR_LIGHTS * 11];\n\n void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n  directLight.direction = directionalLight.direction;\n  directLight.color = directionalLight.color;\n  directLight.visible = true;\n }\n\n#endif\n\n\n#if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0\n\n struct PointLight {\n  vec3 position;\n  vec3 color;\n  float distance;\n  float decay;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n  float shadowCameraNear;\n  float shadowCameraFar;\n };\n\n uniform float pointLights[NUM_POINT_LIGHTS * 15 ];\n\n // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n  vec3 lVector = pointLight.position - geometry.position;\n  directLight.direction = normalize( lVector );\n\n  float lightDistance = length( lVector );\n\n  directLight.color = pointLight.color;\n  directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n  directLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n }\n\n#endif\n\n\n#if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0\n\n struct SpotLight {\n  vec3 position;\n  vec3 direction;\n  vec3 color;\n  float distance;\n  float decay;\n  float coneCos;\n  float penumbraCos;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n };\n\n uniform float spotLights[NUM_SPOT_LIGHTS * 18];\n\n // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n  vec3 lVector = spotLight.position - geometry.position;\n  directLight.direction = normalize( lVector );\n\n  float lightDistance = length( lVector );\n  float angleCos = dot( directLight.direction, spotLight.direction );\n\n  if ( angleCos > spotLight.coneCos ) {\n\n   float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n   directLight.color = spotLight.color;\n   directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n   directLight.visible = true;\n\n  } else {\n\n   directLight.color = vec3( 0.0 );\n   directLight.visible = false;\n\n  }\n }\n\n#endif\n\n\n#if defined(NUM_RECT_AREA_LIGHTS) && NUM_RECT_AREA_LIGHTS > 0\n\n struct RectAreaLight {\n  vec3 color;\n  vec3 position;\n  vec3 halfWidth;\n  vec3 halfHeight;\n };\n\n // Pre-computed values of LinearTransformedCosine approximation of BRDF\n // BRDF approximation Texture is 64x64\n uniform sampler2D ltc_1; // RGBA Float\n uniform sampler2D ltc_2; // RGBA Float\n\n uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if defined(NUM_HEMI_LIGHTS) && NUM_HEMI_LIGHTS > 0\n\n struct HemisphereLight {\n  vec3 direction;\n  vec3 skyColor;\n  vec3 groundColor;\n };\n\n uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n  float dotNL = dot( geometry.normal, hemiLight.direction );\n  float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n  vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n   irradiance *= PI;\n\n  #endif\n\n  return irradiance;\n\n }\n\n#endif\n";
        ShaderChunk.lights_pars_maps = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n  vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n   // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n   // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n   #else\n\n    // force the bias high to get the last LOD level as it is the most blurred.\n    vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n   vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\n  #else\n\n   vec4 envMapColor = vec4( 0.0 );\n\n  #endif\n\n  return PI * envMapColor.rgb * envMapIntensity;\n\n }\n\n // taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n  //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  float maxMIPLevelScalar = float( maxMIPLevel );\n  float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  // clamp to allowable LOD ranges.\n  return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n }\n\n vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n  #else\n\n   vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n  #endif\n\n  reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n  float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n   vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\n  #elif defined( ENVMAP_TYPE_EQUIREC )\n\n   vec2 sampleUV;\n   sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n   sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n\n   vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #endif\n\n  return envMapColor.rgb * envMapIntensity;\n\n }\n\n#endif\n";
        ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
        ShaderChunk.lights_phong_pars_fragment = "varying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n varying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n vec3 diffuseColor;\n vec3 specularColor;\n float specularShininess;\n float specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n #ifdef TOON\n\n  vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n #else\n\n  float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n  vec3 irradiance = dotNL * directLight.color;\n\n #endif\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI; // punctual light\n\n #endif\n\n reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct    RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material ) (0)\n";
        ShaderChunk.lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n material.clearCoat = saturate( clearCoat ); // Burley clearcoat model\n material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
        ShaderChunk.lights_physical_pars_fragment = "struct PhysicalMaterial {\n\n vec3 diffuseColor;\n float specularRoughness;\n vec3 specularColor;\n\n #ifndef STANDARD\n  float clearCoat;\n  float clearCoatRoughness;\n #endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n  vec3 normal = geometry.normal;\n  vec3 viewDir = geometry.viewDir;\n  vec3 position = geometry.position;\n  vec3 lightPos = rectAreaLight.position;\n  vec3 halfWidth = rectAreaLight.halfWidth;\n  vec3 halfHeight = rectAreaLight.halfHeight;\n  vec3 lightColor = rectAreaLight.color;\n  float roughness = material.specularRoughness;\n\n  vec3 rectCoords[ 4 ];\n  rectCoords[ 0 ] = lightPos - halfWidth - halfHeight; // counterclockwise\n  rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n  rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n  rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\n  vec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n  vec4 t1 = texture2D( ltc_1, uv );\n  vec4 t2 = texture2D( ltc_2, uv );\n\n  mat3 mInv = mat3(\n   vec3( t1.x, 0, t1.y ),\n   vec3(    0, 1,    0 ),\n   vec3( t1.z, 0, t1.w )\n  );\n\n  // LTC Fresnel Approximation by Stephen Hill\n  // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n  vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n  reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n  reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n }\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n vec3 irradiance = dotNL * directLight.color;\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI; // punctual light\n\n #endif\n\n #ifndef STANDARD\n  float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n #else\n  float clearCoatDHR = 0.0;\n #endif\n\n reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n #ifndef STANDARD\n\n  reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n #endif\n\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n #ifndef STANDARD\n  float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n  float dotNL = dotNV;\n  float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n #else\n  float clearCoatDHR = 0.0;\n #endif\n\n reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n #ifndef STANDARD\n\n  reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n #endif\n\n}\n\n#define RE_Direct    RE_Direct_Physical\n#define RE_Direct_RectArea  RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular  RE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n";
        ShaderChunk.logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif";
        ShaderChunk.logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n uniform float logDepthBufFC;\n varying float vFragDepth;\n\n#endif\n";
        ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n  varying float vFragDepth;\n\n #else\n\n  uniform float logDepthBufFC;\n\n #endif\n\n#endif\n";
        ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n  vFragDepth = 1.0 + gl_Position.w;\n\n #else\n\n  gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n  gl_Position.z *= gl_Position.w;\n\n #endif\n\n#endif\n";
        ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n vec4 texelColor = texture2D( map, vUv );\n\n // texelColor = mapTexelToLinear( texelColor ); // modified by egret. TODO\n diffuseColor *= texelColor;\n\n#endif\n";
        ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n\n uniform sampler2D map;\n\n#endif\n";
        ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n vec4 mapTexel = texture2D( map, uv );\n diffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n";
        ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n uniform mat3 uvTransform;\n uniform sampler2D map;\n\n#endif\n";
        ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n vec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n // reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n metalnessFactor *= texelMetalness.b;\n\n#endif\n";
        ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\n uniform sampler2D metalnessMap;\n\n#endif";
        ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";
        ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n #ifndef USE_MORPHNORMALS\n\n uniform float morphTargetInfluences[ 8 ];\n\n #else\n\n uniform float morphTargetInfluences[ 4 ];\n\n #endif\n\n#endif";
        ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n #ifndef USE_MORPHNORMALS\n\n transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n #endif\n\n#endif\n";
        ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n uniform sampler2D normalMap;\n uniform vec2 normalScale;\n\n #ifdef OBJECTSPACE_NORMALMAP\n\n  uniform mat3 normalMatrix;\n\n #else\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n   // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n   vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n   vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n   vec2 st0 = dFdx( vUv.st );\n   vec2 st1 = dFdy( vUv.st );\n\n   float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n   vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n   vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n   vec3 N = normalize( surf_norm );\n   mat3 tsn = mat3( S, T, N );\n\n   vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\n   mapN.xy *= normalScale;\n   mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n   return normalize( tsn * mapN );\n\n  }\n\n #endif\n\n#endif\n";
        ShaderChunk.normal_fragment_begin = "#ifdef FLAT_SHADED\n\n // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n vec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n vec3 normal = normalize( vNormal );\n\n #ifdef DOUBLE_SIDED\n\n  normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n #endif\n\n#endif\n";
        ShaderChunk.normal_fragment_maps = "#ifdef USE_NORMALMAP\n\n #ifdef OBJECTSPACE_NORMALMAP\n\n  normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n  #ifdef FLIP_SIDED\n\n   normal = - normal;\n\n  #endif\n\n  #ifdef DOUBLE_SIDED\n\n   normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n  #endif\n\n  normal = normalize( normalMatrix * normal );\n\n #else // tangent-space normal map\n\n  normal = perturbNormal2Arb( -vViewPosition, normal );\n\n #endif\n\n#elif defined( USE_BUMPMAP )\n\n normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n";
        ShaderChunk.packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n return normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n return 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n vec4 r = vec4( fract( v * PackFactors ), v );\n r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n return r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n return dot( v, UnpackFactors );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n return linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
        ShaderChunk.particle_affector = "vec3 lifeVelocity = computeVelocity(t);\nvec4 worldRotation;\nif(u_simulationSpace==1)\n worldRotation=startWorldRotation;\nelse\n worldRotation=u_worldRotation;\nvec3 gravity=u_gravity*age;\nvec3 center=computePosition(startVelocity, lifeVelocity, age, t,gravity,worldRotation); \n#ifdef SPHERHBILLBOARD\n    vec3 cameraForwardVector = cameraForward;\n    if(u_startRotation3D){\n     cameraForwardVector = vec3(0.0,0.0,1.0);//TODO\n    }\n    vec2 corner=corner.xy;\n      vec3 cameraUpVector =normalize(cameraUp);\n      vec3 sideVector = normalize(cross(cameraForwardVector,cameraUpVector));\n      vec3 upVector = normalize(cross(sideVector,cameraForwardVector));\n     corner*=computeBillbardSize(startSize.xy,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n   if(u_startRotation3D){\n    vec3 rotation=vec3(startRotation.xy,computeRotation(startRotation.z,age,t));\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,rotation);\n   }\n   else{\n    float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #else\n   if(u_startRotation3D){\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,startRotation);\n   }\n   else{\n    float c = cos(startRotation.x);\n    float s = sin(startRotation.x);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #endif\n #endif\n #ifdef STRETCHEDBILLBOARD\n  vec2 corner=corner.xy;\n  vec3 velocity;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n      if(u_spaceType==0)\n       velocity=rotation_quaternions(u_sizeScale*(startVelocity+lifeVelocity),worldRotation)+gravity;\n      else\n       velocity=rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+lifeVelocity+gravity;\n   #else\n      velocity= rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+gravity;\n   #endif \n  vec3 cameraUpVector = normalize(velocity);\n  vec3 direction = normalize(center-cameraPosition);\n    vec3 sideVector = normalize(cross(direction,cameraUpVector));\n  sideVector=u_sizeScale.xzy*sideVector;\n  cameraUpVector=length(vec3(u_sizeScale.x,0.0,0.0))*cameraUpVector;\n    vec2 size=computeBillbardSize(startSize.xy,t);\n    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n    corner=rotaionZHalfPI*corner;\n    corner.y=corner.y-abs(corner.y);\n    float speed=length(velocity);\n    center +=sign(u_sizeScale.x)*(sign(u_lengthScale)*size.x*corner.x*sideVector+(speed*u_speeaScale+size.y*u_lengthScale)*corner.y*cameraUpVector);\n #endif\n #ifdef HORIZONTALBILLBOARD\n  vec2 corner=corner.xy;\n    const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n  float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef VERTICALBILLBOARD\n  vec2 corner=corner.xy;\n    const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n    vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n  float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef RENDERMESH\n    vec3 size=computeMeshSize(startSize,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n    if(u_startRotation3D){\n     vec3 rotation=vec3(startRotation.xy,-computeRotation(startRotation.z, age,t));\n     center+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,rotation),worldRotation);\n    }\n    else{\n     #ifdef ROTATIONOVERLIFETIME\n      float angle=computeRotation(startRotation.x, age,t);\n      if(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n       center+= (rotation_quaternions(rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),angle),worldRotation));//已验证\n      }\n      else{\n       #ifdef SHAPE\n        center+= u_sizeScale.xzy*(rotation_quaternions(rotation_axis(position*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n       #else\n        if(u_simulationSpace==1)\n         center+=rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),angle);\n        else if(u_simulationSpace==0)\n         center+=rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),angle),worldRotation);\n       #endif\n      }\n     #endif\n     #ifdef ROTATIONSEPERATE\n      vec3 angle=compute3DRotation(vec3(0.0,0.0,startRotation.z), age,t);\n      center+= (rotation_quaternions(rotation_euler(u_sizeScale*position*size,vec3(angle.x,angle.y,angle.z)),worldRotation));\n     #endif \n    }\n  #else\n  if(u_startRotation3D){\n   center+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,startRotation),worldRotation);\n  }\n  else{\n   if(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n    if(u_simulationSpace==1)\n     center+= rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x);\n    else if(u_simulationSpace==0)\n     center+= (rotation_quaternions(u_sizeScale*rotation_axis(position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x),worldRotation));\n   }\n   else{\n    #ifdef SHAPE\n     if(u_simulationSpace==1)\n      center+= u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x),worldRotation); \n    #else\n     if(u_simulationSpace==1)\n      center+= rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),startRotation.x),worldRotation);\n    #endif\n   }\n  }\n  #endif\n  v_mesh_color=vec4(color, 1.0);\n  #endif";
        ShaderChunk.particle_common = "\n\nuniform float u_currentTime;\nuniform vec3 u_gravity;\n\nuniform vec3 u_worldPosition;\nuniform vec4 u_worldRotation;\nuniform bool u_startRotation3D;\nuniform int u_scalingMode;\nuniform vec3 u_positionScale;\nuniform vec3 u_sizeScale;\nuniform mat4 viewProjectionMatrix;\n\nuniform vec3 cameraForward;\nuniform vec3 cameraUp;\n\nuniform float u_lengthScale;\nuniform float u_speeaScale;\nuniform int u_simulationSpace;\n\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  uniform int u_spaceType;\n#endif\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYTWOCONSTANT)\n  uniform vec3 u_velocityConst;\n#endif\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)\n  uniform vec2 u_velocityCurveX[4];\n  uniform vec2 u_velocityCurveY[4];\n  uniform vec2 u_velocityCurveZ[4];\n#endif\n#ifdef VELOCITYTWOCONSTANT\n  uniform vec3 u_velocityConstMax;\n#endif\n#ifdef VELOCITYTWOCURVE\n  uniform vec2 u_velocityCurveMaxX[4];\n  uniform vec2 u_velocityCurveMaxY[4];\n  uniform vec2 u_velocityCurveMaxZ[4];\n#endif\n\n#ifdef COLOROGRADIENT\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n#endif\n#ifdef COLORTWOGRADIENTS\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n  uniform vec4 u_colorGradientMax[4];\n  uniform vec2 u_alphaGradientMax[4];\n#endif\n\n#if defined(SIZECURVE)||defined(SIZETWOCURVES)\n  uniform vec2 u_sizeCurve[4];\n#endif\n#ifdef SIZETWOCURVES\n  uniform vec2 u_sizeCurveMax[4];\n#endif\n#if defined(SIZECURVESEPERATE)||defined(SIZETWOCURVESSEPERATE)\n  uniform vec2 u_sizeCurveX[4];\n  uniform vec2 u_sizeCurveY[4];\n  uniform vec2 u_sizeCurveZ[4];\n#endif\n#ifdef SIZETWOCURVESSEPERATE\n  uniform vec2 u_sizeCurveMaxX[4];\n  uniform vec2 u_sizeCurveMaxY[4];\n  uniform vec2 u_sizeCurveMaxZ[4];\n#endif\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform float u_rotationConst;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform float u_rotationConstMax;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurve[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMax[4];\n  #endif\n#endif\n#ifdef ROTATIONSEPERATE\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform vec3 u_rotationConstSeprarate;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform vec3 u_rotationConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurveX[4];\n    uniform vec2 u_rotationCurveY[4];\n    uniform vec2 u_rotationCurveZ[4];\n  uniform vec2 u_rotationCurveW[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMaxX[4];\n    uniform vec2 u_rotationCurveMaxY[4];\n    uniform vec2 u_rotationCurveMaxZ[4];\n  uniform vec2 u_rotationCurveMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\n  uniform float u_cycles;\n  uniform vec4 u_subUV;\n  uniform vec2 u_uvCurve[4];\n#endif\n#ifdef TEXTURESHEETANIMATIONTWOCURVE\n  uniform vec2 u_uvCurveMax[4];\n#endif\n\nvarying float v_discard;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\n#ifdef RENDERMESH\n varying vec4 v_mesh_color;\n#endif\n\nvec3 rotation_euler(in vec3 vector,in vec3 euler)\n{\n  float halfPitch = euler.x * 0.5;\n float halfYaw = euler.y * 0.5;\n float halfRoll = euler.z * 0.5;\n\n float sinPitch = sin(halfPitch);\n float cosPitch = cos(halfPitch);\n float sinYaw = sin(halfYaw);\n float cosYaw = cos(halfYaw);\n float sinRoll = sin(halfRoll);\n float cosRoll = cos(halfRoll);\n\n float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n \n}\n\nvec3 rotation_axis(in vec3 vector,in vec3 axis, in float angle)\n{\n float halfAngle = angle * 0.5;\n float sin = sin(halfAngle);\n \n float quaX = axis.x * sin;\n float quaY = axis.y * sin;\n float quaZ = axis.z * sin;\n float quaW = cos(halfAngle);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n}\n\nvec3 rotation_quaternions(in vec3 v,in vec4 q) \n{\n return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(SIZECURVE)||defined(SIZECURVESEPERATE)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)\nfloat evaluate_curve_float(in vec2 curves[4],in float t)\n{\n float res;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  if(curTime>=t)\n  {\n   vec2 lastCurve=curves[i-1];\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res=mix(lastCurve.y,curve.y,tt);\n   break;\n  }\n }\n return res;\n}\n#endif\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\nfloat evaluate_curve_total(in vec2 curves[4],in float t)\n{\n float res=0.0;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  vec2 lastCurve=curves[i-1];\n  float lastValue=lastCurve.y;\n  \n  if(curTime>=t){\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res+=(lastValue+mix(lastValue,curve.y,tt))/2.0*time.x*(t-lastTime);\n   break;\n  }\n  else{\n   res+=(lastValue+curve.y)/2.0*time.x*(curTime-lastCurve.x);\n  }\n }\n return res;\n}\n#endif\n\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)\nvec4 evaluate_curve_color(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float t)\n{\n vec4 overTimeColor;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientAlpha=gradientAlphas[i];\n  float alphaKey=gradientAlpha.x;\n  if(alphaKey>=t)\n  {\n   vec2 lastGradientAlpha=gradientAlphas[i-1];\n   float lastAlphaKey=lastGradientAlpha.x;\n   float age=(t-lastAlphaKey)/(alphaKey-lastAlphaKey);\n   overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n   break;\n  }\n }\n \n for(int i=1;i<4;i++)\n {\n  vec4 gradientColor=gradientColors[i];\n  float colorKey=gradientColor.x;\n  if(colorKey>=t)\n  {\n   vec4 lastGradientColor=gradientColors[i-1];\n   float lastColorKey=lastGradientColor.x;\n   float age=(t-lastColorKey)/(colorKey-lastColorKey);\n   overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n   break;\n  }\n }\n return overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\nfloat evaluate_curve_frame(in vec2 gradientFrames[4],in float t)\n{\n float overTimeFrame;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientFrame=gradientFrames[i];\n  float key=gradientFrame.x;\n  if(key>=t)\n  {\n   vec2 lastGradientFrame=gradientFrames[i-1];\n   float lastKey=lastGradientFrame.x;\n   float age=(t-lastKey)/(key-lastKey);\n   overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n   break;\n  }\n }\n return floor(overTimeFrame);\n}\n#endif\n\nvec3 computeVelocity(in float t)\n{\n  vec3 res;\n  #ifdef VELOCITYCONSTANT\n  res=u_velocityConst; \n  #endif\n  #ifdef VELOCITYCURVE\n     res= vec3(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveZ,t));\n  #endif\n  #ifdef VELOCITYTWOCONSTANT\n  res=mix(u_velocityConst,u_velocityConstMax,vec3(random1.y,random1.z,random1.w)); \n  #endif\n  #ifdef VELOCITYTWOCURVE\n     res=vec3(mix(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveMaxX,t),random1.y),\n             mix(evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveMaxY,t),random1.z),\n        mix(evaluate_curve_float(u_velocityCurveZ,t),evaluate_curve_float(u_velocityCurveMaxZ,t),random1.w));\n  #endif\n     \n  return res;\n} \n\nvec3 computePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float t,vec3 gravityVelocity,vec4 worldRotation)\n{\n    vec3 position;\n    vec3 lifePosition;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n   #ifdef VELOCITYCONSTANT\n      position=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYCURVE\n      position=startVelocity*age;\n      lifePosition=vec3(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveZ,t));\n   #endif\n   #ifdef VELOCITYTWOCONSTANT\n      position=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYTWOCURVE\n      position=startVelocity*age;\n      lifePosition=vec3(mix(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveMaxX,t),random1.y)\n                 ,mix(evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveMaxY,t),random1.z)\n                 ,mix(evaluate_curve_total(u_velocityCurveZ,t),evaluate_curve_total(u_velocityCurveMaxZ,t),random1.w));\n   #endif\n\n   vec3 finalPosition;\n   if(u_spaceType==0){\n     if(u_scalingMode!=2)\n      finalPosition =rotation_quaternions(u_positionScale*(startPosition.xyz+position+lifePosition),worldRotation);\n     else\n      finalPosition =rotation_quaternions(u_positionScale*startPosition.xyz+position+lifePosition,worldRotation);\n   }\n   else{\n     if(u_scalingMode!=2)\n       finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+position),worldRotation)+lifePosition;\n     else\n       finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+position,worldRotation)+lifePosition;\n   }\n    #else\n    position=startVelocity*age;\n    vec3 finalPosition;\n    if(u_scalingMode!=2)\n      finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+position),worldRotation);\n    else\n      finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+position,worldRotation);\n  #endif\n  \n  if(u_simulationSpace==1)\n    finalPosition=finalPosition+startWorldPosition;\n  else if(u_simulationSpace==0) \n    finalPosition=finalPosition+u_worldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return finalPosition;\n}\n\n\nvec4 computeColor(in vec4 color,in float t)\n{\n #ifdef COLOROGRADIENT\n   color*=evaluate_curve_color(u_alphaGradient,u_colorGradient,t);\n #endif \n #ifdef COLORTWOGRADIENTS\n   color*=mix(evaluate_curve_color(u_alphaGradient,u_colorGradient,t),evaluate_curve_color(u_alphaGradientMax,u_colorGradientMax,t),random0.y);\n #endif\n\n  return color;\n}\n\nvec2 computeBillbardSize(in vec2 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec2(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec2(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z));\n #endif\n return size;\n}\n\n#ifdef RENDERMESH\nvec3 computeMeshSize(in vec3 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec3(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveZ,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec3(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z)\n       ,mix(evaluate_curve_float(u_sizeCurveZ,t),evaluate_curve_float(u_sizeCurveMaxZ,t),random0.z));\n #endif\n return size;\n}\n#endif\n\nfloat computeRotation(in float rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConst*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurve,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n     rotation+=ageRot;\n   #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n  #endif\n #endif\n #ifdef ROTATIONSEPERATE\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConstSeprarate.z*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurveZ,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConstSeprarate.z,u_rotationConstMaxSeprarate.z,random0.w)*age;\n         rotation+=ageRot;\n     #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n  #endif\n #endif\n return rotation;\n}\n\n#if defined(RENDERMESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE))\nvec3 compute3DRotation(in vec3 rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n   #ifdef ROTATIONCONSTANT\n     float ageRot=u_rotationConst*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONCURVE\n     rotation+=evaluate_curve_total(u_rotationCurve,t);\n   #endif\n   #ifdef ROTATIONTWOCONSTANTS\n     float ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONTWOCURVES\n     rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n   #endif\n #endif\n #ifdef ROTATIONSEPERATE\n    #ifdef ROTATIONCONSTANT\n     vec3 ageRot=u_rotationConstSeprarate*age;\n           rotation+=ageRot;\n    #endif\n    #ifdef ROTATIONCURVE\n     rotation+=vec3(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveZ,t));\n    #endif\n    #ifdef ROTATIONTWOCONSTANTS\n     vec3 ageRot=mix(u_rotationConstSeprarate,u_rotationConstMaxSeprarate,random0.w)*age;\n           rotation+=ageRot;\n     #endif\n    #ifdef ROTATIONTWOCURVES\n     rotation+=vec3(mix(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveMaxX,t),random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveMaxY,t),random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n    #endif\n #endif\n return rotation;\n}\n#endif\n\nvec2 computeUV(in vec2 uv,in float t)\n{ \n #ifdef TEXTURESHEETANIMATIONCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n  float frame=evaluate_curve_frame(u_uvCurve,uvNormalizedAge);\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n #ifdef TEXTURESHEETANIMATIONTWOCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n   float frame=floor(mix(evaluate_curve_frame(u_uvCurve,uvNormalizedAge),evaluate_curve_frame(u_uvCurveMax,uvNormalizedAge),random1.x));\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n return uv;\n}";
        ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\n // Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n gl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n";
        ShaderChunk.project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\ngl_Position = projectionMatrix * mvPosition;\n";
        ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n vec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n roughnessFactor *= texelRoughness.g;\n\n#endif\n";
        ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\n uniform sampler2D roughnessMap;\n\n#endif";
        ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n  uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n  varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n  uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n  varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n  uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n  varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): create uniforms for area light shadows\n\n #endif\n */\n\n float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n  return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n }\n\n float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n  const vec2 offset = vec2( 0.0, 1.0 );\n\n  vec2 texelSize = vec2( 1.0 ) / size;\n  vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n  float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n  float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n  float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n  float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n  vec2 f = fract( uv * size + 0.5 );\n\n  float a = mix( lb, lt, f.y );\n  float b = mix( rb, rt, f.y );\n  float c = mix( a, b, f.x );\n\n  return c;\n\n }\n\n float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n  float shadow = 1.0;\n\n  shadowCoord.xyz /= shadowCoord.w;\n  shadowCoord.z += shadowBias;//Egret Right-hand\n\n  // if ( something && something ) breaks ATI OpenGL shader compiler\n  // if ( all( something, something ) ) using this instead\n\n  bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n  bool inFrustum = all( inFrustumVec );\n\n  bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n  bool frustumTest = all( frustumTestVec );\n\n  if ( frustumTest ) {\n\n  #if defined( SHADOWMAP_TYPE_PCF )\n\n   vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n   float dx0 = - texelSize.x * shadowRadius;\n   float dy0 = - texelSize.y * shadowRadius;\n   float dx1 = + texelSize.x * shadowRadius;\n   float dy1 = + texelSize.y * shadowRadius;\n\n   shadow = (\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n   ) * ( 1.0 / 9.0 );\n\n  #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n   vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n   float dx0 = - texelSize.x * shadowRadius;\n   float dy0 = - texelSize.y * shadowRadius;\n   float dx1 = + texelSize.x * shadowRadius;\n   float dy1 = + texelSize.y * shadowRadius;\n\n   shadow = (\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n   ) * ( 1.0 / 9.0 );\n\n  #else // no percentage-closer filtering:\n\n   shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n  #endif\n\n  }\n\n  return shadow;\n\n }\n\n // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n // vector suitable for 2D texture mapping. This code uses the following layout for the\n // 2D texture:\n //\n // xzXZ\n //  y Y\n //\n // Y - Positive y direction\n // y - Negative y direction\n // X - Positive x direction\n // x - Negative x direction\n // Z - Positive z direction\n // z - Negative z direction\n //\n // Source and test bed:\n // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n  // Number of texels to avoid at the edge of each square\n\n  vec3 absV = abs( v );\n\n  // Intersect unit cube\n\n  float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n  absV *= scaleToCube;\n\n  // Apply scale to avoid seams\n\n  // two texels less per square (one texel will do for NEAREST)\n  v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n  // Unwrap\n\n  // space: -1 ... 1 range for each square\n  //\n  // #X##  dim    := ( 4 , 2 )\n  //  # #  center := ( 1 , 1 )\n\n  vec2 planar = v.xy;\n\n  float almostATexel = 1.5 * texelSizeY;\n  float almostOne = 1.0 - almostATexel;\n\n  if ( absV.z >= almostOne ) {\n\n   if ( v.z > 0.0 )\n    planar.x = 4.0 - v.x;\n\n  } else if ( absV.x >= almostOne ) {\n\n   float signX = sign( v.x );\n   planar.x = v.z * signX + 2.0 * signX;\n\n  } else if ( absV.y >= almostOne ) {\n\n   float signY = sign( v.y );\n   planar.x = v.x + 2.0 * signY + 2.0;\n   planar.y = v.z * signY - 2.0;\n\n  }\n\n  // Transform to UV space\n\n  // scale := 0.5 / dim\n  // translate := ( center + 0.5 ) / dim\n  return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n }\n\n float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n  vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n  // for point lights, the uniform @vShadowCoord is re-purposed to hold\n  // the vector from the light to the world-space position of the fragment.\n  vec3 lightToPosition = shadowCoord.xyz;\n\n  // dp = normalized distance from light to fragment position\n  float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n  dp += shadowBias;\n\n  // bd3D = base direction 3D\n  vec3 bd3D = normalize( lightToPosition );\n\n  #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n   vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n   return (\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n   ) * ( 1.0 / 9.0 );\n\n  #else // no percentage-closer filtering\n\n   return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n  #endif\n\n }\n\n#endif\n";
        ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n  uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n  varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n  uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n  varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n  uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n  varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): uniforms for area light shadows\n\n #endif\n */\n\n#endif\n";
        ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): update vAreaShadowCoord with area light info\n\n #endif\n */\n\n#endif\n";
        ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n\n float shadow = 1.0;\n\n #ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n DirectionalLight directionalLight;\n\n #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  // directionalLight = directionalLights[ i ];\n  directionalLight.shadow = int(directionalLights[i * 11 + 6]);\n  directionalLight.shadowBias = directionalLights[i * 11 + 7];\n  directionalLight.shadowRadius = directionalLights[i * 11 + 8];\n  directionalLight.shadowMapSize = vec2(directionalLights[i * 11 + 9], directionalLights[i * 11 + 10]);\n  shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n }\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n SpotLight spotLight;\n #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  // spotLight = spotLights[ i ];\n  spotLight.shadow = int(spotLights[i * 18 + 13]);\n  spotLight.shadowBias = spotLights[i * 18 + 14];\n  spotLight.shadowRadius = spotLights[i * 18 + 15];\n  spotLight.shadowMapSize = vec2(spotLights[i * 18 + 16], spotLights[i * 18 + 17]);\n  shadow *= bool(spotLight.shadow) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n }\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n PointLight pointLight;\n\n #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  // pointLight = pointLights[ i ];\n  pointLight.shadow = int(pointLights[i * 15 + 8]);\n  pointLight.shadowBias = pointLights[i * 15 + 9];\n  pointLight.shadowRadius = pointLights[i * 15 + 10];\n  pointLight.shadowMapSize = vec2(pointLights[i * 15 + 11],pointLights[i * 15 + 12]);\n  pointLight.shadowCameraNear = pointLights[i * 15 + 13];\n  pointLight.shadowCameraFar = pointLights[i * 15 + 14];\n  shadow *= bool(pointLight.shadow) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n }\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): update shadow for Area light\n\n #endif\n */\n\n #endif\n\n return shadow;\n\n}\n";
        ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
        ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n // Modify egret.\n // uniform_mat4 bindMatrix;\n // uniform_mat4 bindMatrixInverse;\n\n #ifdef BONE_TEXTURE\n\n  uniform sampler2D boneTexture;\n  uniform int boneTextureSize;\n\n  mat4 getBoneMatrix( const in float i ) {\n\n   float j = i * 4.0;\n   float x = mod( j, float( boneTextureSize ) );\n   float y = floor( j / float( boneTextureSize ) );\n\n   float dx = 1.0 / float( boneTextureSize );\n   float dy = 1.0 / float( boneTextureSize );\n\n   y = dy * ( y + 0.5 );\n\n   vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n   vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n   vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n   vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n   mat4 bone = mat4( v1, v2, v3, v4 );\n\n   return bone;\n\n  }\n\n #else\n\n  uniform mat4 boneMatrices[ MAX_BONES ];\n\n  mat4 getBoneMatrix( const in float i ) {\n\n   mat4 bone = boneMatrices[ int(i) ];\n   return bone;\n\n  }\n\n #endif\n\n#endif\n";
        ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n // modified by egret.\n // vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n vec4 skinVertex = vec4( transformed, 1.0 );\n\n vec4 skinned = vec4( 0.0 );\n skinned += boneMatX * skinVertex * skinWeight.x;\n skinned += boneMatY * skinVertex * skinWeight.y;\n skinned += boneMatZ * skinVertex * skinWeight.z;\n skinned += boneMatW * skinVertex * skinWeight.w;\n\n // modified by egret.\n // transformed = ( bindMatrixInverse * skinned ).xyz;\n transformed = skinned.xyz;\n\n#endif\n";
        ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n mat4 skinMatrix = mat4( 0.0 );\n skinMatrix += skinWeight.x * boneMatX;\n skinMatrix += skinWeight.y * boneMatY;\n skinMatrix += skinWeight.z * boneMatZ;\n skinMatrix += skinWeight.w * boneMatW;\n \n // modified by egret.\n // skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";
        ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n vec4 texelSpecular = texture2D( specularMap, vUv );\n specularStrength = texelSpecular.r;\n\n#else\n\n specularStrength = 1.0;\n\n#endif";
        ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n uniform sampler2D specularMap;\n\n#endif";
        ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n";
        ShaderChunk.tonemapping_pars_fragment = "#ifndef saturate\n #define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n return toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n color *= toneMappingExposure;\n return saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n // John Hable's filmic operator from Uncharted 2 video game\n color *= toneMappingExposure;\n return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n color *= toneMappingExposure;\n color = max( vec3( 0.0 ), color - 0.004 );\n return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n";
        ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n varying vec2 vUv2;\n\n#endif";
        ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n attribute vec2 uv2;\n varying vec2 vUv2;\n #ifdef USE_LIGHTMAP//Egret \n  uniform vec4 lightMapScaleOffset;\n #endif\n\n#endif";
        ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n #ifdef USE_LIGHTMAP // modified by egret.\n  vUv2 = vec2(uv2.x * lightMapScaleOffset.x + lightMapScaleOffset.z, 1.0 - ((1.0 - uv2.y) * lightMapScaleOffset.y + lightMapScaleOffset.w));\n #else \n  vUv2 = uv2;\n #endif\n\n#endif";
        ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n varying vec2 vUv;\n\n#endif";
        ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n varying vec2 vUv;\n uniform mat3 uvTransform;\n\n#endif\n";
        ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n #if defined FLIP_V // modified by egret.\n  vUv = ( uvTransform * vec3( uv.x, 1.0 - uv.y, 1.0 ) ).xy;\n #else\n  vUv = ( uvTransform * vec3( uv, 1.0 ) ).xy;\n #endif\n#endif";
        ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n#endif\n";
    })(ShaderChunk = egret3d.ShaderChunk || (egret3d.ShaderChunk = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    // function promisify(loader: egret.HttpRequest | egret.Sound | any, resource: RES.ResourceInfo): Promise<any> {
    //     return new Promise((resolve, reject) => {
    //         let onSuccess = () => {
    //             let texture = loader['data'] ? loader['data'] : loader['response'];
    //             resolve(texture);
    //         }
    //         let onError = () => {
    //             let e = new RES.ResourceManagerError(1001, resource.url);
    //             reject(e);
    //         }
    //         loader.addEventListener(egret.Event.COMPLETE, onSuccess, this);
    //         loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, this);
    //     });
    // }
    egret3d.BitmapDataProcessor = {
        onLoadStart: function (host, resource) {
            var _this = this;
            var loader = new egret.ImageLoader();
            loader.load(resource.root + resource.url);
            return new Promise(function (resolve, reject) {
                var onSuccess = function () {
                    var bitmapData = loader.data;
                    loader.removeEventListener(egret.Event.COMPLETE, onSuccess, _this);
                    loader.removeEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                    resolve(bitmapData);
                };
                var onError = function () {
                    loader.removeEventListener(egret.Event.COMPLETE, onSuccess, _this);
                    loader.removeEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                    var e = new RES.ResourceManagerError(1001, resource.url);
                    reject(e);
                };
                loader.addEventListener(egret.Event.COMPLETE, onSuccess, _this);
                loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
            });
        },
        onRemoveStart: function (host, resource) {
            return Promise.resolve();
        }
    };
    egret3d.ShaderProcessor = {
        onLoadStart: function (host, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var result, shaders, _i, shaders_1, shader, source, shaderSource, glTF;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, host.load(resource, 'json')];
                        case 1:
                            result = _a.sent();
                            shaders = result.extensions.KHR_techniques_webgl.shaders;
                            if (!(shaders && shaders.length === 2)) return [3 /*break*/, 6];
                            _i = 0, shaders_1 = shaders;
                            _a.label = 2;
                        case 2:
                            if (!(_i < shaders_1.length)) return [3 /*break*/, 5];
                            shader = shaders_1[_i];
                            source = RES.host.resourceConfig["getResource"](shader.uri);
                            if (!source) return [3 /*break*/, 4];
                            return [4 /*yield*/, host.load(source, "text")];
                        case 3:
                            shaderSource = _a.sent();
                            if (shaderSource) {
                                shader.uri = shaderSource;
                            }
                            else {
                                console.error("Load shader error.", shader.uri);
                            }
                            _a.label = 4;
                        case 4:
                            _i++;
                            return [3 /*break*/, 2];
                        case 5: return [3 /*break*/, 7];
                        case 6:
                            console.error("错误的Shader格式数据");
                            _a.label = 7;
                        case 7:
                            glTF = egret3d.Shader.create(resource.name, result);
                            paper.Asset.register(glTF);
                            return [2 /*return*/, glTF];
                    }
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            // data.release();
            return Promise.resolve();
        }
    };
    egret3d.ImageProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bitmapdata").then(function (bitmapData) {
                var texture = egret3d.Texture
                    .create({ name: resource.name, source: bitmapData.source, format: 6408 /* RGBA */, mipmap: true })
                    .setLiner(true)
                    .setRepeat(true);
                paper.Asset.register(texture);
                return texture;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            // data.release();
            return Promise.resolve();
        }
    };
    egret3d.TextureProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                var name = data.name;
                var filterMode = data.filterMode;
                var format = data.format;
                var mipmap = data.mipmap;
                var wrap = data.wrap;
                var textureFormat = 6408 /* RGBA */;
                if (format === "RGB") {
                    textureFormat = 6407 /* RGB */;
                }
                else if (format === "Gray") {
                    textureFormat = 6409 /* Luminance */;
                }
                var linear = true;
                if (filterMode.indexOf("linear") < 0) {
                    linear = false;
                }
                var repeat = false;
                if (wrap.indexOf("Repeat") >= 0) {
                    repeat = true;
                }
                var premultiplyAlpha = 0;
                if (data["premultiply"] !== undefined) {
                    premultiplyAlpha = data["premultiply"] > 0 ? 1 : 0;
                }
                var imgResource = RES.host.resourceConfig["getResource"](name);
                if (imgResource) {
                    return host.load(imgResource, "bitmapdata").then(function (bitmapData) {
                        var texture = egret3d.Texture
                            .create({ name: resource.name, source: bitmapData.source, format: textureFormat, mipmap: mipmap, premultiplyAlpha: premultiplyAlpha })
                            .setLiner(linear)
                            .setRepeat(repeat);
                        paper.Asset.register(texture);
                        return texture;
                    });
                }
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            // data.release();
            return Promise.resolve();
        }
    };
    egret3d.MaterialProcessor = {
        onLoadStart: function (host, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var result, _i, _a, material_1, techniqueRes, values, _b, _c, _d, k, value, r, material;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0: return [4 /*yield*/, host.load(resource, 'json')];
                        case 1:
                            result = _e.sent();
                            if (!result.materials) return [3 /*break*/, 10];
                            _i = 0, _a = result.materials;
                            _e.label = 2;
                        case 2:
                            if (!(_i < _a.length)) return [3 /*break*/, 10];
                            material_1 = _a[_i];
                            techniqueRes = RES.host.resourceConfig["getResource"](material_1.extensions.KHR_techniques_webgl.technique);
                            if (!(techniqueRes && techniqueRes.indexOf("builtin/") < 0)) return [3 /*break*/, 4];
                            return [4 /*yield*/, host.load(techniqueRes, "Shader")];
                        case 3:
                            _e.sent(); // TODO
                            _e.label = 4;
                        case 4:
                            values = material_1.extensions.KHR_techniques_webgl.values;
                            if (!values) return [3 /*break*/, 9];
                            _b = [];
                            for (_c in values)
                                _b.push(_c);
                            _d = 0;
                            _e.label = 5;
                        case 5:
                            if (!(_d < _b.length)) return [3 /*break*/, 9];
                            k = _b[_d];
                            value = values[k];
                            if (!(value && typeof value === "string")) return [3 /*break*/, 8];
                            r = RES.host.resourceConfig["getResource"](value);
                            if (!r) return [3 /*break*/, 7];
                            return [4 /*yield*/, host.load(r, "TextureDesc")];
                        case 6:
                            _e.sent(); // TODO
                            return [3 /*break*/, 8];
                        case 7:
                            console.log("Load image error.", value);
                            _e.label = 8;
                        case 8:
                            _d++;
                            return [3 /*break*/, 5];
                        case 9:
                            _i++;
                            return [3 /*break*/, 2];
                        case 10:
                            material = egret3d.Material.create(resource.name, result);
                            paper.Asset.register(material);
                            return [2 /*return*/, material];
                    }
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            // data.release();
            return Promise.resolve();
        }
    };
    egret3d.MeshProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bin").then(function (result) {
                var parseResult = egret3d.GLTFAsset.parseFromBinary(result instanceof ArrayBuffer ? new Uint32Array(result) : result);
                var mesh = egret3d.Mesh.create(resource.name, parseResult.config, parseResult.buffers);
                paper.Asset.register(mesh);
                return mesh;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            // data.release();
            return Promise.resolve();
        }
    };
    egret3d.AnimationProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bin").then(function (result) {
                var parseResult = egret3d.GLTFAsset.parseFromBinary(new Uint32Array(result));
                var animation = egret3d.AnimationAsset.create(resource.name, parseResult.config, parseResult.buffers);
                paper.Asset.register(animation);
                return animation;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            // data.release();
            return Promise.resolve();
        }
    };
    egret3d.PrefabProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                return loadSubAssets(data, resource).then(function () {
                    var prefab = new paper.Prefab(data, resource.name); // TODO
                    paper.Asset.register(prefab);
                    return prefab;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            // data.release();
            return Promise.resolve();
        }
    };
    egret3d.SceneProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                return loadSubAssets(data, resource).then(function () {
                    var rawScene = new paper.RawScene(data, resource.name); // TODO
                    paper.Asset.register(rawScene);
                    return rawScene;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            // data.release();
            return Promise.resolve();
        }
    };
    function loadSubAssets(data, resource) {
        return Promise.all(data.assets.map((function (item) {
            var host = RES.host;
            var r = host.resourceConfig["getResource"](item);
            if (r) {
                return host.load(r);
            }
            else {
                if (item.indexOf("builtin/") !== 0) {
                    console.error("加载不存在的资源", item);
                }
                return Promise.resolve();
            }
        })));
    }
    function getResType(uri) {
        var file = uri.substr(uri.lastIndexOf("/") + 1);
        var i = file.indexOf(".", 0);
        var extname = "";
        while (i >= 0) {
            extname = file.substr(i);
            if (extname === ".assetbundle.json") {
                return 'Bundle';
            }
            else if (extname === ".png" || extname === ".jpg") {
                return 'Texture';
            }
            else if (extname === ".pvr.bin" || extname === ".pvr") {
                return 'PVR';
            }
            else if (extname === ".atlas.json") {
                return 'Atlas';
            }
            else if (extname === ".font.json") {
                return 'Font';
            }
            else if (extname === ".json" || extname === ".txt" || extname === ".effect.json") {
                return 'TextAsset';
            }
            else if (extname === ".packs.bin") {
                return 'PackBin';
            }
            else if (extname === ".packs.txt") {
                return 'PackTxt';
            }
            else if (extname === ".path.json") {
                return 'pathAsset';
            }
            else if (extname === ".mp3" || extname === ".ogg") {
                return 'Sound';
            }
            else if (extname === ".prefab.json") {
                return 'Prefab';
            }
            else if (extname === ".scene.json") {
                return 'Scene';
            }
            else if (extname === ".vs.glsl") {
                return 'text';
            }
            else if (extname === ".fs.glsl") {
                return 'text';
            }
            else if (extname === ".glsl") {
                return 'text';
            }
            else if (extname === ".shader.json") {
                return 'Shader';
            }
            else if (extname === ".image.json") {
                return 'TextureDesc';
            }
            else if (extname === ".mat.json") {
                return 'Material';
            }
            else if (extname === ".mesh.bin") {
                return 'Mesh';
            }
            else if (extname === ".ani.bin") {
                return 'Animation';
            }
            i = file.indexOf(".", i + 1);
        }
        return "Unknown";
    }
    function getResByURL(uri, root) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (r) {
                        RES.getResByUrl(root + uri, function (data) {
                            paper.Asset.register(data);
                            r(data);
                        }, RES, getResType(uri));
                    })];
            });
        });
    }
    RES.processor.map("Shader", egret3d.ShaderProcessor);
    RES.processor.map("Texture", egret3d.ImageProcessor);
    RES.processor.map("TextureDesc", egret3d.TextureProcessor);
    RES.processor.map("Material", egret3d.MaterialProcessor);
    RES.processor.map("Mesh", egret3d.MeshProcessor);
    RES.processor.map("Animation", egret3d.AnimationProcessor);
    RES.processor.map("Prefab", egret3d.PrefabProcessor);
    RES.processor.map("Scene", egret3d.SceneProcessor);
    RES.processor.map("bitmapdata", egret3d.BitmapDataProcessor);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 正则表达式的工具类，提供一些引擎用到的正则表达式
     */
    var RegexpUtil = (function () {
        function RegexpUtil() {
        }
        // shader properties
        RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
        RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        // material
        RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        // 特效解析，[1,2],2,1
        RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
        return RegexpUtil;
    }());
    egret3d.RegexpUtil = RegexpUtil;
    __reflect(RegexpUtil.prototype, "egret3d.RegexpUtil");
})(egret3d || (egret3d = {}));
// 0.04 处理utf8 string 不能用encode decode
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        var BinReader = (function () {
            function BinReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            BinReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinReader.prototype.peek = function () {
                return this._seek;
            };
            BinReader.prototype.length = function () {
                return this._data.byteLength;
            };
            BinReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            BinReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            BinReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            BinReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            BinReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUint8Array = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            BinReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            BinReader.prototype.readUint16Array = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this.readUInt16();
                }
                return target;
            };
            BinReader.prototype.readSingleArray = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                // console.log(this._data.byteLength, this._data.byteOffset);
                for (var i = 0; i < length; i++) {
                    // target[i] = this._data.getFloat32(this._seek, true);
                    // this._seek += 4;
                    target[i] = this.readSingle();
                }
                return target;
            };
            Object.defineProperty(BinReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            BinReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            BinReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            BinReader.prototype.readBytes = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            BinReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            BinReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            BinReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            BinReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return BinReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            BinReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            BinReader.prototype.readShort = function () {
                return this.readInt16();
            };
            BinReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return BinReader;
        }());
        io.BinReader = BinReader;
        __reflect(BinReader.prototype, "egret3d.io.BinReader");
        var BinWriter = (function () {
            function BinWriter() {
                var buf = new ArrayBuffer(1024);
                this._length = 0;
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            BinWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            BinWriter.prototype.getLength = function () {
                return length;
            };
            BinWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            BinWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinWriter.prototype.peek = function () {
                return this._seek;
            };
            BinWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            BinWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            BinWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            BinWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            BinWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            BinWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(BinWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            BinWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            BinWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            BinWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            BinWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            BinWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            BinWriter.prototype.writeUTFBytes = function (str) {
                var strArray = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            BinWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            BinWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            BinWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return BinWriter;
        }());
        io.BinWriter = BinWriter;
        __reflect(BinWriter.prototype, "egret3d.io.BinWriter");
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var utils;
    (function (utils) {
        function getRelativePath(targetPath, sourcePath) {
            var relPath = "";
            targetPath = targetPath.replace("\\", "/");
            sourcePath = sourcePath.replace("\\", "/");
            var targetPathArr = targetPath.split('/');
            var sourcePathArr = sourcePath.split('/');
            var targetPathLen = targetPathArr.length;
            var sourcePathLen = sourcePathArr.length;
            var i = 0;
            while (targetPathArr[i] == sourcePathArr[i] && i < targetPathLen && i < sourcePathLen) {
                i++;
            }
            for (var j = 0; j < sourcePathLen - i - 1; j++) {
                relPath += "../";
            }
            targetPathArr = targetPathArr.slice(i, targetPathArr.length);
            relPath = relPath + targetPathArr.join("/");
            relPath = relPath.replace(" ", "_");
            return relPath;
        }
        utils.getRelativePath = getRelativePath;
    })(utils = egret3d.utils || (egret3d.utils = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        function isPowerOfTwo(width, height) {
            return egret3d.math.isPowerOfTwo(width) && egret3d.math.isPowerOfTwo(height);
        }
        web.isPowerOfTwo = isPowerOfTwo;
        /**
         * @internal
         */
        function filterFallback(f) {
            if (f === 9728 /* Nearest */ || f === 9984 /* MearestMipmapNearest */ || f === 9986 /* NearestMipMapLinear */) {
                return 9728 /* Nearest */;
            }
            return 9729 /* Linear */;
        }
        web.filterFallback = filterFallback;
        /**
         * @internal
         */
        function setTexturexParameters(isPowerOfTwo, sampler) {
            var webgl = web.WebGLRenderState.webgl;
            var magFilter = sampler.magFilter;
            var minFilter = sampler.minFilter;
            var wrapS = sampler.wrapS;
            var wrapT = sampler.wrapT;
            if (isPowerOfTwo) {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, magFilter);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, minFilter);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, wrapS);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, wrapT);
            }
            else {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.CLAMP_TO_EDGE);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.CLAMP_TO_EDGE);
                if (wrapS !== 33071 /* ClampToEdge */ || wrapT !== 33071 /* ClampToEdge */) {
                    console.warn('Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to gltf.TextureWrap.CLAMP_TO_EDGE.');
                }
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, filterFallback(magFilter));
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, filterFallback(minFilter));
                if (minFilter !== 9728 /* Nearest */ && minFilter !== 9729 /* Linear */) {
                    console.warn('Texture is not power of two. Texture.minFilter should be set to gltf.TextureFilter.NEAREST or gltf.TextureFilter.LINEAR.');
                }
            }
            //TODO EXT_texture_filter_anisotropic
        }
        web.setTexturexParameters = setTexturexParameters;
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    /**
     *
     */
    var Frustum = (function (_super) {
        __extends(Frustum, _super);
        /**
         * 请使用 `egret3d.Frustum.create()` 创建实例。
         * @see egret3d.Frustum.create()
         */
        function Frustum() {
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.planes = [
                egret3d.Plane.create(),
                egret3d.Plane.create(),
                egret3d.Plane.create(),
                egret3d.Plane.create(),
                egret3d.Plane.create(),
                egret3d.Plane.create(),
            ];
            return _this;
        }
        /**
         *
         */
        Frustum.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new Frustum();
        };
        Frustum.prototype.serialize = function () {
            var index = 0;
            var array = [];
            for (var _i = 0, _a = this.planes; _i < _a.length; _i++) {
                var plane = _a[_i];
                plane.toArray(array, index++);
            }
            return array;
        };
        Frustum.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Frustum.prototype.clone = function () {
            return Frustum.create().set(this.planes);
        };
        Frustum.prototype.copy = function (value) {
            return this.set(value.planes);
        };
        Frustum.prototype.set = function (planes) {
            var index = 0;
            for (var _i = 0, planes_2 = planes; _i < planes_2.length; _i++) {
                var plane = planes_2[_i];
                this.planes[index++].copy(plane);
            }
            return this;
        };
        Frustum.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            for (var _i = 0, _a = this.planes; _i < _a.length; _i++) {
                var plane = _a[_i];
                plane.fromArray(array, offset);
                offset += 4;
            }
            return this;
        };
        Frustum.prototype.fromMatrix = function (matrix) {
            var planes = this.planes;
            var me = matrix.rawData;
            var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
            var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
            var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
            var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            var helpVector3 = _helpVector3;
            planes[0].set(helpVector3.set(me3 - me0, me7 - me4, me11 - me8), me15 - me12).normalize();
            planes[1].set(helpVector3.set(me3 + me0, me7 + me4, me11 + me8), me15 + me12).normalize();
            planes[2].set(helpVector3.set(me3 + me1, me7 + me5, me11 + me9), me15 + me13).normalize();
            planes[3].set(helpVector3.set(me3 - me1, me7 - me5, me11 - me9), me15 - me13).normalize();
            planes[4].set(helpVector3.set(me3 - me2, me7 - me6, me11 - me10), me15 - me14).normalize();
            planes[5].set(helpVector3.set(me3 + me2, me7 + me6, me11 + me10), me15 + me14).normalize();
            return this;
        };
        Frustum.prototype.containsPoint = function (point) {
            for (var _i = 0, _a = this.planes; _i < _a.length; _i++) {
                var plane = _a[_i];
                if (plane.getDistance(point) < 0.0) {
                    return false;
                }
            }
            return true;
        };
        Frustum._instances = [];
        return Frustum;
    }(paper.BaseRelease));
    egret3d.Frustum = Frustum;
    __reflect(Frustum.prototype, "egret3d.Frustum", ["paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        // 运行时 draw call 排序优化使用。
        var _hashCode = 0;
        /**
         * @internal
         */
        var WebGLProgramBinder = (function () {
            function WebGLProgramBinder(webglProgram) {
                this.id = _hashCode++;
                this.attributes = [];
                this.contextUniforms = [];
                this.uniforms = [];
                this.program = webglProgram;
            }
            return WebGLProgramBinder;
        }());
        web.WebGLProgramBinder = WebGLProgramBinder;
        __reflect(WebGLProgramBinder.prototype, "egret3d.web.WebGLProgramBinder");
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var WebGLTexture = (function (_super) {
            __extends(WebGLTexture, _super);
            function WebGLTexture() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.webglTexture = null;
                _this.dirty = true;
                return _this;
            }
            WebGLTexture.prototype.setupTexture = function (index) {
                if (!this._image || !this._image.uri) {
                    return;
                }
                var webgl = web.WebGLRenderState.webgl;
                if (!this.webglTexture) {
                    this.webglTexture = webgl.createTexture();
                }
                var image = this._image;
                var sampler = this._sampler;
                var paperExtension = this._gltfTexture.extensions.paper;
                webgl.activeTexture(webgl.TEXTURE0 + index);
                webgl.bindTexture(webgl.TEXTURE_2D, this.webglTexture);
                webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, paperExtension.premultiplyAlpha);
                webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, paperExtension.flipY);
                webgl.pixelStorei(webgl.UNPACK_ALIGNMENT, paperExtension.unpackAlignment);
                var isPowerTwo = web.isPowerOfTwo(paperExtension.width, paperExtension.height);
                web.setTexturexParameters(isPowerTwo, sampler);
                if (ArrayBuffer.isView(image.uri)) {
                    webgl.texImage2D(webgl.TEXTURE_2D, 0, paperExtension.format, paperExtension.width, paperExtension.height, 0, paperExtension.format, paperExtension.type, image.uri);
                }
                else {
                    webgl.texImage2D(webgl.TEXTURE_2D, 0, paperExtension.format, paperExtension.format, webgl.UNSIGNED_BYTE, image.uri);
                }
                var minFilter = sampler.minFilter;
                var canGenerateMipmap = isPowerTwo && minFilter !== 9728 /* Nearest */ && minFilter !== 9729 /* Linear */;
                if (canGenerateMipmap) {
                    webgl.generateMipmap(webgl.TEXTURE_2D);
                }
                this.dirty = false;
            };
            return WebGLTexture;
        }(egret3d.Texture));
        web.WebGLTexture = WebGLTexture;
        __reflect(WebGLTexture.prototype, "egret3d.web.WebGLTexture", ["egret3d.web.IWebGLTexture"]);
        // Retargeting.
        egret3d.Texture = WebGLTexture;
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var WebGLRenderTexture = (function (_super) {
            __extends(WebGLRenderTexture, _super);
            function WebGLRenderTexture() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.webglTexture = null;
                _this.frameBuffer = null;
                _this.renderBuffer = null;
                _this.dirty = true;
                return _this;
            }
            WebGLRenderTexture.prototype._setupFrameBufferTexture = function (frameBuffer, texture, textureTarget, type, width, height, format, attachment) {
                var webgl = web.WebGLRenderState.webgl;
                webgl.texImage2D(textureTarget, 0, format, width, height, 0, format, type, null);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, frameBuffer);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, attachment, textureTarget, texture, 0);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
            };
            WebGLRenderTexture.prototype._setupRenderBufferStorage = function (frameBuffer, renderBuffer, depthBuffer, stencilBuffer, width, height) {
                var webgl = web.WebGLRenderState.webgl;
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, frameBuffer);
                //
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, renderBuffer);
                if (depthBuffer && stencilBuffer) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, renderBuffer);
                }
                else if (depthBuffer) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, renderBuffer);
                }
                else {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.RGBA4, width, height);
                }
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
                //
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
            };
            WebGLRenderTexture.prototype._setupDepthRenderbuffer = function (frameBuffer, renderBuffer, depthBuffer, stencilBuffer, width, height) {
                var webgl = web.WebGLRenderState.webgl;
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, frameBuffer);
                this._setupRenderBufferStorage(frameBuffer, renderBuffer, depthBuffer, stencilBuffer, width, height);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
            };
            WebGLRenderTexture.prototype._setupRenderTexture = function () {
                var sampler = this._sampler;
                var paperExtension = this._gltfTexture.extensions.paper;
                var width = paperExtension.width;
                var height = paperExtension.height;
                var format = paperExtension.format;
                var depth = paperExtension.depthBuffer;
                var stencil = paperExtension.stencilBuffer;
                //
                var webgl = web.WebGLRenderState.webgl;
                if (!this.frameBuffer) {
                    this.frameBuffer = webgl.createFramebuffer();
                }
                if (!this.webglTexture) {
                    this.webglTexture = webgl.createTexture();
                }
                webgl.bindTexture(webgl.TEXTURE_2D, this.webglTexture);
                var isPowerTwo = web.isPowerOfTwo(width, height);
                web.setTexturexParameters(isPowerTwo, sampler);
                this._setupFrameBufferTexture(this.frameBuffer, this.webglTexture, webgl.TEXTURE_2D, 5121 /* UNSIGNED_BYTE */, width, height, format, webgl.COLOR_ATTACHMENT0);
                var minFilter = sampler.minFilter;
                var canGenerateMipmap = isPowerTwo && minFilter !== 9728 /* Nearest */ && minFilter !== 9729 /* Linear */;
                if (canGenerateMipmap) {
                    webgl.generateMipmap(webgl.TEXTURE_2D);
                }
                webgl.bindTexture(webgl.TEXTURE_2D, null);
                if (depth || stencil) {
                    if (!this.renderBuffer) {
                        this.renderBuffer = webgl.createRenderbuffer();
                    }
                    this._setupDepthRenderbuffer(this.frameBuffer, this.renderBuffer, depth, stencil, width, height);
                }
            };
            WebGLRenderTexture.prototype.activateRenderTexture = function () {
                if (this.dirty) {
                    this._setupRenderTexture();
                    this.dirty = false;
                }
                var webgl = web.WebGLRenderState.webgl;
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.frameBuffer);
            };
            WebGLRenderTexture.prototype.generateMipmap = function () {
                if (this._mipmap) {
                    var webgl = web.WebGLRenderState.webgl;
                    webgl.bindTexture(webgl.TEXTURE_2D, this.webglTexture);
                    webgl.generateMipmap(webgl.TEXTURE_2D);
                    webgl.bindTexture(webgl.TEXTURE_2D, null);
                    return true;
                }
                return false;
            };
            WebGLRenderTexture.prototype.dispose = function () {
                if (!_super.prototype.dispose.call(this)) {
                    return false;
                }
                var webgl = web.WebGLRenderState.webgl;
                if (!this.webglTexture) {
                    webgl.deleteBuffer(this.webglTexture);
                }
                if (!this.frameBuffer) {
                    webgl.deleteFramebuffer(this.frameBuffer);
                }
                if (!this.renderBuffer) {
                    webgl.deleteRenderbuffer(this.renderBuffer);
                }
                //
                this.webglTexture = null;
                this.frameBuffer = null;
                this.renderBuffer = null;
                return true;
            };
            return WebGLRenderTexture;
        }(egret3d.RenderTexture));
        web.WebGLRenderTexture = WebGLRenderTexture;
        __reflect(WebGLRenderTexture.prototype, "egret3d.web.WebGLRenderTexture", ["egret3d.web.IWebGLTexture", "egret3d.web.IWebGLRenderTexture"]);
        // Retargetting.
        egret3d.RenderTexture = WebGLRenderTexture;
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var WebGLMesh = (function (_super) {
            __extends(WebGLMesh, _super);
            function WebGLMesh() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.ibos = [];
                _this.vbo = null;
                return _this;
            }
            WebGLMesh.prototype.dispose = function () {
                if (!_super.prototype.dispose.call(this)) {
                    return false;
                }
                //
                var webgl = web.WebGLRenderState.webgl;
                this.vbo && webgl.deleteBuffer(this.vbo);
                for (var _i = 0, _a = this.ibos; _i < _a.length; _i++) {
                    var ibo = _a[_i];
                    ibo && webgl.deleteBuffer(ibo);
                }
                //
                this.ibos.length = 0;
                this.vbo = null;
                return true;
            };
            WebGLMesh.prototype.createBuffer = function () {
                var vertexBufferViewAccessor = this.getAccessor(this._glTFMesh.primitives[0].attributes.POSITION || 0);
                var vertexBuffer = this.createTypeArrayFromBufferView(this.getBufferView(vertexBufferViewAccessor), 5126 /* Float */);
                var webgl = web.WebGLRenderState.webgl;
                var vbo = webgl.createBuffer();
                if (vbo) {
                    this.vbo = vbo;
                    var attributeNames = [];
                    for (var k in this._glTFMesh.primitives[0].attributes) {
                        attributeNames.push(k);
                    }
                    var subMeshIndex = 0;
                    for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                        var primitive = _a[_i];
                        if (primitive.indices !== undefined) {
                            var ibo = webgl.createBuffer();
                            if (ibo) {
                                this.ibos[subMeshIndex] = ibo;
                                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, this.getBufferLength(this.getAccessor(primitive.indices)), this._drawMode);
                                this.uploadSubIndexBuffer(subMeshIndex);
                            }
                            else {
                                this.ibos[subMeshIndex] = null;
                                console.error("Create webgl element buffer error.");
                            }
                        }
                        subMeshIndex++;
                    }
                    webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                    webgl.bufferData(webgl.ARRAY_BUFFER, vertexBuffer.byteLength, this._drawMode);
                    this.uploadVertexBuffer(attributeNames);
                }
                else {
                    console.error("Create webgl buffer error.");
                }
            };
            /**
             * 更新该网格的顶点缓存。
             * @param uploadAttributes 要更新的顶点属性名，可以为一个属性，或属性列表，或 `null` （更新所有属性）。
             * @param offset 更新顶点的偏移。 [0: 不偏移，N: 从 N + 1 个顶点开始] （默认：0）
             * @param count 更新顶点的总数。 [0: 所有顶点，N: N 个顶点] （默认：0）
             */
            WebGLMesh.prototype.uploadVertexBuffer = function (uploadAttributes, offset, count) {
                if (uploadAttributes === void 0) { uploadAttributes = null; }
                if (offset === void 0) { offset = 0; }
                if (count === void 0) { count = 0; }
                if (!this.vbo) {
                    return;
                }
                var attributes = this._glTFMesh.primitives[0].attributes;
                var webgl = web.WebGLRenderState.webgl;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                if (!uploadAttributes) {
                    uploadAttributes = [];
                    for (var k in this._glTFMesh.primitives[0].attributes) {
                        uploadAttributes.push(k);
                    }
                }
                if (Array.isArray(uploadAttributes)) {
                    for (var _i = 0, uploadAttributes_1 = uploadAttributes; _i < uploadAttributes_1.length; _i++) {
                        var attributeName = uploadAttributes_1[_i];
                        var accessorIndex = attributes[attributeName];
                        if (accessorIndex !== undefined) {
                            var accessor = this.getAccessor(accessorIndex);
                            var bufferOffset = this.getBufferOffset(accessor);
                            var subVertexBuffer = this.createTypeArrayFromAccessor(accessor, offset, count);
                            if (offset > 0) {
                                bufferOffset += offset * accessor.typeCount * egret3d.GLTFAsset.getComponentTypeCount(accessor.componentType);
                            }
                            webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                        }
                        else {
                            console.warn("Error arguments.");
                        }
                    }
                }
                else {
                    var accessorIndex = attributes[uploadAttributes];
                    if (accessorIndex !== undefined) {
                        var accessor = this.getAccessor(accessorIndex);
                        var bufferOffset = this.getBufferOffset(accessor);
                        var subVertexBuffer = this.createTypeArrayFromAccessor(accessor);
                        webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
            };
            /**
             * 更新该网格的索引缓存。
             * @param subMeshIndex
             */
            WebGLMesh.prototype.uploadSubIndexBuffer = function (subMeshIndex) {
                if (subMeshIndex === void 0) { subMeshIndex = 0; }
                if (!this.vbo) {
                    return;
                }
                if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                    var primitive = this._glTFMesh.primitives[subMeshIndex];
                    if (primitive.indices !== undefined) {
                        var accessor = this.getAccessor(primitive.indices);
                        var subIndexBuffer = this.createTypeArrayFromAccessor(accessor);
                        var ibo = this.ibos[subMeshIndex];
                        var webgl = web.WebGLRenderState.webgl;
                        webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                        webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, 0, subIndexBuffer);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
                else {
                    console.warn("Error arguments.");
                }
            };
            return WebGLMesh;
        }(egret3d.Mesh));
        web.WebGLMesh = WebGLMesh;
        __reflect(WebGLMesh.prototype, "egret3d.web.WebGLMesh");
        // Retargeting.
        egret3d.Mesh = WebGLMesh;
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var BeginSystem = (function (_super) {
            __extends(BeginSystem, _super);
            function BeginSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._canvas = null;
                return _this;
            }
            BeginSystem.prototype._updateCanvas = function (stage) {
                var canvas = this._canvas;
                var screenSize = stage.screenSize;
                var viewport = stage.viewport;
                // Update canvas size and rotate.
                var parentElement = canvas.parentElement;
                canvas.width = viewport.w;
                canvas.height = viewport.h;
                // canvas.width = viewport.w * window.devicePixelRatio;
                // canvas.height = viewport.h * window.devicePixelRatio;
                canvas.style.top = (parentElement ? parentElement.offsetTop : 0) + "px";
                canvas.style.position = "absolute";
                canvas.style[egret.web.getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
                // canvas.scale(window.devicePixelRatio, window.devicePixelRatio);
                if (stage.rotated) {
                    // canvas.style.width = h + "px";
                    // canvas.style.height = w + "px";
                    canvas.style.left = (parentElement ? parentElement.offsetLeft : 0) + screenSize.w + "px";
                    var transform = "matrix(0," + screenSize.h / canvas.width + "," + -screenSize.w / canvas.height + ",0,0,0)";
                    canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
                }
                else {
                    // canvas.style.width = w + "px";
                    // canvas.style.height = h + "px";
                    // canvas.style[egret.web.getPrefixStyleName("transform")] = null;
                    canvas.style.left = (parentElement ? parentElement.offsetLeft : 0) + "px";
                    var transform = "matrix(" + screenSize.w / canvas.width + ",0,0," + screenSize.h / canvas.height + ",0,0)";
                    canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
                }
            };
            BeginSystem.prototype.onAwake = function (config) {
                var _this = this;
                var globalGameObject = paper.GameObject.globalGameObject;
                // Add stage, set stage, update canvas.
                this._canvas = config.canvas;
                var isWX = egret.Capabilities.runtimeType === egret.RuntimeType.WXGAME || this._canvas.parentElement === undefined;
                var screenWidth = isWX ? window.innerWidth : this._canvas.parentElement.clientWidth;
                var screenHeight = isWX ? window.innerHeight : this._canvas.parentElement.clientHeight;
                globalGameObject.addComponent(egret3d.Stage, {
                    size: { w: config.contentWidth, h: config.contentHeight },
                    screenSize: { w: screenWidth, h: screenHeight },
                });
                globalGameObject.addComponent(egret3d.DefaultMeshes);
                globalGameObject.addComponent(egret3d.DefaultShaders);
                globalGameObject.addComponent(egret3d.DefaultTextures);
                globalGameObject.addComponent(egret3d.DefaultMaterials);
                globalGameObject.addComponent(egret3d.InputCollecter);
                globalGameObject.addComponent(egret3d.RenderState, config);
                // Update canvas when screen resized.
                this._updateCanvas(egret3d.stage); // First update.
                egret3d.stage.onScreenResize.add(function () {
                    _this._updateCanvas(egret3d.stage);
                }, this);
                egret3d.stage.onResize.add(function () {
                    _this._updateCanvas(egret3d.stage);
                }, this);
            };
            BeginSystem.prototype.onUpdate = function () {
                // TODO 查询是否有性能问题。
                var screenSize = egret3d.stage.screenSize;
                // 
                var parentElement = this._canvas.parentElement;
                var isWX = egret.Capabilities.runtimeType === egret.RuntimeType.WXGAME || parentElement === undefined;
                var screenWidth = isWX ? window.innerWidth : parentElement.clientWidth;
                var screenHeight = isWX ? window.innerHeight : parentElement.clientHeight;
                if (screenSize.w !== screenWidth || screenSize.h !== screenHeight) {
                    egret3d.stage.screenSize = { w: screenWidth, h: screenHeight };
                }
            };
            return BeginSystem;
        }(paper.BaseSystem));
        web.BeginSystem = BeginSystem;
        __reflect(BeginSystem.prototype, "egret3d.web.BeginSystem");
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var WebGLRenderSystem = (function (_super) {
            __extends(WebGLRenderSystem, _super);
            function WebGLRenderSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.interests = [
                    [
                        { componentClass: egret3d.Camera }
                    ],
                    [
                        { componentClass: egret3d.Egret2DRenderer }
                    ],
                    [
                        { componentClass: [egret3d.DirectionalLight, egret3d.SpotLight, egret3d.PointLight] }
                    ]
                ];
                _this._egret2DOrderCount = 0;
                _this._drawCallCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCallCollecter);
                _this._cameraAndLightCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.CameraAndLightCollecter);
                _this._renderState = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.RenderState);
                _this._lightCamera = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.Camera);
                //
                _this._cacheMaterialVerision = -1;
                _this._cacheMaterial = null;
                //
                _this._cacheSubMeshIndex = -1;
                _this._cacheMesh = null;
                return _this;
            }
            // private _renderLightShadow(light: BaseLight) {
            // const camera = this._lightCamera;
            // const renderState = this._renderState;
            // const isPointLight = light.constructor === PointLight;
            // const shadowMaterial = isPointLight ? DefaultMaterials.SHADOW_DISTANCE : DefaultMaterials.SHADOW_DEPTH;
            // const drawCalls = this._drawCallCollecter;
            // const shadowCalls = drawCalls.shadowCalls;
            // const webgl = WebGLRenderState.webgl!;
            // light.updateShadow(camera);
            // light.renderTarget.use();
            // renderState.clearBuffer(gltf.BufferBit.DEPTH_BUFFER_BIT | gltf.BufferBit.COLOR_BUFFER_BIT, Color.WHITE);
            // for (let i = 0, l = isPointLight ? 6 : 1; i < l; ++i) {
            //     const context = camera.context;
            //     if (isPointLight) {
            //         light.updateFace(camera, i);
            //     }
            //     webgl.viewport(light.viewPortPixel.x, light.viewPortPixel.y, light.viewPortPixel.w, light.viewPortPixel.h);
            //     webgl.depthRange(0, 1);
            //     drawCalls.shadowFrustumCulling(camera);
            //     for (const drawCall of shadowCalls) {
            //         this._draw(context, drawCall, shadowMaterial);
            //     }
            // }
            // webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
            // }
            WebGLRenderSystem.prototype._render = function (camera, renderTarget, material) {
                var renderState = this._renderState;
                renderState.updateViewport(camera.viewport, renderTarget);
                renderState.clearBuffer(camera.bufferMask, camera.backgroundColor);
                // Step 1 draw opaques.
                for (var _i = 0, _a = camera.context.opaqueCalls; _i < _a.length; _i++) {
                    var drawCall = _a[_i];
                    this.draw(drawCall, material);
                }
                // Step 2 draw transparents.
                for (var _b = 0, _c = camera.context.transparentCalls; _b < _c.length; _b++) {
                    var drawCall = _c[_b];
                    this.draw(drawCall, material);
                }
                //
                if (renderTarget && renderTarget.generateMipmap()) {
                    renderState.clearState(); // Fixed there is no texture bound to the unit 0 error.
                }
                // Render 2D.
                var webgl = web.WebGLRenderState.webgl;
                webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1); // TODO 解决字体模糊。
                for (var _d = 0, _e = this.groups[1].gameObjects; _d < _e.length; _d++) {
                    var gameObject = _e[_d];
                    var egret2DRenderer = gameObject.getComponent(egret3d.Egret2DRenderer);
                    if (camera.cullingMask & egret2DRenderer.gameObject.layer) {
                        if (egret2DRenderer._order < 0) {
                            egret2DRenderer._order = this._egret2DOrderCount++;
                        }
                        egret2DRenderer._draw();
                        renderState.clearState();
                    }
                }
            };
            WebGLRenderSystem.prototype._updateGlobalUniforms = function (program, context) {
                var webgl = web.WebGLRenderState.webgl;
                // TODO
                var camera = context.camera;
                var drawCall = context.drawCall;
                var matrix = drawCall.matrix;
                for (var _i = 0, _a = program.contextUniforms; _i < _a.length; _i++) {
                    var glUniform = _a[_i];
                    var semantic = glUniform.semantic;
                    if (!semantic) {
                        continue;
                    }
                    var location_3 = glUniform.location;
                    switch (semantic) {
                        case "MODEL" /* MODEL */:
                            webgl.uniformMatrix4fv(location_3, false, matrix.rawData);
                            break;
                        case "MODELVIEW" /* MODELVIEW */:
                            webgl.uniformMatrix4fv(location_3, false, context.matrix_mv.rawData);
                            break;
                        case "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */:
                            webgl.uniformMatrix4fv(location_3, false, context.matrix_mvp.rawData);
                            break;
                        case "MODELVIEWINVERSE" /* MODELVIEWINVERSE */:
                            webgl.uniformMatrix3fv(location_3, false, context.matrix_mv_inverse.rawData);
                            break;
                        case "VIEW" /* VIEW */:
                            webgl.uniformMatrix4fv(location_3, false, camera.worldToCameraMatrix.rawData);
                            break;
                        case "PROJECTION" /* PROJECTION */:
                            webgl.uniformMatrix4fv(location_3, false, camera.projectionMatrix.rawData);
                            break;
                        case "_VIEWPROJECTION" /* _VIEWPROJECTION */:
                            webgl.uniformMatrix4fv(location_3, false, camera.worldToClipMatrix.rawData);
                            break;
                        case "_CAMERA_POS" /* _CAMERA_POS */:
                            webgl.uniform3fv(location_3, context.cameraPosition);
                            break;
                        case "_CAMERA_FORWARD" /* _CAMERA_FORWARD */:
                            webgl.uniform3fv(location_3, context.cameraForward);
                            break;
                        case "_CAMERA_UP" /* _CAMERA_UP */:
                            webgl.uniform3fv(location_3, context.cameraUp);
                            break;
                        case "JOINTMATRIX" /* JOINTMATRIX */:
                            var skinnedMeshRenderer = drawCall.renderer.source || drawCall.renderer;
                            webgl.uniformMatrix4fv(location_3, false, skinnedMeshRenderer.boneMatrices);
                            break;
                        case "_DIRECTLIGHTS" /* _DIRECTLIGHTS */:
                            if (context.directLightCount > 0) {
                                webgl.uniform1fv(location_3, context.directLightArray);
                            }
                            break;
                        case "_POINTLIGHTS" /* _POINTLIGHTS */:
                            if (context.pointLightCount > 0) {
                                webgl.uniform1fv(location_3, context.pointLightArray);
                            }
                            break;
                        case "_SPOTLIGHTS" /* _SPOTLIGHTS */:
                            if (context.spotLightCount > 0) {
                                webgl.uniform1fv(location_3, context.spotLightArray);
                            }
                            break;
                        case "_AMBIENTLIGHTCOLOR" /* _AMBIENTLIGHTCOLOR */:
                            var currenAmbientColor = drawCall.renderer ? drawCall.renderer.gameObject.scene.ambientColor : paper.Scene.activeScene.ambientColor;
                            webgl.uniform3f(location_3, currenAmbientColor.r, currenAmbientColor.g, currenAmbientColor.b);
                            break;
                        case "_DIRECTIONSHADOWMAT" /* _DIRECTIONSHADOWMAT */:
                            webgl.uniformMatrix4fv(location_3, false, context.directShadowMatrix);
                            break;
                        case "_SPOTSHADOWMAT" /* _SPOTSHADOWMAT */:
                            webgl.uniformMatrix4fv(location_3, false, context.spotShadowMatrix);
                            break;
                        case "_POINTSHADOWMAT" /* _POINTSHADOWMAT */:
                            webgl.uniformMatrix4fv(location_3, false, context.pointShadowMatrix);
                            break;
                        case "_DIRECTIONSHADOWMAP" /* _DIRECTIONSHADOWMAP */:
                            var directShadowLen = context.directShadowMaps.length;
                            if (directShadowLen > 0 && glUniform.textureUnits) {
                                var units = glUniform.textureUnits;
                                webgl.uniform1iv(location_3, units);
                                for (var i = 0, l = units.length; i < l; i++) {
                                    if (context.directShadowMaps[i]) {
                                        var unit = units[i];
                                        var texture = context.directShadowMaps[i];
                                        if (texture.dirty) {
                                            texture.setupTexture(unit);
                                        }
                                        else {
                                            webgl.activeTexture(webgl.TEXTURE0 + unit);
                                            webgl.bindTexture(webgl.TEXTURE_2D, texture.webglTexture);
                                        }
                                    }
                                }
                            }
                            break;
                        case "_POINTSHADOWMAP" /* _POINTSHADOWMAP */:
                            var pointShadowLen = context.pointShadowMaps.length;
                            if (pointShadowLen > 0 && glUniform.textureUnits) {
                                var units = glUniform.textureUnits;
                                webgl.uniform1iv(location_3, units);
                                for (var i = 0, l = units.length; i < l; i++) {
                                    if (context.pointShadowMaps[i]) {
                                        var unit = units[i];
                                        var texture = context.pointShadowMaps[i];
                                        if (texture.dirty) {
                                            texture.setupTexture(unit);
                                        }
                                        else {
                                            webgl.activeTexture(webgl.TEXTURE0 + unit);
                                            webgl.bindTexture(webgl.TEXTURE_2D, texture.webglTexture);
                                        }
                                    }
                                }
                            }
                            break;
                        case "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */:
                            var spotShadowLen = context.spotShadowMaps.length;
                            if (spotShadowLen > 0 && glUniform.textureUnits) {
                                var units = glUniform.textureUnits;
                                webgl.uniform1iv(location_3, units);
                                for (var i = 0, l = units.length; i < l; i++) {
                                    if (context.spotShadowMaps[i]) {
                                        var unit = units[i];
                                        var texture = context.spotShadowMaps[i];
                                        if (texture.dirty) {
                                            texture.setupTexture(unit);
                                        }
                                        else {
                                            webgl.activeTexture(webgl.TEXTURE0 + unit);
                                            webgl.bindTexture(webgl.TEXTURE_2D, texture.webglTexture);
                                        }
                                    }
                                }
                            }
                            break;
                        case "_LIGHTMAPTEX" /* _LIGHTMAPTEX */:
                            if (glUniform.textureUnits && glUniform.textureUnits.length === 1 && context.lightmap) {
                                var texture = context.lightmap;
                                var unit = glUniform.textureUnits[0];
                                webgl.uniform1i(location_3, unit);
                                if (texture.dirty) {
                                    texture.setupTexture(unit);
                                }
                                else {
                                    webgl.activeTexture(webgl.TEXTURE0 + unit);
                                    webgl.bindTexture(webgl.TEXTURE_2D, texture.webglTexture);
                                }
                            }
                            else {
                                console.error("Error texture unit.");
                            }
                            break;
                        case "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */:
                            webgl.uniform1f(location_3, context.lightmapIntensity);
                            break;
                        case "_LIGHTMAP_SCALE_OFFSET" /* _LIGHTMAP_SCALE_OFFSET */:
                            webgl.uniform4fv(location_3, context.lightmapScaleOffset);
                            break;
                        case "_NEARDICTANCE" /* _NEARDICTANCE */:
                            webgl.uniform1f(location_3, context.lightShadowCameraNear);
                            break;
                        case "_FARDISTANCE" /* _FARDISTANCE */:
                            webgl.uniform1f(location_3, context.lightShadowCameraFar);
                            break;
                        case "_FOG_COLOR" /* _FOG_COLOR */:
                            webgl.uniform3fv(location_3, context.fogColor);
                            break;
                        case "_FOG_DENSITY" /* _FOG_DENSITY */:
                            webgl.uniform1f(location_3, context.fogDensity);
                            break;
                        case "_FOG_NEAR" /* _FOG_NEAR */:
                            webgl.uniform1f(location_3, context.fogNear);
                            break;
                        case "_FOG_FAR" /* _FOG_FAR */:
                            webgl.uniform1f(location_3, context.fogFar);
                            break;
                        case "_TONE_MAPPING_EXPOSURE" /* _TONE_MAPPING_EXPOSURE */:
                            webgl.uniform1f(location_3, this._renderState.toneMappingExposure);
                            break;
                        case "_TONE_MAPPING_WHITE_POINT" /* _TONE_MAPPING_WHITE_POINT */:
                            webgl.uniform1f(location_3, this._renderState.toneMappingWhitePoint);
                            break;
                        default:
                            console.warn("不识别的Uniform语义:" + semantic);
                            break;
                    }
                }
            };
            WebGLRenderSystem.prototype._updateUniforms = function (program, material, technique, forceUpdate) {
                var needUpdate = this._cacheMaterial !== material || this._cacheMaterialVerision !== material._version || forceUpdate;
                if (!needUpdate) {
                    return;
                }
                this._cacheMaterial = material;
                this._cacheMaterialVerision = material._version;
                var webgl = web.WebGLRenderState.webgl;
                var unifroms = technique.uniforms;
                for (var _i = 0, _a = program.uniforms; _i < _a.length; _i++) {
                    var glUniform = _a[_i];
                    var uniform = unifroms[glUniform.name];
                    if (uniform.semantic) {
                        continue;
                    }
                    var location_4 = glUniform.location;
                    var value = uniform.value;
                    switch (uniform.type) {
                        case 35670 /* BOOL */:
                        case 5124 /* INT */:
                            if (glUniform.size > 1) {
                                webgl.uniform1iv(location_4, value);
                            }
                            else {
                                webgl.uniform1i(location_4, value);
                            }
                            break;
                        case 35671 /* BOOL_VEC2 */:
                        case 35667 /* INT_VEC2 */:
                            webgl.uniform2iv(location_4, value);
                            break;
                        case 35672 /* BOOL_VEC3 */:
                        case 35668 /* INT_VEC3 */:
                            webgl.uniform3iv(location_4, value);
                            break;
                        case 35673 /* BOOL_VEC4 */:
                        case 35669 /* INT_VEC4 */:
                            webgl.uniform4iv(location_4, value);
                            break;
                        case 5126 /* FLOAT */:
                            if (glUniform.size > 1) {
                                webgl.uniform1fv(location_4, value);
                            }
                            else {
                                webgl.uniform1f(location_4, value);
                            }
                            break;
                        case 35664 /* FLOAT_VEC2 */:
                            webgl.uniform2fv(location_4, value);
                            break;
                        case 35665 /* FLOAT_VEC3 */:
                            webgl.uniform3fv(location_4, value);
                            break;
                        case 35666 /* FLOAT_VEC4 */:
                            webgl.uniform4fv(location_4, value);
                            break;
                        case 35674 /* FLOAT_MAT2 */:
                            webgl.uniformMatrix2fv(location_4, false, value);
                            break;
                        case 35675 /* FLOAT_MAT3 */:
                            webgl.uniformMatrix3fv(location_4, false, value);
                            break;
                        case 35676 /* FLOAT_MAT4 */:
                            webgl.uniformMatrix4fv(location_4, false, value);
                            break;
                        case 35678 /* SAMPLER_2D */:
                            if (glUniform.textureUnits && glUniform.textureUnits.length === 1) {
                                var texture = value;
                                var unit = glUniform.textureUnits[0];
                                webgl.uniform1i(location_4, unit);
                                if (texture.dirty) {
                                    texture.setupTexture(unit);
                                }
                                else {
                                    webgl.activeTexture(webgl.TEXTURE0 + unit);
                                    webgl.bindTexture(webgl.TEXTURE_2D, texture.webglTexture);
                                }
                            }
                            else {
                                console.error("Error texture unit");
                            }
                            break;
                    }
                }
            };
            WebGLRenderSystem.prototype._updateAttributes = function (program, mesh, subMeshIndex, technique, forceUpdate) {
                var needUpdate = forceUpdate || this._cacheSubMeshIndex !== subMeshIndex || this._cacheMesh !== mesh;
                if (!needUpdate) {
                    return;
                }
                this._cacheSubMeshIndex = subMeshIndex;
                this._cacheMesh = mesh;
                var webgl = web.WebGLRenderState.webgl;
                var attributes = mesh.glTFMesh.primitives[subMeshIndex].attributes;
                //
                if (!mesh.vbo && !mesh.isDisposed) {
                    mesh.createBuffer();
                }
                // vbo.
                webgl.bindBuffer(webgl.ARRAY_BUFFER, mesh.vbo);
                for (var _i = 0, _a = program.attributes; _i < _a.length; _i++) {
                    var attribute = _a[_i];
                    var location_5 = attribute.location;
                    var accessorIndex = attributes[attribute.semantic];
                    if (accessorIndex !== undefined) {
                        var accessor = mesh.getAccessor(accessorIndex);
                        webgl.vertexAttribPointer(location_5, accessor.typeCount, accessor.componentType, accessor.normalized !== undefined ? accessor.normalized : false, 0, mesh.getBufferOffset(accessor)); // TODO normalized应该来源于mesh，应该还没有
                        webgl.enableVertexAttribArray(location_5);
                    }
                    else {
                        webgl.disableVertexAttribArray(location_5);
                    }
                }
                // ibo.
                var ibo = mesh.ibos[subMeshIndex];
                if (ibo) {
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                }
            };
            WebGLRenderSystem.prototype.render = function (camera, material) {
                if (material === void 0) { material = null; }
                if (egret3d.Camera.current !== camera) {
                    egret3d.Camera.current = camera;
                    camera._update();
                    //
                    if (this._cameraAndLightCollecter.lightDirty) {
                        camera.context.updateLights(this._cameraAndLightCollecter.lights); // TODO 性能优化
                    }
                    //
                    var isAnyActivated = false;
                    var postprocessings = camera.gameObject.getComponents(egret3d.CameraPostprocessing, true);
                    if (postprocessings.length > 0) {
                        for (var _i = 0, postprocessings_1 = postprocessings; _i < postprocessings_1.length; _i++) {
                            var postprocessing = postprocessings_1[_i];
                            if (postprocessing.isActiveAndEnabled) {
                                isAnyActivated = true;
                                break;
                            }
                        }
                    }
                    if (!isAnyActivated) {
                        this._render(camera, camera.renderTarget, material);
                    }
                    else {
                        this._render(camera, camera._readRenderTarget, material);
                        for (var _a = 0, postprocessings_2 = postprocessings; _a < postprocessings_2.length; _a++) {
                            var postprocessing = postprocessings_2[_a];
                            if (postprocessing.isActiveAndEnabled) {
                                postprocessing.render(camera);
                            }
                        }
                        var temp = camera._readRenderTarget;
                        camera._readRenderTarget = camera._writeRenderTarget;
                        camera._writeRenderTarget = temp;
                    }
                }
                else {
                    this._render(camera, camera.renderTarget, material);
                }
                //
                egret3d.Camera.current = null;
            };
            WebGLRenderSystem.prototype.draw = function (drawCall, material) {
                if (material === void 0) { material = null; }
                if (drawCall.renderer && drawCall.renderer.gameObject._beforeRenderBehaviors.length > 0) {
                    var flag = false;
                    for (var _i = 0, _a = drawCall.renderer.gameObject._beforeRenderBehaviors; _i < _a.length; _i++) {
                        var behaviour = _a[_i];
                        flag = !behaviour.onBeforeRender() || flag;
                    }
                    if (flag) {
                        return;
                    }
                }
                var camera = egret3d.Camera.current;
                var context = camera.context;
                material = material || drawCall.material;
                var shaderContextDefine = context.updateDrawCall(drawCall);
                //
                var webgl = web.WebGLRenderState.webgl;
                var technique = material._technique;
                var techniqueState = technique.states || null;
                var renderState = this._renderState;
                var program = renderState.getProgram(material, technique, shaderContextDefine); // Get program.
                if (program) {
                    var force = renderState.useProgram(program); // Use program.
                    renderState.updateState(techniqueState); // Update states.
                    //  TODO
                    // if (techniqueState && context.drawCall.renderer.transform._worldMatrixDeterminant < 0) {
                    //     if (techniqueState.functions!.frontFace[0] === CCW) {
                    //         webgl.frontFace(CW);
                    //     }
                    //     else {
                    //         webgl.frontFace(CCW);
                    //     }
                    // }
                    // Update static uniforms.
                    this._updateGlobalUniforms(program, context);
                    // Update uniforms.
                    this._updateUniforms(program, material, technique, force);
                    // Update attributes.
                    this._updateAttributes(program, drawCall.mesh, drawCall.subMeshIndex, technique, force);
                    // Draw.
                    var mesh = drawCall.mesh;
                    var glTFMesh = mesh.glTFMesh;
                    var primitive = glTFMesh.primitives[drawCall.subMeshIndex];
                    var vertexAccessor = mesh.getAccessor(glTFMesh.primitives[0].attributes.POSITION || 0);
                    var bufferOffset = mesh.getBufferOffset(vertexAccessor);
                    var drawMode = primitive.mode === undefined ? 4 /* Triangles */ : primitive.mode;
                    if (primitive.indices !== undefined) {
                        var indexAccessor = mesh.getAccessor(primitive.indices);
                        webgl.drawElements(drawMode, indexAccessor.count, webgl.UNSIGNED_SHORT, bufferOffset);
                    }
                    else {
                        webgl.drawArrays(drawMode, bufferOffset, vertexAccessor.count);
                    }
                    if (true && drawCall.drawCount >= 0) {
                        drawCall.drawCount++;
                    }
                }
            };
            WebGLRenderSystem.prototype.onAwake = function () {
                var renderState = this._renderState;
                renderState.render = this.render.bind(this);
                renderState.draw = this.draw.bind(this);
            };
            WebGLRenderSystem.prototype.onUpdate = function () {
                if (!web.WebGLRenderState.webgl) {
                    return;
                }
                var isPlayerMode = paper.Application.playerMode === 0 /* Player */;
                var drawCallCollecter = this._drawCallCollecter;
                var cameraAndLightCollecter = this._cameraAndLightCollecter;
                var renderState = this._renderState;
                var editorScene = paper.Application.sceneManager.editorScene;
                var cameras = cameraAndLightCollecter.cameras;
                var lights = cameraAndLightCollecter.lights;
                //
                if (!renderState.oesStandardDerivatives) {
                    for (var _i = 0, _a = drawCallCollecter.addDrawCalls; _i < _a.length; _i++) {
                        var drawCall = _a[_i];
                        if (drawCall) {
                            var material = drawCall.material;
                            material
                                .removeDefine("USE_NORMALMAP" /* USE_NORMALMAP */)
                                .removeDefine("USE_BUMPMAP" /* USE_BUMPMAP */)
                                .removeDefine("FLAT_SHADED" /* FLAT_SHADED */)
                                .removeDefine("ENVMAP_TYPE_CUBE_UV" /* ENVMAP_TYPE_CUBE_UV */);
                        }
                    }
                }
                //
                drawCallCollecter._update();
                // Render lights.
                if (lights.length > 0) {
                    for (var _b = 0, lights_3 = lights; _b < lights_3.length; _b++) {
                        var light = lights_3[_b];
                        if (!light.castShadows) {
                            continue;
                        }
                        // this._renderLightShadow(light);
                    }
                }
                // Render cameras.
                if (cameras.length > 0) {
                    this._egret2DOrderCount = 0;
                    for (var _c = 0, cameras_1 = cameras; _c < cameras_1.length; _c++) {
                        var camera = cameras_1[_c];
                        var scene = camera.gameObject.scene;
                        if (isPlayerMode ? scene !== editorScene : scene === editorScene) {
                            this.render(camera);
                        }
                    }
                }
                else {
                    renderState.clearBuffer(256 /* Depth */ | 16384 /* Color */, egret3d.Color.BLACK);
                }
            };
            return WebGLRenderSystem;
        }(paper.BaseSystem));
        web.WebGLRenderSystem = WebGLRenderSystem;
        __reflect(WebGLRenderSystem.prototype, "egret3d.web.WebGLRenderSystem", ["egret3d.IRenderSystem"]);
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var InputSystem = (function (_super) {
            __extends(InputSystem, _super);
            function InputSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._hasTouch = false;
                _this._canvas = null;
                _this._onPointerEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    var rotated = egret3d.stage.rotated;
                    var canvas = _this._canvas;
                    var downPointers = egret3d.inputCollecter._downPointers;
                    var holdPointers = egret3d.inputCollecter._holdPointers;
                    var pointer = egret3d.inputCollecter.getPointer(event.pointerId);
                    var prevEvent = pointer.event;
                    pointer.event = event;
                    pointer.position.set(event.clientX - (canvas.offsetLeft || 0.0), event.clientY - (canvas.offsetTop || 0.0), 0.0);
                    if (rotated) {
                        pointer.position.x += egret3d.stage.screenSize.w;
                    }
                    egret3d.stage.screenToStage(pointer.position, pointer.position);
                    switch (event.type) {
                        case "pointerover":
                            if (holdPointers.length > 0 && event.buttons === 0 /* None */) {
                                _this._pointerUp(pointer, true);
                            }
                            egret3d.inputCollecter.onPointerOver.dispatch(pointer, egret3d.inputCollecter.onPointerOver);
                            event.preventDefault();
                            break;
                        case "pointerenter":
                            egret3d.inputCollecter.onPointerEnter.dispatch(pointer, egret3d.inputCollecter.onPointerEnter);
                            event.preventDefault();
                            break;
                        case "pointerdown":
                            if (downPointers.indexOf(pointer) < 0 && holdPointers.indexOf(pointer) < 0) {
                                pointer.downPosition.copy(pointer.position);
                                downPointers.push(pointer);
                                holdPointers.push(pointer);
                                egret3d.inputCollecter.onPointerDown.dispatch(pointer, egret3d.inputCollecter.onPointerDown);
                                event.preventDefault();
                            }
                            break;
                        case "pointermove":
                            if (event.target === canvas || holdPointers.length > 0) {
                                egret3d.inputCollecter.onPointerMove.dispatch(pointer, egret3d.inputCollecter.onPointerMove);
                                event.preventDefault();
                            }
                            else {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "pointerup":
                            if (!_this._pointerUp(pointer, false)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                        case "pointercancel":
                            if (!_this._pointerUp(pointer, true)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                        case "pointerout":
                            egret3d.inputCollecter.onPointerOut.dispatch(pointer, egret3d.inputCollecter.onPointerOut);
                            event.preventDefault();
                            break;
                        case "pointerleave":
                            egret3d.inputCollecter.onPointerLeave.dispatch(pointer, egret3d.inputCollecter.onPointerLeave);
                            event.preventDefault();
                            break;
                    }
                };
                _this._onMouseWheelEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    if (event.detail) {
                        egret3d.inputCollecter.mouseWheel = -1 * event.detail;
                    }
                    else if (event.wheelDelta) {
                        egret3d.inputCollecter.mouseWheel = event.wheelDelta / 120;
                    }
                    else {
                        egret3d.inputCollecter.mouseWheel = 0;
                    }
                    egret3d.inputCollecter.onMouseWheel.dispatch(_this);
                    event.preventDefault();
                };
                _this._onMouseEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    event.isPrimary = true;
                    event.pointerId = 1;
                    event.pressure = 0;
                    event.tangentialPressure = 0;
                    event.twist = 0;
                    event.width = 1;
                    event.height = 1;
                    event.tiltX = 0;
                    event.tiltY = 0;
                    event.pointerType = "mouse";
                    var rotated = egret3d.stage.rotated;
                    var pointerEvent = event;
                    var canvas = _this._canvas;
                    var downPointers = egret3d.inputCollecter._downPointers;
                    var holdPointers = egret3d.inputCollecter._holdPointers;
                    var pointer = egret3d.inputCollecter.getPointer(pointerEvent.pointerId);
                    var prevEvent = pointer.event;
                    pointer.event = pointerEvent;
                    pointer.position.set(event.clientX - (canvas.offsetLeft || 0.0), event.clientY - (canvas.offsetTop || 0.0), 0.0);
                    if (rotated) {
                        pointer.position.x += egret3d.stage.screenSize.w;
                    }
                    egret3d.stage.screenToStage(pointer.position, pointer.position);
                    switch (event.type) {
                        case "mouseover":
                            if (holdPointers.length > 0 && event.buttons === 0 /* None */) {
                                event.type = "pointerup";
                                _this._pointerUp(pointer, true);
                            }
                            event.type = "pointerover";
                            egret3d.inputCollecter.onPointerOver.dispatch(pointer, egret3d.inputCollecter.onPointerOver);
                            event.preventDefault();
                            break;
                        case "mouseenter":
                            event.type = "pointerenter";
                            egret3d.inputCollecter.onPointerEnter.dispatch(pointer, egret3d.inputCollecter.onPointerEnter);
                            event.preventDefault();
                            break;
                        case "mousedown":
                            if (downPointers.indexOf(pointer) < 0 && holdPointers.indexOf(pointer) < 0) {
                                pointer.downPosition.copy(pointer.position);
                                downPointers.push(pointer);
                                holdPointers.push(pointer);
                                event.type = "pointerdown";
                                egret3d.inputCollecter.onPointerDown.dispatch(pointer, egret3d.inputCollecter.onPointerDown);
                                event.preventDefault();
                            }
                            break;
                        case "mousemove":
                            if (event.target === canvas || holdPointers.length > 0) {
                                event.type = "pointermove";
                                egret3d.inputCollecter.onPointerMove.dispatch(pointer, egret3d.inputCollecter.onPointerMove);
                                event.preventDefault();
                            }
                            else {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "mouseup":
                            event.type = "pointerup";
                            if (!_this._pointerUp(pointer, false)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                        case "mousecancel":
                            event.type = "pointercancel";
                            if (!_this._pointerUp(pointer, true)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                        case "mouseout":
                            event.type = "pointerout";
                            egret3d.inputCollecter.onPointerOut.dispatch(pointer, egret3d.inputCollecter.onPointerOut);
                            event.preventDefault();
                            break;
                        case "mouseleave":
                            event.type = "pointerleave";
                            egret3d.inputCollecter.onPointerLeave.dispatch(pointer, egret3d.inputCollecter.onPointerLeave);
                            event.preventDefault();
                            break;
                    }
                };
                _this._onTouchEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    if (!_this._hasTouch) {
                        _this._hasTouch = true;
                        _this._removeMouseEvent(); // TODO 同时支持 mouse 和 touch.
                    }
                    var touch = event.changedTouches[0];
                    if (!touch) {
                        // WX BUG.
                        console.error("WX touch error.", event.type);
                        return;
                    }
                    event.isPrimary = true; // TODO
                    event.pointerId = touch.identifier + 2;
                    event.pressure = touch.force || 0.5; // TODO egret build bug
                    event.tangentialPressure = 0;
                    event.twist = 0;
                    event.width = (touch.radiusX || 0) * 2; // TODO egret build bug
                    event.height = (touch.radiusY || 0) * 2; // TODO egret build bug
                    event.tiltX = 0;
                    event.tiltY = 0;
                    event.pointerType = "touch";
                    event.button = 0;
                    event.buttons = (event.type === "touchstart" || event.type === "touchmove") ? 1 : 0;
                    event.clientX = touch.clientX;
                    event.clientY = touch.clientY;
                    event.pageX = touch.pageX;
                    event.pageY = touch.pageY;
                    event.screenX = touch.screenX;
                    event.screenY = touch.screenY;
                    var rotated = egret3d.stage.rotated;
                    var pointerEvent = event;
                    var canvas = _this._canvas;
                    var downPointers = egret3d.inputCollecter._downPointers;
                    var holdPointers = egret3d.inputCollecter._holdPointers;
                    var pointer = egret3d.inputCollecter.getPointer(pointerEvent.pointerId);
                    var prevEvent = pointer.event;
                    pointer.event = pointerEvent;
                    pointer.position.set(pointerEvent.clientX - (canvas.offsetLeft || 0.0), pointerEvent.clientY - (canvas.offsetTop || 0.0), 0.0);
                    if (rotated) {
                        pointer.position.x += egret3d.stage.screenSize.w;
                    }
                    egret3d.stage.screenToStage(pointer.position, pointer.position);
                    switch (event.type) {
                        case "touchstart":
                            if (downPointers.indexOf(pointer) < 0 && holdPointers.indexOf(pointer) < 0) {
                                pointer.downPosition.copy(pointer.position);
                                downPointers.push(pointer);
                                holdPointers.push(pointer);
                                event.type = "pointerdown";
                                egret3d.inputCollecter.onPointerDown.dispatch(pointer, egret3d.inputCollecter.onPointerDown);
                                event.preventDefault();
                            }
                            break;
                        case "touchmove":
                            if (event.target === canvas || holdPointers.length > 0) {
                                event.type = "pointermove";
                                egret3d.inputCollecter.onPointerMove.dispatch(pointer, egret3d.inputCollecter.onPointerMove);
                                for (var i = 0, l = event.targetTouches.length; i < l; ++i) {
                                    var eachTouch = event.targetTouches[i];
                                    if (eachTouch !== touch) {
                                        var eachPointer = egret3d.inputCollecter.getPointer(eachTouch.identifier + 2);
                                        var eachPointerEvent = eachPointer.event;
                                        eachPointerEvent.pressure = eachTouch.force || 0.5; // TODO egret build bug
                                        eachPointerEvent.width = (eachTouch.radiusX || 0) * 2; // TODO egret build bug
                                        eachPointerEvent.height = (eachTouch.radiusY || 0) * 2; // TODO egret build bug
                                        eachPointerEvent.clientX = eachTouch.clientX;
                                        eachPointerEvent.clientY = eachTouch.clientY;
                                        eachPointerEvent.pageX = eachTouch.pageX;
                                        eachPointerEvent.pageY = eachTouch.pageY;
                                        eachPointerEvent.screenX = eachTouch.screenX;
                                        eachPointerEvent.screenY = eachTouch.screenY;
                                        eachPointerEvent.type = "pointermove";
                                        eachPointer.position.set(eachPointerEvent.clientX - (canvas.offsetLeft || 0.0), eachPointerEvent.clientY - (canvas.offsetTop || 0.0), 0.0);
                                        if (rotated) {
                                            eachPointer.position.x += egret3d.stage.screenSize.w;
                                        }
                                        egret3d.stage.screenToStage(eachPointer.position, eachPointer.position);
                                        egret3d.inputCollecter.onPointerMove.dispatch(eachPointer, egret3d.inputCollecter.onPointerMove);
                                    }
                                }
                                event.preventDefault();
                            }
                            else {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "touchend":
                            event.type = "pointerup";
                            if (!_this._pointerUp(pointer, false)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                        case "touchcancel":
                            event.type = "pointercancel";
                            if (!_this._pointerUp(pointer, true)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                    }
                };
                _this._onContextMenu = function (event) {
                    if (egret3d.inputCollecter._downPointers.length > 0 ||
                        egret3d.inputCollecter._holdPointers.length > 0 ||
                        egret3d.inputCollecter._upPointers.length > 0) {
                        event.preventDefault();
                    }
                };
                _this._onKeyEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    var downKeys = egret3d.inputCollecter._downKeys;
                    var holdKeys = egret3d.inputCollecter._holdKeys;
                    var upKeys = egret3d.inputCollecter._upKeys;
                    var key = egret3d.inputCollecter.getKey(event.code);
                    key.event = event;
                    switch (event.type) {
                        case "keydown":
                            if (downKeys.indexOf(key) < 0 && holdKeys.indexOf(key) < 0) {
                                downKeys.push(key);
                                holdKeys.push(key);
                                egret3d.inputCollecter.onKeyDown.dispatch(key, egret3d.inputCollecter.onKeyDown);
                            }
                            break;
                        case "keyup": {
                            var isDown = false;
                            var index = downKeys.indexOf(key);
                            if (index >= 0) {
                                isDown = true;
                                downKeys.splice(index, 1);
                            }
                            index = holdKeys.indexOf(key);
                            if (index >= 0) {
                                isDown = true;
                                holdKeys.splice(index, 1);
                            }
                            if (isDown && upKeys.indexOf(key) < 0) {
                                upKeys.push(key);
                                egret3d.inputCollecter.onKeyUp.dispatch(key, egret3d.inputCollecter.onKeyUp);
                            }
                            break;
                        }
                    }
                };
                return _this;
            }
            InputSystem.prototype._pointerUp = function (pointer, isCancel) {
                if (pointer.event.buttons !== 0 /* None */) {
                    return false;
                }
                var isDown = false;
                var downPointers = egret3d.inputCollecter._downPointers;
                var holdPointers = egret3d.inputCollecter._holdPointers;
                var upPointers = egret3d.inputCollecter._upPointers;
                var index = downPointers.indexOf(pointer);
                if (index >= 0) {
                    isDown = true;
                    downPointers.splice(index, 1);
                }
                index = holdPointers.indexOf(pointer);
                if (index >= 0) {
                    isDown = true;
                    holdPointers.splice(index, 1);
                }
                if (isDown && upPointers.indexOf(pointer) < 0) {
                    egret3d.inputCollecter.removePointer(pointer.event.pointerId);
                    upPointers.push(pointer);
                    if (isCancel) {
                        egret3d.inputCollecter.onPointerCancel.dispatch(pointer, egret3d.inputCollecter.onPointerCancel);
                    }
                    else {
                        egret3d.inputCollecter.onPointerUp.dispatch(pointer, egret3d.inputCollecter.onPointerUp);
                    }
                    return true;
                }
                return false;
            };
            InputSystem.prototype._removeMouseEvent = function () {
                var canvas = this._canvas;
                canvas.removeEventListener("mouseover", this._onMouseEvent);
                canvas.removeEventListener("mouseenter", this._onMouseEvent);
                canvas.removeEventListener("mousedown", this._onMouseEvent);
                window.removeEventListener("mousemove", this._onMouseEvent);
                window.removeEventListener("mouseup", this._onMouseEvent);
                canvas.removeEventListener("mouseout", this._onMouseEvent);
                canvas.removeEventListener("mouseleave", this._onMouseEvent);
            };
            InputSystem.prototype.onAwake = function (config) {
                this._canvas = config.canvas;
            };
            InputSystem.prototype.onEnable = function () {
                var canvas = this._canvas;
                // if ((window as any).PointerEvent) { // TODO 会无故触发 pointercancel （PVP 项目）
                //     Pointer events.
                //     canvas.addEventListener("pointerover", this._onPointerEvent);
                //     canvas.addEventListener("pointerenter", this._onPointerEvent);
                //     canvas.addEventListener("pointerdown", this._onPointerEvent);
                //     window.addEventListener("pointermove", this._onPointerEvent);
                //     window.addEventListener("pointerup", this._onPointerEvent);
                //     canvas.addEventListener("pointercancel", this._onPointerEvent);
                //     canvas.addEventListener("pointerout", this._onPointerEvent);
                //     canvas.addEventListener("pointerleave", this._onPointerEvent);
                // }
                // else {
                // Mouse events.
                if (!this._hasTouch) {
                    canvas.addEventListener("mousedown", this._onMouseEvent);
                    canvas.addEventListener("mouseover", this._onMouseEvent);
                    canvas.addEventListener("mouseenter", this._onMouseEvent);
                    window.addEventListener("mousemove", this._onMouseEvent);
                    window.addEventListener("mouseup", this._onMouseEvent);
                    canvas.addEventListener("mouseout", this._onMouseEvent);
                    canvas.addEventListener("mouseleave", this._onMouseEvent);
                }
                // Touch events.
                canvas.addEventListener("touchstart", this._onTouchEvent);
                canvas.addEventListener("touchmove", this._onTouchEvent);
                canvas.addEventListener("touchend", this._onTouchEvent);
                window.addEventListener("touchcancel", this._onTouchEvent);
                // }
                // Context menu event.
                window.addEventListener("contextmenu", this._onContextMenu);
                // Mouse wheel event.
                canvas.addEventListener("mousewheel", this._onMouseWheelEvent);
                // Key events.
                window.addEventListener("keydown", this._onKeyEvent);
                window.addEventListener("keyup", this._onKeyEvent);
            };
            InputSystem.prototype.onDisable = function () {
                var canvas = this._canvas;
                // Pointer events.
                canvas.removeEventListener("pointerover", this._onPointerEvent);
                canvas.removeEventListener("pointerenter", this._onPointerEvent);
                canvas.removeEventListener("pointerdown", this._onPointerEvent);
                window.removeEventListener("pointermove", this._onPointerEvent);
                window.removeEventListener("pointerup", this._onPointerEvent);
                canvas.removeEventListener("pointercancel", this._onPointerEvent);
                canvas.removeEventListener("pointerout", this._onPointerEvent);
                canvas.removeEventListener("pointerleave", this._onPointerEvent);
                // Mouse events.
                this._removeMouseEvent();
                // Touch events.
                canvas.removeEventListener("touchstart", this._onTouchEvent);
                canvas.removeEventListener("touchmove", this._onTouchEvent);
                canvas.removeEventListener("touchend", this._onTouchEvent);
                window.removeEventListener("touchcancel", this._onTouchEvent);
                // Context menu event.
                window.removeEventListener("contextmenu", this._onContextMenu);
                // Mouse wheel event.
                canvas.removeEventListener("mousewheel", this._onMouseWheelEvent);
                // Key events.
                window.removeEventListener("keydown", this._onKeyEvent);
                window.removeEventListener("keyup", this._onKeyEvent);
                egret3d.inputCollecter.clear();
            };
            InputSystem.prototype.onUpdate = function (deltaTime) {
                if (egret3d.inputCollecter.isActiveAndEnabled) {
                    egret3d.inputCollecter.update(deltaTime).clear();
                }
            };
            return InputSystem;
        }(paper.BaseSystem));
        web.InputSystem = InputSystem;
        __reflect(InputSystem.prototype, "egret3d.web.InputSystem");
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var EndSystem = (function (_super) {
            __extends(EndSystem, _super);
            function EndSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._contactCollecter = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.ContactCollecter);
                return _this;
            }
            EndSystem.prototype.onUpdate = function () {
                this._contactCollecter._update();
            };
            return EndSystem;
        }(paper.BaseSystem));
        web.EndSystem = EndSystem;
        __reflect(EndSystem.prototype, "egret3d.web.EndSystem");
    })(web = egret3d.web || (egret3d.web = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Profile = (function () {
        function Profile() {
        }
        Profile._getNow = function () {
            // if (window.performance) {
            //     return window.performance.now();
            // }
            // return Date.now() * 0.001;
            return new Date().getTime();
        };
        Profile._print = function (list) {
            var totalTime = 0.0;
            for (var _a = 0, list_1 = list; _a < list_1.length; _a++) {
                var item = list_1[_a];
                totalTime += item.time;
            }
            console.log("------------------------");
            for (var _b = 0, list_2 = list; _b < list_2.length; _b++) {
                var item = list_2[_b];
                console.log(item.key + ":用时" + item.time + "平均:" + (item.time / item.count) + "最大值:" + item.maxTime + " 权重:" + (Math.round(item.time / totalTime * 100)) + "%");
            }
        };
        Profile.clear = function () {
            this.profileList.keys.length = 0;
            this.profileList.values.length = 0;
        };
        Profile.startTime = function (key, group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                this.profileList.keys.push(key);
                index = this.profileList.values.length;
                this.profileList.values.push({ key: key, count: 0, startTime: 0, time: 0, group: group, maxTime: 0 });
            }
            var item = this.profileList.values[index];
            item.count++;
            item.startTime = this._getNow();
        };
        Profile.endTime = function (key) {
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                console.log("invalid key error.", this);
            }
            else {
                var item = this.profileList.values[index];
                var d = this._getNow() - item.startTime;
                item.time += d;
                item.maxTime = item.maxTime > d ? item.maxTime : d;
            }
        };
        Profile.printAll = function () {
            if (!this.debug) {
                return;
            }
            var groups = {};
            for (var _a = 0, _b = this.profileList.values; _a < _b.length; _a++) {
                var item = _b[_a];
                if (!groups[item.group]) {
                    groups[item.group] = [];
                }
                groups[item.group].push(item);
            }
            for (var key in groups) {
                this._print(groups[key]);
            }
        };
        Profile.print = function (group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var list = [];
            for (var _a = 0, _b = this.profileList.values; _a < _b.length; _a++) {
                var item = _b[_a];
                if (item.group === group) {
                    list.push(item);
                }
            }
            this._print(list);
        };
        Profile.test = function () {
            var list0 = [];
            var map = {};
            for (var i = 0; i < 1000; i++) {
                list0.push(i);
                map[i] = i;
            }
            var old = this._getNow();
            for (var _a = 0, list0_1 = list0; _a < list0_1.length; _a++) {
                var _i = list0_1[_a];
                console.log("list:");
            }
            console.log("list of用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var _i in list0) {
                console.log("list:");
            }
            console.log("list in用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var _i in map) {
                console.log("map:");
            }
            console.log("map用时:" + (this._getNow() - old));
        };
        Profile.debug = false;
        Profile.profileList = { keys: [], values: [] };
        return Profile;
    }());
    egret3d.Profile = Profile;
    __reflect(Profile.prototype, "egret3d.Profile");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 引擎启动入口
     */
    function runEgret(options) {
        if (!options) {
            options = {};
        }
        console.info("Egret", paper.Application.version, "start.");
        // TODO
        egret.Sound = egret.web ? egret.web.HtmlSound : egret['wxgame']['HtmlSound']; //TODO:Sound
        egret.Capabilities["renderMode" + ""] = "webgl";
        var canvas = getMainCanvas(options);
        if (options.alpha === undefined) {
            options.alpha = false;
        }
        if (options.antialias === undefined) {
            options.antialias = true;
        }
        if (options.antialiasSamples === undefined) {
            options.antialiasSamples = 4;
        }
        if (options.contentWidth === undefined) {
            var defaultWidth = 1136;
            if (window.canvas) {
                options.contentWidth = defaultWidth;
            }
            else {
                var div = document.getElementsByClassName("egret-player")[0];
                options.contentWidth = parseInt(div.getAttribute("data-content-width")) || defaultWidth;
            }
        }
        if (options.contentHeight === undefined) {
            var defaultHeight = 640;
            if (window.canvas) {
                options.contentHeight = defaultHeight;
            }
            else {
                var div = document.getElementsByClassName("egret-player")[0];
                options.contentHeight = parseInt(div.getAttribute("data-content-height")) || defaultHeight;
            }
        }
        options.canvas = canvas;
        options.webgl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        paper.Application.initialize(options);
        var systemManager = paper.Application.systemManager;
        systemManager.register(egret3d.web.BeginSystem, 0 /* Begin */, options);
        systemManager.register(egret3d.AnimationSystem, 5000 /* Animation */);
        systemManager.register(egret3d.MeshRendererSystem, 7000 /* BeforeRenderer */);
        systemManager.register(egret3d.SkinnedMeshRendererSystem, 7000 /* BeforeRenderer */);
        systemManager.register(egret3d.particle.ParticleSystem, 7000 /* BeforeRenderer */);
        systemManager.register(egret3d.Egret2DRendererSystem, 7000 /* BeforeRenderer */, options);
        systemManager.register(egret3d.CameraAndLightSystem, 7000 /* BeforeRenderer */);
        systemManager.register(egret3d.web.WebGLRenderSystem, 8000 /* Renderer */, options);
        systemManager.register(egret3d.web.InputSystem, 10000 /* End */, options);
        systemManager.register(egret3d.web.EndSystem, 10000 /* End */, options);
        // TODO
        systemManager._preRegisterSystems();
        paper.Application.resume();
        console.info("Egret start complete.");
    }
    egret3d.runEgret = runEgret;
    function getMainCanvas(options) {
        if (window.canvas) {
            return window.canvas;
        }
        else if (options.canvas) {
            return options.canvas;
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            var canvas = document.createElement("canvas");
            div.appendChild(canvas);
            return canvas;
        }
    }
})(egret3d || (egret3d = {}));
window.paper = paper;
window.egret3d = egret3d;
var egret3d;
(function (egret3d) {
    var DirtyMask;
    (function (DirtyMask) {
        DirtyMask[DirtyMask["ProjectionMatrix"] = 1] = "ProjectionMatrix";
        DirtyMask[DirtyMask["TransformMatrix"] = 2] = "TransformMatrix";
        DirtyMask[DirtyMask["ClipToWorldMatrix"] = 4] = "ClipToWorldMatrix";
        DirtyMask[DirtyMask["WorldToClipMatrix"] = 8] = "WorldToClipMatrix";
        DirtyMask[DirtyMask["CullingMatrix"] = 16] = "CullingMatrix";
        DirtyMask[DirtyMask["PixelViewport"] = 32] = "PixelViewport";
        DirtyMask[DirtyMask["CullingFrustum"] = 64] = "CullingFrustum";
        DirtyMask[DirtyMask["ClipMatrix"] = 12] = "ClipMatrix";
        DirtyMask[DirtyMask["ProjectionAndClipMatrix"] = 13] = "ProjectionAndClipMatrix";
        DirtyMask[DirtyMask["Culling"] = 80] = "Culling";
        DirtyMask[DirtyMask["All"] = 125] = "All";
    })(DirtyMask || (DirtyMask = {}));
    /**
     * 相机组件。
     */
    var Camera = (function (_super) {
        __extends(Camera, _super);
        function Camera() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 该相机的绘制缓冲掩码。
             */
            _this.bufferMask = 16640 /* DepthAndColor */;
            /**
             * 该相机的渲染剔除掩码。
             * - 用来选择性的渲染部分实体。
             * - camera.cullingMask = paper.Layer.UI;
             * - camera.cullingMask |= paper.Layer.UI;
             * - camera.cullingMask &= ~paper.Layer.UI;
             */
            _this.cullingMask = 4294967295 /* Everything */;
            /**
             * 该相机渲染排序。
             * - 该值越低的相机优先绘制。
             */
            _this.order = 0;
            /**
             * 该相机的背景色。
             */
            _this.backgroundColor = egret3d.Color.create(0.15, 0.25, 0.5, 1.0);
            /**
             * 该相机的渲染上下文。
             * @private
             */
            _this.context = new egret3d.CameraRenderContext(_this);
            _this._nativeCulling = false;
            _this._nativeProjection = false;
            _this._nativeTransform = false;
            _this._dirtyMask = 125 /* All */;
            _this._opvalue = 1.0;
            _this._fov = Math.PI * 0.25;
            _this._near = 0.3;
            _this._far = 1000.0;
            _this._size = 1.0;
            _this._viewport = egret3d.Rectangle.create(0.0, 0.0, 1.0, 1.0);
            _this._pixelViewport = egret3d.Rectangle.create(0.0, 0.0, 1.0, 1.0);
            _this._frustum = egret3d.Frustum.create();
            _this._viewportMatrix = egret3d.Matrix4.create();
            _this._cullingMatrix = egret3d.Matrix4.create();
            _this._projectionMatrix = egret3d.Matrix4.create();
            _this._cameraToWorldMatrix = egret3d.Matrix4.create();
            _this._worldToCameraMatrix = egret3d.Matrix4.create();
            _this._worldToClipMatrix = egret3d.Matrix4.create();
            _this._clipToWorldMatrix = egret3d.Matrix4.create();
            _this._renderTarget = null;
            /**
             * @internal
             */
            _this._readRenderTarget = null;
            /**
             * @internal
             */
            _this._writeRenderTarget = null;
            return _this;
        }
        Object.defineProperty(Camera, "main", {
            /**
             * 当前场景的主相机。
             * - 如果没有则创建一个。
             */
            get: function () {
                var scene = paper.Application.sceneManager.activeScene;
                var gameObject = scene.findWithTag("MainCamera" /* MainCamera */);
                if (!gameObject) {
                    gameObject = scene.findWithTag("Main Camera");
                    if (gameObject) {
                        gameObject.tag = "MainCamera" /* MainCamera */;
                    }
                }
                if (!gameObject) {
                    gameObject = paper.GameObject.create("Main Camera" /* MainCamera */, "MainCamera" /* MainCamera */);
                    gameObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    gameObject.transform.lookAt(egret3d.Vector3.ZERO);
                }
                return gameObject.getOrAddComponent(Camera);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera, "editor", {
            /**
             * 编辑相机。
             * - 如果没有则创建一个。
             */
            get: function () {
                var gameObject = paper.Application.sceneManager.editorScene.find("Editor Camera" /* EditorCamera */);
                if (!gameObject) {
                    gameObject = paper.GameObject.create("Editor Camera" /* EditorCamera */, "EditorOnly" /* EditorOnly */, paper.Application.sceneManager.editorScene);
                    gameObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    gameObject.transform.lookAt(egret3d.Vector3.ZERO);
                    var camera = gameObject.addComponent(Camera);
                    camera.cullingMask &= ~32 /* UI */; // TODO 更明确的 UI 编辑方案。
                    camera.far = 10000.0;
                }
                return gameObject.getOrAddComponent(Camera);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @internal
         */
        Camera.prototype._update = function () {
            this.context._frustumCulling();
            this.context.updateCameraTransform(); // TODO
        };
        Camera.prototype._onStageResize = function () {
            this._dirtyMask |= 32 /* PixelViewport */;
            if (!this._nativeProjection) {
                this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
            }
            if (!this._nativeCulling) {
                this._dirtyMask |= 80 /* Culling */;
            }
        };
        Camera.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            //TODO
            this._readRenderTarget = egret3d.RenderTexture.create({ width: egret3d.stage.viewport.w, height: egret3d.stage.viewport.h, depthBuffer: true });
            this._writeRenderTarget = egret3d.RenderTexture.create({ width: egret3d.stage.viewport.w, height: egret3d.stage.viewport.h, depthBuffer: true });
            this.transform.registerObserver(this);
            egret3d.stage.onScreenResize.add(this._onStageResize, this);
            egret3d.stage.onResize.add(this._onStageResize, this);
        };
        Camera.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._readRenderTarget) {
                this._readRenderTarget.dispose();
            }
            if (this._writeRenderTarget) {
                this._writeRenderTarget.dispose();
            }
            this._readRenderTarget = null;
            this._writeRenderTarget = null;
            egret3d.stage.onScreenResize.remove(this._onStageResize, this);
            egret3d.stage.onResize.remove(this._onStageResize, this);
        };
        Camera.prototype.onTransformChange = function () {
            if (!this._nativeTransform) {
                this._dirtyMask |= 12 /* ClipMatrix */;
                if (!this._nativeCulling) {
                    this._dirtyMask |= 80 /* Culling */;
                }
            }
        };
        /**
         * 将舞台坐标基于该相机的视角转换为世界坐标。
         * @param stagePosition 舞台坐标。
         * @param worldPosition 世界坐标。
         */
        Camera.prototype.stageToWorld = function (stagePosition, worldPosition) {
            if (!worldPosition) {
                worldPosition = egret3d.Vector3.create();
            }
            var backupZ = stagePosition.z;
            var _a = this.renderTargetSize, w = _a.w, h = _a.h;
            var kX = 2.0 / w;
            var kY = 2.0 / h;
            var clipToWorldMatrix = this.clipToWorldMatrix;
            var cameraToWorldMatrix = this.cameraToWorldMatrix;
            worldPosition.set((stagePosition.x * kX - 1.0), (1.0 - stagePosition.y * kY), 0.95).applyMatrix(clipToWorldMatrix);
            var position = egret3d.Vector3.create().fromMatrixPosition(cameraToWorldMatrix).release();
            var forward = egret3d.Vector3.create().fromMatrixColumn(cameraToWorldMatrix, 2).multiplyScalar(-1.0).release();
            var distanceToPlane = worldPosition.subtract(position).dot(forward);
            if (distanceToPlane < -2.220446049250313e-16 /* EPSILON */ || 2.220446049250313e-16 /* EPSILON */ < distanceToPlane) {
                if (this._opvalue === 0.0) {
                    // TODO
                    // worldPosition.subtract(vppos, forward.multiplyScalar(distanceToPlane - stagePosition.z));
                }
                else {
                    worldPosition.multiplyScalar(-backupZ / distanceToPlane).add(position);
                }
            }
            return worldPosition;
        };
        /**
         * 将舞台坐标基于该相机的视角转换为世界坐标。
         * @param worldPosition 世界坐标。
         * @param stagePosition 舞台坐标。
         */
        Camera.prototype.worldToStage = function (worldPosition, stagePosition) {
            if (!stagePosition) {
                stagePosition = egret3d.Vector3.create();
            }
            var _a = this.renderTargetSize, w = _a.w, h = _a.h;
            var worldToClipMatrix = this.worldToClipMatrix;
            stagePosition.applyMatrix(worldToClipMatrix, worldPosition);
            stagePosition.x = (stagePosition.x + 1.0) * w * 0.5;
            stagePosition.y = (1.0 - stagePosition.y) * h * 0.5;
            // stagePosition.z = TODO
            return stagePosition;
        };
        /**
         * 将舞台坐标基于该相机的视角转换为世界射线。
         * @param stageX 舞台水平坐标。
         * @param stageY 舞台垂直坐标。
         * @param ray 射线。
         */
        Camera.prototype.stageToRay = function (stageX, stageY, ray) {
            if (!ray) {
                ray = egret3d.Ray.create();
            }
            var _a = this.renderTargetSize, w = _a.w, h = _a.h;
            var kX = 2.0 / w;
            var kY = 2.0 / h;
            var clipToWorldMatrix = this.clipToWorldMatrix;
            ray.origin.set(stageX * kX - 1.0, 1.0 - stageY * kY, 0.0).applyMatrix(clipToWorldMatrix);
            ray.direction.set(stageX * kX - 1.0, 1.0 - stageY * kY, 1.0).applyMatrix(clipToWorldMatrix).subtract(ray.origin).normalize();
            return ray;
        };
        /**
         *
         */
        Camera.prototype.resetCullingMatrix = function () {
            this._nativeCulling = false;
            return this;
        };
        /**
         *
         */
        Camera.prototype.resetProjectionMatrix = function () {
            this._nativeProjection = false;
            return this;
        };
        /**
         *
         */
        Camera.prototype.resetWorldToCameraMatrix = function () {
            this._nativeTransform = false;
            return this;
        };
        Object.defineProperty(Camera.prototype, "opvalue", {
            /**
             * 控制该相机从正交到透视的过渡的系数，0：正交，1：透视，中间值则在两种状态间插值。
             */
            get: function () {
                return this._opvalue;
            },
            set: function (value) {
                if (this._opvalue === value) {
                    return;
                }
                this._opvalue = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "near", {
            /**
             * 该相机的视点到近裁剪面距离。
             * - 该值过小会引起深度冲突。
             */
            get: function () {
                return this._near;
            },
            set: function (value) {
                if (value >= this.far) {
                    value = this.far - 0.01;
                }
                if (value < 0.01) {
                    value = 0.01;
                }
                this._near = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "far", {
            /**
             * 该相机的视点到远裁剪面距离。
             */
            get: function () {
                return this._far;
            },
            set: function (value) {
                if (value <= this._near) {
                    value = this._near + 0.01;
                }
                if (value >= 10000.0) {
                    value = 10000.0;
                }
                this._far = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "fov", {
            /**
             * 透视投影的视野。
             */
            get: function () {
                return this._fov;
            },
            set: function (value) {
                if (this._fov === value) {
                    return;
                }
                this._fov = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "size", {
            /**
             * 该相机的正交投影的尺寸。
             */
            get: function () {
                return this._size;
            },
            set: function (value) {
                if (this._size === value) {
                    return;
                }
                this._size = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "aspect", {
            /**
             * 该相机视口的宽高比。
             */
            get: function () {
                var _a = this.pixelViewport, w = _a.w, h = _a.h;
                return w / h;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "renderTargetSize", {
            /**
             * 该相机渲染目标的尺寸。
             */
            get: function () {
                var w;
                var h;
                var renderTarget = this._renderTarget;
                if (renderTarget) {
                    w = renderTarget.width;
                    h = renderTarget.height;
                }
                else {
                    var stageViewport = egret3d.stage.viewport;
                    w = stageViewport.w;
                    h = stageViewport.h;
                }
                return { w: w, h: h };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "viewport", {
            /**
             * 该相机归一化的渲染视口。
             */
            get: function () {
                return this._viewport;
            },
            set: function (value) {
                var viewport = this._viewport;
                if (viewport !== value) {
                    viewport.copy(value);
                }
                viewport.w = viewport.w || 1.0;
                viewport.h = viewport.h || 1.0;
                this._dirtyMask |= 32 /* PixelViewport */;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "pixelViewport", {
            /**
             * 该相机像素化的渲染视口。
             */
            get: function () {
                var pixelViewport = this._pixelViewport;
                if (this._dirtyMask & 32 /* PixelViewport */) {
                    var _a = this.renderTargetSize, w = _a.w, h = _a.h;
                    var viewport = this._viewport;
                    pixelViewport.x = w * viewport.x;
                    pixelViewport.y = h * viewport.y;
                    pixelViewport.w = w * viewport.w;
                    pixelViewport.h = h * viewport.h;
                    this._dirtyMask &= ~32 /* PixelViewport */;
                }
                return pixelViewport;
            },
            set: function (value) {
                var pixelViewport = this._pixelViewport;
                if (pixelViewport !== value) {
                    pixelViewport.copy(value);
                }
                pixelViewport.w = pixelViewport.w || 1.0;
                pixelViewport.h = pixelViewport.h || 1.0;
                var _a = this.renderTargetSize, w = _a.w, h = _a.h;
                this._viewport.set(pixelViewport.x / w, pixelViewport.y / h, (pixelViewport.w || 1.0) / w, (pixelViewport.h || 1.0) / h);
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "frustum", {
            /**
             *
             */
            get: function () {
                if (this._dirtyMask & 64 /* CullingFrustum */) {
                    this._frustum.fromMatrix(this.cullingMatrix);
                    this._dirtyMask &= ~64 /* CullingFrustum */;
                }
                return this._frustum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "cullingMatrix", {
            /**
             * 该相机在世界空间坐标系的裁切矩阵。
             */
            get: function () {
                if (!this._nativeCulling) {
                    if (this._dirtyMask & 16 /* CullingMatrix */) {
                        this._cullingMatrix.multiply(this.projectionMatrix, this.worldToCameraMatrix);
                        this._dirtyMask &= ~16 /* CullingMatrix */;
                    }
                }
                return this._cullingMatrix;
            },
            set: function (value) {
                var cullingMatrix = this._cullingMatrix;
                if (cullingMatrix !== value) {
                    cullingMatrix.copy(value);
                }
                this._nativeCulling = true;
                this._dirtyMask |= 64 /* CullingFrustum */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "projectionMatrix", {
            /**
             * 该相机的投影矩阵。
             */
            get: function () {
                if (this._nativeProjection) {
                    return this._projectionMatrix;
                }
                var viewportMatrix = this._viewportMatrix;
                if (this._dirtyMask & 1 /* ProjectionMatrix */) {
                    viewportMatrix.fromProjection(this._fov, this._near, this._far, this._size, this._opvalue, this.aspect, egret3d.stage.matchFactor);
                    this._dirtyMask &= ~1 /* ProjectionMatrix */;
                }
                return viewportMatrix;
            },
            set: function (value) {
                var projectionMatrix = this._projectionMatrix;
                if (projectionMatrix !== value) {
                    projectionMatrix.copy(value);
                }
                this._nativeProjection = true;
                this._dirtyMask |= 12 /* ClipMatrix */;
                if (!this._nativeCulling) {
                    this._dirtyMask |= 80 /* Culling */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "cameraToWorldMatrix", {
            /**
             * 从该相机空间坐标系到世界空间坐标系的变换矩阵。
             */
            get: function () {
                if (this._nativeTransform) {
                    if (this._dirtyMask & 2 /* TransformMatrix */) {
                        this._cameraToWorldMatrix.inverse(this._worldToCameraMatrix);
                    }
                    return this._cameraToWorldMatrix;
                }
                return this.gameObject.transform.localToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "worldToCameraMatrix", {
            /**
             * 从世界空间坐标系到该相机空间坐标系的变换矩阵。
             * - 当设置该矩阵时，该相机将使用设置值代替变换组件的矩阵进行渲染。
             */
            get: function () {
                if (this._nativeTransform) {
                    return this._worldToCameraMatrix;
                }
                return this.gameObject.transform.worldToLocalMatrix;
            },
            set: function (value) {
                var worldToCameraMatrix = this._worldToCameraMatrix;
                if (worldToCameraMatrix !== value) {
                    worldToCameraMatrix.copy(value);
                }
                this._nativeTransform = true;
                this._dirtyMask |= 2 /* TransformMatrix */;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                }
                if (!this._nativeCulling) {
                    this._dirtyMask |= 80 /* Culling */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "worldToClipMatrix", {
            /**
             * 从世界变换到该相机裁切空间的矩阵。
             */
            get: function () {
                if (this._dirtyMask & 8 /* WorldToClipMatrix */) {
                    this._worldToClipMatrix.multiply(this.projectionMatrix, this.worldToCameraMatrix);
                    this._dirtyMask &= ~8 /* WorldToClipMatrix */;
                }
                return this._worldToClipMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "clipToWorldMatrix", {
            /**
             * 从该相机裁切空间变换到世界的矩阵。
             */
            get: function () {
                if (this._dirtyMask & 4 /* ClipToWorldMatrix */) {
                    this._clipToWorldMatrix.inverse(this.worldToClipMatrix);
                    this._dirtyMask &= ~4 /* ClipToWorldMatrix */;
                }
                return this._clipToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "renderTarget", {
            /**
             * 该相机的渲染目标。
             * - 未设置该值则直接绘制到舞台。
             */
            get: function () {
                return this._renderTarget;
            },
            set: function (value) {
                if (this._renderTarget === value) {
                    return;
                }
                this._renderTarget = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "postprocessingRenderTarget", {
            /**
             *
             */
            get: function () {
                return this._readRenderTarget;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, z, out) {
            var _a = this.renderTargetSize, w = _a.w, h = _a.h;
            var nearpos = egret3d.helpVector3A;
            nearpos.z = -this.near;
            nearpos.x = screenPos.x - w * 0.5;
            nearpos.y = h * 0.5 - screenPos.y;
            var farpos = egret3d.helpVector3B;
            farpos.z = -this.far;
            farpos.x = this.far * nearpos.x / this.near;
            farpos.y = this.far * nearpos.y / this.near;
            var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
            out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
            out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
        };
        /**
         * @deprecated
         */
        Camera.prototype.calcScreenPosFromWorldPos = function (worldPos, outScreenPos) {
            var _a = this.renderTargetSize, w = _a.w, h = _a.h;
            var worldToClipMatrix = this.worldToClipMatrix;
            var ndcPos = egret3d.helpVector3A;
            worldToClipMatrix.transformVector3(worldPos, ndcPos);
            outScreenPos.x = (ndcPos.x + 1.0) * w * 0.5;
            outScreenPos.y = (1.0 - ndcPos.y) * h * 0.5;
        };
        /**
         * @deprecated
         */
        Camera.prototype.calcWorldPosFromScreenPos = function (screenPos, outWorldPos) {
            this.stageToWorld(screenPos, outWorldPos);
        };
        /**
         * @deprecated
         */
        Camera.prototype.createRayByScreen = function (screenPosX, screenPosY, ray) {
            return this.stageToRay(screenPosX, screenPosY, ray);
        };
        Object.defineProperty(Camera.prototype, "clearOption_Color", {
            /**
             * @deprecated
             */
            get: function () {
                return (this.bufferMask & 16384 /* Color */) !== 0;
            },
            set: function (value) {
                if (value) {
                    this.bufferMask |= 16384 /* Color */;
                }
                else {
                    this.bufferMask &= ~16384 /* Color */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "clearOption_Depth", {
            /**
             * @deprecated
             */
            get: function () {
                return (this.bufferMask & 256 /* Depth */) !== 0;
            },
            set: function (value) {
                if (value) {
                    this.bufferMask |= 256 /* Depth */;
                }
                else {
                    this.bufferMask &= ~256 /* Depth */;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 在渲染阶段正在执行渲染的相机。
         * - 通常在后期渲染和渲染前生命周期中使用。
         */
        Camera.current = null;
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(gltf.BufferMask) }) // TODO
        ], Camera.prototype, "bufferMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.Layer) }) // TODO
        ], Camera.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("INT" /* INT */)
        ], Camera.prototype, "order", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("COLOR" /* COLOR */)
        ], Camera.prototype, "backgroundColor", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0, maximum: 1.0, step: 0.01 })
        ], Camera.prototype, "opvalue", null);
        __decorate([
            paper.serializedField("_near"),
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, maximum: 3000.0 - 0.01, step: 1 })
        ], Camera.prototype, "near", null);
        __decorate([
            paper.serializedField("_far"),
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.02, maximum: 3000.0, step: 1 })
        ], Camera.prototype, "far", null);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, maximum: Math.PI - 0.01, step: 0.01 })
        ], Camera.prototype, "fov", null);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Camera.prototype, "size", null);
        __decorate([
            paper.serializedField,
            paper.editor.property("RECT" /* RECT */, { step: 0.01 })
        ], Camera.prototype, "viewport", null);
        __decorate([
            paper.editor.property("RECT" /* RECT */, { step: 1 })
        ], Camera.prototype, "pixelViewport", null);
        return Camera;
    }(paper.BaseComponent));
    egret3d.Camera = Camera;
    __reflect(Camera.prototype, "egret3d.Camera", ["egret3d.ITransformObserver"]);
})(egret3d || (egret3d = {}));
